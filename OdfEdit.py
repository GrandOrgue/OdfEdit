#-------------------------------------------------------------------------------
# Name:        OdfEdit
# Purpose:     Application helping to edit an organ definition file (ODF) in plain text
#              and permitting to convert a Hauptwerk ODF into GrandOrgue ODF
#              The ODF can be used in the GrandOrgue application
#              Implemented with Python 3
#              Tested in Windows 10 and Ubuntu 21.10
#              It is contains 4 classes :
#                   C_LOGS to manage the logs generated by the various fonctions of the application
#                   C_GO_DATA_CHECK to check the syntax and the consistency of the edited ODF data
#                   C_GO_ODF_DATA to manage the edited ODF data
#                   C_ODF_HW2GO to manage the convertion from a Hauptwerk ODF to a GrandOrgue ODF
#                   C_GUI to manage the graphical user interface of this application
#                   CreateToolTip to display a tool tip on a GUI widget
# Author:      Eric Turpault (France, ChÃ¢tellerault)
# Copyright:   open source
# Licence:     free to modify, please share the modification with the author
#
# The considered GrandOrgue ODF syntax is :
#    [object_uid]  ; comment
#    ; comment line, empty lines are ignored
#    ; object_uid can contain only alphanumeric characters
#    attribute1=value1  ; comment
#    attribute2=value2
#    ; attribute can contain only alphanumeric or '_' characters
#
# The new panel format is detected if the Panel000 object is present and contains the attribute NumberOfGUIElements
#
# Versions history :
#   v1.0 - 15 April 2022 - initial version
#   v1.1 - 16 April 2022 - minor changes to be Linux compatible, minor GUI fixes
#   v1.2 - 27 April 2022 - some GUI behavior improvements, minor improvements in the help and the objects checks
#   v1.3 - 19 May   2022 - data management improvement, change in the way to define the parent-child relations between the objects,
#                          completed some attributes values maximum check, added a tab to search a string in the whole ODF
#   v2.0 - 23 Dec.  2022 - fix made in the function check_object_Manual around the key_type checks
#                          fix made in the function check_attribute_value to not change out of range integer value and better check HTML color code
#                          use the PIL library instead of Tk to check the sample set images sizes
#                          first implementation of the Hauptwerk to GrandOrgue ODF conversion feature
#   v2.1 - 22 Dec.  2023 - HW2GO : fix for files path separator management in various OS
#                          HW2GO : get the actual files path/name/extension case from the HW sample set instead of from the HW ODF
#                          HW2GO : some design changes without functional impact
#                          HW2GO : added general sound stops (blower, bells, ...) and stop action noise support
#   v2.2 - 12 Jan. 2023  - HW2GO : improved and more robust way to detect Stop / Coupler / Switch objects to build
#                          HW2GO : fix of issues observed with some newly tested HW sample sets
#                          HW2GO : added support of HW continuous control and enclosure objects, converted into GO enclosure objects
#                          GUI : graphical user interface rework with resizable width for lists and notebook areas
#                          GUI : Organ object placed systematically at the top of the objects list
#   v2.3 - 08 April 2023 - fix for help text not loaded with Windows OdfEdit.exe (fix in file Help.txt due to characters 0x81 not supported by unicode format)
#                          add the support of comments at the end of the lines in the ODF
#                          add the support of the separator / in the files path in the ODF
#                          improved display and selection of parents/children objects of the selected object
#                          improved several behaviors in the GUI management
#                          ODF saving in a file places the objects by alphabetical UID order, but Header and Organ which are placed in first position
#                          new buttons to add, link to parents/children or rename an object, with automatical update of the object referencing
#                             and the total number in other objects, new panel format only is supported
#                          HW2GO : visual elements of the main panel are now defined in Panel999Element999 objects
#                          HW2GO : Switches have by default StoreInDivisional=Y, StoreInGeneral=Y, GCState=0
#-------------------------------------------------------------------------------

APP_VERSION = 'v2.3'
RELEASE_DATE = 'April 8th 2023'
DEV_MODE = False


MAIN_WINDOW_TITLE = 'OdfEdit - ' + APP_VERSION + (' - DEV MODE' if DEV_MODE else '')

import os
import shutil

from tkinter import *
from tkinter import filedialog as fd
from tkinter import simpledialog as sd
from tkinter import messagebox, ttk
import tkinter.font as tkf

from PIL import Image   # install with : pip install pillow
from lxml import etree  # install with : pip install lxml

# warning message displayed before to start a HW to GO ODF conversion
HW_CONV_MSG = """An ODF will be built in order to use the selected Hauptwerk sample set in the GrandOrgue application. None file of the Hauptwerk sample set will be modified.
ATTENTION :
- Please do this operation only with a free Hauptwerk sample set or a not-free sample set that you have duly paid for, and if the editor of this sample set does not preclude its use outside Hauptwerk application.
- Don't expect to have necessarily with GrandOrgue the sound quality and all control possibilities that this sample set can have with Hauptwerk.
"""

ORGAN_COMMENT = 'GrandOrgue ODF automatically generated from a Hauptwerk ODF by OdfEdit ' + APP_VERSION + ' (see github.com/GrandOrgue/ODFEdit)'

ENCODING_ISO_8859_1 = 'ISO-8859-1'  # one of the two supported encoding type for an ODF
ENCODING_UTF8_BOM = 'utf_8_sig'     # one of the two supported encoding type for an ODF

ALLOWED_CHARS_4_FIELDS = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_'  # characters allowed in a attribute name

# data types used in the attributes of the objects, used in the check object/attribute functions
ATTR_TYPE_INTEGER = 1
ATTR_TYPE_FLOAT = 2
ATTR_TYPE_BOOLEAN = 3
ATTR_TYPE_STRING = 4
ATTR_TYPE_COLOR = 5            # used in Button, Enclosure, Label, Panel
ATTR_TYPE_FONT_SIZE = 6        # used in Button, Enclosure, Label
ATTR_TYPE_PANEL_SIZE = 7       # used in Panel
ATTR_TYPE_COUPLER_TYPE = 8     # used in Coupler
ATTR_TYPE_ELEMENT_TYPE = 9     # used in Panel Element
ATTR_TYPE_TREMULANT_TYPE = 10  # used in Tremulant
ATTR_TYPE_PISTON_TYPE = 11     # used in Piston
ATTR_TYPE_DRAWSTOP_FCT = 12    # used in DrawStop
ATTR_TYPE_FILE_NAME = 13       # used in many objects for bitmap or wav files
ATTR_TYPE_OBJECT_REF = 14      # used in many objects to make a reference to another object ID
ATTR_TYPE_PIPE_WAVE = 15       # used in Rank

# constants to identify a link between objects
TO_PARENT = 1
TO_CHILD = 2

# constants to make the code more understandable
FIRST_ONE = True
MANDATORY = True

#-------------------------------------------------------------------------------------------------
class C_LOGS:
    # class to manage logs

    logs_list = [] # list of logs strings (errors or messages resulting from file operation or syntax check)

    #-------------------------------------------------------------------------------------------------
    def add(self, log_string):
        # add the given string to the events log list
        self.logs_list.append(log_string)

    #-------------------------------------------------------------------------------------------------
    def get(self):
        # recover the logs list
        return self.logs_list

    #-------------------------------------------------------------------------------------------------
    def nb_get(self):
        # recover the number of logs present in the list
        return len(self.logs_list)

    #-------------------------------------------------------------------------------------------------
    def clear(self):
        # clear the log list
        self.logs_list.clear()

# create an instance of the C_LOGS class
logs = C_LOGS()

#-------------------------------------------------------------------------------------------------
class C_GO_DATA_CHECK:
    # class to check the data contained in the ODF data

    check_files_names_bool = None  # flag storing the choice of the user to check or not the files names in the ODF (None if not defined, False, True)
    checked_attr_nb = 0            # number of attributes checked during the checking operation

    #-------------------------------------------------------------------------------------------------
    def check_odf_data(self, progress_status_update_fct):
        # check the consistency of the data which are present in ODF data of the C_GO_ODF_DATA class

        if self.check_files_names_bool == None:
            # ask the user if he wants to check the files names (to make a faster check)
            self.check_files_names_bool = messagebox.askyesno("ODF Editor", "Do you want to check the files names (to have a faster check or to test only the ODF content) ? \nThis choice will be kept until the next ODF opening")

        self.checked_attr_nb = 0

        logs.add("ODF data check report :")

        # check the presence of the Organ object
        if 'Organ' not in self.odf_data_dic.keys():
            logs.add("ERROR the Organ object is not defined")

        for object_uid, object_dic in sorted(self.odf_data_dic.items()):
            # parse the objects of the ODF data

            # recover a copy of the lines of the current object
            object_lines_list = list(object_dic['lines'])

            # update in the GUI the name of the checked object
            progress_status_update_fct(f'Checking {object_uid}...')

            if len(object_lines_list) > 0:
                # lines have been recovered for the current object

                # sort the lines list to make faster the search which is done in check_attribute_value
                object_lines_list.sort()

                # remove the first line while it is empty (after the sorting the empty lines are all in first positions)
                while len(object_lines_list) > 0 and object_lines_list[0] == '':
                    object_lines_list.pop(0)

                # check if the attributes are all uniques in the object
                self.check_attributes_unicity(object_uid, object_lines_list)

                # check the attributes and values of the object by type
                object_type = self.object_type_get(object_uid)
                if object_type == 'Header':
                    pass
                elif object_type == 'Organ':
                    self.check_object_Organ(object_uid, object_lines_list)
                elif object_type == 'Coupler':
                    self.check_object_Coupler(object_uid, object_lines_list)
                elif object_type == 'Divisional':
                    self.check_object_Divisional(object_uid, object_lines_list)
                elif object_type == 'DivisionalCoupler':
                    self.check_object_DivisionalCoupler(object_uid, object_lines_list)
                elif object_type == 'Enclosure':
                    self.check_object_Enclosure(object_uid, object_lines_list)
                elif object_type == 'General':
                    self.check_object_General(object_uid, object_lines_list)
                elif object_type == 'Image':
                    self.check_object_Image(object_uid, object_lines_list)
                elif object_type == 'Label':
                    self.check_object_Label(object_uid, object_lines_list)
                elif object_type == 'Manual':
                    self.check_object_Manual(object_uid, object_lines_list)
                elif object_type == 'Panel':
                    self.check_object_Panel(object_uid, object_lines_list)
                elif object_type == 'PanelElement':
                    self.check_object_PanelElement(object_uid, object_lines_list)
                elif object_type[:5] == 'Panel': # Panel999Coupler999, Panel999Divisional999, Panel999Image999, ...
                    self.check_object_PanelOther(object_uid, object_lines_list)
                elif object_type == 'Rank':
                    self.check_object_Rank(object_uid, object_lines_list)
                elif object_type == 'ReversiblePiston':
                    self.check_object_ReversiblePiston(object_uid, object_lines_list)
                elif object_type == 'SetterElement':
                    self.check_object_SetterElement(object_uid, object_lines_list)
                elif object_type == 'Stop':
                    self.check_object_Stop(object_uid, object_lines_list)
                elif object_type == 'Switch':
                    self.check_object_Switch(object_uid, object_lines_list)
                elif object_type == 'Tremulant':
                    self.check_object_Tremulant(object_uid, object_lines_list)
                elif object_type == 'WindchestGroup':
                    self.check_object_WindchestGroup(object_uid, object_lines_list)
                else:
                    # the object UID has not been recognized
                    logs.add(f"WARNING the object type of {object_uid} is unknown")
                    # empty the lines list of the object which is not recognized, to not display in the log its attributes which have not been checked
                    object_lines_list = []

                # check the lines not checked by the function check_attribute_value() (that is which are still present in the lines list)
                for line in object_lines_list:
                    (error_msg, attr_name, attr_value, comment) = self.object_line_split(line)
                    if error_msg != None:
                        logs.add(f'ERROR in {object_uid} section, line "{line}" : {error_msg}')

                    if attr_name not in (None, 'uid'):
                        # the current line is an attribute line
                        self.checked_attr_nb += 1
                        logs.add(f"WARNING in {object_uid} : the attribute {attr_name} is not expected in this object section or is misspelled")

        # display in the log the number of checked attributes
        logs.add(f"{self.checked_attr_nb:,} attributes checked")

        # update the panel format flag
        self.check_panel_format()

        # display in the log if none error has been detected
        if logs.nb_get() <= 3:  # 3 log lines when no error : check start message + detected panel format + number of checked attributes
            logs.add("None error found")

    #-------------------------------------------------------------------------------------------------
    def check_panel_format(self):
        # check which is the panel format used in the ODF (new or old) and update the flag

        value = self.object_attr_value_get('Panel000', 'NumberOfGUIElements')
        if value != None:
            self.new_panel_format_bool = (value.isdigit() and int(value) >= 0)
        else:
            self.new_panel_format_bool = False

        if self.new_panel_format_bool:
            logs.add(f'New panel format')
        else:
            logs.add(f'Old panel format')

    #-------------------------------------------------------------------------------------------------
    def check_object_uid(self, object_uid):
        # return an error message if an issue has been detected in the given object UID, else None

        error_msg = None

        object_type = self.object_type_get(object_uid)

        if not object_uid.isalnum():
            error_msg = 'an object identifier must contain only alphanumeric characters'
        elif object_type not in self.go_objects_children_dic.keys():
            error_msg = f'unknown object type'
        elif not object_type in ('Organ', 'Header'):
            if not object_uid[-3:].isdigit():
                error_msg = f'three digits are expected at the end of "{object_uid}"'
            elif int(object_uid[-3:]) == 0 and not object_type in ('Panel', 'Manual'):
                error_msg = f"{object_uid} cannot have the index 000"
            elif object_uid[:5] == 'Panel' and len(object_uid) > 8 and not object_uid[5:8].isdigit():
                # Panel999xxxxx999 object
                error_msg = f'three digits are expected after "Panel" in "{object_uid}"'

        return error_msg

    #-------------------------------------------------------------------------------------------------
    def check_object_line(self, line):
        # check the syntax of the given object line and extract from it the attribute name + attribute value + comment
        # return a tuple containing : (error message, attribute name, attribute value, comment)
        # attribute name = 'uid' if the given line contains an object UID between brackets, the UID is in the attribute value
        # error message = an error description message in case a syntax error has been detected in the given line, or None if no error found

        error_msg = attr_name = attr_value = comment = None

        if len(line) > 0: # not an empty line
            if line[0] == "[":
                # line with an object UID inside normally
                pos = line.find(']', 1)
                if pos == -1:  # object ID without closing bracket
                    error_msg = 'character "]" is missing to define an object ID'
                    comment = line
                elif pos == 1: # object ID with no string between the brackets
                    error_msg = 'no object identifier defined between the brackets'
                    comment = line
                else:
                    attr_name = 'uid'
                    attr_value = line[1:pos]
                    # check the coherency of the UID
                    error_msg = self.check_object_uid(attr_value)

                    if error_msg == None and len(line) > pos + 1:
                        # there are characters after the ]
                        comment = line[pos+1:]
                        if comment.lstrip()[0] != ';':
                            error_msg = 'only text beginning by ; is allowed after the ] character'

            elif line[0] != ";":  # not a comment line
                pos = line.find('=', 0)
                if pos == -1:  # no equal character in the line
                    error_msg = 'character ";" missing at the beginning of the line to make it a comment line'
                    comment = line
                elif pos == 0:  # the line starts by an equal character
                    error_msg = 'the character "=" must not start a line'
                    comment = line
                else:
                    attr_name = line[0:pos]
                    for char in attr_name:
                        if char not in ALLOWED_CHARS_4_FIELDS:
                            # the attribute name has a forbiden character
                            error_msg = f'the attribute "{attr_name}" can contain only alphanumeric or "_" characters'
                            break

                    posc = line.find(';', pos + 1)
                    if posc != -1:
                        # there is a comment after the attribute value
                        while line[posc-1] == ' ': posc -= 1
                        attr_value = line[pos+1:posc]
                        comment = line[posc:]
                    else:
                        attr_value = line[pos+1:]
                    attr_value = attr_value.rstrip()

            else: # comment or empty line
                comment = line

        return (error_msg, attr_name, attr_value, comment)


    #-------------------------------------------------------------------------------------------------
    def check_object_Organ(self, object_uid, lines_list):
        # check the data of an Organ object section which the lines are in the given lines list

        # required attributes
        self.check_attribute_value(object_uid, lines_list, 'ChurchName', ATTR_TYPE_STRING, True)
        self.check_attribute_value(object_uid, lines_list, 'ChurchAddress', ATTR_TYPE_STRING, True)

        value = self.check_attribute_value(object_uid, lines_list, 'HasPedals', ATTR_TYPE_BOOLEAN, True)
        if value != None and value == "Y" and not ('Manual000' in self.odf_data_dic):
            logs.add(f"ERROR in {object_uid} : HasPedals=Y but no Manual000 object is defined")
        elif value == "N" and ('Manual000' in self.odf_data_dic):
            logs.add(f"ERROR in {object_uid} : HasPedals=N whereas a Manual000 object is defined")

        value = self.check_attribute_value(object_uid, lines_list, 'NumberOfDivisionalCouplers', ATTR_TYPE_INTEGER, True, 0, 8)
        if value != None and value.isdigit() and int(value) >= 0:
            count = self.objects_type_number_get('DivisionalCoupler')
            if count != int(value):
                logs.add(f"ERROR in {object_uid} : NumberOfDivisionalCouplers={value} whereas {count} DivisionalCoupler object(s) defined")

        value = self.check_attribute_value(object_uid, lines_list, 'NumberOfEnclosures', ATTR_TYPE_INTEGER, True, 0, 50)
        if value != None and value.isdigit() and int(value) >= 0:
            count = self.objects_type_number_get('Enclosure')
            if count != int(value):
                logs.add(f"ERROR in {object_uid} : NumberOfEnclosures={value} whereas {count} Enclosure object(s) defined")

        value = self.check_attribute_value(object_uid, lines_list, 'NumberOfGenerals', ATTR_TYPE_INTEGER, True, 0, 99)
        if value != None and value.isdigit() and int(value) >= 0:
            count = self.objects_type_number_get('General')
            if count != int(value):
                logs.add(f"ERROR in {object_uid} : NumberOfGenerals={value} whereas {count} General object(s) defined")

        value = self.check_attribute_value(object_uid, lines_list, 'NumberOfManuals', ATTR_TYPE_INTEGER, True, 1, 16)
        if value != None and value.isdigit() and int(value) >= 0:
            count = self.objects_type_number_get('Manual')
            if 'Manual000' in self.odf_data_dic.keys(): count -= 1
            if count != int(value):
                logs.add(f"ERROR in {object_uid} : NumberOfManuals={value} whereas {count} Manual object(s) defined")

        value = self.check_attribute_value(object_uid, lines_list, 'NumberOfPanels', ATTR_TYPE_INTEGER, self.new_panel_format_bool, 0, 100)
        if value != None and value.isdigit() and int(value) >= 0:
            count = self.objects_type_number_get('Panel')
            if 'Panel000' in self.odf_data_dic.keys(): count -= 1
            if count != int(value):
                logs.add(f"ERROR in {object_uid} : NumberOfPanels={value} whereas {count} Panel object(s) defined")

        if self.new_panel_format_bool and not ('Panel000' in self.odf_data_dic):
            logs.add("ERROR new panel format used but no Panel000 object is defined")
        elif not self.new_panel_format_bool and ('Panel000' in self.odf_data_dic):
            logs.add(f"ERROR in {object_uid} : old panel format used whereas a Panel000 is defined")

        value = self.check_attribute_value(object_uid, lines_list, 'NumberOfReversiblePistons', ATTR_TYPE_INTEGER, True, 0, 32)
        if value != None and value.isdigit() and int(value) >= 0:
            count = self.objects_type_number_get('ReversiblePiston')
            if count != int(value):
                logs.add(f"ERROR in {object_uid} : NumberOfReversiblePistons={value} whereas {count} ReversiblePiston object(s) defined")

        value = self.check_attribute_value(object_uid, lines_list, 'NumberOfTremulants', ATTR_TYPE_INTEGER, True, 0, 10)
        if value != None and value.isdigit() and int(value) >= 0:
            count = self.objects_type_number_get('Tremulant')
            if count != int(value):
                logs.add(f"ERROR in {object_uid} : NumberOfTremulants={value} whereas {count} Tremulant object(s) defined")

        value = self.check_attribute_value(object_uid, lines_list, 'NumberOfWindchestGroups', ATTR_TYPE_INTEGER, True, 1, 50)
        if value != None and value.isdigit() and int(value) >= 0:
            count = self.objects_type_number_get('WindchestGroup')
            if count != int(value):
                logs.add(f"ERROR in {object_uid} : NumberOfWindchestGroups={value} whereas {count} WindchestGroup object(s) defined")

        self.check_attribute_value(object_uid, lines_list, 'DivisionalsStoreIntermanualCouplers', ATTR_TYPE_BOOLEAN, True)
        self.check_attribute_value(object_uid, lines_list, 'DivisionalsStoreIntramanualCouplers', ATTR_TYPE_BOOLEAN, True)
        self.check_attribute_value(object_uid, lines_list, 'DivisionalsStoreTremulants', ATTR_TYPE_BOOLEAN, True)
        self.check_attribute_value(object_uid, lines_list, 'GeneralsStoreDivisionalCouplers', ATTR_TYPE_BOOLEAN, True)

        # optional attributes
        self.check_attribute_value(object_uid, lines_list, 'OrganBuilder', ATTR_TYPE_STRING, False)
        self.check_attribute_value(object_uid, lines_list, 'OrganBuildDate', ATTR_TYPE_STRING, False)
        self.check_attribute_value(object_uid, lines_list, 'OrganComments', ATTR_TYPE_STRING, False)
        self.check_attribute_value(object_uid, lines_list, 'RecordingDetails', ATTR_TYPE_STRING, False)
        self.check_attribute_value(object_uid, lines_list, 'InfoFilename', ATTR_TYPE_STRING, False)

        value = self.check_attribute_value(object_uid, lines_list, 'NumberOfImages', ATTR_TYPE_INTEGER, False, 0, 999) # old panel format
        if value != None and value.isdigit() and int(value) >= 0:
            count = self.objects_type_number_get('Image')
            if count != int(value):
                logs.add(f"ERROR in {object_uid} : NumberOfImages={value} whereas {count} Image object(s) defined")

        value = self.check_attribute_value(object_uid, lines_list, 'NumberOfLabels', ATTR_TYPE_INTEGER, False, 0, 999)  # old panel format
        if value != None and value.isdigit() and int(value) >= 0:
            count = self.objects_type_number_get('Label')
            if count != int(value):
                logs.add(f"ERROR in {object_uid} : NumberOfLabels={value} whereas {count} Label object(s) defined")

        value = self.check_attribute_value(object_uid, lines_list, 'NumberOfRanks', ATTR_TYPE_INTEGER, False, 0, 999)
        if value != None and value.isdigit() and int(value) >= 0:
            count = self.objects_type_number_get('Rank')
            if count != int(value):
                logs.add(f"ERROR in {object_uid} : NumberOfRanks={value} whereas {count} Rank object(s) defined")

        value = self.check_attribute_value(object_uid, lines_list, 'NumberOfSetterElements', ATTR_TYPE_INTEGER, False, 0, 999)  # old panel format
        if value != None and value.isdigit() and int(value) >= 0:
            count = self.objects_type_number_get('SetterElement')
            if count != int(value):
                logs.add(f"ERROR in {object_uid} : NumberOfSetterElements={value} whereas {count} SetterElement object(s) defined")

        value = self.check_attribute_value(object_uid, lines_list, 'NumberOfSwitches', ATTR_TYPE_INTEGER, False, 0, 999)
        if value != None and value.isdigit() and int(value) >= 0:
            count = self.objects_type_number_get('Switch')
            if count != int(value):
                logs.add(f"ERROR in {object_uid} : NumberOfSwitches={value} whereas {count} Switch object(s) defined")

        self.check_attribute_value(object_uid, lines_list, 'CombinationsStoreNonDisplayedDrawstops', ATTR_TYPE_BOOLEAN, False)
        self.check_attribute_value(object_uid, lines_list, 'AmplitudeLevel', ATTR_TYPE_FLOAT, False, 0, 1000)
        self.check_attribute_value(object_uid, lines_list, 'Gain', ATTR_TYPE_FLOAT, False, -120, 40)
        self.check_attribute_value(object_uid, lines_list, 'PitchTuning', ATTR_TYPE_FLOAT, False, -1200, 1200)
        self.check_attribute_value(object_uid, lines_list, 'TrackerDelay', ATTR_TYPE_FLOAT, False, 0, 10000)

        if not self.new_panel_format_bool:
            # if old parnel format, the Organ object contains panel attributes
            self.check_object_Panel(object_uid, lines_list)

    #-------------------------------------------------------------------------------------------------
    def check_object_Button(self, object_uid, lines_list):
        # check the data of a Button object section which the lines are in the given lines list

        # optional attributes
        self.check_attribute_value(object_uid, lines_list, 'Name', ATTR_TYPE_STRING, False)
        self.check_attribute_value(object_uid, lines_list, 'ShortcutKey', ATTR_TYPE_INTEGER, False, 0, 255)
        self.check_attribute_value(object_uid, lines_list, 'StopControlMIDIKeyNumber', ATTR_TYPE_INTEGER, False, 0, 127)
        self.check_attribute_value(object_uid, lines_list, 'MIDIProgramChangeNumber', ATTR_TYPE_INTEGER, False, 1, 128)
        self.check_attribute_value(object_uid, lines_list, 'Displayed', ATTR_TYPE_BOOLEAN, False)
        self.check_attribute_value(object_uid, lines_list, 'DisplayInInvertedState', ATTR_TYPE_BOOLEAN, False)

        display_as_piston = self.check_attribute_value(object_uid, lines_list, 'DisplayAsPiston', ATTR_TYPE_BOOLEAN, False)
        if display_as_piston == '':
            # attribute not defined, set its default value
            if (object_uid.startwith(('Divisional', 'General')) or
                (object_uid[8:15] == 'Element' and self.object_attr_value_get(object_uid, 'Type') in ('Divisional', 'General'))):
                # the object is a Divisional or General button or a panel element of Divisional or General type, so it must be displayed as a piston by default
                display_as_piston = 'Y'
            else:
                display_as_piston = 'N'

        self.check_attribute_value(object_uid, lines_list, 'DispLabelColour', ATTR_TYPE_COLOR, False)
        self.check_attribute_value(object_uid, lines_list, 'DispLabelFontSize', ATTR_TYPE_FONT_SIZE, False)
        self.check_attribute_value(object_uid, lines_list, 'DispLabelFontName', ATTR_TYPE_STRING, False)
        self.check_attribute_value(object_uid, lines_list, 'DispLabelText', ATTR_TYPE_STRING, False)
        self.check_attribute_value(object_uid, lines_list, 'DispKeyLabelOnLeft', ATTR_TYPE_BOOLEAN, False)
        self.check_attribute_value(object_uid, lines_list, 'DispImageNum', ATTR_TYPE_INTEGER, False, 1, 5 if display_as_piston == 'Y' else 6)
        self.check_attribute_value(object_uid, lines_list, 'DispButtonRow', ATTR_TYPE_INTEGER, False, 0, 199)
        self.check_attribute_value(object_uid, lines_list, 'DispButtonCol', ATTR_TYPE_INTEGER, False, 1, 32)
        self.check_attribute_value(object_uid, lines_list, 'DispDrawstopRow', ATTR_TYPE_INTEGER, False, 1, 199)
        self.check_attribute_value(object_uid, lines_list, 'DispDrawstopCol', ATTR_TYPE_INTEGER, False, 1, 12)
        image_on = self.check_attribute_value(object_uid, lines_list, 'ImageOn', ATTR_TYPE_FILE_NAME, False)
        self.check_attribute_value(object_uid, lines_list, 'ImageOff', ATTR_TYPE_FILE_NAME, False)
        self.check_attribute_value(object_uid, lines_list, 'MaskOn', ATTR_TYPE_FILE_NAME, False)
        self.check_attribute_value(object_uid, lines_list, 'MaskOff', ATTR_TYPE_FILE_NAME, False)

        # get the dimensions of the parent panel
        panel_uid = self.object_parent_panel_get(object_uid)
        value = self.object_attr_value_get(panel_uid, 'DispScreenSizeHoriz')
        panel_width = int(value) if value != None and value.isdigit() else 3000
        value = self.object_attr_value_get(panel_uid, 'DispScreenSizeVert')
        panel_height = int(value) if value != None and value.isdigit() else 2000

        self.check_attribute_value(object_uid, lines_list, 'PositionX', ATTR_TYPE_INTEGER, False, 0, panel_width)
        self.check_attribute_value(object_uid, lines_list, 'PositionY', ATTR_TYPE_INTEGER, False, 0, panel_height)
        width = self.check_attribute_value(object_uid, lines_list, 'Width', ATTR_TYPE_INTEGER, False, 0, panel_width)
        height = self.check_attribute_value(object_uid, lines_list, 'Height', ATTR_TYPE_INTEGER, False, 0, panel_height)
        max_width = int(width) if width != None and width.isdigit() else panel_width
        max_height = int(height) if height != None and height.isdigit() else panel_height

        # get the dimensions of the button bitmap
        if image_on != None and image_on != '':
            # an image is defined to display the button
            if self.check_files_names_bool:
                # get the sizes of the image in the file which is existing
                im = Image.open(os.path.dirname(self.odf_file_name) + os.sep + path2ospath(image_on))
                bitmap_width = im.size[0]
                bitmap_height = im.size[1]
            else:
                bitmap_width = 500  # arbritrary default value
                bitmap_height = 200 # arbritrary default value
        else:
            # no image file defined, get the dimensions of the internal bitmap (piston or drawstop)
            if display_as_piston == 'Y':
                bitmap_width = bitmap_height = 32
            else:
                bitmap_width = bitmap_height = 62

        self.check_attribute_value(object_uid, lines_list, 'TileOffsetX', ATTR_TYPE_INTEGER, False, 0, bitmap_width)
        self.check_attribute_value(object_uid, lines_list, 'TileOffsetY', ATTR_TYPE_INTEGER, False, 0, bitmap_height)

        self.check_attribute_value(object_uid, lines_list, 'MouseRectLeft', ATTR_TYPE_INTEGER, False, 0, max_width)
        self.check_attribute_value(object_uid, lines_list, 'MouseRectTop', ATTR_TYPE_INTEGER, False, 0, max_height)
        mouse_rect_width = self.check_attribute_value(object_uid, lines_list, 'MouseRectWidth', ATTR_TYPE_INTEGER, False, 0, max_width)
        mouse_rect_height = self.check_attribute_value(object_uid, lines_list, 'MouseRectHeight', ATTR_TYPE_INTEGER, False, 0, max_height)

        if mouse_rect_width != None and mouse_rect_width.isdigit() and mouse_rect_height != None and  mouse_rect_height.isdigit():
            mouse_radius = max(int(mouse_rect_width), int(mouse_rect_height))
        else:
            mouse_radius = max(bitmap_width, bitmap_height)
        self.check_attribute_value(object_uid, lines_list, 'MouseRadius', ATTR_TYPE_INTEGER, False, 0, mouse_radius)

        self.check_attribute_value(object_uid, lines_list, 'TextRectLeft', ATTR_TYPE_INTEGER, False, 0, max_width)
        self.check_attribute_value(object_uid, lines_list, 'TextRectTop', ATTR_TYPE_INTEGER, False, 0, max_height)
        text_rect_width = self.check_attribute_value(object_uid, lines_list, 'TextRectWidth', ATTR_TYPE_INTEGER, False, 0, max_width)
        self.check_attribute_value(object_uid, lines_list, 'TextRectHeight', ATTR_TYPE_INTEGER, False, 0, max_height)

        if text_rect_width != None and text_rect_width.isdigit():
            text_break_width = int(text_rect_width)
        else:
            text_break_width = bitmap_width
        self.check_attribute_value(object_uid, lines_list, 'TextBreakWidth', ATTR_TYPE_INTEGER, False, 0, text_break_width)

    #-------------------------------------------------------------------------------------------------
    def check_object_Coupler(self, object_uid, lines_list):
        # check the data of a Coupler object section which the lines are in the given lines list

        # required attributes
        ret1 = self.check_attribute_value(object_uid, lines_list, 'UnisonOff', ATTR_TYPE_BOOLEAN, True)
        ret2 = self.check_attribute_value(object_uid, lines_list, 'CouplerType', ATTR_TYPE_COUPLER_TYPE, False)  # optional but here to recover its value used after
        self.check_attribute_value(object_uid, lines_list, 'DestinationManual', ATTR_TYPE_INTEGER, True if ret1 == 'N' else False, 0, 16) # conditional required/optional
        self.check_attribute_value(object_uid, lines_list, 'DestinationKeyshift', ATTR_TYPE_INTEGER, True if ret1 == 'N' else False, -24, 24) # conditional required/optional

        is_required = (ret1 != None and ret2 != None and ret1 == 'N' and not(ret2.upper() in ('MELODY', 'BASS')))
        self.check_attribute_value(object_uid, lines_list, 'CoupleToSubsequentUnisonIntermanualCouplers', ATTR_TYPE_BOOLEAN, is_required)
        self.check_attribute_value(object_uid, lines_list, 'CoupleToSubsequentUpwardIntermanualCouplers', ATTR_TYPE_BOOLEAN, is_required)
        self.check_attribute_value(object_uid, lines_list, 'CoupleToSubsequentDownwardIntermanualCouplers', ATTR_TYPE_BOOLEAN, is_required)
        self.check_attribute_value(object_uid, lines_list, 'CoupleToSubsequentUpwardIntramanualCouplers', ATTR_TYPE_BOOLEAN, is_required)
        self.check_attribute_value(object_uid, lines_list, 'CoupleToSubsequentDownwardIntramanualCouplers', ATTR_TYPE_BOOLEAN, is_required)

        # optional attributes
        self.check_attribute_value(object_uid, lines_list, 'FirstMIDINoteNumber', ATTR_TYPE_INTEGER, False, 0, 127)
        self.check_attribute_value(object_uid, lines_list, 'NumberOfKeys', ATTR_TYPE_INTEGER, False, 0, 127)

        # a Coupler has in addition the attributes of a DrawStop
        self.check_object_DrawStop(object_uid, lines_list)

    #-------------------------------------------------------------------------------------------------
    def check_object_Divisional(self, object_uid, lines_list):
        # check the data of a Divisional object section which the lines are in the given lines list

        # recover the ID of manual in which is referenced this Divisional
        parent_manual_uid = self.object_parent_manual_get(object_uid)

        # required attributes
        value = self.object_attr_value_get(parent_manual_uid, 'NumberOfCouplers')
        max = int(value) if value != None and value.isdigit() else 999
        value = self.check_attribute_value(object_uid, lines_list, 'NumberOfCouplers', ATTR_TYPE_INTEGER, True, 0, max)
        if value != None and value.isdigit():
            for idx in range(1, int(value)+1):
                self.check_attribute_value(object_uid, lines_list, f'Coupler{str(idx).zfill(3)}', ATTR_TYPE_OBJECT_REF, True)

        value = self.object_attr_value_get(parent_manual_uid, 'NumberOfStops')
        max = int(value) if value != None and value.isdigit() else 999
        value = self.check_attribute_value(object_uid, lines_list, 'NumberOfStops', ATTR_TYPE_INTEGER, True, 0, max)
        if value != None and value.isdigit():
            for idx in range(1, int(value)+1):
                self.check_attribute_value(object_uid, lines_list, f'Stop{str(idx).zfill(3)}', ATTR_TYPE_OBJECT_REF, True)

        value = self.object_attr_value_get(parent_manual_uid, 'NumberOfTremulants')
        max = int(value) if value != None and value.isdigit() else 10
        value = self.check_attribute_value(object_uid, lines_list, 'NumberOfTremulants', ATTR_TYPE_INTEGER, True, 0, max)
        if value != None and value.isdigit():
            for idx in range(1, int(value)+1):
                self.check_attribute_value(object_uid, lines_list, f'Tremulant{str(idx).zfill(3)}', ATTR_TYPE_OBJECT_REF, True)

        # optional attributes
        self.check_attribute_value(object_uid, lines_list, 'Protected', ATTR_TYPE_BOOLEAN, False)

        value = self.object_attr_value_get(parent_manual_uid, 'NumberOfSwitches')
        max = int(value) if value != None and value.isdigit() else 999
        value = self.check_attribute_value(object_uid, lines_list, 'NumberOfSwitches', ATTR_TYPE_INTEGER, False, 0, max)
        if value != None and value.isdigit():
            for idx in range(1, int(value)+1):
                self.check_attribute_value(object_uid, lines_list, f'Switch{str(idx).zfill(3)}', ATTR_TYPE_OBJECT_REF, True)

        # a Divisional has in addition the attributes of a Push Button
        self.check_object_PushButton(object_uid, lines_list)

    #-------------------------------------------------------------------------------------------------
    def check_object_DivisionalCoupler(self, object_uid, lines_list):
        # check the data of a Divisional Coupler object section which the lines are in the given lines list

        # required attributes
        self.check_attribute_value(object_uid, lines_list, 'BiDirectionalCoupling', ATTR_TYPE_BOOLEAN, True)

        value = self.object_attr_value_get('Organ', 'NumberOfManuals')
        max = int(value) if value != None and value.isdigit() else 16
        value = self.check_attribute_value(object_uid, lines_list, 'NumberOfManuals', ATTR_TYPE_INTEGER, True, 1, max)
        if value != None and value.isdigit():
            for idx in range(1, int(value)+1):
                self.check_attribute_value(object_uid, lines_list, f"Manual{str(idx).zfill(3)}", ATTR_TYPE_OBJECT_REF, True)

        # a Divisional Coupler has in addition the attributes of a DrawStop
        self.check_object_DrawStop(object_uid, lines_list)

    #-------------------------------------------------------------------------------------------------
    def check_object_DrawStop(self, object_uid, lines_list):
        # check the data of a DrawStop object section which the lines are in the given lines list

        # optional attributes
        self.check_attribute_value(object_uid, lines_list, 'Function', ATTR_TYPE_DRAWSTOP_FCT, False)

        value = self.object_attr_value_get('Organ', 'NumberOfSwitches')
        max = int(value) if value != None and value.isdigit() else 999
        switch_id = int(object_uid[-3:]) if (object_uid[-3:].isdigit() and object_uid[:-3] == 'Switch') else 999
        value = self.check_attribute_value(object_uid, lines_list, 'SwitchCount', ATTR_TYPE_INTEGER, False, 1, max)
        if value != None and value.isdigit():
            for idx in range(1, int(value)+1):
                self.check_attribute_value(object_uid, lines_list, f"Switch{str(idx).zfill(3)}", ATTR_TYPE_OBJECT_REF, True)
                if switch_id != 999:
                    self.check_attribute_value(object_uid, lines_list, f"Switch{str(idx).zfill(3)}", ATTR_TYPE_INTEGER, True, 1, switch_id - 1)

        self.check_attribute_value(object_uid, lines_list, 'DefaultToEngaged', ATTR_TYPE_BOOLEAN, False)
        self.check_attribute_value(object_uid, lines_list, 'GCState', ATTR_TYPE_INTEGER, False, -1, 1)
        self.check_attribute_value(object_uid, lines_list, 'StoreInDivisional', ATTR_TYPE_BOOLEAN, False)
        self.check_attribute_value(object_uid, lines_list, 'StoreInGeneral', ATTR_TYPE_BOOLEAN, False)

        # a Drawstop has in addition the attributes of a Button
        self.check_object_Button(object_uid, lines_list)

    #-------------------------------------------------------------------------------------------------
    def check_object_Enclosure(self, object_uid, lines_list):
        # check the data of an Enclosure object section which the lines are in the given lines list

        # required attributes
        # none required attribute

        # optional attributes
        self.check_attribute_value(object_uid, lines_list, 'Name', ATTR_TYPE_STRING, False)
        self.check_attribute_value(object_uid, lines_list, 'AmpMinimumLevel', ATTR_TYPE_INTEGER, False, 0, 100)
        self.check_attribute_value(object_uid, lines_list, 'MIDIInputNumber', ATTR_TYPE_INTEGER, False, 0, 100)
        self.check_attribute_value(object_uid, lines_list, 'Displayed', ATTR_TYPE_BOOLEAN, False)
        self.check_attribute_value(object_uid, lines_list, 'DispLabelColour', ATTR_TYPE_COLOR, False)
        self.check_attribute_value(object_uid, lines_list, 'DispLabelFontSize', ATTR_TYPE_FONT_SIZE, False)
        self.check_attribute_value(object_uid, lines_list, 'DispLabelFontName', ATTR_TYPE_STRING, False)
        self.check_attribute_value(object_uid, lines_list, 'DispLabelText', ATTR_TYPE_STRING, False)
        self.check_attribute_value(object_uid, lines_list, 'EnclosureStyle', ATTR_TYPE_INTEGER, False, 1, 4)

        value = self.check_attribute_value(object_uid, lines_list, 'BitmapCount', ATTR_TYPE_INTEGER, False, 1, 128)
        if value != None and value.isdigit():
            image = None
            for idx in range(1, int(value)+1):
                image = self.check_attribute_value(object_uid, lines_list, f'Bitmap{str(idx).zfill(3)}', ATTR_TYPE_FILE_NAME, True)
                self.check_attribute_value(object_uid, lines_list, f'Mask{str(idx).zfill(3)}', ATTR_TYPE_FILE_NAME, False)
            # get the dimensions of the last enclosure bitmap
            if image != None and image != '' and self.check_files_names_bool:
                # an image is defined to display the enclosure
                # get the sizes of the image in the file which is existing
                im = Image.open(os.path.dirname(self.odf_file_name) + os.sep + path2ospath(image))
                bitmap_width = im.size[0]
                bitmap_height = im.size[1]
            else:
                bitmap_width = 100  # arbitrary default value
                bitmap_height = 200 # arbitrary default value
        else:
            # no image file defined, get the dimensions of the internal bitmap
            bitmap_width = 46
            bitmap_height = 61

        # get the dimensions of the parent panel
        panel_uid = self.object_parent_panel_get(object_uid)
        value = self.object_attr_value_get(panel_uid, 'DispScreenSizeHoriz')
        panel_width = int(value) if value != None and value.isdigit() else 3000
        value = self.object_attr_value_get(panel_uid, 'DispScreenSizeVert')
        panel_height = int(value) if value != None and value.isdigit() else 2000

        self.check_attribute_value(object_uid, lines_list, 'PositionX', ATTR_TYPE_INTEGER, False, 0, panel_width)
        self.check_attribute_value(object_uid, lines_list, 'PositionY', ATTR_TYPE_INTEGER, False, 0, panel_height)
        width = self.check_attribute_value(object_uid, lines_list, 'Width', ATTR_TYPE_INTEGER, False, 0, panel_width)
        height = self.check_attribute_value(object_uid, lines_list, 'Height', ATTR_TYPE_INTEGER, False, 0, panel_height)
        max_width = int(width) if width != None and width.isdigit() else panel_width
        max_height = int(height) if height != None and height.isdigit() else panel_height

        self.check_attribute_value(object_uid, lines_list, 'TileOffsetX', ATTR_TYPE_INTEGER, False, 0, bitmap_width)
        self.check_attribute_value(object_uid, lines_list, 'TileOffsetY', ATTR_TYPE_INTEGER, False, 0, bitmap_height)

        self.check_attribute_value(object_uid, lines_list, 'MouseRectLeft', ATTR_TYPE_INTEGER, False, 0, max_width)
        self.check_attribute_value(object_uid, lines_list, 'MouseRectTop', ATTR_TYPE_INTEGER, False, 0, max_height)
        self.check_attribute_value(object_uid, lines_list, 'MouseRectWidth', ATTR_TYPE_INTEGER, False, 0, max_width)
        mouse_rect_height = self.check_attribute_value(object_uid, lines_list, 'MouseRectHeight', ATTR_TYPE_INTEGER, False, 0, max_height)

        if mouse_rect_height != None and mouse_rect_height.isdigit():
            max_start = int(mouse_rect_height)
        else:
            max_start = 200
        mouse_axis_start = self.check_attribute_value(object_uid, lines_list, 'MouseAxisStart', ATTR_TYPE_INTEGER, False, 0, max_start)

        if mouse_axis_start != None and mouse_axis_start.isdigit():
            min_end = int(mouse_axis_start)
        else:
            min_end = 200
        self.check_attribute_value(object_uid, lines_list, 'MouseAxisEnd', ATTR_TYPE_INTEGER, False, min_end, max_start)

        self.check_attribute_value(object_uid, lines_list, 'TextRectLeft', ATTR_TYPE_INTEGER, False, 0, max_width)
        self.check_attribute_value(object_uid, lines_list, 'TextRectTop', ATTR_TYPE_INTEGER, False, 0, max_height)
        text_rect_width = self.check_attribute_value(object_uid, lines_list, 'TextRectWidth', ATTR_TYPE_INTEGER, False, 0, max_width)
        self.check_attribute_value(object_uid, lines_list, 'TextRectHeight', ATTR_TYPE_INTEGER, False, 0, max_height)

        if text_rect_width != None and text_rect_width.isdigit():
            text_break_width = int(text_rect_width)
        else:
            text_break_width = bitmap_width
        self.check_attribute_value(object_uid, lines_list, 'TextBreakWidth', ATTR_TYPE_INTEGER, False, 0, text_break_width)

    #-------------------------------------------------------------------------------------------------
    def check_object_General(self, object_uid, lines_list):
        # check the data of a General object section which the lines are in the given lines list

        is_general_obj = (self.object_type_get(object_uid) == 'General') # some mandatory attributes are not mandatory for objects which inherit the General attributes

        # required attributes
        max = self.objects_type_number_get('Coupler')
        value = self.check_attribute_value(object_uid, lines_list, 'NumberOfCouplers', ATTR_TYPE_INTEGER, is_general_obj, 0, max)
        if value != None and value.isdigit():
            for idx in range(1, int(value)+1):
                self.check_attribute_value(object_uid, lines_list, f'CouplerNumber{str(idx).zfill(3)}', ATTR_TYPE_OBJECT_REF, True)
                self.check_attribute_value(object_uid, lines_list, f'CouplerManual{str(idx).zfill(3)}', ATTR_TYPE_OBJECT_REF, True)

        max = self.objects_type_number_get('DivisionalCoupler')
        value = self.check_attribute_value(object_uid, lines_list, 'NumberOfDivisionalCouplers', ATTR_TYPE_INTEGER, False, 0, max)
        if value != None and value.isdigit():
            for idx in range(1, int(value)+1):
                self.check_attribute_value(object_uid, lines_list, f'DivisionalCouplerNumber{str(idx).zfill(3)}', ATTR_TYPE_OBJECT_REF, True)

        max = self.objects_type_number_get('Stop')
        value = self.check_attribute_value(object_uid, lines_list, 'NumberOfStops', ATTR_TYPE_INTEGER, is_general_obj, 0, max)
        if value != None and value.isdigit():
            for idx in range(1, int(value)+1):
                self.check_attribute_value(object_uid, lines_list, f'StopNumber{str(idx).zfill(3)}', ATTR_TYPE_OBJECT_REF, True)
                self.check_attribute_value(object_uid, lines_list, f'StopManual{str(idx).zfill(3)}', ATTR_TYPE_OBJECT_REF, True)

        max = self.objects_type_number_get('Tremulant')
        value = self.check_attribute_value(object_uid, lines_list, 'NumberOfTremulants', ATTR_TYPE_INTEGER, is_general_obj, 0, max)
        if value != None and value.isdigit():
            for idx in range(1, int(value)+1):
                self.check_attribute_value(object_uid, lines_list, f'TremulantNumber{str(idx).zfill(3)}', ATTR_TYPE_OBJECT_REF, True)

        # optional attributes
        max = self.objects_type_number_get('Switch')
        value = self.check_attribute_value(object_uid, lines_list, 'NumberOfSwitches', ATTR_TYPE_INTEGER, False, 0, max)
        if value != None and value.isdigit():
            for idx in range(1, int(value)+1):
                self.check_attribute_value(object_uid, lines_list, f'SwitchNumber{str(idx).zfill(3)}', ATTR_TYPE_OBJECT_REF, True)

        self.check_attribute_value(object_uid, lines_list, 'Protected', ATTR_TYPE_BOOLEAN, False)

        # a General has in addition the attributes of a Push Button
        self.check_object_PushButton(object_uid, lines_list)

    #-------------------------------------------------------------------------------------------------
    def check_object_Image(self, object_uid, lines_list):
        # check the data of an Image object section which the lines are in the given lines list

        # required attributes
        image = self.check_attribute_value(object_uid, lines_list, 'Image', ATTR_TYPE_FILE_NAME, True)

        # get the dimensions of the parent panel
        parent_panel_uid = self.object_parent_panel_get(object_uid)
        value = self.object_attr_value_get(parent_panel_uid, 'DispScreenSizeHoriz')
        panel_width = int(value) if value != None and value.isdigit() else 3000
        value = self.object_attr_value_get(parent_panel_uid, 'DispScreenSizeVert')
        panel_height = int(value) if value != None and value.isdigit() else 2000

        # optional attributes
        self.check_attribute_value(object_uid, lines_list, 'Mask', ATTR_TYPE_FILE_NAME, False)
        self.check_attribute_value(object_uid, lines_list, 'PositionX', ATTR_TYPE_INTEGER, False, 0, panel_width)
        self.check_attribute_value(object_uid, lines_list, 'PositionY', ATTR_TYPE_INTEGER, False, 0, panel_height)
        self.check_attribute_value(object_uid, lines_list, 'Width', ATTR_TYPE_INTEGER, False, 0, panel_width)
        self.check_attribute_value(object_uid, lines_list, 'Height', ATTR_TYPE_INTEGER, False, 0, panel_height)

        # get the dimensions of the image bitmap
        if image != None and image != '':
            # an image is defined
            if self.check_files_names_bool:
                # get the sizes of the image in the file which is existing
                im = Image.open(os.path.dirname(self.odf_file_name) + os.sep + path2ospath(image))
                bitmap_width = im.size[0]
                bitmap_height = im.size[1]
            else:
                bitmap_width = panel_width
                bitmap_height = panel_height
        else:
            # no image file defined
            bitmap_width = panel_width
            bitmap_height = panel_height

        self.check_attribute_value(object_uid, lines_list, 'TileOffsetX', ATTR_TYPE_INTEGER, False, 0, bitmap_width)
        self.check_attribute_value(object_uid, lines_list, 'TileOffsetY', ATTR_TYPE_INTEGER, False, 0, bitmap_height)

    #-------------------------------------------------------------------------------------------------
    def check_object_Label(self, object_uid, lines_list):
        # check the data of a Label object section which the lines are in the given lines list

        # optional attributes
        self.check_attribute_value(object_uid, lines_list, 'Name', ATTR_TYPE_STRING, False)
        ret1 = self.check_attribute_value(object_uid, lines_list, 'FreeXPlacement', ATTR_TYPE_BOOLEAN, False)
        ret2 = self.check_attribute_value(object_uid, lines_list, 'FreeYPlacement', ATTR_TYPE_BOOLEAN, False)

        # get the dimensions of the parent panel
        parent_panel_uid = self.object_parent_panel_get(object_uid)
        value = self.object_attr_value_get(parent_panel_uid, 'DispScreenSizeHoriz')
        panel_width = int(value) if value != None and value.isdigit() else 3000
        value = self.object_attr_value_get(parent_panel_uid, 'DispScreenSizeVert')
        panel_height = int(value) if value != None and value.isdigit() else 2000

        self.check_attribute_value(object_uid, lines_list, 'DispXpos', ATTR_TYPE_INTEGER, False, 0, panel_width)
        self.check_attribute_value(object_uid, lines_list, 'DispYpos', ATTR_TYPE_INTEGER, False, 0, panel_height)

        self.check_attribute_value(object_uid, lines_list, 'DispAtTopOfDrawstopCol', ATTR_TYPE_BOOLEAN, ret2 == 'N')

        # get the number of drawstop columns in the parent panel
        value = self.object_attr_value_get(parent_panel_uid, 'DispDrawstopCols')
        columns_nb = int(value) if value != None and value.isdigit() else 12
        self.check_attribute_value(object_uid, lines_list, 'DispDrawstopCol', ATTR_TYPE_INTEGER, ret1 == 'N', 1, columns_nb)

        self.check_attribute_value(object_uid, lines_list, 'DispSpanDrawstopColToRight', ATTR_TYPE_BOOLEAN, True if ret1 == 'N' else False)
        self.check_attribute_value(object_uid, lines_list, 'DispLabelColour', ATTR_TYPE_COLOR, False)
        self.check_attribute_value(object_uid, lines_list, 'DispLabelFontSize', ATTR_TYPE_FONT_SIZE, False)
        self.check_attribute_value(object_uid, lines_list, 'DispLabelFontName', ATTR_TYPE_STRING, False)
        image_num = self.check_attribute_value(object_uid, lines_list, 'DispImageNum', ATTR_TYPE_INTEGER, False, 1, 12)
        image = self.check_attribute_value(object_uid, lines_list, 'Image', ATTR_TYPE_FILE_NAME, False)
        self.check_attribute_value(object_uid, lines_list, 'Mask', ATTR_TYPE_FILE_NAME, False)

        self.check_attribute_value(object_uid, lines_list, 'PositionX', ATTR_TYPE_INTEGER, False, 0, panel_width)
        self.check_attribute_value(object_uid, lines_list, 'PositionY', ATTR_TYPE_INTEGER, False, 0, panel_height)
        width = self.check_attribute_value(object_uid, lines_list, 'Width', ATTR_TYPE_INTEGER, False, 0, panel_width)
        height = self.check_attribute_value(object_uid, lines_list, 'Height', ATTR_TYPE_INTEGER, False, 0, panel_height)
        max_width = int(width) if width != None and width.isdigit() else panel_width
        max_height = int(height) if height != None and height.isdigit() else panel_height

        # get the dimensions of the label bitmap
        if image != None and image != '':
            # an image is defined to display the label
            if self.check_files_names_bool:
                # get the sizes of the image in the file which is existing
                im = Image.open(os.path.dirname(self.odf_file_name) + os.sep + path2ospath(image))
                bitmap_width = im.size[0]
                bitmap_height = im.size[1]
            else:
                bitmap_width = 400  # arbritrary default value
                bitmap_height = 100 # arbritrary default value
        else:
            if   image_num == '1':  bitmap_width = 80; bitmap_height = 25
            elif image_num == '2':  bitmap_width = 80; bitmap_height = 50
            elif image_num == '3':  bitmap_width = 80; bitmap_height = 25
            elif image_num == '4':  bitmap_width = 160; bitmap_height = 25
            elif image_num == '5':  bitmap_width = 200; bitmap_height = 50
            elif image_num == '6':  bitmap_width = 80; bitmap_height = 50
            elif image_num == '7':  bitmap_width = 80; bitmap_height = 25
            elif image_num == '8':  bitmap_width = 160; bitmap_height = 25
            elif image_num == '9':  bitmap_width = 80; bitmap_height = 50
            elif image_num == '10': bitmap_width = 80; bitmap_height = 25
            elif image_num == '11': bitmap_width = 160; bitmap_height = 25
            else:                   bitmap_width = 200; bitmap_height = 50


        self.check_attribute_value(object_uid, lines_list, 'TileOffsetX', ATTR_TYPE_INTEGER, False, 0, bitmap_width)
        self.check_attribute_value(object_uid, lines_list, 'TileOffsetY', ATTR_TYPE_INTEGER, False, 0, bitmap_height)

        self.check_attribute_value(object_uid, lines_list, 'TextRectLeft', ATTR_TYPE_INTEGER, False, 0, max_width)
        self.check_attribute_value(object_uid, lines_list, 'TextRectTop', ATTR_TYPE_INTEGER, False, 0, max_height)
        text_rect_width = self.check_attribute_value(object_uid, lines_list, 'TextRectWidth', ATTR_TYPE_INTEGER, False, 0, max_width)
        self.check_attribute_value(object_uid, lines_list, 'TextRectHeight', ATTR_TYPE_INTEGER, False, 0, max_height)

        if text_rect_width != None and text_rect_width.isdigit():
            text_break_width = int(text_rect_width)
        else:
            text_break_width = bitmap_width
        self.check_attribute_value(object_uid, lines_list, 'TextBreakWidth', ATTR_TYPE_INTEGER, False, 0, text_break_width)

    #-------------------------------------------------------------------------------------------------
    def check_object_Manual(self, object_uid, lines_list):
        # check the data of a Manual object section which the lines are in the given lines list

        is_manual_obj = (self.object_type_get(object_uid) == 'Manual') # some mandatory attributes are not mandatory for objects which inherit the Manual attributes

        if not is_manual_obj:
            # object_uid is a PanelElement object with Type=Manual, get the UID of the linked Manual
            manual_uid = self.object_attr_value_get(object_uid, 'Manual')
            if manual_uid != None:
                manual_uid = 'Manual' + str(int(manual_uid)).zfill(3)
        else:
            manual_uid = None

        # required attributes
        self.check_attribute_value(object_uid, lines_list, 'Name', ATTR_TYPE_STRING, is_manual_obj)
        value = self.check_attribute_value(object_uid, lines_list, 'NumberOfLogicalKeys', ATTR_TYPE_INTEGER, is_manual_obj, 1, 192)
        if value == None and manual_uid != None:
            # recover the number of logical keys in the linked Manual object
            value = self.object_attr_value_get(manual_uid, 'NumberOfLogicalKeys')

        if value != None and value.isdigit() and int(value) > 0:
            for idx in range(1, int(value) + 1):
                # attributes Key999xxx
                image = self.check_attribute_value(object_uid, lines_list, f'Key{str(idx).zfill(3)}ImageOn', ATTR_TYPE_FILE_NAME, False)
                if image != None and image != '':
                    # check the other attributes for this key only if an image on is defined
                    self.check_attribute_value(object_uid, lines_list, f'Key{str(idx).zfill(3)}ImageOff', ATTR_TYPE_FILE_NAME, False)
                    self.check_attribute_value(object_uid, lines_list, f'Key{str(idx).zfill(3)}MaskOn', ATTR_TYPE_FILE_NAME, False)
                    self.check_attribute_value(object_uid, lines_list, f'Key{str(idx).zfill(3)}MaskOff', ATTR_TYPE_FILE_NAME, False)
                    self.check_attribute_value(object_uid, lines_list, f'Key{str(idx).zfill(3)}Width', ATTR_TYPE_INTEGER, False, 0, 500)
                    self.check_attribute_value(object_uid, lines_list, f'Key{str(idx).zfill(3)}Offset', ATTR_TYPE_INTEGER, False, -500, 500)
                    self.check_attribute_value(object_uid, lines_list, f'Key{str(idx).zfill(3)}YOffset', ATTR_TYPE_INTEGER, False, 0, 500)

                    # get the dimensions of the key bitmap
                    # an image is defined to display the key
                    if self.check_files_names_bool:
                        # get the sizes of the image in the file which is existing
                        im = Image.open(os.path.dirname(self.odf_file_name) + os.sep + path2ospath(image))
                        bitmap_width = im.size[0]
                        bitmap_height = im.size[1]
                    else:
                        bitmap_width = 100  # arbritrary default value
                        bitmap_height = 300 # arbritrary default value

                    self.check_attribute_value(object_uid, lines_list, f'Key{str(idx).zfill(3)}MouseRectLeft', ATTR_TYPE_INTEGER, False, 0, bitmap_width)
                    self.check_attribute_value(object_uid, lines_list, f'Key{str(idx).zfill(3)}MouseRectTop', ATTR_TYPE_INTEGER, False, 0, bitmap_height)
                    self.check_attribute_value(object_uid, lines_list, f'Key{str(idx).zfill(3)}MouseRectWidth', ATTR_TYPE_INTEGER, False, 0, bitmap_width)
                    self.check_attribute_value(object_uid, lines_list, f'Key{str(idx).zfill(3)}MouseRectHeight', ATTR_TYPE_INTEGER, False, 0, bitmap_height)

        logical_keys_nb = int(value) if value != None and value.isdigit() else 192
        self.check_attribute_value(object_uid, lines_list, 'FirstAccessibleKeyLogicalKeyNumber', ATTR_TYPE_INTEGER, is_manual_obj, 1, logical_keys_nb)
        self.check_attribute_value(object_uid, lines_list, 'FirstAccessibleKeyMIDINoteNumber', ATTR_TYPE_INTEGER, is_manual_obj, 0, 127)

        value = self.check_attribute_value(object_uid, lines_list, 'NumberOfAccessibleKeys', ATTR_TYPE_INTEGER, is_manual_obj, 0, 85)
        accessible_keys_nb = int(value) if value != None and value.isdigit() else 85

        value = self.check_attribute_value(object_uid, lines_list, 'NumberOfCouplers', ATTR_TYPE_INTEGER, False, 0, 999)
        if value != None and value.isdigit() and int(value) > 0:
            for idx in range(1, int(value)+1):
                self.check_attribute_value(object_uid, lines_list, f'Coupler{str(idx).zfill(3)}', ATTR_TYPE_OBJECT_REF, True)

        value = self.check_attribute_value(object_uid, lines_list, 'NumberOfDivisionals', ATTR_TYPE_INTEGER, False, 0, 999)
        if value != None and value.isdigit() and int(value) > 0:
            for idx in range(1, int(value)+1):
                self.check_attribute_value(object_uid, lines_list, f'Divisional{str(idx).zfill(3)}', ATTR_TYPE_OBJECT_REF, True)

        value = self.check_attribute_value(object_uid, lines_list, 'NumberOfStops', ATTR_TYPE_INTEGER, False, 0, 999)
        if value != None and value.isdigit() and int(value) > 0:
            for idx in range(1, int(value)+1):
                self.check_attribute_value(object_uid, lines_list, f'Stop{str(idx).zfill(3)}', ATTR_TYPE_OBJECT_REF, True)

        max = self.objects_type_number_get('Switch')
        value = self.check_attribute_value(object_uid, lines_list, 'NumberOfSwitches', ATTR_TYPE_INTEGER, False, 0, max)
        if value != None and value.isdigit() and int(value) > 0:
            for idx in range(1, int(value)+1):
                self.check_attribute_value(object_uid, lines_list, f'Switch{str(idx).zfill(3)}', ATTR_TYPE_OBJECT_REF, True)

        max = self.objects_type_number_get('Tremulant')
        value = self.check_attribute_value(object_uid, lines_list, 'NumberOfTremulants', ATTR_TYPE_INTEGER, False, 0, max)
        if value != None and value.isdigit() and int(value) > 0:
            for idx in range(1, int(value)+1):
                self.check_attribute_value(object_uid, lines_list, f'Tremulant{str(idx).zfill(3)}', ATTR_TYPE_OBJECT_REF, True)

        # optional attributes
        for idx in range(0, 128):
            self.check_attribute_value(object_uid, lines_list, f'MIDIKey{str(idx).zfill(3)}', ATTR_TYPE_INTEGER, False, 0, 127)

        self.check_attribute_value(object_uid, lines_list, 'MIDIInputNumber', ATTR_TYPE_INTEGER, False, 0, 200)
        self.check_attribute_value(object_uid, lines_list, 'Displayed', ATTR_TYPE_BOOLEAN, False)

        # get the dimensions of the parent panel
        parent_panel_uid = self.object_parent_panel_get(object_uid)
        value = self.object_attr_value_get(parent_panel_uid, 'DispScreenSizeHoriz')
        panel_width = int(value) if value != None and value.isdigit() else 3000
        value = self.object_attr_value_get(parent_panel_uid, 'DispScreenSizeVert')
        panel_height = int(value) if value != None and value.isdigit() else 2000

        self.check_attribute_value(object_uid, lines_list, 'PositionX', ATTR_TYPE_INTEGER, False, 0, panel_width)
        self.check_attribute_value(object_uid, lines_list, 'PositionY', ATTR_TYPE_INTEGER, False, 0, panel_height)

        self.check_attribute_value(object_uid, lines_list, 'DispKeyColourInverted', ATTR_TYPE_BOOLEAN, False)
        self.check_attribute_value(object_uid, lines_list, 'DispKeyColourWooden', ATTR_TYPE_BOOLEAN, False)
        self.check_attribute_value(object_uid, lines_list, 'DisplayFirstNote', ATTR_TYPE_INTEGER, False, 0, 127)

        value = self.check_attribute_value(object_uid, lines_list, 'DisplayKeys', ATTR_TYPE_INTEGER, False, 1, accessible_keys_nb)
        if value != None and value.isdigit() and int(value) > 0:
            for idx in range(1, int(value)+1):
                self.check_attribute_value(object_uid, lines_list, f'DisplayKey{str(idx).zfill(3)}', ATTR_TYPE_INTEGER, False, 0, 127)
                self.check_attribute_value(object_uid, lines_list, f'DisplayKey{str(idx).zfill(3)}Note', ATTR_TYPE_INTEGER, False, 0, 127)

        # optional attributes with the KEYTYPE format
        ImageOn_First_keytype = None # variable to store if the first attribute have been already checked for the ImageOn key type
        ImageOff_First_keytype = None
        MaskOn_First_keytype = None
        MaskOff_First_keytype = None
        Width_First_keytype = None
        Offset_First_keytype = None
        YOffset_First_keytype = None

        ImageOn_Last_keytype = None
        ImageOff_Last_keytype = None
        MaskOn_Last_keytype = None
        MaskOff_Last_keytype = None
        Width_Last_keytype = None
        Offset_Last_keytype = None
        YOffset_Last_keytype = None

        if object_uid == 'Panel000Element001':
            pass

        for keytype in ('C', 'Cis', 'D', 'Dis', 'E', 'F', 'Fis', 'G', 'Gis', 'A', 'Ais', 'B'):
            self.check_attribute_value(object_uid, lines_list, f'ImageOn_{keytype}', ATTR_TYPE_FILE_NAME, False)
            self.check_attribute_value(object_uid, lines_list, f'ImageOff_{keytype}', ATTR_TYPE_FILE_NAME, False)
            self.check_attribute_value(object_uid, lines_list, f'MaskOn_{keytype}', ATTR_TYPE_FILE_NAME, False)
            self.check_attribute_value(object_uid, lines_list, f'MaskOff_{keytype}', ATTR_TYPE_FILE_NAME, False)
            self.check_attribute_value(object_uid, lines_list, f'Width_{keytype}', ATTR_TYPE_INTEGER, False, 0, 500)
            self.check_attribute_value(object_uid, lines_list, f'Offset_{keytype}', ATTR_TYPE_INTEGER, False, -500, 500)
            self.check_attribute_value(object_uid, lines_list, f'YOffset_{keytype}', ATTR_TYPE_INTEGER, False, 0, 500)
            # the First and Last attributes are checked only once for each key property
            # so if there is more than one First or Last definition it will appear in the warning logs because it will not have been checked here
            if ImageOn_First_keytype == None : ImageOn_First_keytype = self.check_attribute_value(object_uid, lines_list, f'ImageOn_First{keytype}', ATTR_TYPE_FILE_NAME, False)
            if ImageOff_First_keytype == None : ImageOff_First_keytype = self.check_attribute_value(object_uid, lines_list, f'ImageOff_First{keytype}', ATTR_TYPE_FILE_NAME, False)
            if MaskOn_First_keytype == None : MaskOn_First_keytype = self.check_attribute_value(object_uid, lines_list, f'MaskOn_First{keytype}', ATTR_TYPE_FILE_NAME, False)
            if MaskOff_First_keytype == None : MaskOff_First_keytype = self.check_attribute_value(object_uid, lines_list, f'MaskOff_First{keytype}', ATTR_TYPE_FILE_NAME, False)
            if Width_First_keytype == None : Width_First_keytype = self.check_attribute_value(object_uid, lines_list, f'Width_First{keytype}', ATTR_TYPE_INTEGER, False, 0, 500)
            if Offset_First_keytype == None : Offset_First_keytype = self.check_attribute_value(object_uid, lines_list, f'Offset_First{keytype}', ATTR_TYPE_INTEGER, False, -500, 500)
            if YOffset_First_keytype == None : YOffset_First_keytype = self.check_attribute_value(object_uid, lines_list, f'YOffset_First{keytype}', ATTR_TYPE_INTEGER, False, 0, 500)

            if ImageOn_Last_keytype == None : ImageOn_Last_keytype = self.check_attribute_value(object_uid, lines_list, f'ImageOn_Last{keytype}', ATTR_TYPE_FILE_NAME, False)
            if ImageOff_Last_keytype == None : ImageOff_Last_keytype = self.check_attribute_value(object_uid, lines_list, f'ImageOff_Last{keytype}', ATTR_TYPE_FILE_NAME, False)
            if MaskOn_Last_keytype == None : MaskOn_Last_keytype = self.check_attribute_value(object_uid, lines_list, f'MaskOn_Last{keytype}', ATTR_TYPE_FILE_NAME, False)
            if MaskOff_Last_keytype == None : MaskOff_Last_keytype = self.check_attribute_value(object_uid, lines_list, f'MaskOff_Last{keytype}', ATTR_TYPE_FILE_NAME, False)
            if Width_Last_keytype == None : Width_Last_keytype = self.check_attribute_value(object_uid, lines_list, f'Width_Last{keytype}', ATTR_TYPE_INTEGER, False, 0, 500)
            if Offset_Last_keytype == None : Offset_Last_keytype = self.check_attribute_value(object_uid, lines_list, f'Offset_Last{keytype}', ATTR_TYPE_INTEGER, False, -500, 500)
            if YOffset_Last_keytype == None : YOffset_Last_keytype = self.check_attribute_value(object_uid, lines_list, f'YOffset_Last{keytype}', ATTR_TYPE_INTEGER, False, 0, 500)

    #-------------------------------------------------------------------------------------------------
    def check_object_Panel(self, object_uid, lines_list):
        # check the data of a Panel object section which the lines are in the given lines list

        is_additional_panel = not(object_uid in ('Panel000', 'Organ')) # it is an additional panel, in addition to the Panel000 or Organ (old format) panel

        if self.new_panel_format_bool:

            # required attributes (new panel format)
            self.check_attribute_value(object_uid, lines_list, 'Name', ATTR_TYPE_STRING, is_additional_panel)
            self.check_attribute_value(object_uid, lines_list, 'HasPedals', ATTR_TYPE_BOOLEAN, True)

            value = self.check_attribute_value(object_uid, lines_list, 'NumberOfGUIElements', ATTR_TYPE_INTEGER, True, 0, 999)
            if value != None and value.isdigit() and int(value) >= 0:
                count = self.objects_type_number_get(f'{object_uid}Element')
                if count != int(value):
                    logs.add(f"ERROR in {object_uid} : NumberOfGUIElements={value} whereas {count} {object_uid}Element object(s) defined")

            # optional attributes (new panel format)
            self.check_attribute_value(object_uid, lines_list, 'Group', ATTR_TYPE_STRING, False)

            value = self.check_attribute_value(object_uid, lines_list, 'NumberOfImages', ATTR_TYPE_INTEGER, False, 0, 999)
            if value != None and value.isdigit() and int(value) >= 0:
                count = self.objects_type_number_get(f'{object_uid}Image')
                if count != int(value):
                    logs.add(f"ERROR in {object_uid} : NumberOfImages={value} whereas {count} {object_uid}Image object(s) defined")

        elif is_additional_panel:  # additional panel in the old panel format (for the main panel, the non display metrics attributes are defined in the Organ object)

            # required attributes (old panel format, additional panel)
            self.check_attribute_value(object_uid, lines_list, 'Name', ATTR_TYPE_STRING, True)
            self.check_attribute_value(object_uid, lines_list, 'HasPedals', ATTR_TYPE_BOOLEAN, True)

            value = self.check_attribute_value(object_uid, lines_list, 'NumberOfCouplers', ATTR_TYPE_INTEGER, True, 0, 999)
            if value != None and value.isdigit() and int(value) >= 0:
                for idx in range(1, int(value)+1):
                    self.check_attribute_value(object_uid, lines_list, f"Coupler{str(idx).zfill(3)}", ATTR_TYPE_OBJECT_REF, True)
                    self.check_attribute_value(object_uid, lines_list, f"Coupler{str(idx).zfill(3)}Manual", ATTR_TYPE_OBJECT_REF, True)
                count = self.objects_type_number_get(f'{object_uid}Coupler')
                if count != int(value):
                    logs.add(f"ERROR in {object_uid} : NumberOfCouplers={value} whereas {count} {object_uid}Coupler object(s) defined")

            value = self.check_attribute_value(object_uid, lines_list, 'NumberOfDivisionals', ATTR_TYPE_INTEGER, True, 0, 999)
            if value != None and value.isdigit() and int(value) >= 0:
                for idx in range(1, int(value)+1):
                    self.check_attribute_value(object_uid, lines_list, f"Divisional{str(idx).zfill(3)}", ATTR_TYPE_OBJECT_REF, True)
                    self.check_attribute_value(object_uid, lines_list, f"Divisional{str(idx).zfill(3)}Manual", ATTR_TYPE_OBJECT_REF, True)
                count = self.objects_type_number_get(f'{object_uid}Divisional')
                if count != int(value):
                    logs.add(f"ERROR in {object_uid} : NumberOfDivisionals={value} whereas {count} {object_uid}Divisional object(s) defined")

            value = self.check_attribute_value(object_uid, lines_list, 'NumberOfDivisionalCouplers', ATTR_TYPE_INTEGER, True, 0, 8)
            if value != None and value.isdigit() and int(value) >= 0:
                for idx in range(1, int(value)+1):
                    self.check_attribute_value(object_uid, lines_list, f"DivisionalCoupler{str(idx).zfill(3)}", ATTR_TYPE_OBJECT_REF, True)
                count = self.objects_type_number_get(f'{object_uid}DivisionalCoupler')
                if count != int(value):
                    logs.add(f"ERROR in {object_uid} : NumberOfDivisionalCouplers={value} whereas {count} {object_uid}DivisionalCoupler object(s) defined")

            value = self.check_attribute_value(object_uid, lines_list, 'NumberOfEnclosures', ATTR_TYPE_INTEGER, True, 0, 50)
            if value != None and value.isdigit() and int(value) >= 0:
                for idx in range(1, int(value)+1):
                    self.check_attribute_value(object_uid, lines_list, f"Enclosure{str(idx).zfill(3)}", ATTR_TYPE_OBJECT_REF, True)
                count = self.objects_type_number_get(f'{object_uid}Enclosure')
                if count != int(value):
                    logs.add(f"ERROR in {object_uid} : NumberOfEnclosures={value} whereas {count} {object_uid}Enclosure object(s) defined")

            value = self.check_attribute_value(object_uid, lines_list, 'NumberOfGenerals', ATTR_TYPE_INTEGER, True, 0, 99)
            if value != None and value.isdigit() and int(value) >= 0:
                for idx in range(1, int(value)+1):
                    self.check_attribute_value(object_uid, lines_list, f"General{str(idx).zfill(3)}", ATTR_TYPE_OBJECT_REF, True)
                count = self.objects_type_number_get(f'{object_uid}General')
                if count != int(value):
                    logs.add(f"ERROR in {object_uid} : NumberOfGenerals={value} whereas {count} {object_uid}General object(s) defined")

            value = self.check_attribute_value(object_uid, lines_list, 'NumberOfImages', ATTR_TYPE_INTEGER, True, 0, 999)
            if value != None and value.isdigit() and int(value) >= 0:
                count = self.objects_type_number_get(f'{object_uid}Image')
                if count != int(value):
                    logs.add(f"ERROR in {object_uid} : NumberOfImages={value} whereas {count} {object_uid}Image object(s) defined")

            value = self.check_attribute_value(object_uid, lines_list, 'NumberOfLabels', ATTR_TYPE_INTEGER, True, 0, 999)
            if value != None and value.isdigit() and int(value) >= 0:
                count = self.objects_type_number_get(f'{object_uid}Label')
                if count != int(value):
                    logs.add(f"ERROR in {object_uid} : NumberOfLabels={value} whereas {count} {object_uid}Label object(s) defined")

            value = self.check_attribute_value(object_uid, lines_list, 'NumberOfManuals', ATTR_TYPE_INTEGER, True, 0, 16)
            if value != None and value.isdigit() and int(value) >= 0:
                for idx in range(1, int(value)+1):
                    self.check_attribute_value(object_uid, lines_list, f"Manual{str(idx).zfill(3)}", ATTR_TYPE_OBJECT_REF, True)

            value = self.check_attribute_value(object_uid, lines_list, 'NumberOfReversiblePistons', ATTR_TYPE_INTEGER, True, 0, 32)
            if value != None and value.isdigit() and int(value) >= 0:
                for idx in range(1, int(value)+1):
                    self.check_attribute_value(object_uid, lines_list, f"ReversiblePiston{str(idx).zfill(3)}", ATTR_TYPE_OBJECT_REF, True)
                count = self.objects_type_number_get(f'{object_uid}ReversiblePiston')
                if count != int(value):
                    logs.add(f"ERROR in {object_uid} : NumberOfReversiblePistons={value} whereas {count} {object_uid}ReversiblePiston object(s) defined")

            value = self.check_attribute_value(object_uid, lines_list, 'NumberOfStops', ATTR_TYPE_INTEGER, True, 0, 999)
            if value != None and value.isdigit() and int(value) >= 0:
                for idx in range(1, int(value)+1):
                    self.check_attribute_value(object_uid, lines_list, f"Stop{str(idx).zfill(3)}", ATTR_TYPE_OBJECT_REF, True)
                    self.check_attribute_value(object_uid, lines_list, f"Stop{str(idx).zfill(3)}Manual", ATTR_TYPE_OBJECT_REF, True)
                count = self.objects_type_number_get(f'{object_uid}Stop')
                if count != int(value):
                    logs.add(f"ERROR in {object_uid} : NumberOfStops={value} whereas {count} {object_uid}Stop object(s) defined")

            value = self.check_attribute_value(object_uid, lines_list, 'NumberOfTremulants', ATTR_TYPE_INTEGER, True, 0, 10)
            if value != None and value.isdigit() and int(value) >= 0:
                for idx in range(1, int(value)+1):
                    self.check_attribute_value(object_uid, lines_list, f"Tremulant{str(idx).zfill(3)}", ATTR_TYPE_OBJECT_REF, True)
                count = self.objects_type_number_get(f'{object_uid}Tremulant')
                if count != int(value):
                    logs.add(f"ERROR in {object_uid} : NumberOfTremulants={value} whereas {count} {object_uid}Tremulant object(s) defined")

            # optional attributes (old panel format, additional panel)
            self.check_attribute_value(object_uid, lines_list, 'Group', ATTR_TYPE_STRING, False)

            value = self.check_attribute_value(object_uid, lines_list, 'NumberOfSetterElements', ATTR_TYPE_INTEGER, False, 0, 8)
            if value != None and value.isdigit() and int(value) >= 0:
                count = self.objects_type_number_get(f'{object_uid}SetterElement')
                if count != int(value):
                    logs.add(f"ERROR in {object_uid} : NumberOfSetterElements={value} whereas {count} {object_uid}SetterElement object(s) defined")

            value = self.check_attribute_value(object_uid, lines_list, 'NumberOfSwitches', ATTR_TYPE_INTEGER, False, 0, 999)
            if value != None and value.isdigit() and int(value) >= 0:
                for idx in range(1, int(value)+1):
                    self.check_attribute_value(object_uid, lines_list, f"Switch{str(idx).zfill(3)}", ATTR_TYPE_OBJECT_REF, True)
                count = self.objects_type_number_get(f'{object_uid}Switch')
                if count != int(value):
                    logs.add(f"ERROR in {object_uid} : NumberOfSwitches={value} whereas {count} {object_uid}Switch object(s) defined")


        # display metrics (common to old and new panel formats)

        # required attributes (panel display metrics)
        self.check_attribute_value(object_uid, lines_list, 'DispScreenSizeHoriz', ATTR_TYPE_PANEL_SIZE, True)
        self.check_attribute_value(object_uid, lines_list, 'DispScreenSizeVert', ATTR_TYPE_PANEL_SIZE, True)
        self.check_attribute_value(object_uid, lines_list, 'DispDrawstopBackgroundImageNum', ATTR_TYPE_INTEGER, True, 1, 64)
        self.check_attribute_value(object_uid, lines_list, 'DispConsoleBackgroundImageNum', ATTR_TYPE_INTEGER, True, 1, 64)
        self.check_attribute_value(object_uid, lines_list, 'DispKeyHorizBackgroundImageNum', ATTR_TYPE_INTEGER, True, 1, 64)
        self.check_attribute_value(object_uid, lines_list, 'DispKeyVertBackgroundImageNum', ATTR_TYPE_INTEGER, True, 1, 64)
        self.check_attribute_value(object_uid, lines_list, 'DispDrawstopInsetBackgroundImageNum', ATTR_TYPE_INTEGER, True, 1, 64)
        self.check_attribute_value(object_uid, lines_list, 'DispControlLabelFont', ATTR_TYPE_STRING, True)
        self.check_attribute_value(object_uid, lines_list, 'DispShortcutKeyLabelFont', ATTR_TYPE_STRING, True)
        self.check_attribute_value(object_uid, lines_list, 'DispShortcutKeyLabelColour', ATTR_TYPE_COLOR, True)
        self.check_attribute_value(object_uid, lines_list, 'DispGroupLabelFont', ATTR_TYPE_STRING, True)
        self.check_attribute_value(object_uid, lines_list, 'DispDrawstopCols', ATTR_TYPE_INTEGER, True, 2, 12)
        self.check_attribute_value(object_uid, lines_list, 'DispDrawstopRows', ATTR_TYPE_INTEGER, True, 1, 20)
        cols_offset = self.check_attribute_value(object_uid, lines_list, 'DispDrawstopColsOffset', ATTR_TYPE_BOOLEAN, True)
        self.check_attribute_value(object_uid, lines_list, 'DispPairDrawstopCols', ATTR_TYPE_BOOLEAN, True)
        self.check_attribute_value(object_uid, lines_list, 'DispExtraDrawstopRows', ATTR_TYPE_INTEGER, True, 0, 99)
        self.check_attribute_value(object_uid, lines_list, 'DispExtraDrawstopCols', ATTR_TYPE_INTEGER, True, 0, 40)
        self.check_attribute_value(object_uid, lines_list, 'DispButtonCols', ATTR_TYPE_INTEGER, True, 1, 32)
        self.check_attribute_value(object_uid, lines_list, 'DispExtraButtonRows', ATTR_TYPE_INTEGER, True, 0, 99)
        extra_pedal_buttons = self.check_attribute_value(object_uid, lines_list, 'DispExtraPedalButtonRow', ATTR_TYPE_BOOLEAN, True)
        self.check_attribute_value(object_uid, lines_list, 'DispButtonsAboveManuals', ATTR_TYPE_BOOLEAN, True)
        self.check_attribute_value(object_uid, lines_list, 'DispExtraDrawstopRowsAboveExtraButtonRows', ATTR_TYPE_BOOLEAN, True)
        self.check_attribute_value(object_uid, lines_list, 'DispTrimAboveManuals', ATTR_TYPE_BOOLEAN, True)
        self.check_attribute_value(object_uid, lines_list, 'DispTrimBelowManuals', ATTR_TYPE_BOOLEAN, True)
        self.check_attribute_value(object_uid, lines_list, 'DispTrimAboveExtraRows', ATTR_TYPE_BOOLEAN, True)

        # optional attributes (panel display metrics)
        self.check_attribute_value(object_uid, lines_list, 'DispDrawstopWidth', ATTR_TYPE_INTEGER, False, 1, 150)
        self.check_attribute_value(object_uid, lines_list, 'DispDrawstopHeight', ATTR_TYPE_INTEGER, False, 1, 150)
        self.check_attribute_value(object_uid, lines_list, 'DispDrawstopOuterColOffsetUp', ATTR_TYPE_BOOLEAN, True if cols_offset != None and cols_offset == 'Y' else False)
        self.check_attribute_value(object_uid, lines_list, 'DispExtraPedalButtonRowOffset', ATTR_TYPE_BOOLEAN, True if extra_pedal_buttons != None and extra_pedal_buttons == 'Y' else False)
        self.check_attribute_value(object_uid, lines_list, 'DispExtraPedalButtonRowOffsetRight', ATTR_TYPE_BOOLEAN, False)
        self.check_attribute_value(object_uid, lines_list, 'DispPistonWidth', ATTR_TYPE_INTEGER, False, 1, 150)
        self.check_attribute_value(object_uid, lines_list, 'DispPistonHeight', ATTR_TYPE_INTEGER, False, 1, 150)
        self.check_attribute_value(object_uid, lines_list, 'DispEnclosureWidth', ATTR_TYPE_INTEGER, False, 1, 150)
        self.check_attribute_value(object_uid, lines_list, 'DispEnclosureHeight', ATTR_TYPE_INTEGER, False, 1, 150)
        self.check_attribute_value(object_uid, lines_list, 'DispPedalHeight', ATTR_TYPE_INTEGER, False, 1, 500)
        self.check_attribute_value(object_uid, lines_list, 'DispPedalKeyWidth', ATTR_TYPE_INTEGER, False, 1, 500)
        self.check_attribute_value(object_uid, lines_list, 'DispManualHeight', ATTR_TYPE_INTEGER, False, 1, 500)
        self.check_attribute_value(object_uid, lines_list, 'DispManualKeyWidth', ATTR_TYPE_INTEGER, False, 1, 500)

    #-------------------------------------------------------------------------------------------------
    def check_object_PanelElement(self, object_uid, lines_list):
        # check the data of a Panel Element object section which the lines are in the given lines list

        # required attributes
        type = self.check_attribute_value(object_uid, lines_list, 'Type', ATTR_TYPE_ELEMENT_TYPE, True)

        if type == None:
            pass
        elif type == 'Coupler':
            self.check_attribute_value(object_uid, lines_list, 'Manual', ATTR_TYPE_OBJECT_REF, True)
            self.check_attribute_value(object_uid, lines_list, 'Coupler', ATTR_TYPE_OBJECT_REF, True)
            self.check_object_Coupler(object_uid, lines_list)
        elif type == 'Divisional':
            self.check_attribute_value(object_uid, lines_list, 'Manual', ATTR_TYPE_OBJECT_REF, True)
            self.check_attribute_value(object_uid, lines_list, 'Divisional', ATTR_TYPE_OBJECT_REF, True)
            self.check_object_Divisional(object_uid, lines_list)
        elif type == 'DivisionalCoupler':
            self.check_attribute_value(object_uid, lines_list, 'DivisionalCoupler', ATTR_TYPE_OBJECT_REF, True)
            self.check_object_DivisionalCoupler(object_uid, lines_list)
        elif type == 'Enclosure':
            self.check_attribute_value(object_uid, lines_list, 'Enclosure', ATTR_TYPE_OBJECT_REF, True)
            self.check_object_Enclosure(object_uid, lines_list)
        elif type == 'General':
            self.check_attribute_value(object_uid, lines_list, 'General', ATTR_TYPE_OBJECT_REF, True)
            self.check_object_General(object_uid, lines_list)
        elif type == 'Label':
            self.check_object_Label(object_uid, lines_list)
        elif type == 'Manual':
            self.check_attribute_value(object_uid, lines_list, 'Manual', ATTR_TYPE_OBJECT_REF, True)
            self.check_object_Manual(object_uid, lines_list)
        elif type == 'ReversiblePiston':
            self.check_attribute_value(object_uid, lines_list, 'ReversiblePiston', ATTR_TYPE_OBJECT_REF, True)
            self.check_object_ReversiblePiston(object_uid, lines_list)
        elif type == 'Stop':
            self.check_attribute_value(object_uid, lines_list, 'Manual', ATTR_TYPE_OBJECT_REF, True)
            self.check_attribute_value(object_uid, lines_list, 'Stop', ATTR_TYPE_OBJECT_REF, True)
            self.check_object_Stop(object_uid, lines_list)
        elif type == 'Swell':
            self.check_object_Enclosure(object_uid, lines_list)
        elif type == 'Switch':
            self.check_attribute_value(object_uid, lines_list, 'Switch', ATTR_TYPE_OBJECT_REF, True)
            self.check_object_Switch(object_uid, lines_list)
        elif type == 'Tremulant':
            self.check_attribute_value(object_uid, lines_list, 'Tremulant', ATTR_TYPE_OBJECT_REF, True)
            self.check_object_Tremulant(object_uid, lines_list)
        else:
            self.check_object_SetterElement(object_uid, lines_list, type)

    #-------------------------------------------------------------------------------------------------
    def check_object_PanelOther(self, object_uid, lines_list):
        # check the data of an other kind of Panel object section (Panel999Coupler999, Panel999Divisional999, ...) which the lines are in the given lines list

        # get the panel elemnt type from the object UID (for example Coupler from Panel999Coupler999)
        panel_element_type = object_uid[8:-3]

        # check the attributes of the object depending on the object type
        if panel_element_type == 'Coupler':
            self.check_object_Coupler(object_uid, lines_list)
        elif panel_element_type == 'Divisional':
            self.check_object_Divisional(object_uid, lines_list)
        elif panel_element_type == 'DivisionalCoupler':
            self.check_object_DivisionalCoupler(object_uid, lines_list)
        elif panel_element_type == 'Enclosure':
            self.check_object_Enclosure(object_uid, lines_list)
        elif panel_element_type == 'General':
            self.check_object_General(object_uid, lines_list)
        elif panel_element_type == 'Image':
            self.check_object_Image(object_uid, lines_list)
        elif panel_element_type == 'Label':
            self.check_object_Label(object_uid, lines_list)
        elif panel_element_type == 'ReversiblePiston':
            self.check_object_ReversiblePiston(object_uid, lines_list)
        elif panel_element_type == 'SetterElement':
            self.check_object_SetterElement(object_uid, lines_list)
        elif panel_element_type == 'Stop':
            self.check_object_Stop(object_uid, lines_list)
        elif panel_element_type == 'Switch':
            self.check_object_Switch(object_uid, lines_list)
        elif panel_element_type == 'Tremulant':
            self.check_object_Tremulant(object_uid, lines_list)

    #-------------------------------------------------------------------------------------------------
    def check_object_Piston(self, object_uid, lines_list):
        # check the data of a Piston object section which the lines are in the given lines list

        # required attributes
        value = self.check_attribute_value(object_uid, lines_list, 'ObjectType', ATTR_TYPE_PISTON_TYPE, True)
        self.check_attribute_value(object_uid, lines_list, 'ManualNumber', ATTR_TYPE_OBJECT_REF, value in ('STOP', 'COUPLER'))
        self.check_attribute_value(object_uid, lines_list, 'ObjectNumber', ATTR_TYPE_INTEGER, False, 1, 200)

        # a Piston has also the attributes of a Push Button
        self.check_object_PushButton(object_uid, lines_list)

    #-------------------------------------------------------------------------------------------------
    def check_object_PushButton(self, object_uid, lines_list):
        # check the data of a Push Button object section which the lines are in the given lines list

        # a Push Button has only the attributes of a Button
        self.check_object_Button(object_uid, lines_list)

    #-------------------------------------------------------------------------------------------------
    def check_object_Rank(self, object_uid, lines_list):
        # check the data of a Rank object section which the lines are in the given lines list

        is_rank_obj = (self.object_type_get(object_uid) == 'Rank') # some mandatory attributes are not mandatory for objects which inherit the Rank attributes (like Stop)

        # required attributes
        self.check_attribute_value(object_uid, lines_list, 'Name', ATTR_TYPE_STRING, True)
        self.check_attribute_value(object_uid, lines_list, 'FirstMidiNoteNumber', ATTR_TYPE_INTEGER, is_rank_obj, 0, 256)
        self.check_attribute_value(object_uid, lines_list, 'WindchestGroup', ATTR_TYPE_OBJECT_REF, True)
        self.check_attribute_value(object_uid, lines_list, 'Percussive', ATTR_TYPE_BOOLEAN, True)

        # optional attributes
        self.check_attribute_value(object_uid, lines_list, 'AmplitudeLevel', ATTR_TYPE_FLOAT, False, 0, 1000)
        self.check_attribute_value(object_uid, lines_list, 'Gain', ATTR_TYPE_FLOAT, False, -120, 40)
        self.check_attribute_value(object_uid, lines_list, 'PitchTuning', ATTR_TYPE_FLOAT, False, -1200, 1200)
        self.check_attribute_value(object_uid, lines_list, 'TrackerDelay', ATTR_TYPE_INTEGER, False, 0, 10000)
        self.check_attribute_value(object_uid, lines_list, 'HarmonicNumber', ATTR_TYPE_FLOAT, False, 1, 1024)
        self.check_attribute_value(object_uid, lines_list, 'PitchCorrection', ATTR_TYPE_FLOAT, False, -1200, 1200)
        self.check_attribute_value(object_uid, lines_list, 'MinVelocityVolume', ATTR_TYPE_FLOAT, False, 0, 1000)
        self.check_attribute_value(object_uid, lines_list, 'MaxVelocityVolume', ATTR_TYPE_FLOAT, False, 0, 1000)
        self.check_attribute_value(object_uid, lines_list, 'AcceptsRetuning', ATTR_TYPE_BOOLEAN, False)

        value = self.check_attribute_value(object_uid, lines_list, 'NumberOfLogicalPipes', ATTR_TYPE_INTEGER, is_rank_obj, 1, 192)
        if value != None and value.isdigit():
            for idx in range(1, int(value)+1):  # Pipe999xxx attributes
                self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}', ATTR_TYPE_PIPE_WAVE, True)
                self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}Percussive', ATTR_TYPE_BOOLEAN, False)
                self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}AmplitudeLevel', ATTR_TYPE_FLOAT, False, 0, 1000)
                self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}Gain', ATTR_TYPE_FLOAT, False, -120, 40)
                self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}PitchTuning', ATTR_TYPE_FLOAT, False, -1200, 1200)
                self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}TrackerDelay', ATTR_TYPE_FLOAT, False, 0, 10000)
                self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}LoadRelease', ATTR_TYPE_BOOLEAN, False)
                self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}AttackVelocity', ATTR_TYPE_INTEGER, False, 0, 127)
                self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}MaxTimeSinceLastRelease', ATTR_TYPE_INTEGER, False, -1, 100000)
                self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}IsTremulant', ATTR_TYPE_INTEGER, False, -1, 1)
                self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}MaxKeyPressTime', ATTR_TYPE_INTEGER, False, -1, 100000)
                self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}AttackStart', ATTR_TYPE_INTEGER, False, 0, 158760000)
                self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}CuePoint', ATTR_TYPE_INTEGER, False, -1, 158760000)
                self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}ReleaseEnd', ATTR_TYPE_INTEGER, False, -1, 158760000)
                self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}HarmonicNumber', ATTR_TYPE_FLOAT, False, 1, 1024)
                self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}MIDIKeyNumber', ATTR_TYPE_INTEGER, False, -1, 127)
                self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}PitchCorrection', ATTR_TYPE_FLOAT, False, -1200, 1200)
                self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}AcceptsRetuning', ATTR_TYPE_BOOLEAN, False)
                self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}WindchestGroup', ATTR_TYPE_OBJECT_REF, False)
                self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}MinVelocityVolume', ATTR_TYPE_FLOAT, False, 0, 1000)
                self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}MaxVelocityVolume', ATTR_TYPE_FLOAT, False, 0, 1000)

                ret1 = self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}LoopCount', ATTR_TYPE_INTEGER, False, 1, 100)
                if ret1 != None and ret1.isdigit():
                    for idx1 in range(1, int(ret1)+1):  # Pipe999Loop999xxx attributes
                        value = self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}Loop{str(idx1).zfill(3)}Start', ATTR_TYPE_INTEGER, False, 0, 158760000)
                        loop_start = int(value) if value.isdigit() else 1
                        self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}Loop{str(idx1).zfill(3)}End', ATTR_TYPE_INTEGER, False, loop_start + 1, 158760000)

                ret1 = self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}AttackCount', ATTR_TYPE_INTEGER, False, 1, 100)
                if ret1 != None and ret1.isdigit():
                    for idx1 in range(1, int(ret1)+1):  # Pipe999Attack999xxx attributes
                        self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}Attack{str(idx1).zfill(3)}', ATTR_TYPE_FILE_NAME, True)
                        self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}Attack{str(idx1).zfill(3)}LoadRelease', ATTR_TYPE_BOOLEAN, False)
                        self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}Attack{str(idx1).zfill(3)}AttackVelocity', ATTR_TYPE_INTEGER, False, 0, 127)
                        self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}Attack{str(idx1).zfill(3)}MaxTimeSinceLastRelease', ATTR_TYPE_INTEGER, False, -1, 100000)
                        self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}Attack{str(idx1).zfill(3)}IsTremulant', ATTR_TYPE_INTEGER, False, -1, 1)
                        self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}Attack{str(idx1).zfill(3)}MaxKeyPressTime', ATTR_TYPE_INTEGER, False, -1, 100000)
                        self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}Attack{str(idx1).zfill(3)}AttackStart', ATTR_TYPE_INTEGER, False, 0, 158760000)
                        self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}Attack{str(idx1).zfill(3)}CuePoint', ATTR_TYPE_INTEGER, False, -1, 158760000)
                        self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}Attack{str(idx1).zfill(3)}ReleaseEnd', ATTR_TYPE_INTEGER, False, -1, 158760000)

                        ret2 = self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}Attack{str(idx1).zfill(3)}LoopCount', ATTR_TYPE_INTEGER, False, 1, 100)
                        if ret2 != None and ret2.isdigit():
                            for idx2 in range(1, int(ret2)+1):  # Pipe999Attack999Loop999xxx attributes
                                value = self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}Attack{str(idx1).zfill(3)}Loop{str(idx2).zfill(3)}Start', ATTR_TYPE_INTEGER, True, 0, 158760000)
                                loop_start = int(value) if value != None and value.isdigit() else 1
                                self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}Attack{str(idx1).zfill(3)}Loop{str(idx2).zfill(3)}End', ATTR_TYPE_INTEGER, True, loop_start + 1, 158760000)

                ret1 = self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}ReleaseCount', ATTR_TYPE_INTEGER, False, 1, 100)
                if ret1 != None and ret1.isdigit():
                    for idx1 in range(1, int(ret1)+1):  # Pipe999Release999xxx attributes
                        self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}Release{str(idx1).zfill(3)}', ATTR_TYPE_FILE_NAME, True)
                        self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}Release{str(idx1).zfill(3)}IsTremulant', ATTR_TYPE_INTEGER, False, -1, 1)
                        self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}Release{str(idx1).zfill(3)}MaxKeyPressTime', ATTR_TYPE_INTEGER, False, -1, 100000)
                        self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}Release{str(idx1).zfill(3)}CuePoint', ATTR_TYPE_INTEGER, False, -1, 158760000)
                        self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}Release{str(idx1).zfill(3)}ReleaseEnd', ATTR_TYPE_INTEGER, False, -1, 158760000)

                self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}LoopCrossfadeLength', ATTR_TYPE_INTEGER, False, 0, 120)
                self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}ReleaseCrossfadeLength', ATTR_TYPE_INTEGER, False, 0, 120)

    #-------------------------------------------------------------------------------------------------
    def check_object_ReversiblePiston(self, object_uid, lines_list):
        # check the data of a Reversible Piston object section which the lines are in the given lines list

        # unkown expected attributes...
        pass

     #-------------------------------------------------------------------------------------------------
    def check_object_SetterElement(self, object_uid, lines_list, type = None):
        # check the data of a Setter Element object section which the lines are in the given lines list

        # required attributes
        if type == None:
            # type not provided by the caller, recover it from the object lines list
            type = self.check_attribute_value(object_uid, lines_list, 'Type', ATTR_TYPE_ELEMENT_TYPE, True)

        if type == None:
            pass
        elif type == 'CrescendoLabel':
            self.check_object_Label(object_uid, lines_list)
        elif type in ('CrescendoA', 'CrescendoB', 'CrescendoC', 'CrescendoD'):
            self.check_object_Button(object_uid, lines_list)
        elif type in ('CrescendoPrev', 'CrescendoNext', 'CrescendoCurrent'):
            self.check_object_Button(object_uid, lines_list)
        elif type in ('Current', 'Full', 'GC'):
            self.check_object_Button(object_uid, lines_list)
        elif type[:7] == "General" and len(type) == 9 and type[7:9].isdigit() and int(type[7:9]) in range(1, 51):
            self.check_object_Button(object_uid, lines_list)
        elif type == 'GeneralLabel':
            self.check_object_Label(object_uid, lines_list)
        elif type in ('GeneralPrev', 'GeneralNext', 'Home', 'Insert', 'Delete'):
            self.check_object_Button(object_uid, lines_list)
        elif type[:1] == "L" and len(type) == 2 and type[1:2].isdigit() and int(type[1:2]) in range(0, 10):
            self.check_object_Button(object_uid, lines_list)
        elif type in ('M100', 'M10', 'M1', 'P1', 'P10', 'P100'):
            self.check_object_Button(object_uid, lines_list)
        elif type == 'PitchLabel':
            self.check_object_Label(object_uid, lines_list)
        elif type in ('PitchM100', 'PitchM10', 'PitchM1', 'PitchP1', 'PitchP10', 'PitchP100'):
            self.check_object_Button(object_uid, lines_list)
        elif type in ('Prev', 'Next', 'Set'):
            self.check_object_Button(object_uid, lines_list)
        elif type in ('Regular', 'Scope', 'Scoped', 'Save'):
            self.check_object_Button(object_uid, lines_list)
        elif type in ('SequencerLabel', 'TemperamentLabel'):
            self.check_object_Label(object_uid, lines_list)
        elif type in ('TemperamentPrev', 'TemperamentNext'):
            self.check_object_Button(object_uid, lines_list)
        elif type in ('TransposeDown', 'TransposeUp'):
            self.check_object_Button(object_uid, lines_list)
        elif type == 'TransposeLabel':
            self.check_object_Label(object_uid, lines_list)

    #-------------------------------------------------------------------------------------------------
    def check_object_Stop(self, object_uid, lines_list):
        # check the data of a Stop object section which the lines are in the given lines list

        is_stop_obj = (self.object_type_get(object_uid) == 'Stop') # some mandatory attributes are not mandatory for objects which inherit the Stop attributes

        # optional attribute
        value = self.check_attribute_value(object_uid, lines_list, 'NumberOfRanks', ATTR_TYPE_INTEGER, False, 0, 999)
        if value == None or (value != None and not value.isdigit()):
            # number of ranks not defined or not a number
            nb_ranks = 0
        else:
            nb_ranks = int(value)

        # required attributes
        self.check_attribute_value(object_uid, lines_list, 'FirstAccessiblePipeLogicalKeyNumber', ATTR_TYPE_INTEGER, is_stop_obj, 1, 128)
        self.check_attribute_value(object_uid, lines_list, 'FirstAccessiblePipeLogicalPipeNumber', ATTR_TYPE_INTEGER, nb_ranks == 0, 1, 192)

        value = self.check_attribute_value(object_uid, lines_list, 'NumberOfAccessiblePipes', ATTR_TYPE_INTEGER, True, 1, 192)
        nb_pipes = int(value) if value != None and value.isdigit() else 192

        # optional attributes
        if nb_ranks > 0:
            for idx in range(1, nb_ranks+1):
                self.check_attribute_value(object_uid, lines_list, f'Rank{str(idx).zfill(3)}', ATTR_TYPE_OBJECT_REF, True)
                self.check_attribute_value(object_uid, lines_list, f'Rank{str(idx).zfill(3)}FirstPipeNumber', ATTR_TYPE_INTEGER, False, 1, nb_pipes)
                self.check_attribute_value(object_uid, lines_list, f'Rank{str(idx).zfill(3)}PipeCount', ATTR_TYPE_INTEGER, False, 0, nb_pipes)
                self.check_attribute_value(object_uid, lines_list, f'Rank{str(idx).zfill(3)}FirstAccessibleKeyNumber', ATTR_TYPE_INTEGER, False, 1, nb_pipes)
        elif nb_ranks == 0:
            # number of ranks set at 0, the Stop must contain rank attributes
            self.check_object_Rank(object_uid, lines_list)

        # a Stop has also the attributes of a Drawstop
        self.check_object_DrawStop(object_uid, lines_list)

    #-------------------------------------------------------------------------------------------------
    def check_object_Switch(self, object_uid, lines_list):
        # check the data of a Switch object section which the lines are in the given lines list

        # a Switch has only the attributes of a Drawstop
        self.check_object_DrawStop(object_uid, lines_list)

    #-------------------------------------------------------------------------------------------------
    def check_object_Tremulant(self, object_uid, lines_list):
        # check the data of a Tremulant object section which the lines are in the given lines list

        # optional attributes
        value = self.check_attribute_value(object_uid, lines_list, 'TremulantType', ATTR_TYPE_TREMULANT_TYPE, False)
        is_synth = (value == 'Synth')
        self.check_attribute_value(object_uid, lines_list, 'Period', ATTR_TYPE_INTEGER, is_synth, 32, 44100)
        self.check_attribute_value(object_uid, lines_list, 'StartRate', ATTR_TYPE_INTEGER, is_synth, 1, 100)
        self.check_attribute_value(object_uid, lines_list, 'StopRate', ATTR_TYPE_INTEGER, is_synth, 1, 100)
        self.check_attribute_value(object_uid, lines_list, 'AmpModDepth', ATTR_TYPE_INTEGER, is_synth, 1, 100)

        # a Tremulant has also the attributes of a Drawstop
        self.check_object_DrawStop(object_uid, lines_list)

    #-------------------------------------------------------------------------------------------------
    def check_object_WindchestGroup(self, object_uid, lines_list):
        # check the data of a WindChest Group object section which the lines are in the given lines list

        # required attributes
        max = self.objects_type_number_get('Enclosure')
        value = self.check_attribute_value(object_uid, lines_list, 'NumberOfEnclosures', ATTR_TYPE_INTEGER, True, 0, max)
        if value != None and value.isdigit():
            for idx in range(1, int(value)+1):
                self.check_attribute_value(object_uid, lines_list, f'Enclosure{str(idx).zfill(3)}', ATTR_TYPE_OBJECT_REF, True)

        max = self.objects_type_number_get('Tremulant')
        value = self.check_attribute_value(object_uid, lines_list, 'NumberOfTremulants', ATTR_TYPE_INTEGER, True, 0, max)
        if value != None and value.isdigit():
            for idx in range(1, int(value)+1):
                self.check_attribute_value(object_uid, lines_list, f'Tremulant{str(idx).zfill(3)}', ATTR_TYPE_OBJECT_REF, True)

        # optional attributes
        self.check_attribute_value(object_uid, lines_list, 'Name', ATTR_TYPE_STRING, False)

    #-------------------------------------------------------------------------------------------------
    def check_attribute_value(self, object_uid, lines_list, attribute_name, attribute_value_type, required_attribute_bool, attribute_value_min=0, attribute_value_max=0):
        # check if the given attribute name is present in the given object lines list (sorted)
        # and if its value is correct for its value type and min/max values
        # the min and max values are ignored if max <= min. The given lines list is considered to be sorted
        # returns the value of the attribute if it has been found and without error, else return None

        # check that the given max value is higher or equal to the min value (this should never happen)
        if attribute_value_max < attribute_value_max:
            logs.add(f"INTERNAL ERROR check_attribute_value called with max < min for {object_uid} / {attribute_name} : min={attribute_value_min}, max={attribute_value_max}")
            return None

        # search in the given lines list the line with the attribute to check
        attr_value = None
        line = None
        for i, line in enumerate(lines_list):
            if line[:len(attribute_name)] > attribute_name:
                # the given lines list being sorted, exit the loop if the current line starts by a string higher than the one of the attribute name
                break
            if line.startswith(attribute_name + '='):
                # line found
                (error_msg, attr_name, attr_value, comment) = self.object_line_split(line)
                if error_msg != None:
                    logs.add(f'ERROR in {object_uid} section, line "{line}" : {error_msg}')
                if attr_name != None and attr_value != None:
                    # the current line contains the attribute to check
                    self.checked_attr_nb += 1
                     # remove the line of the found attribute, to know at the end of the object check which of its attributes have not been checked
                    lines_list.pop(i)
                    break

        if attr_value != None:
            # the attribute has been found

            # check the attribute value according to the given type

            if attribute_value_type == ATTR_TYPE_INTEGER:
                if (not attr_value.lstrip("-+").isdigit() or
                    ((int(attr_value) < attribute_value_min or int(attr_value) > attribute_value_max))):
                    logs.add(f"ERROR in {object_uid} {line} : the assigned value must be an integer in the range [{attribute_value_min} - {attribute_value_max}]")

            elif attribute_value_type == ATTR_TYPE_FLOAT:
                if (not(attr_value.lstrip("-+").replace('.', '', 1).isdigit()) or
                    ((float(attr_value) < attribute_value_min or float(attr_value) > attribute_value_max))):
                    logs.add(f"ERROR in {object_uid} {line} : the assigned value must be an integer or decimal in the range [{attribute_value_min} - {attribute_value_max}]")
                    attr_value = ''

            elif attribute_value_type == ATTR_TYPE_BOOLEAN:
                if attr_value.upper() not in ('Y', 'N'):
                    logs.add(f"ERROR in {object_uid} {line} : the assigned value must be Y or N (boolean attribute)")
                    attr_value = ''

            elif attribute_value_type == ATTR_TYPE_STRING:
                pass # nothing to check in case of string value

            elif attribute_value_type == ATTR_TYPE_COLOR:
                if (not(attr_value.upper() in ('BLACK', 'BLUE', 'DARK BLUE', 'GREEN', 'DARK GREEN', 'CYAN', 'DARK CYAN', 'RED', 'DARK RED',
                                               'MAGENTA', 'DARK MAGENTA', 'YELLOW', 'DARK YELLOW', 'LIGHT GREY', 'DARK GREY', 'WHITE', 'BROWN')) and
                    not(len(attr_value) == 7 and attr_value[0] == '#' and attr_value[1:].isalnum())):  # check of the HTML format #RRGGBB
                    logs.add(f"ERROR in {object_uid} {line} : the assigned value is not a valid color (look at the help)")
                    attr_value = ''

            elif attribute_value_type == ATTR_TYPE_FONT_SIZE:
                if (not(attr_value.upper() in ('SMALL', 'NORMAL', 'LARGE')) and
                    not(attr_value.isdigit() and int(attr_value) >= 1 and int(attr_value) <= 50)):
                    logs.add(f"ERROR in {object_uid} {line} : the assigned value is not a valid font size (look at the help)")
                    attr_value = ''

            elif attribute_value_type == ATTR_TYPE_PANEL_SIZE:
                if (not(attr_value.upper() in ('SMALL', 'MEDIUM', 'MEDIUM LARGE', 'LARGE')) and
                    not(attr_value.isdigit() and int(attr_value) >= 100 and int(attr_value) <= 4000)):
                    logs.add(f"ERROR in {object_uid} {line} : the assigned value is not a valid panel size (look at the help)")
                    attr_value = ''

            elif attribute_value_type == ATTR_TYPE_OBJECT_REF:  # for example Switch002=12 or ManualNumber=2 or Stop003Manual=2 or Pipe015WindchestGroup=1
                if attribute_name[-3:].isdigit():
                    attribute_name = attribute_name[:-3]   # remove the three digits at the end of the attribute name to get the object name

                if attribute_name[-6:] == 'Number':
                    attribute_name = attribute_name[:-6]   # remove the 'Number' string at the end, used in General and Piston objects
                elif attribute_name[-6:] == 'Manual':
                    attribute_name = 'Manual'         # keep only the 'Manual' string, used in General object
                elif attribute_name[-14:] == 'WindchestGroup':
                    attribute_name = 'WindchestGroup' # keep only the 'WindchestGroup' string, used in Rank object

                attr_value = attr_value.lstrip("+-") # remove possible + or - at the beginning of the value, used in General or Divisional objects

                if not(attribute_name + attr_value.zfill(3)) in self.odf_data_dic:
                    logs.add(f"ERROR in {object_uid} {line} : the object {attribute_name + attr_value.zfill(3)} does not exist")
                    attr_value = ''

            elif attribute_value_type == ATTR_TYPE_ELEMENT_TYPE:
                if (not(attr_value in ('Coupler', 'Divisional', 'DivisionalCoupler', 'Enclosure', 'General', 'Label', 'Manual', 'ReversiblePiston', 'Stop', 'Swell',
                                      'Switch', 'Tremulant', 'CrescendoA', 'CrescendoB', 'CrescendoC', 'CrescendoD', 'CrescendoPrev', 'CrescendoNext', 'CrescendoCurrent',
                                      'Current', 'Full', 'GC', 'GeneralLabel', 'GeneralPrev', 'GeneralNext', 'Home', 'Insert', 'Delete', 'M100', 'M10', 'M1', 'P1', 'P10', 'P100',
                                      'PitchLabel', 'PitchP1', 'PitchP10', 'PitchP100', 'PitchM1', 'PitchM10', 'PitchM100', 'Prev', 'Next', 'Set', 'Regular', 'Scope', 'Scoped',
                                      'Save', 'SequencerLabel', 'TemperamentLabel', 'TemperamentPrev', 'TemperamentNext', 'TransposeDown', 'TransposeUp', 'TransposeLabel')) and
                    not(attr_value[0] == 'L' and attr_value[1].isdigit() and int(attr_value[1]) in range(0, 10)) and
                    not(attr_value[:14] == 'CrescendoLabel' and attr_value[14:].isdigit() and int(attr_value[14:]) in range(1, 33)) and
                    not(attr_value[:7] == 'General' and attr_value[7:].isdigit() and int(attr_value[7:]) in range(1, 51))):
                    logs.add(f"ERROR in {object_uid} {line} : the assigned value is not a valid panel element type (look at the help)")
                    attr_value = ''
                pass

            elif attribute_value_type == ATTR_TYPE_COUPLER_TYPE:
                if not(attr_value.upper() in ('NORMAL', 'BASS', 'MELODY')):
                    logs.add(f"ERROR in {object_uid} {line} : the assigned value is not a valid coupler type (look at the help)")
                    attr_value = ''

            elif attribute_value_type == ATTR_TYPE_TREMULANT_TYPE:
                if not(attr_value.upper() in ('SYNTH', 'WAVE')):
                    logs.add(f"ERROR in {object_uid} {line} : the assigned value is not a valid tremulant type (look at the help)")
                    attr_value = ''

            elif attribute_value_type == ATTR_TYPE_PISTON_TYPE:
                if not(attr_value.upper() in ('STOP', 'COUPLER', 'SWITCH', 'TREMULANT')):
                    logs.add(f"ERROR in {object_uid} {line} : the assigned value is not a valid piston type (look at the help)")
                    attr_value = ''

            elif attribute_value_type == ATTR_TYPE_DRAWSTOP_FCT:
                if not(attr_value.upper() in ('INPUT', 'NOT', 'AND', 'XOR', 'NAND', 'NOR', 'OR')):
                    logs.add(f"ERROR in {object_uid} {line} : the assigned value is not a valid drawstop function (look at the help)")
                    attr_value = ''

            elif attribute_value_type == ATTR_TYPE_FILE_NAME:
                if self.check_files_names_bool and not os.path.isfile(os.path.dirname(self.odf_file_name) + os.sep + path2ospath(attr_value)):
                    logs.add(f"ERROR in {object_uid} {line} : file does not exist")
                    attr_value = ''

            elif attribute_value_type == ATTR_TYPE_PIPE_WAVE and self.check_files_names_bool :
                if attr_value.upper()[-4:] == '.WAV':
                    if self.check_files_names_bool and not os.path.isfile(os.path.dirname(self.odf_file_name) + os.sep + path2ospath(attr_value)):
                        logs.add(f"ERROR in {object_uid} {line} : file not found")
                        attr_value = ''
                elif attr_value[:4] == 'REF:':  # for example REF:001:005:007
                    if not (attr_value[5:7].isdigit and attr_value[7] == ':' and
                            attr_value[8:11].isdigit and attr_value[11] == ':' and
                            attr_value[12:15].isdigit and len(attr_value) == 15):
                        logs.add(f"ERROR in {object_uid} {line} : wrong pipe referencing, expected REF:999:999:999")
                        attr_value = ''
                elif attr_value != 'EMPTY':
                    logs.add(f"ERROR in {object_uid} {line} : wrong pipe definition")
                    attr_value = ''

        elif required_attribute_bool:
            # the attribute has not been found and it is required
            logs.add(f"ERROR in {object_uid} : the attribute {attribute_name} is expected, it is missing or misspelled")

        return attr_value

    #-------------------------------------------------------------------------------------------------
    def check_attributes_unicity(self, object_uid, lines_list):
        # check in the given object lines list if each attribute is unique

        # copy the attributes names of the given lines list in an attributes list
        attributes_list = []
        for line in lines_list:
            pos = line.find('=', 1)
            if pos != -1 and line[0] != ';':
                # line with an attribute
                attributes_list.append(line[:pos])

        # sort the attributes list
        attributes_list.sort()

        # check if there are consecutive names in the sorted list
        for i in range(0, len(attributes_list) - 1):
            if attributes_list[i] == attributes_list[i+1]:
                logs.add(f"ERROR in {object_uid} : the attribute {attributes_list[i]} is defined more than once")

#-------------------------------------------------------------------------------------------------
class C_GO_MISC:
    # class containing miscellaneous functions to manage data of GO objects

    def extend_manual_compass(manual_uid, new_max_midi_note):
        # extends the compass of the given manual of the ODF up to the given MIDI note included

        manual_dic = self.object_dic_get(manual_uid)
        if manual_dic != None:
            min_midi_note = self.object_attr_value_get(manual_dic, 'FirstAccessibleKeyMIDINoteNumber')
            midi_note_nb = self.object_attr_value_get(manual_dic, 'NumberOfAccessibleKeys')

##        for object_uid in self.odf_data_dic.keys():
##            # parse the objects of the ODF data
##            if self.object_type_get(object_uid) == 'Manual' and object_uid != 'Manual000':
##                # this is a manual and not the pedal
##                object_dic = self.object_dic_get(object_uid)

#-------------------------------------------------------------------------------------------------
class C_GO_ODF_DATA(C_GO_DATA_CHECK, C_GO_MISC):
    #--- class to store and manage a GrandOrgue ODF data

    odf_file_name = ""      # name of the ODF which the data have been loaded
    odf_file_encoding = ""  # encoding type of the loaded ODF

    new_panel_format_bool = False  # flag indicating if the ODF data use the new panel format or not

    odf_data_dic = {}  # dictionary in which are stored the data of the loaded GrandOrgue ODF
                       # it has the following structure with two nested dictionaries :
                       #   {object UID: string (for example Organ, Panel001, Rank003)
                       #       {"names": list of strings
                       #        "parents": list of strings (UID)
                       #        "children": list of strings (UID)
                       #        "lines": list of strings (data lines of the object)
                       #       }
                       #    ...
                       #   }

    # dictionary containing the possible GO objects types and their possible child objects types
    go_objects_children_dic = {
        'Header': [],
        'Organ': ['General', 'Manual', 'Panel', 'WindchestGroup'],
        'Coupler': ['Switch'],
        'Divisional': ['Coupler', 'Stop', 'Switch', 'Tremulant'],
        'DivisionalCoupler': ['Manual', 'Switch'],
        'Enclosure': [],
        'General': ['Coupler', 'DivisionalCoupler', 'Stop', 'Switch', 'Tremulant'],
        'Manual': ['Coupler', 'Divisional', 'Stop', 'Switch', 'Tremulant'],
        'Panel': ['PanelElement', 'PanelImage'],
        'PanelElement': ['Coupler', 'Divisional', 'DivisionalCoupler', 'Enclosure', 'General', 'Manual', 'Stop', 'Switch', 'Tremulant'],
        'PanelImage': [],
        'Rank': [],
        'Stop': ['Rank', 'Switch'],
        'Switch': ['Switch'],
        'Tremulant': ['Switch'],
        'WindchestGroup': ['Enclosure', 'Stop', 'Rank', 'Tremulant'],
        # old panel format
        'Image': [],
        'Label': [],
        'SetterElement': [],
        'PanelCoupler': ['Coupler'],
        'PanelDivisional': ['Divisional'],
        'PanelDivisionalCoupler': ['DivisionalCoupler'],
        'PanelEnclosure': ['Enclosure'],
        'PanelGeneral': ['General'],
        'PanelLabel': ['Label'],
        'PanelSetterElement': ['SetterElement'],
        'PanelStop': ['Stop'],
        'PanelSwitch': ['Switch'],
        'PanelTremulant': ['Tremulant'],
        }

    # dictionary containing the possible GO objects types and their possible parent objects types
    # it is built automatically from go_objects_children_dic in the function objects_templates_load
    go_objects_parents_dic = {}

    # dictionary in which are stored the GO objects templates (loaded from the file GoObjectsTemplates.txt located in the resources sub-folder)
    go_templates_dic = {}

    #-------------------------------------------------------------------------------------------------
    def reset_all_data(self):
        # reset all the data of the class

        self.odf_file_name = ''
        self.odf_file_encoding = ENCODING_ISO_8859_1
        self.new_panel_format_bool = False
        self.odf_data_dic.clear()

    #-------------------------------------------------------------------------------------------------
    def objects_templates_load(self):
        # load the GO objects templates from the file GoObjectsTemplates.txt (if it is present and there is no error)
        # return True or False whether the operation has succeeded or not

        # initialize the go_objects_parents_dic dictionary from the keys of the go_objects_children_dic dictionary
        for object_type in self.go_objects_children_dic.keys():
            self.go_objects_parents_dic[object_type] = []
        # build the go_objects_parents_dic dictionary from the go_objects_children_dic dictionary content (create the opposite kinship)
        for parent_object_type, object_children_list in self.go_objects_children_dic.items():
            # parse the objects types of the object children dictionary
            for child_object_type in object_children_list:
                if parent_object_type not in ('Organ'): # do not include Organ in the parents
                    self.go_objects_parents_dic[child_object_type].append(parent_object_type)

        if len(self.go_templates_dic) == 0:
            # the dictionary has not been loaded yet

            file_name = os.path.dirname(__file__) + os.sep + 'resources' + os.sep + 'GoObjectsTemplates.txt'

            try:
                with open(file_name, 'r') as f:
                    self.go_templates_dic = eval(f.read())

            except OSError as err:
                # it has not be possible to open the file
                logs.add(f'ERROR Cannot open the file "{file_name}" : {err}')
            except SyntaxError as err:
                # syntax error in the dictionary structure which is in the file
                logs.add(f'ERROR Syntax error in the file "{file_name}" : {err}')
                logs.add( 'ERROR Fix the issue in the file then restart OdfEdit')
            except:
                # other error
                logs.add(f'ERROR while opening the file "{file_name}"')
            return False
        else:
            return True

    #-----------------------------------------------------------------------------------------------
    def load_from_file(self, file_name):
        # load the data of the given ODF
        # returns True/False whether the file has been loaded correctly or not

        file_name = path2ospath(file_name)

        # open the given ODF in read mode, and check its encoding format
        try:
            file = open(file_name, mode='r', encoding=ENCODING_ISO_8859_1)
        except OSError as err:
            # it has not be possible to open the file
            logs.add(f"Cannot open the file. {err}")
            valid_odf_file_bool = False
        else:
            if file.readline(3) == "Ã¯Â»Â¿":  # UTF-8 BOM file encoding header
                # close the file
                file.close()
                # reopen the file with the proper encoding format
                file = open(file_name, mode='r', encoding=ENCODING_UTF8_BOM)
                self.odf_file_encoding = ENCODING_UTF8_BOM
            else:
                file.seek(0)  # reset the position of the cursor at the beginning of the file
                self.odf_file_encoding = ENCODING_ISO_8859_1
            # store the name of the ODF
            self.odf_file_name = file_name
            valid_odf_file_bool = True

            # clear data before to parse the file
            self.odf_data_dic.clear()

            object_types_list = []  # list containing the types of objects loaded from the ODF, to display statistics
            object_uid = 'Header'  # UID of the object currently recovered, header section by default
            object_dic = self.object_new(object_uid) # dictionary of the object currently recovered
            total_attr_nb = 0      # number of whole attributes in the loaded ODF
            file_lines_nb = 0      # number of lines in the loaded ODF

            for line in file:
                # parse the lines of the ODF to load
                file_lines_nb += 1

                # remove the ending \n character if present in the current line
                if line[-1:] == '\n': line = line[:-1]

                # recover and check the syntax of the data present in the current line
                (error_msg, attr_name, attr_value, comment) = self.object_line_split(line)
                if error_msg != None:
                    logs.add(f'ERROR in {object_uid} section, line "{line}" : {error_msg}')
                    line = ';!!! ' + line
                    attr_name = None

                if attr_name == 'uid':
                    # line containing an object UID

                    # add in the ODF data the object in construction if it has lines inside
                    if (object_uid == 'Header' and len(object_dic['lines']) > 1) or len(object_dic['lines']) > 0:
                        # in case of Header the UID line is not considered
                        self.odf_data_dic[object_uid] = object_dic

                    object_uid = attr_value
                    while object_uid in self.odf_data_dic.keys():
                        # there is already an object with the same UID in the ODF (which is not normal) : add '_' at end of the UID until the UID is unique
                        logs.add(f"WARNING : another occurence of the object {object_uid} is present in the ODF, it has been renamed in {object_uid}_")
                        object_uid += '_'

                    # create the next object in construction
                    object_dic = self.object_new(object_uid, comment)

                    # store the object type for statistics
                    object_type = self.object_type_get(object_uid)
                    if not object_type in object_types_list:
                        object_types_list.append(object_type)

                elif attr_name != None and object_uid == 'Header':
                    # attribute line in the header : it is an error
                    logs.add('ERROR only comments are allowed in the header section')
                    line = ';!!! ' + line
                    attr_name = None

                elif attr_name != None :
                    total_attr_nb += 1

                # add the current line to the object in construction
                if len(line) > 0:
                    object_dic['lines'].append(line)

            # add in the ODF dictionary the dictionary of the last loaded object
            if len(object_dic) > 0:
                self.odf_data_dic[object_uid] = object_dic

            # close the ODF
            file.close()

            # update the kinship links between the objects
            self.objects_kinship_update()

            # reset the check files names flag
            self.check_files_names_bool = None

            if self.odf_file_encoding == ENCODING_UTF8_BOM:
                file_encoding = 'UTF8'
            else:
                file_encoding = 'ISO_8859_1'

            logs.add(f'GrandOrgue ODF loaded "{file_name}"')
            logs.add(f'{file_lines_nb:,} lines, file encoding {file_encoding}')

            logs.add(f'{total_attr_nb:,} attributes among {len(self.odf_data_dic)-1:,} objects among {len(object_types_list)} object types')

            # update the panel format flag from the ODF data content
            self.check_panel_format()

        return valid_odf_file_bool

    #-------------------------------------------------------------------------------------------------
    def save_to_file(self, file_name):
        # save the odf_data_dic in the given ODF
        # if no file name is given, the saving is done in the already loaded ODF file ('Save as' feature)
        # returns True/False whether the writting in file has been done correctly or not

        file_saved_bool = False

        if len(self.odf_data_dic) == 0:
            # the ODF dictionary is empty, there are no data to save
            logs.add(f"None data to save in the file {file_name}")
        elif file_name == '' and self.odf_file_name == '':
            # no file name known, should not occur, so no possibility to make the save operation
            pass
        else:
            # open the given ODF in write mode
            if file_name == '':
                # no given file name, make the saving in the already loaded ODF
                file_name = self.odf_file_name

            if self.odf_file_encoding == '':
                self.odf_file_encoding = ENCODING_UTF8_BOM  # default encoding

            # check if the file name has an extension, if not add the .organ extension
            if file_name[-6:] != '.organ':
                file_name += '.organ'

            try:
                file = open(file_name, mode='w', encoding=self.odf_file_encoding)
            except OSError as err:
                logs.add(f"Cannot write in the file. {err}")
            else:
                # write the ODF data dictionary content in the ODF
                # eliminating the blank lines and ensuring a blanck line before each object section start
                # write the Header and Organ objects if defined
                for object_uid in ('Header', 'Organ'):
                    if object_uid in self.odf_data_dic.keys():
                        for line in self.odf_data_dic[object_uid]['lines']:
                            if line != '':
                                if line[0] == '[':
                                    # start of a section : add a blank line before
                                    file.write('\n\n' + line)
                                else:
                                    file.write('\n' + line)
                # write the other objects by UID ascending order
                for object_uid in sorted(self.odf_data_dic.keys()):
                    # parse the sorted objects of the ODF data
                    if object_uid not in ('Header', 'Organ'):
                        for line in self.odf_data_dic[object_uid]['lines']:
                            # parse the lines of the current object
                            if line != '':
                                if line[0] == '[':
                                    # start of a section : add a blank line before
                                    file.write('\n\n' + line)
                                else:
                                    file.write('\n' + line)

                file.close()
                file_saved_bool = True

                # store the name of the ODF file
                self.odf_file_name = file_name

                logs.add(f'Data saved in file "{self.odf_file_name}" with encoding {self.odf_file_encoding}')

        return file_saved_bool

    #-------------------------------------------------------------------------------------------------
    def object_line_split(self, line):
        # check the syntax of the given object line and extract from it the attribute name + attribute value + comment
        # return a tuple containing : (error message, attribute name, attribute value, comment)
        # attribute name = 'uid' if the given line contains an object UID between brackets, the UID is in the attribute value
        # error message = an error description message in case a syntax error has been detected in the given line, or None if no error found

        return self.check_object_line(line)

    #-------------------------------------------------------------------------------------------------
    def object_line_join(self, attr_name, attr_value, comment=None):
        # join in a single string line in ODF format the provided data, return this line

        attr_value = str(attr_value)
        line = ''

        if attr_name == 'uid':
            # UID of the object, start of a section
            if comment != None:
                line = '[' + attr_value + ']' + comment
            else:
                line = '[' + attr_value + ']'

        elif attr_name != None:
            # attribute line
            if comment != None:
                line = attr_name + '=' + attr_value + comment
            else:
                line = attr_name + '=' + attr_value

        elif comment != None:
            # comment line
            line = comment

        return line

    #-------------------------------------------------------------------------------------------------
    def object_lines_read(self, object_uid):
        # return in a list the lines of the given object UID
        # or None if the object UID doesn't exist

        object_dic = self.object_dic_get(object_uid)
        if object_dic != None:
            return list(object_dic['lines'])
        else:
            return None

    #-------------------------------------------------------------------------------------------------
    def object_lines_write(self, object_lines_list, expected_object_uid=None, parent_object_uid=None):
        # write the given object lines in the ODF
        # the first line of the list must contain the object UID between brackets
        # if the given object UID doesn't exist, create a new object in the ODF dictionary to store the lines
        # return the UID of the updated/created object or None if a syntax error has been detected

        if expected_object_uid == None:
            object_uid = 'Header'   # header section by default
        else:
            object_uid = expected_object_uid

        tmp_object_dic = self.object_new(object_uid)  # object to store the provided lines and their UID

        for i, line in enumerate(object_lines_list):
            # parse the lines of the given list to check them, to recover the UID and copy them in an object element

            # recover and check the data present in the current line
            (error_msg, attr_name, attr_value, comment) = self.object_line_split(line)

            if error_msg != None:
                logs.add(f'ERROR in {object_uid}, line "{line}" : {error_msg}')
                return None
            elif i == 0 and attr_name != 'uid' and object_uid != 'Header':
                logs.add('ERROR no object identifier defined in the first line')
                return None
            elif i > 0 and attr_name == 'uid':
                logs.add('ERROR an object identifier can be defined only in the first line')
                return None
            elif attr_name == 'uid' and attr_value != None:
                object_uid = attr_value
                if object_uid in self.odf_data_dic.keys() and object_uid != expected_object_uid:
                    logs.add(f'ERROR another object named {object_uid} already exists')
                    return None
                elif (expected_object_uid != None and object_uid != expected_object_uid and
                      self.object_type_get(object_uid) != self.object_type_get(expected_object_uid)):
                    logs.add(f'ERROR {expected_object_uid} cannot be renamed in {object_uid} which is of different type')
                    return None
            elif object_uid == 'Header' and attr_name != None:
                logs.add('ERROR only comments are allowed in the header section')
                return None

            # add the current line to the temporary object
            tmp_object_dic['lines'].append(line)

        if expected_object_uid != None:
            # we expect a particular object UID in the lines
            # update the object with the content of the built temporary object
            object_dic = self.object_dic_get(expected_object_uid)
            if object_dic != None:
                object_dic['lines'] = tmp_object_dic['lines']
                logs.add(f"{expected_object_uid} : updated")

                if expected_object_uid == object_uid:
                    # update the kinship links between the objects
                    self.objects_kinship_update()
                    return object_uid
                else:
                    # the provided lines contain different object UID than the expected one
                    # rename in the ODF data the object with the new UID if possible
                    return self.object_rename(expected_object_uid, object_uid)
        else:
            # there is no expected UID
            # add the built temporary object in the ODF
            self.odf_data_dic[object_uid] = tmp_object_dic
            logs.add(f"{object_uid} : added")

            if parent_object_uid != None:
                # link the new object to its parent if provided
                self.object_parent2child_link(parent_object_uid, object_uid, 'link')
            elif self.object_type_get(object_uid) in ('PanelElement', 'PanelImage'):
                # update the number of objects in the parent Panel object if PanelElement or PanelImage
                self.object_parent2child_link(object_uid[:8], object_uid, 'link')

            # update the kinship links between the objects
            self.objects_kinship_update()

            # update the number of object type in the Organ object if necessary
            self.object_organ_numbers_update(object_uid)

            return object_uid

        return None

    #-------------------------------------------------------------------------------------------------
    def object_new(self, object_uid, comment=None, object_type=None):
        # return the dictionary of a new object having the given UID and all other fields void

        object_dic = {}
        object_dic['names'] = []    # list with the various names of the object
        object_dic['parents'] = []  # list with the UID of parent objects
        object_dic['children'] = [] # list with the UID of children objects
        object_dic['lines'] = [] # list with the data lines (including the UID) of the object

        return object_dic

    #-------------------------------------------------------------------------------------------------
    def object_add(self, object_type, parent_uid):
        # add in the ODF data an object corresponding to the given object type and having the attributes of the corresponding template if defined
        # return the UID of the created object, or None if an error occured

        if not object_type in self.go_objects_children_dic.keys():
            logs.add(f'INTERNAL ERROR in object_add : object type {object_type} is unknown')
            return None

        if object_type in self.go_templates_dic.keys():
            # the given object type has a template defined
            # recover the lines of the template
            object_lines_list = list(self.go_templates_dic[object_type])
        else:
            object_lines_list = []

        # define an UID for the object to add
        object_uid = None
        if object_type in ('Header', 'Organ'):
            object_uid = object_type
            parent_uid = None
        else:
            parent_type = self.object_type_get(parent_uid)
            if parent_type == 'Panel':
                # childs of a Panel have their UID starting by the panel UID
                if object_type == 'PanelElement':
                    object_type = parent_uid + 'Element'
                elif object_type == 'PanelImage':
                    object_type = parent_uid + 'Image'
                else:
                    object_type = None

            if object_type != None:
                # define the UID using a free ID in the given object type
                id = self.object_type_free_id_get(object_type)
                object_uid = object_type + str(id).zfill(3)

        if object_uid != None:
            # a new object can be added
            # add the object UID in first line of the template lines if it is not the Header
            if object_uid != 'Header':
                object_lines_list.insert(0, '[' + object_uid + ']')

            # add the object and its lines in the ODF and recover the result (can be None in case of error in the lines)
            object_uid = self.object_lines_write(object_lines_list, None, parent_uid)

        return object_uid

    #-------------------------------------------------------------------------------------------------
    def object_link(self, object_uid, kinship_objects_list, relationship):
        # link the given object to the objects of the given kinship objects list with the given relationship (TO_PARENT or TO_CHILD)
        # return the object_uid (which can be renamed for children of Panel) or None if an issue occured

        if relationship not in (TO_PARENT, TO_CHILD):
            logs.add(f'INTERNAL ERROR in object_link : wrong given relationship {relationship}')

        object_dic = self.object_dic_get(object_uid)
        if object_dic == None:
            return None
        object_type = self.object_type_get(object_uid)

        # recover the list of the current parents or children of the given object
        current_kinship_list = sorted(self.object_kinship_list_get(object_uid, relationship))

        # make the list of kinship objects types and their number
        kinship_objects_types_dic = {}
        for obj_uid in kinship_objects_list:
            obj_type = self.object_type_get(obj_uid)
            if obj_type not in kinship_objects_types_dic.keys():
                kinship_objects_types_dic[obj_type] = 0
            kinship_objects_types_dic[obj_type] += 1

        # check if the given kinship list contains more parents/children type than allowed for the given object type
        if relationship == TO_PARENT:
            if object_type in ('PanelElement', 'PanelImage'):
                if 'Panel' in kinship_objects_types_dic.keys() and kinship_objects_types_dic['Panel'] > 1:
                    # PanelElement or PanelImage with more than one Panel parent in the kinship list
                    messagebox.showerror(title='Selection error', message=f'A {object_type} object cannot have more than one parent Panel, please select a single parent Panel.')
                    return None
                elif 'Panel' not in kinship_objects_types_dic.keys():
                    # PanelElement or PanelImage with none Panel parent in the kinship list
                    messagebox.showerror(title='Selection error', message=f'A {object_type} object must have one parent Panel, please select a parent Panel.')
                    return None
            elif (object_type in ('Rank', 'Stop') and
                  'WindchestGroup' in kinship_objects_types_dic.keys() and kinship_objects_types_dic['WindchestGroup'] > 1):
                # Rank and Stop object which has more than 1 parent WindchestGroup
                messagebox.showerror(title='Selection error', message=f'A {object_type} object cannot have more than one parent WindchestGroup, please select a single parent WindchestGroup.')
                return None
        else: # TO_CHILD
            if object_type == 'PanelElement' and len(kinship_objects_list) > 1:
                # a PanelElement can have only one child object
                messagebox.showerror(title='Selection error', message=f'A {object_type} object can have only one child object, please select a single child for {object_uid}.')
                return None

        ret_object_uid = object_uid
        if relationship == TO_PARENT:
            # unlink the selected object with its parent objects which have been unselected, cannot unlink Panel and PanelElement/PanelImage
            if object_type not in ('PanelElement', 'PanelImage'):
                for obj_uid in current_kinship_list:
                    # parse the current parent objects
                    if obj_uid not in kinship_objects_list:
                        # it is no more a parent : remove the link
                        self.object_parent2child_link(obj_uid, object_uid, 'unlink')

            # link the selected object with its new selected parent objects
            for obj_uid in kinship_objects_list:
                # parse the current parent objects
                if obj_uid not in current_kinship_list:
                    # it is not yet a parent : add the link
                    ret_object_uid = self.object_parent2child_link(obj_uid, object_uid, 'link')
        else:
            # unlink the selected object with its child objects which have been unselected, cannot unlink Panel and PanelElement/PanelImage
            if object_type != 'Panel':
                for obj_uid in current_kinship_list:
                    # parse the current child objects
                    if obj_uid not in kinship_objects_list:
                        # it is no more a child : remove the link
                        self.object_parent2child_link(object_uid, obj_uid, 'unlink')

            # link the selected object with its new selected child objects
            for obj_uid in kinship_objects_list:
                # parse the current child objects
                if obj_uid not in current_kinship_list:
                    # it is not yet a child : add the link
                    self.object_parent2child_link(object_uid, obj_uid, 'link')

        # update the kinship links between the objects of the ODF
        self.objects_kinship_update()

        return ret_object_uid

    #-------------------------------------------------------------------------------------------------
    def object_rename(self, old_object_uid, new_object_uid):
        # rename in the ODF data the object having the given UID to the new UID (only the three last digits of the UID can be changed)
        # return the new UID of the object, or None if failure

        # check the provided object UIDs
        object_dic = self.object_dic_get(new_object_uid)
        if object_dic != None:
            logs.add(f"ERROR cannot rename {old_object_uid} in {new_object_uid} which already exits")
            return None

        object_dic = self.object_dic_get(old_object_uid)
        if object_dic == None:
            logs.add(f"INTERNAL ERROR in object_rename : object {old_object_uid} does not exit")
            return None

        object_type = self.object_type_get(old_object_uid)
        if object_type != self.object_type_get(new_object_uid):
            logs.add(f"INTERNAL ERROR in object_rename : old object type {old_object_uid} and new object type {new_object_uid} are not the same")
            return None

        # move in the ODF data dictionary the object data under another key which has the new UID
        object_dic = self.odf_data_dic[new_object_uid] = self.odf_data_dic.pop(old_object_uid)

        # update the UID in the first line of the new object
        (error_msg, attr_name, attr_value, comment) = self.object_line_split(object_dic['lines'][0])
        if attr_name == 'uid':
            object_dic['lines'][0] = self.object_line_join(attr_name, new_object_uid, comment)

        logs.add(f"{old_object_uid} : renamed in {new_object_uid}")

        # rename the reference to the new object in its kinship objects
        if object_type == 'Panel':
            # rename the UID of the children of the new Panel UID (PanelElement and PanelImage)
            for old_child_uid in object_dic['children']:
                new_child_uid = new_object_uid + old_child_uid[8:]
                # move the child object data under another key which has its new UID
                self.odf_data_dic[new_child_uid] = self.odf_data_dic.pop(old_child_uid)
                # update the UID in the first line of the child object
                (error_msg, attr_name, attr_value, comment) = self.object_line_split(self.odf_data_dic[new_child_uid]['lines'][0])
                if attr_name == 'uid':
                    self.odf_data_dic[new_child_uid]['lines'][0] = self.object_line_join(attr_name, new_child_uid, comment)
                logs.add(f"{old_child_uid} : renamed in {new_child_uid}")

        elif object_type == 'WindchestGroup':
            # rename the reference to the new WindchestGroup UID in the children objects Stop or Rank
            windchest_id = self.object_id_get(new_object_uid)
            if windchest_id != None:
                for child_uid in object_dic['children']:
                    if self.object_type_get(child_uid) in ('Stop', 'Rank'):
                        self.object_attr_value_set(child_uid, 'WindchestGroup', int(windchest_id))
                        logs.add(f"{child_uid} : attribute WindchestGroup set to {windchest_id}")

        elif object_type not in ('PanelElement', 'PanelImage'):
            # other kinds of objects : rename the reference to the new object UID in the parents
            # not to do for PanelElement or PanelImage objects
            for parent_uid in sorted(object_dic['parents']):
                # parse the parent objects of the object to rename
                # look for the line of the current parent which contains the reference to rename
                parent_type = self.object_type_get(parent_uid)
                parent_dic = self.object_dic_get(parent_uid)
                if parent_dic != None:
                    # define the name of the attribute in the parent which contains the reference to rename
                    ref_attr_name = object_type
                    if parent_type == 'General':
                        ref_attr_name += 'Number'
                    # recover the lines of the parent object to rename in it the reference to the renamed object
                    parent_lines_list = parent_dic['lines']
                    for i in range(len(parent_lines_list)):
                        # parse the lines of the parent object
                        if parent_lines_list[i].startswith(ref_attr_name):
                            # the current line should contain a reference to the child object type
                            (error_msg, attr_name, attr_value, comment) = self.object_line_split(parent_lines_list[i])
                            if attr_name != None and (attr_name == ref_attr_name or attr_name[:-3] == ref_attr_name) and abs(int(attr_value)) == int(old_object_uid[-3:]):
                                # the current line contains a reference to the child object type
                                # set in the parent object the new reference number
                                sign = '-' if attr_value[0] == '-' else ''
                                self.object_attr_value_set(parent_dic, attr_name, sign + new_object_uid[-3:])
                                logs.add(f"{parent_uid} : reference to {old_object_uid} changed to {new_object_uid}")
                                break

            # if a manual is renamed, rename as well the StopManual and CouplerManual references in General objects
            if object_type == 'Manual':
                for obj_uid in self.odf_data_dic.keys():
                    # parse the objects of the ODF data
                    if self.object_type_get(obj_uid) == 'General':
                        # parse the lines of the current General object to update StopManual and CouplerManual attributes if they refer to the old_object_uid
                        obj_dic = self.object_dic_get(obj_uid)
                        lines_list = obj_dic['lines']
                        for i in range(len(lines_list)):
                            # parse the lines of the General object
                            if lines_list[i].startswith(('StopManual', 'CouplerManual')):
                                # the current line contains a reference to the child object type
                                (error_msg, attr_name, attr_value, comment) = self.object_line_split(lines_list[i])
                                if attr_name != None and int(attr_value) == int(old_object_uid[-3:]):
                                    # the current line contains a reference to the Manual UID to rename
                                    self.object_attr_value_set(obj_dic, attr_name, new_object_uid[-3:])
                                    logs.add(f"{obj_uid} : attribute {attr_name} updated")

        if object_type in ('Manual', 'Panel'):
            # update the number of object type in the Organ object if necessary if a Manual or Panel ID has changed between 0 and not 0
            self.object_organ_numbers_update(new_object_uid)

        # update the kinship links between the objects
        self.objects_kinship_update()

        return new_object_uid

    #-------------------------------------------------------------------------------------------------
    def object_delete(self, object_uid):
        # delete in the ODF data the object having the given UID
        # return True or False whether the deletion has been done or not

        object_dic = self.object_dic_get(object_uid)
        if object_dic != None:
            # unlink the given object with its parents
            for parent_uid in sorted(object_dic['parents']):
                self.object_parent2child_link(parent_uid, object_uid, 'unlink')

            # delete the given object in the ODF data
            del self.odf_data_dic[object_uid]
            logs.add(f"{object_uid} : deleted")

            # update the number of object type in the Organ object if necessary
            self.object_organ_numbers_update(object_uid)

            # update the kinship links between the objects
            self.objects_kinship_update()

            return True
        else:
            logs.add(f"ERROR {object_uid} cannot deleted because not found")
            return False

    #-------------------------------------------------------------------------------------------------
    def object_id_get(self, object_uid):
        # return the ID (integer) of the given object UID (for example from Stop012 will return 12)
        # return None if the ID is not valid : not 3 digits at the end of the UID

        if not(object_uid[-3:].isdigit()):
            # the last 3 characters are not all digits
            return None
        else:
            return int(object_uid[-3:])

    #-------------------------------------------------------------------------------------------------
    def object_type_get(self, object_uid):
        # return the type of the given object UID (for example from Panel012 will return Panel)

        if object_uid not in (None, ''):
            # remove the digits which are inside the UID string
            object_type = ''
            for c in object_uid:
                if not c.isdigit():
                    object_type += c
        else:
            object_type = None

        return object_type

    #-------------------------------------------------------------------------------------------------
    def object_type_free_id_get(self, object_type):
        # return the first unused ID value (last 3 digits of the UID) for the given object type
        # if the given type is PanelElement or PanelImage, returns None because it has no sense, a parent Panel UID has to be provided
        # if the given type is Panel999Element or Panel999Image, returns a free ID in the Panel999Element or Panel999Image objects ensemble

        if object_type in ('PanelElement', 'PanelImage'):
            return None

        if object_type in ('Manual', 'Panel'):
            # Manual and Panel ID only can start from 0
            free_id = 0
        else:
            free_id = 1

        for object_uid in sorted(self.odf_data_dic.keys()):
            # parse the objects of the ODF data
            if object_uid[:-3] == object_type and object_uid[-3:].isdigit():
                id = int(object_uid[-3:])
                if id <= free_id:
                    free_id = id + 1
                else:
                    break

        return free_id

    #-------------------------------------------------------------------------------------------------
    def object_dic_get(self, object_uid):
        # return the dictionary of the object of the ODF dictionary having the given UID

        try:
            return self.odf_data_dic[object_uid]
        except:
            # object not existing
            return None

    #-------------------------------------------------------------------------------------------------
    def object_names_get(self, object_uid):
        # return the names to display for the object having the given UID

        object_dic = self.object_dic_get(object_uid)

        if object_dic != None:
            name = '|'.join(object_dic['names'])
            return name if len(name) > 0 else None
        else:
            return None

    #-------------------------------------------------------------------------------------------------
    def object_attr_value_get(self, object_dic_or_uid, attribute_name):
        # return the value of the given attribute defined in the given object dictionary or UID
        # return None if the given object or the attribute doesn't exist

        if object_dic_or_uid == None:
            return None

        elif isinstance(object_dic_or_uid, str):
            object_dic = self.object_dic_get(object_dic_or_uid)
        else:
            object_dic = object_dic_or_uid

        if object_dic != None:
            for line in object_dic['lines']:
                # parse the data lines of the object
                (error_msg, attr_name, attr_value, comment) = self.object_line_split(line)

                if attr_name == attribute_name:
                    # given attribute found : return its value
                    return attr_value

        return None

    #-------------------------------------------------------------------------------------------------
    def object_attr_value_set(self, object_dic_or_uid, attribute_name, attribute_value):
        # write the given value in the given attribute defined in the given object dictionary or UID
        # return True or False whether it has been possible or not to the set the value

        if isinstance(object_dic_or_uid, str):
            object_dic = self.object_dic_get(object_dic_or_uid)
        else:
            object_dic = object_dic_or_uid

        if object_dic != None:
            comment = None
            for i, line in enumerate(object_dic['lines']):
                # parse the data lines of the object
                (error_msg, attr_name, attr_value, comment) = self.object_line_split(line)

                if attr_name == attribute_name:
                    # given attribute found : update its value
                    object_dic['lines'][i] = self.object_line_join(attribute_name, attribute_value, comment)
                    return True

            # attribute not present in the object lines, add a line for it
            object_dic['lines'].append(self.object_line_join(attribute_name, attribute_value, comment))
            return True

        return False

    #-------------------------------------------------------------------------------------------------
    def object_parent2child_link(self, parent_object_uid, child_object_uid, operation):
        # link/unlink the given child object to the given parent object (both must already exist in the ODF data)
        # operation parameter can be 'link' or 'unlink'
        # return the UID of the child object (can be renamed in case of child of Panel) or None if an error occured

        # types of referencing parent to child :
        #   WindchestGroup -> Stop (rank inside) or Rank : WindchestGroup ID is set in the attribute WindchestGroup of the Stop or Rank object
        #   Panel -> PanelElement or PanelImage : PanelElement or PanelImage UID starts with the parent Panel UID
        #   PanelElement -> Coupler/General/Manual/... : only one child can be defined
        #   Stop -> Switch (example) : the value of the attribute Switchxxx of the Stop is the Rank ID

        if (parent_object_uid == None or child_object_uid == None):
            return None

        if operation not in ('link', 'unlink'):
            logs.add(f'INTERNAL ERROR in object_parent2child_link : wrong requested operation name "{operation}"')
            return None

        # recover the dictionary, type and ID of the given parent
        parent_object_dic = self.object_dic_get(parent_object_uid)
        if parent_object_dic == None:
            logs.add(f"INTERNAL ERROR in object_parent2child_link : parent object {parent_object_uid} does not exit")
            return None
        parent_object_type = self.object_type_get(parent_object_uid)
        parent_object_id = self.object_id_get(parent_object_uid)
        if parent_object_type in ('Organ', 'Header'):
            # the Organ and Header objects cannot be linked to a child
            return None

        # recover the dictionary, type and ID of the given child
        child_object_dic = self.object_dic_get(child_object_uid)
        if child_object_dic == None:
            logs.add(f"INTERNAL ERROR in object_parent2child_link : child object {child_object_uid} does not exit")
            return None
        child_object_type = self.object_type_get(child_object_uid)
        child_object_id = self.object_id_get(child_object_uid)

        # check that the given parent object can have the given child object as a child
        if not child_object_type in self.go_objects_children_dic[parent_object_type]:
            logs.add(f"INTERNAL ERROR in object_parent2child_link : the object type {parent_object_type} cannot have the object type {child_object_type} as a child")
            return None

        if parent_object_type == 'WindchestGroup' and child_object_type in ('Rank', 'Stop'):
            # link between WindchestGroup and Rank or Stop object, the referencing is done in the Rank or Stop object
            # set or erase the ID of the parent WindchestGroup in the attribute WindchestGroup of the Rank or Stop object
            if operation == 'link':
                self.object_attr_value_set(child_object_dic, 'WindchestGroup', int(parent_object_id))
                logs.add(f"{child_object_uid} : reference to {parent_object_uid} added")
                return child_object_uid
            else:
                self.object_attr_value_set(child_object_dic, 'WindchestGroup', '')
                logs.add(f"{child_object_uid} : reference to {parent_object_uid} removed")
                return child_object_uid

        elif parent_object_type == 'Panel':
            # link between Panel and PanelElement or PanelImage object (unlink is not possible)
            # store the previous Panel UID of the child before to rename its UID
            prev_parent_panel_uid = child_object_uid[:8]
            if operation == 'link':
                if parent_object_uid != prev_parent_panel_uid:
                    # the given child PanelElement or PanelImage doesn't refer to the given parent UID
                    # define the new UID for the child
                    if child_object_type == 'PanelElement':
                        id = self.object_type_free_id_get(parent_object_uid + 'Element')
                        new_child_object_uid = parent_object_uid + 'Element' + str(id).zfill(3)
                    elif child_object_type == 'PanelImage':
                        id = self.object_type_free_id_get(parent_object_uid + 'Image')
                        new_child_object_uid = parent_object_uid + 'Image' + str(id).zfill(3)
                    else:
                        logs.add(f"INTERNAL ERROR in object_parent2child_link : object type {panel_child_object_type} cannot be child of {parent_object_type}")
                        return None

                    # move the object data of the child object under another key which has the new child UID
                    new_object_dic = self.odf_data_dic[new_child_object_uid] = self.odf_data_dic.pop(child_object_uid)

                    # write the new UID in the first line of the new object
                    (error_msg, attr_name, attr_value, comment) = self.object_line_split(new_object_dic['lines'][0])
                    if attr_name == 'uid':
                        new_object_dic['lines'][0] = self.object_line_join(attr_name, new_child_object_uid, comment)

                    logs.add(f"{child_object_uid} : renamed in {new_child_object_uid}")

                    # update the NumberOf attribute of the old parent Panel object which doesn't contain anymore the child object
                    if child_object_type == 'PanelElement':
                        nb = self.objects_type_number_get(prev_parent_panel_uid + 'Element')
                        self.object_attr_value_set(prev_parent_panel_uid, 'NumberOfGUIElements', nb)
                        logs.add(f"{prev_parent_panel_uid} : attribute NumberOfGUIElements updated")
                    else:
                        nb = self.objects_type_number_get(prev_parent_panel_uid + 'Image')
                        self.object_attr_value_set(prev_parent_panel_uid, 'NumberOfImages', nb)
                        logs.add(f"{prev_parent_panel_uid} : attribute NumberOfImages updated")

                    child_object_uid = new_child_object_uid

                # update the NumberOf attribute of the new parent Panel object to add the child object
                if child_object_type == 'PanelElement':
                    nb = self.objects_type_number_get(parent_object_uid + 'Element')
                    self.object_attr_value_set(parent_object_uid, 'NumberOfGUIElements', nb)
                    logs.add(f"{parent_object_uid} : attribute NumberOfGUIElements updated")
                else:
                    nb = self.objects_type_number_get(parent_object_uid + 'Image')
                    self.object_attr_value_set(parent_object_uid, 'NumberOfImages', nb)
                    logs.add(f"{parent_object_uid} : attribute NumberOfImages updated")

                return child_object_uid

        elif parent_object_type == 'PanelElement':
            # link between a PanelElement and a single child object
            # remove in the PanelElement object all the lines with Type or referencing attribute
            i = 0
            parent_lines_list = parent_object_dic['lines']
            while i < len(parent_lines_list):
                # parse the lines of the parent object
                (error_msg, attr_name, attr_value, comment) = self.object_line_split(parent_lines_list[i])
                if attr_name != None and (attr_name in self.go_objects_children_dic['PanelElement'] or attr_name == 'Type'):
                    # the current line contains an attribute to remove
                    del parent_object_dic['lines'][i]
                    i -= 1
                i += 1
            if operation == 'link':
                # add the type and reference to the child object
                parent_object_dic['lines'].insert(1, f'Type={child_object_type}')
                parent_object_dic['lines'].insert(2, f'{child_object_type}={str(child_object_id).zfill(3)}')
                logs.add(f"{parent_object_uid} : link to {child_object_uid} added")
            else:
                # add an empty type attribute
                parent_object_dic['lines'].insert(1, 'Type=')
                logs.add(f"{parent_object_uid} : link to {child_object_uid} removed")

            return child_object_uid

        else:
            # management of the other types of objects links
            # add/remove in the parent object the attribute which refers to the child object and update the NumberOf attribute

            # define the name of the parent attribute which defines the number of child objects type
            if parent_object_type in ('Coupler', 'DivisionalCoupler', 'Stop', 'Switch', 'Tremulant') and child_object_type == 'Switch':
                nb_of_attr_name = 'SwitchCount'
            else:
                if child_object_type == 'Switch':
                    nb_of_attr_name = 'NumberOfSwitches'
                else:
                    nb_of_attr_name = 'NumberOf' + child_object_type + 's'

            # define the name of the parent attributes which refers to the child objects type
            if parent_object_type == 'General':
                object_type_attr_name = child_object_type + 'Number'
                if child_object_type in ('Coupler', 'Stop'):
                    object_type_attr_name2 = child_object_type + 'Manual'
                else:
                    object_type_attr_name2 = None
            else:
                object_type_attr_name = child_object_type
                object_type_attr_name2 = None

            # make the list of the references to the child object type in the parent object and delete the lines having these references
            references_list = []
            nb_of_attr_name_line_nb = None  # line number in the parent where is located the NumberOf attributes
            i = 0
            parent_lines_list = parent_object_dic['lines']
            while i < len(parent_lines_list):
                # parse the lines of the parent object
                if parent_lines_list[i].startswith(child_object_type):
                    # the current line should contain a reference to the child object type
                    (error_msg, attr_name, attr_value, comment) = self.object_line_split(parent_lines_list[i])
                    if attr_name != None and attr_value not in ('', None):
                        # the current line contains a not empty attribute
                        if attr_name[:-3] == object_type_attr_name:
                            # the attribute is referencing a child object
                            if abs(int(attr_value)) != child_object_id:
                                # store the reference of the child object and the comment if the current line doesn't refer to the child object ID
                                references_list.append((attr_value, comment))
                            # delete the referencing line
                            del parent_object_dic['lines'][i]
                            i -= 1
                        elif attr_name[:-3] == object_type_attr_name2:
                            # the attribute is referencing a manual to which contains a child object
                            # delete the referencing line
                            del parent_object_dic['lines'][i]
                            i -= 1

                if parent_lines_list[i].startswith(nb_of_attr_name + '='):
                    # line containing the NumberOf or Count attribute
                    nb_of_attr_name_line_nb = i
                i += 1

            if nb_of_attr_name_line_nb == None:
                # attribute NumberOf or Count not found : add it in the last line of the parent object
                parent_object_dic['lines'].append(nb_of_attr_name + '=0')
                nb_of_attr_name_line_nb = len(parent_object_dic['lines']) - 1

            # add the reference to the child object in the references list without comment
            if operation == 'link':
                references_list.append((str(child_object_id).zfill(3), None))

            # set in the parent object the new references number
            self.object_attr_value_set(parent_object_dic, nb_of_attr_name, len(references_list))

            # insert all the references in the parent object after the NumberOf line
            insert_idx = nb_of_attr_name_line_nb + 1
            for ref_idx in range(len(references_list)):
                line = self.object_line_join(object_type_attr_name + str(ref_idx + 1).zfill(3), references_list[ref_idx][0], references_list[ref_idx][1])
                parent_object_dic['lines'].insert(insert_idx, line)
                insert_idx += 1
                if object_type_attr_name2 != None:
                    # need to add an attribute CouplerManual999 or StopManual999 after the attribute CouplerNumber999 or StopNumber999
                    # recover the referenced Coupler or Manual
                    ref_object_dic = self.object_dic_get(child_object_type + str(references_list[ref_idx][0]).zfill(3))
                    if ref_object_dic != None:
                        # recover the UID of the parent Manual object if any
                        for parent_uid in ref_object_dic['parents']:
                            if parent_uid[:6] == 'Manual':
                                # add a line with the reference to the Manual
                                line = self.object_line_join(object_type_attr_name2 + str(ref_idx + 1).zfill(3), parent_uid[-3:])
                                parent_object_dic['lines'].insert(insert_idx, line)
                                insert_idx += 1

            if operation == 'link':
                logs.add(f"{parent_object_uid} : reference to {child_object_uid} added")
            else:
                logs.add(f"{parent_object_uid} : reference to {child_object_uid} removed")
            logs.add(f"{parent_object_uid} : attribute {nb_of_attr_name} updated")

            return child_object_uid

        return None

    #-------------------------------------------------------------------------------------------------
    def object_parent_panel_get(self, object_uid):
        # returns the UID of the panel (Panel999 or Organ if old panel format) to which belongs the given object UID
        # returns None if it has no parent panel

        if object_uid[:5] == 'Panel':
            if len(object_uid) == 8:
                # Panel999 : it has no parent panel
                parent_panel_uid = None
            else:
                # Panel999NNNNN999
                parent_panel_uid = object_uid[:8]
        else:
            # the object UID is not Panel999 or Panel999Element999, so it is necessarily displayed in the main panel
            if self.new_panel_format_bool:
                parent_panel_uid = 'Panel000'
            else:
                parent_panel_uid = 'Organ'

        return parent_panel_uid

    #-------------------------------------------------------------------------------------------------
    def object_parent_manual_get(self, object_uid):
        # returns the UID of the manual (Manual999) to which belongs the given object UID
        # returns None if it has no parent manuel

        for parent_uid in self.object_kinship_list_get(object_uid, TO_PARENT):
            if parent_uid[:6] == 'Manual':
                return parent_uid

        return None

    #-------------------------------------------------------------------------------------------------
    def object_kinship_list_add(self, object_uid, ref_object_uid, relationship):
        # add in the parents/children list of the given object UID the given referenced object UID
        # the given relationship must be TO_PARENT or TO_CHILD

        object_dic = self.object_dic_get(object_uid)
        if object_dic != None:
            ref_object_dic = self.object_dic_get(ref_object_uid)
            if ref_object_dic != None:
                # both the given object and referenced object are defined
                if relationship == TO_CHILD:
                    # the target object is child of the given object
                    if ref_object_uid not in object_dic['children']: object_dic['children'].append(ref_object_uid)
                    if object_uid     not in ref_object_dic['parents']:  ref_object_dic['parents'].append(object_uid)
                elif relationship == TO_PARENT:
                    # the target object is parent of the given object
                    if ref_object_uid not in object_dic['parents']:  object_dic['parents'].append(ref_object_uid)
                    if object_uid     not in ref_object_dic['children']: ref_object_dic['children'].append(object_uid)
                else:
                    logs.add('INTERNAL ERROR undefined link type given to object_kinship_list_add')
            else:
                logs.add(f'WARNING cannot link {object_uid} to {ref_object_uid} which does not exist')

    #-------------------------------------------------------------------------------------------------
    def object_kinship_list_get(self, object_uid, relationship):
        # get the parents/children list of the given object UID
        # the given relationship must be TO_PARENT or TO_CHILD

        object_dic = self.object_dic_get(object_uid)
        if object_dic != None:
            if relationship == TO_PARENT:
                return object_dic['parents']
            elif relationship == TO_CHILD:
                return object_dic['children']
            else:
                logs.add('INTERNAL ERROR undefined link type given to object_kinship_link_get')
                return []
        else:
            return []

    #-------------------------------------------------------------------------------------------------
    def objects_kinship_update(self):
        # update the kinship links between the objects of the ODF dictionary

        for object_uid, object_dic in self.odf_data_dic.items():
            # parse the objects of the ODF dictionary to reset their internal attributes and define their names from some attributes values

            # reset names/parents/children lists which are updated in this function
            object_dic['names'] = []
            object_dic['parents'] = []
            object_dic['children'] = []

            for line in object_dic['lines']:
                # parse the lines of the current object to get its various names
                (error_msg, attr_name, attr_value, comment) = self.object_line_split(line)
                if (attr_name != None and attr_value != None and attr_value != '' and
                    (attr_name in ['Name', 'ChurchName', 'Type', 'Image', 'ImageOff', 'Comment'] or attr_name[-4:] == 'Text')):
                    if attr_name in ['Image', 'ImageOff']:
                        # image attribute, the value is the path of the image : keep from the image path only the file name (string after the last \ character)
                        attr_value = path2ospath(attr_value)
                        path_elements_list = attr_value.split(os.sep)
                        attr_value = path_elements_list[len(path_elements_list)-1]
                    # add the attribute value in the names list of this object
                    if len(attr_value) > 0:
                        object_dic['names'].append(attr_value)

            # in case of PanelElement or PanelImage object, add the name of the parent Panel
            if self.object_type_get(object_uid) in ('PanelElement', 'PanelImage'):
                panel_uid = object_uid[:8]
                panel_dic = self.object_dic_get(panel_uid)
                if panel_dic != None:
                    name = self.object_attr_value_get(panel_dic, 'Name')
                    if name not in (None, ''):
                        object_dic['names'].append(name)

        for object_uid, object_dic in self.odf_data_dic.items():
            # parse the objects of the ODF dictionary to define their parent/child kinship links

            object_type = self.object_type_get(object_uid)
            if object_type.startswith('Panel') and len(object_type) > 5:
                # Panel999 object type
                # link the current object to its Panel parent
                panel_uid = object_uid[:8]
                self.object_kinship_list_add(object_uid, panel_uid, TO_PARENT)

                # add the name of the referenced object if PanelElement is referencing a child object
                if object_type == 'PanelElement':
                    ref_object_type = self.object_attr_value_get(object_dic, 'Type')
                    ref_object_id = self.object_attr_value_get(object_dic, ref_object_type)
                    if ref_object_id != None:
                        # generate the UID of the referenced object
                        ref_object_uid = ref_object_type + str(int(ref_object_id)).zfill(3)
                        ref_object_dic = self.object_dic_get(ref_object_uid)
                        if ref_object_dic != 'None':
                            # get the name of the referenced object
                            ref_object_name = self.object_attr_value_get(ref_object_dic, 'Name')
                            if ref_object_name != None:
                                # add this name to the PanelElement names list
                                object_dic['names'].insert(1, ref_object_name)

            for line in object_dic['lines']:
                # parse the lines of the current object to detect links toward other objects
                (error_msg, attr_name, attr_value, comment) = self.object_line_split(line)
                if attr_value != None:
                    # the attribute has a value
                    if attr_name[-3:].isdigit() and (attr_value.isdigit() or (len(attr_value) > 0 and attr_value[0] == '-' and attr_value[1:].isdigit())):
                        # attribute which ends with 3 digits (like Coupler999) : it contains in its value the reference to another object
                        # link the current object to the referenced object as child
                        ref_object_type = attr_name[:-3]
                        if object_type == 'General':
                            if ref_object_type[-6:] == 'Number'  : ref_object_type = ref_object_type[:-6]  # remove the string 'Number'
                            elif ref_object_type[-6:] == 'Manual': ref_object_type = None
                        if ref_object_type != None:
                            ref_object_uid = ref_object_type + str(abs(int(attr_value))).zfill(3)
                            self.object_kinship_list_add(object_uid, ref_object_uid, TO_CHILD)

                    elif attr_name == 'WindchestGroup' and attr_value.isdigit():
                        # attribute WindchestGroup : it contains in its value the reference to a WindchestGroup
                        # link the current object to the referenced WindchestGroup as parent
                        ref_object_uid = attr_name + str(int(attr_value)).zfill(3)
                        self.object_kinship_list_add(object_uid, ref_object_uid, TO_PARENT)

                    elif object_type == 'PanelElement' and attr_name in self.go_objects_children_dic['PanelElement']:
                        # Panel999Element999 object with a reference to a child object
                        # link the current object to the child object
                        ref_object_uid = attr_name + str(int(attr_value)).zfill(3)
                        self.object_kinship_list_add(object_uid, ref_object_uid, TO_CHILD)

    #-------------------------------------------------------------------------------------------------
    def object_organ_numbers_update(self, object_uid):
        # update in the Organ object the NumberOf attribute corresponding to the gieven object

        object_type = self.object_type_get(object_uid)

        if object_type == 'Switch':
            nb_of_attr_name = 'NumberOfSwitches'
        elif object_type in ('Enclosure', 'General', 'Manual', 'Panel', 'Rank', 'Tremulant', 'WindchestGroup'):
            nb_of_attr_name = 'NumberOf' + object_type + 's'
        else:
            nb_of_attr_name = None

        if nb_of_attr_name != None:
            nb = self.objects_type_number_get(object_type)
            if ((object_type == 'Manual' and 'Manual000' in self.odf_data_dic.keys()) or
                (object_type == 'Panel' and 'Panel000' in self.odf_data_dic.keys())):
                # Manual000 and Panel000 are not counted
                    nb -= 1
            self.object_attr_value_set('Organ', nb_of_attr_name, nb)
            logs.add(f'Organ : attribute {nb_of_attr_name} updated')

    #-------------------------------------------------------------------------------------------------
    def objects_number_get(self):
        # return the total number of objects defined in the ODF data

        return len(self.odf_data_dic)

    #-------------------------------------------------------------------------------------------------
    def objects_type_number_get(self, object_type):
        # return the number of objects defined in the ODF data having the given type (Manual, Enclosure, PanelElement, PanelImage, ...)
        # if the given type is Panel999Element or Panel999Image, returns the number of defined Panel999Element or Panel999Image objects

        # check if Panel999Element or Panel999Image type is given
        nb_in_panel_bool = (object_type[:5] == 'Panel' and object_type[5:8].isdigit and len(object_type) > 8)

        number = 0
        for object_uid in self.odf_data_dic.keys():
            # parse the objects of the ODF data
            if ((nb_in_panel_bool and object_uid.startswith(object_type)) or
                (not nb_in_panel_bool and self.object_type_get(object_uid) == object_type)):
                number += 1

        return number

    #-------------------------------------------------------------------------------------------------
    def objects_list_get(self):
        # return the list of the objects UID of the ODF data

        return list(self.odf_data_dic.keys())

    #-------------------------------------------------------------------------------------------------
    def object_poss_kinship_list_get(self, object_uid):
        # return two lists in a tuple : the one with the objects UID of the ODF data which can be possibly parent of the given object UID
        #                               the one with the objects UID of the ODF data which can be possibly children of the given object UID

        object_dic = self.object_dic_get(object_uid)
        if object_dic == None: return ([], [])

        object_type = self.object_type_get(object_uid)
        parents_list = []
        children_list = []

        if object_type in ('Header', 'Organ'):
            # no parent and no child for these object types
            return (parents_list, children_list)

        # recover the lists of possible parents/children object types for the given object type
        parent_types_list = list(self.go_objects_parents_dic[object_type])
        children_types_list = list(self.go_objects_children_dic[object_type])

        # if the given object is a Stop not refering to a WindchestGroup (it has not a rank defined inside), remove the WindchestGroup parent
        if object_type == 'Stop' and self.object_attr_value_get(object_dic, 'WindchestGroup') == None and 'WindchestGroup' in parent_types_list:
            parent_types_list.remove('WindchestGroup')

        # recover from the ODF data the objects UID which have a type which can be parent/child of the given object
        for obj_uid in self.odf_data_dic.keys():
            # parse the objects of the ODF dictionary
            obj_type = self.object_type_get(obj_uid)
            if obj_type in parent_types_list and obj_uid != object_uid:
                # the current object has a type which can be parent of the given object
                if obj_type == 'PanelElement':
                    if self.object_attr_value_get(obj_uid, 'Type') == object_type:
                        parents_list.append(obj_uid)
                else:
                    parents_list.append(obj_uid)
            if obj_type in children_types_list and obj_uid != object_uid:
                # the current object has a type which can be child of the given object
                children_list.append(obj_uid)

        return (parents_list, children_list)

    #-------------------------------------------------------------------------------------------------
    def object_poss_children_type_list_get(self, object_uid):
        # return the list of the object types which can be possibly children of the given object or which doesn't need a parent (Header and Organ if not already existing)

        object_dic = self.object_dic_get(object_uid)
        object_type = self.object_type_get(object_uid)

        # define the objects types which can be created as child of the given object type
        if   object_type == 'Organ':   child_types_list = ['General', 'Manual', 'Panel', 'WindchestGroup']
        elif object_type == 'Coupler': child_types_list = ['Switch']
        elif object_type == 'General': child_types_list = ['Switch']
        elif object_type == 'Manual':  child_types_list = ['Coupler', 'Divisional', 'Stop', 'Switch', 'Tremulant']
        elif object_type == 'Panel':   child_types_list = ['PanelElement', 'PanelImage']
        elif object_type == 'PanelElement': child_types_list = ['Coupler', 'Divisional', 'DivisionalCoupler', 'Enclosure', 'General', 'Manual', 'Stop', 'Tremulant']
        elif object_type == 'Stop':    child_types_list =   ['Rank', 'Switch']
        elif object_type == 'Switch':  child_types_list = ['Switch']
        elif object_type == 'Tremulant':      child_types_list = ['Switch']
        elif object_type == 'WindchestGroup': child_types_list = ['Enclosure', 'Stop', 'Rank', 'Tremulant']
        else: child_types_list = []

        # if the given object is a Stop refering to a WindchestGroup (it has a rank defined inside), remove the Rank child
        if object_type == 'Stop' and self.object_attr_value_get(object_dic, 'WindchestGroup') != None:
            child_types_list.remove('Rank')

        # if the given object is a PanelElement with a type defined and it is the type of an object, let only this type in the child types list
        if object_type == 'PanelElement':
            element_type = self.object_attr_value_get(object_dic, 'Type')
            if element_type != None:
                if element_type in child_types_list:
                    # the element type is one of the possible children of a PanelElement
                    child_types_list.clear()
                    child_types_list.append(element_type)
                else:
                    child_types_list.clear()

        if 'Organ' not in self.odf_data_dic.keys():
            child_types_list.insert(0, 'Organ')
        if ('Header' not in self.odf_data_dic.keys()) and (object_type in (None, 'Organ')):
            child_types_list.insert(0, 'Header')

        return child_types_list

#-------------------------------------------------------------------------------------------------
class C_ODF_HW2GO():
    #--- class to manage the conversion of a Hauptwerk ODF in a GrandOrgue ODF

    HW_sample_set_path = '' # path of the folder containing the loaded Hauptwerk sample set (which contains the sub-folders OrganDefinitions and OrganInstallationPackages)
    HW_odf_file_name = ''   # path of the loaded Hauptwerk ODF (which is inside the sub-folder OrganDefinitions)

    silent_loop_file_used = False  # flag to indicate that the file SilentLoop.wav is used by a built GO Stop

    HW_odf_dic = {}  # dictionary in which are stored the data of the loaded Hauptwerk ODF file (XML file)
                     # it has the following structure with three nested dictionaries :
                     #   {ObjectType:                      -> string, for example _General, KeyImageSet, DisplayPage
                     #       {ObjectID:                    -> integer, from 1 to 999999, recovered from the HW ODF objects ID when possible, else set by increment
                     #           {Attribute: Value, ...},  -> string: string
                     #        ...
                     #       },
                     #       ...
                     #    ...
                     #   }
                     # the ObjectUID (unique ID) is a string made by the concatenation of the ObjectType and the ObjectID on 6 digits, for example DisplayPage000006
                     # exception : the ObjectType _General has the ObjectUID _General

    GO_odf_dic = {}  # dictionary in which are stored the data of the GrandOrgue ODF built from the Hauptwerk ODF dictionary
                     # it has the following structure with two nested dictionaries :
                     #   {ObjectUID:                   -> string, for example Organ, Panel001, Rank003
                     #       {Attribute: Value, ...}   -> string: string or integer if number / dimension / code
                     #    ...
                     #   }

    HW_odf_attr_dic = {} # dictionary which contains the definition of the various HW object types and their attributes (loaded from the file HwObjectsAttributesDict.txt)
                         # it has the following structure with two nested dictionaries :
                         #   {ObjectType:                                  -> string, for example _General, KeyImageSet, DisplayPage
                         #       {AttributeLetter: AttributeFullName, ...} -> string: string
                         #    ...
                         #   }

    GO_objects_type_nb_dic = {}  # dictionary with GO objects types names as keys and the associated number of these objects types as integer values

    available_HW_packages_id_list = []  # list storing the ID of the installation packages which are actually accessible in the sample set package

    HW_default_display_page_id = 0  # ID of the HW default display page (which is displayed by default on organ loading and will be the GO Panel000)
    HW_console_display_page_id = 0  # ID of the HW console display page (which contains the displayed keyboards, can be different from the default display page)

    progress_status_show_function = None # address of a callback function to call to show a progression message during the ODF building

    #-------------------------------------------------------------------------------------------------
    def reset_all_data(self):
        # reset all the data of the class, except the HW_odf_attr_dic dictionary

        # clear the content of the dictionary HW_odf_dic
        self.HW_odf_dic.clear()
        self.GO_odf_dic.clear()
        self.GO_objects_type_nb_dic.clear()
        self.available_HW_packages_id_list = []
        self.HW_odf_file_name = ''
        self.HW_sample_set_path = ''

    #-------------------------------------------------------------------------------------------------
    def HW_ODF_load_from_file(self, file_name):
        # fill the Hauptwerk ODF dictionary from the data of the given Hauptwerk ODF XML file
        # return True or False whether the operation has succeeded or not

        """
        the considered Hauptwerk ODF XML syntax is :

        <Hauptwerk FileFormat="Organ" FileFormatVersion="xxxxxx">
            <ObjectList ObjectType="ObjectTypeName">
                <"ObjectTypeName">
                    <"Attribute1">Value</"Attribute1">
                    <"Attribute2">Value</"Attribute2">
                    ...
                </"ObjectTypeName">
                ...
                <o>                    -> compressed format
                    <a>Value</a>
                    <b>Value</b>
                    ...
                </o>
                ...
            </ObjectList>
               ...
        </Hauptwerk>

        the attributes letters are converted to attributes full name thanks to the dictionary HW_odf_attr_dic
        """

        file_name = path2ospath(file_name)

        # check the extension of the given file name
        filename_str, file_extension_str = os.path.splitext(file_name)
        if file_extension_str != '.Organ_Hauptwerk_xml' and file_extension_str != '.xml':
            logs.add(f'ERROR : The file "{file_name}" does not have the expected extension .xml or .Organ_Hauptwerk_xml')
            return False

        # check the existence of the given file name
        if not(os.path.isfile(file_name)):
            logs.add(f'ERROR : The file "{file_name}" does not exist')
            return False

        # load the dictionary HwObjectsAttributesDict if not already loaded
        if not self.HW_ODF_attr_dic_file_load():
            # error occurred while loading the dictionary
            return False

        self.reset_all_data()

        # load the content of the HW XML file as an elements tree
        HW_ODF_xml_tree = etree.parse(file_name)

        # check that it is actually an Hauptwerk ODF and recover the file format version
        HW_xml_id_tag_str = HW_ODF_xml_tree.xpath("/Hauptwerk")
        HW_file_format_str = HW_xml_id_tag_str[0].get("FileFormat")
        HW_file_format_version_str = HW_xml_id_tag_str[0].get("FileFormatVersion")
        if HW_file_format_str != 'Organ':
            # it is not an ODF
            logs.add(f'ERROR : The file "{file_name}" is not a supported Hauptwerk organ definition file')
            return False

        object_type_nb_int = 0  # total number of object types found
        object_elem_nb_int = 0  # total number of object elements found
        object_attr_nb_int = 0  # total number of object attributes found
        for xml_object_type in HW_ODF_xml_tree.xpath("/Hauptwerk/ObjectList"):
            # parse the object types defined in the XML file (in the tags <ObjectList ObjectType="xxxx">)
            object_type_nb_int += 1

            # recover the name of the current object type
            HW_object_type = xml_object_type.get("ObjectType")

            self.progress_status_show_function(f'Loading the Hauptwerk ODF... {HW_object_type}')

            # create an entry in the HW dictionary for the current object type
            object_type_dic = self.HW_odf_dic[HW_object_type] = {}

            if HW_object_type in self.HW_odf_attr_dic.keys():
                # the current object type is defined in the HW attributes dictionary
                # get the dictionary defining the attributes of the current object type
                object_type_attr_dic = self.HW_odf_attr_dic[HW_object_type]
                # recover the name of the attribute of the object elements of the current object type which define the ID of each element, if it exists
                object_id_attr_name_str = object_type_attr_dic['IDattr']

                object_id_counter_int = 0  # ID which can be assigned to the current object element inside the current object type if it has not an ID defined in the attributes
                for xml_object_element in xml_object_type:
                    # parse the object elements defined in the current object type
                    object_elem_nb_int += 1
                    object_id_counter_int += 1
                    object_id_int = 0

                    # create a new object element dictionary
                    object_dic = {}

                    # add at the beginning of the current object element dictionary some custom attributes used for the GO ODF building
                    object_dic['_HW_uid'] = ''  # Unique ID of the HW object
                    object_dic['_GO_uid'] = ''  # Unique ID of the corresponding built GO object
                    object_dic['_parents'] = []   # list of the parent HW objects dictionaries
                    object_dic['_children'] = []  # list of the children HW objects dictionaries

                    for xml_object_attribute in xml_object_element:
                        # parse the attributes defined in the current object element
                        object_attr_nb_int += 1
                        attribute_name_str = xml_object_attribute.tag
                        attribute_value_str = xml_object_attribute.text

                        if attribute_value_str != '' and attribute_value_str != None:
                            # the attributes with an empty or undefined value are ignored
                            if len(attribute_name_str) <= 2:
                                # the attribute name is defined by a tag of one or two characters (this is the Hauptwerk XML compressed format)
                                # recover the attribute long name corresponding to this tag
                                try:
                                    attribute_name_str = object_type_attr_dic[attribute_name_str]
                                except:
                                    # no attribute long name known
                                    attribute_name_str = attribute_name_str + '???'

                            # add the current attribute name and value to the current object
                            object_dic[attribute_name_str] = attribute_value_str

                            if object_id_int == 0 and object_id_attr_name_str != '' and attribute_name_str == object_id_attr_name_str:
                                # the current attribute is the attribute which contains the ID of the object in the current object type
                                if not attribute_value_str.isnumeric():
                                    logs.add(f'ERROR : attribute {attribute_name_str}={attribute_value_str} has not a numeric value in the object {HW_object_type} #{object_id_counter_int}')
                                else:
                                    object_id_int = int(attribute_value_str)

                    if object_id_int == 0:
                        # no object ID recovered from the attributes
                        if object_id_attr_name_str != '':
                            # the object should have had an ID attribute
                            logs.add(f'ERROR : attribute {object_id_attr_name_str} not found in the object {HW_object_type} #{object_id_counter_int}')
                        # use as object ID the objects counter
                        object_id_int = object_id_counter_int

                    # store in the object its UID (unique ID)
                    if HW_object_type == '_General':
                        object_dic['_HW_uid'] = '_General'
                    else:
                        object_dic['_HW_uid'] = HW_object_type + str(object_id_int).zfill(6)

                    if object_id_int in object_type_dic.keys():
                        logs.add(f'WARNING: HW object {object_dic["_HW_uid"]} has an ID which is not unique !')

                    # add the object dictionary to the current object type dictionary
                    object_type_dic[object_id_int] = object_dic

            else:
                logs.add(f'INTERNAL ERROR : object type {HW_object_type} unknown in the HW attributes dictionary')

        logs.add(f'Hauptwerk ODF loaded "{file_name}"')
        logs.add(f'Hauptwerk organ file format version {HW_file_format_version_str}')
        logs.add(f'{object_attr_nb_int:,} attributes among {object_elem_nb_int:,} objects among {object_type_nb_int} object types')

        self.HW_odf_file_name = path2ospath(file_name)
        self.HW_sample_set_path = path2ospath(os.path.dirname(os.path.dirname(file_name)))

        return True

    #-------------------------------------------------------------------------------------------------
    def HW_ODF_attr_dic_file_load(self):
        # load the Hauptwerk attributes dictionary from the file HwObjectsAttributesDict.txt (if it is present and there is no error)
        # return True or False whether the operation has succeeded or not

        if len(self.HW_odf_attr_dic) == 0:
            # the dictionary has not been loaded yet

            file_name = os.path.dirname(__file__) + os.sep + 'resources' + os.sep + 'HwObjectsAttributesDict.txt'

            try:
                with open(file_name, 'r') as f:
                    self.HW_odf_attr_dic = eval(f.read())
                    return True
            except OSError as err:
                # it has not be possible to open the file
                logs.add(f'ERROR Cannot open the file "{file_name}" : {err}')
            except SyntaxError as err:
                # syntax error in the dictionary structure which is in the file
                logs.add(f'ERROR Syntax error in the file "{file_name}" : {err}')
            except:
                # other error
                logs.add(f'ERROR while opening the file "{file_name}"')

            return False

        else:
            return True

    #-------------------------------------------------------------------------------------------------
    def HW_ODF_do_links_between_objects(self):
        # set in the Hauptwerk ODF dictionary the relationships (parent, children) between the various objects
        # add in the objects of the HW_odf_dic the attributes "_parents" and "_children" with as value the list of the respective parent or child objects

        HW_general_object_dic = None
        HW_object_type = '_General'
        self.progress_status_show_function(f'Building the Hauptwerk ODF objects tree... {HW_object_type}')
        if HW_object_type in self.HW_odf_dic.keys():
            for HW_object_dic in self.HW_odf_dic[HW_object_type].values():
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'OrganInfo_InstallationPackageID', 'RequiredInstallationPackage', TO_CHILD)
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'SpecialObjects_DefaultDisplayPageID', 'DisplayPage', TO_CHILD)
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'SpecialObjects_MasterCaptureSwitchID', 'Switch', TO_CHILD)
                HW_general_object_dic = HW_object_dic
        if HW_general_object_dic == None:
            logs.add('ERROR : no _General object defined in the Hauptwerk ODF')
            return False

        HW_object_type = 'DivisionInput'
        self.progress_status_show_function(f'Building the Hauptwerk ODF objects tree... {HW_object_type}')
        if HW_object_type in self.HW_odf_dic.keys():
            for HW_object_dic in self.HW_odf_dic[HW_object_type].values():
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'DivisionID', 'Division', TO_PARENT)
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'SwitchID', 'Switch', TO_PARENT)

        HW_object_type = 'Keyboard'
        self.progress_status_show_function(f'Building the Hauptwerk ODF objects tree... {HW_object_type}')
        if HW_object_type in self.HW_odf_dic.keys():
            for HW_object_dic in self.HW_odf_dic[HW_object_type].values():
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'KeyGen_DisplayPageID', 'DisplayPage', TO_PARENT)
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'KeyGen_KeyImageSetID', 'KeyImageSet',  TO_CHILD)
                # link the keyboard to its division
                HW_division_dic = self.HW_ODF_get_object_dic_by_ref_id('Division', HW_object_dic, 'Hint_PrimaryAssociatedDivisionID')
                if HW_division_dic == None:
                    # find the division ID from the keyboard code, supposing to the following matching :
                    #     keyboard code 1 = division 1 = Pedal
                    #     keyboard code 2 = division 2 = Manual 1
                    #     keyboard code 3 = division 3 = Manual 2
                    #     ...
                    HW_division_dic = self.HW_ODF_get_object_dic_by_ref_id('Division', HW_object_dic, 'DefaultInputOutputKeyboardAsgnCode')
                if HW_division_dic != None:
                    self.HW_ODF_do_link_between_obj(HW_object_dic, HW_division_dic, TO_PARENT)

        HW_object_type = 'KeyAction'
        self.progress_status_show_function(f'Building the Hauptwerk ODF objects tree... {HW_object_type}')
        if HW_object_type in self.HW_odf_dic.keys():
            for HW_object_dic in self.HW_odf_dic[HW_object_type].values():
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'SourceKeyboardID', 'Keyboard', TO_PARENT)
                HW_cond_switch_dic = self.HW_ODF_get_attribute_value(HW_object_dic, 'ConditionSwitchID')
                if self.HW_ODF_get_attribute_value(HW_object_dic, 'DestDivisionID') != None:
                    # the key action destination is a division
                    self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'DestDivisionID', 'Division', TO_CHILD)
                    # link directly the source keyboard to the destination division if there is no conditional switch
                    # this link may have been done already while processing the Keyboard objects above
                    if HW_cond_switch_dic == None:
                        HW_source_keyboard_dic = self.HW_ODF_get_object_dic_by_ref_id('Keyboard', HW_object_dic, 'SourceKeyboardID')
                        HW_dest_division_dic = self.HW_ODF_get_object_dic_by_ref_id('Division', HW_object_dic, 'DestDivisionID')
                        self.HW_ODF_do_link_between_obj(HW_source_keyboard_dic, HW_dest_division_dic, TO_PARENT)
                else:
                    # the key action destination is a keyboard
                    self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'DestKeyboardID', 'Keyboard', TO_CHILD)
                    # link directly the source keyboard to the destination keyboard
                    # this link may have been done already while processing the Keyboard objects above
                    if HW_cond_switch_dic == None:
                        HW_source_keyboard_dic = self.HW_ODF_get_object_dic_by_ref_id('Keyboard', HW_object_dic, 'SourceKeyboardID')
                        HW_dest_keyboard_dic = self.HW_ODF_get_object_dic_by_ref_id('Keyboard', HW_object_dic, 'DestKeyboardID')
                        self.HW_ODF_do_link_between_obj(HW_source_keyboard_dic, HW_dest_keyboard_dic, TO_CHILD)
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'ConditionSwitchID', 'Switch', TO_PARENT)

        HW_object_type = 'KeyboardKey'
        self.progress_status_show_function(f'Building the Hauptwerk ODF objects tree... {HW_object_type}')
        if HW_object_type in self.HW_odf_dic.keys():
            for HW_object_dic in self.HW_odf_dic[HW_object_type].values():
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'KeyboardID', 'Keyboard', TO_PARENT)
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'SwitchID', 'Switch', TO_PARENT)

        HW_object_type = 'KeyImageSet'
        self.progress_status_show_function(f'Building the Hauptwerk ODF objects tree... {HW_object_type}')
        if HW_object_type in self.HW_odf_dic.keys():
            for HW_object_dic in self.HW_odf_dic[HW_object_type].values():
                for obj_attr_name_str in list(HW_object_dic.keys()):
                    if obj_attr_name_str.startswith('KeyShapeImageSetID'):
                        self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, obj_attr_name_str, 'ImageSet', TO_CHILD)

        HW_object_type = 'ImageSetElement'
        self.progress_status_show_function(f'Building the Hauptwerk ODF objects tree... {HW_object_type}')
        if HW_object_type in self.HW_odf_dic.keys():
            for HW_object_dic in self.HW_odf_dic[HW_object_type].values():
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'ImageSetID', 'ImageSet', TO_PARENT)

        HW_object_type = 'TextInstance'
        self.progress_status_show_function(f'Building the Hauptwerk ODF objects tree... {HW_object_type}')
        if HW_object_type in self.HW_odf_dic.keys():
            for HW_object_dic in self.HW_odf_dic[HW_object_type].values():
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'DisplayPageID', 'DisplayPage', TO_PARENT)
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'TextStyleID', 'TextStyle', TO_CHILD)
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'AttachedToImageSetInstanceID', 'ImageSetInstance', TO_CHILD)

        HW_object_type = 'Switch'
        self.progress_status_show_function(f'Building the Hauptwerk ODF objects tree... {HW_object_type}')
        if HW_object_type in self.HW_odf_dic.keys():
            for HW_object_dic in self.HW_odf_dic[HW_object_type].values():
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'Disp_ImageSetInstanceID', 'ImageSetInstance', TO_CHILD)
                # if the Switch is linked to an ImageSetInstance object, link it to the DisplayPage in which it is displayed
                HW_image_set_inst_dic = self.HW_ODF_get_object_dic_by_ref_id('ImageSetInstance', HW_object_dic, 'Disp_ImageSetInstanceID')
                if HW_image_set_inst_dic != None:
                    HW_display_page_dic = self.HW_ODF_get_object_dic_by_ref_id('DisplayPage', HW_image_set_inst_dic, 'DisplayPageID')
                    self.HW_ODF_do_link_between_obj(HW_object_dic, HW_display_page_dic, TO_PARENT)

        HW_object_type = 'SwitchLinkage'
        self.progress_status_show_function(f'Building the Hauptwerk ODF objects tree... {HW_object_type}')
        if HW_object_type in self.HW_odf_dic.keys():
            for HW_object_dic in self.HW_odf_dic[HW_object_type].values():
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'SourceSwitchID', 'Switch', TO_PARENT)
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'DestSwitchID', 'Switch', TO_CHILD)
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'ConditionSwitchID', 'Switch', TO_PARENT)
                if DEV_MODE:
                    # only in development mode to speed up the links creation in application mode, this parent/child association is not used to convert the HW to GO ODF
                    # make direct link between source and destination switches
                    HW_source_switch_dic = self.HW_ODF_get_object_dic_by_ref_id('Switch', HW_object_dic, 'SourceSwitchID')
                    HW_dest_switch_dic = self.HW_ODF_get_object_dic_by_ref_id('Switch', HW_object_dic, 'DestSwitchID')
                    HW_cond_switch_dic = self.HW_ODF_get_object_dic_by_ref_id('Switch', HW_object_dic, 'ConditionSwitchID')
                    if HW_source_switch_dic != None and HW_dest_switch_dic != None :
                        self.HW_ODF_do_link_between_obj(HW_source_switch_dic, HW_dest_switch_dic, TO_CHILD)
                        if HW_cond_switch_dic != None:
                            self.HW_ODF_do_link_between_obj(HW_cond_switch_dic, HW_dest_switch_dic, TO_CHILD)

        HW_object_type = 'SwitchExclusiveSelectGroupElement'
        self.progress_status_show_function(f'Building the Hauptwerk ODF objects tree... {HW_object_type}')
        if HW_object_type in self.HW_odf_dic.keys():
            for HW_object_dic in self.HW_odf_dic[HW_object_type].values():
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'SwitchID', 'Switch', TO_CHILD)
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'GroupID', 'SwitchExclusiveSelectGroup', TO_PARENT)

        HW_object_type = 'WindCompartment'
        self.progress_status_show_function(f'Building the Hauptwerk ODF objects tree... {HW_object_type}')
        if HW_object_type in self.HW_odf_dic.keys():
            for HW_object_dic in self.HW_odf_dic[HW_object_type].values():
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'PressureOutputContinuousControlID', 'ContinuousControl', TO_PARENT)

        HW_object_type = 'WindCompartmentLinkage'
        self.progress_status_show_function(f'Building the Hauptwerk ODF objects tree... {HW_object_type}')
        if HW_object_type in self.HW_odf_dic.keys():
            for HW_object_dic in self.HW_odf_dic[HW_object_type].values():
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'FirstWindCompartmentID', 'WindCompartment', TO_PARENT)
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'SecondWindCompartmentID', 'WindCompartment', TO_CHILD)
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'ValveControllingContinuousControlID', 'ContinuousControl', TO_PARENT)
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'ValveControllingSwitchID', 'Switch', TO_PARENT)
                # make direct link between source and destination wind compartments
                HW_first_wind_comp_dic = self.HW_ODF_get_object_dic_by_ref_id('WindCompartment', HW_object_dic, 'FirstWindCompartmentID')
                HW_second_wind_comp_dic = self.HW_ODF_get_object_dic_by_ref_id('WindCompartment', HW_object_dic, 'SecondWindCompartmentID')
                if HW_first_wind_comp_dic != None and HW_second_wind_comp_dic != None :
                    self.HW_ODF_do_link_between_obj(HW_first_wind_comp_dic, HW_second_wind_comp_dic, TO_CHILD)

        HW_object_type = 'Stop'
        self.progress_status_show_function(f'Building the Hauptwerk ODF objects tree... {HW_object_type}')
        if HW_object_type in self.HW_odf_dic.keys():
            for HW_object_dic in self.HW_odf_dic[HW_object_type].values():
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'DivisionID', 'Division', TO_PARENT)
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'ControllingSwitchID', 'Switch', TO_PARENT)
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'Hint_PrimaryAssociatedRankID', 'Rank', TO_CHILD)

        HW_object_type = 'StopRank'
        self.progress_status_show_function(f'Building the Hauptwerk ODF objects tree... {HW_object_type}')
        if HW_object_type in self.HW_odf_dic.keys():
            for HW_object_dic in self.HW_odf_dic[HW_object_type].values():
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'StopID', 'Stop', TO_PARENT)
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'RankID', 'Rank', TO_CHILD)
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'SwitchIDToSwitchToAlternateRank', 'Switch', TO_PARENT)
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'AlternateRankID', 'Rank', TO_CHILD)

        HW_object_type = 'Combination'
        self.progress_status_show_function(f'Building the Hauptwerk ODF objects tree... {HW_object_type}')
        if HW_object_type in self.HW_odf_dic.keys():
            for HW_object_dic in self.HW_odf_dic[HW_object_type].values():
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'ActivatingSwitchID', 'Switch', TO_PARENT)

        HW_object_type = 'CombinationElement'
        self.progress_status_show_function(f'Building the Hauptwerk ODF objects tree... {HW_object_type}')
        if HW_object_type in self.HW_odf_dic.keys():
            for HW_object_dic in self.HW_odf_dic[HW_object_type].values():
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'CombinationID', 'Combination', TO_PARENT)
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'ControlledSwitchID', 'Switch', TO_CHILD)
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'CapturedSwitchID', 'Switch', TO_CHILD)
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'MemorySwitchID', 'Switch', TO_CHILD)

        HW_object_type = 'Pipe_SoundEngine01'
        self.progress_status_show_function(f'Building the Hauptwerk ODF objects tree... {HW_object_type}')
        if HW_object_type in self.HW_odf_dic.keys():
            for HW_object_dic in self.HW_odf_dic[HW_object_type].values():
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'RankID', 'Rank', TO_PARENT)
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'ControllingPalletSwitchID', 'Switch', TO_PARENT)
                if DEV_MODE:
                    # only in development mode to speed up the links creation in application mode, this parent/child association is not used to convert the HW to GO ODF
                    self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'WindSupply_SourceWindCompartmentID', 'WindCompartment', TO_PARENT)
                    self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'WindSupply_OutputWindCompartmentID', 'WindCompartment', TO_CHILD)

        HW_object_type = 'Pipe_SoundEngine01_Layer'
        self.progress_status_show_function(f'Building the Hauptwerk ODF objects tree... {HW_object_type}')
        if HW_object_type in self.HW_odf_dic.keys():
            for HW_object_dic in self.HW_odf_dic[HW_object_type].values():
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'PipeID', 'Pipe_SoundEngine01', TO_PARENT)
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'AmpLvl_ScalingContinuousControlID', 'ContinuousControl', TO_PARENT)
##                if DEV_MODE:
##                    # only in development mode to speed up the links creation in application mode, this parent/child association is not used to convert the HW to GO ODF
##                    self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'Main_AttackSelCriteria_ContinuousControlID', 'ContinuousControl', TO_PARENT)
##                    self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'Main_ReleaseSelCriteria_ContinuousControlID', 'ContinuousControl', TO_PARENT)

        HW_object_type = 'Pipe_SoundEngine01_AttackSample'
        self.progress_status_show_function(f'Building the Hauptwerk ODF objects tree... {HW_object_type}')
        if HW_object_type in self.HW_odf_dic.keys():
            for HW_object_dic in self.HW_odf_dic[HW_object_type].values():
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'LayerID', 'Pipe_SoundEngine01_Layer', TO_PARENT)
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'SampleID', 'Sample', TO_CHILD)

        HW_object_type = 'Pipe_SoundEngine01_ReleaseSample'
        self.progress_status_show_function(f'Building the Hauptwerk ODF objects tree... {HW_object_type}')
        if HW_object_type in self.HW_odf_dic.keys():
            for HW_object_dic in self.HW_odf_dic[HW_object_type].values():
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'LayerID', 'Pipe_SoundEngine01_Layer', TO_PARENT)
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'SampleID', 'Sample', TO_CHILD)

        HW_object_type = 'ContinuousControlStageSwitch'
        self.progress_status_show_function(f'Building the Hauptwerk ODF objects tree... {HW_object_type}')
        if HW_object_type in self.HW_odf_dic.keys():
            for HW_object_dic in self.HW_odf_dic[HW_object_type].values():
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'ContinuousControlID', 'ContinuousControl', TO_PARENT)
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'ControlledSwitchID', 'Switch', TO_CHILD)

        HW_object_type = 'ContinuousControlLinkage'
        self.progress_status_show_function(f'Building the Hauptwerk ODF objects tree... {HW_object_type}')
        if HW_object_type in self.HW_odf_dic.keys():
            for HW_object_dic in self.HW_odf_dic[HW_object_type].values():
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'SourceControlID', 'ContinuousControl', TO_PARENT)
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'DestControlID', 'ContinuousControl', TO_CHILD)
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'ConditionSwitchID', 'Switch', TO_PARENT)

        HW_object_type = 'ContinuousControl'
        self.progress_status_show_function(f'Building the Hauptwerk ODF objects tree... {HW_object_type}')
        if HW_object_type in self.HW_odf_dic.keys():
            for HW_object_dic in self.HW_odf_dic[HW_object_type].values():
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'ImageSetInstanceID', 'ImageSetInstance', TO_CHILD)
                # if the ContinuousControl is linked to an ImageSetInstance object, link it to the DisplayPage in which it is displayed
                HW_image_set_inst_dic = self.HW_ODF_get_object_dic_by_ref_id('ImageSetInstance', HW_object_dic, 'ImageSetInstanceID')
                if HW_image_set_inst_dic != None:
                    HW_display_page_dic = self.HW_ODF_get_object_dic_by_ref_id('DisplayPage', HW_image_set_inst_dic, 'DisplayPageID')
                    self.HW_ODF_do_link_between_obj(HW_object_dic, HW_display_page_dic, TO_PARENT)

        HW_object_type = 'ContinuousControlImageSetStage'
        self.progress_status_show_function(f'Building the Hauptwerk ODF objects tree... {HW_object_type}')
        if HW_object_type in self.HW_odf_dic.keys():
            for HW_object_dic in self.HW_odf_dic[HW_object_type].values():
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'ImageSetID', 'ImageSet', TO_PARENT)

        HW_object_type = 'ContinuousControlDoubleLinkage'
        self.progress_status_show_function(f'Building the Hauptwerk ODF objects tree... {HW_object_type}')
        if HW_object_type in self.HW_odf_dic.keys():
            for HW_object_dic in self.HW_odf_dic[HW_object_type].values():
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'FirstSourceControl_UID', 'ContinuousControl', TO_PARENT)
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'SecondSourceControl_UID', 'ContinuousControl', TO_PARENT)
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'DestControl_UID', 'ContinuousControl', TO_CHILD)

        HW_object_type = 'Enclosure'
        self.progress_status_show_function(f'Building the Hauptwerk ODF objects tree... {HW_object_type}')
        if HW_object_type in self.HW_odf_dic.keys():
            for HW_object_dic in self.HW_odf_dic[HW_object_type].values():
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'ShutterPositionContinuousControlID', 'ContinuousControl', TO_PARENT)

        HW_object_type = 'EnclosurePipe'
        self.progress_status_show_function(f'Building the Hauptwerk ODF objects tree... {HW_object_type}')
        if HW_object_type in self.HW_odf_dic.keys():
            for HW_object_dic in self.HW_odf_dic[HW_object_type].values():
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'EnclosureID', 'Enclosure', TO_PARENT)
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'PipeID', 'Pipe_SoundEngine01', TO_CHILD)

		#        HW_object_type = 'TremulantWaveformPipe'
		#        if HW_object_type in self.HW_odf_dic.keys():
		#            for HW_object_dic in self.HW_odf_dic[HW_object_type].values():
		#                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'PipeID', 'Pipe_SoundEngine01', TO_CHILD)
		# put in comment, when used in some sample set, it points to PipeID values which none exits

        HW_object_type = 'Tremulant'
        self.progress_status_show_function(f'Building the Hauptwerk ODF objects tree... {HW_object_type}')
        if HW_object_type in self.HW_odf_dic.keys():
            for HW_object_dic in self.HW_odf_dic[HW_object_type].values():
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'ControllingSwitchID', 'Switch', TO_PARENT)
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'PhaseAngleOutputContinuousControlID', 'ContinuousControl', TO_PARENT)

        HW_object_type = 'TremulantWaveform'
        self.progress_status_show_function(f'Building the Hauptwerk ODF objects tree... {HW_object_type}')
        if HW_object_type in self.HW_odf_dic.keys():
            for HW_object_dic in self.HW_odf_dic[HW_object_type].values():
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'TremulantID', 'Tremulant', TO_PARENT)
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'PhaseAngleOutputContinuousControlID', 'ContinuousControl', TO_PARENT)
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'PitchOutputContinuousControlID', 'ContinuousControl', TO_PARENT)
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'PitchAndFundamentalWaveformSampleID', 'Sample', TO_CHILD)

        HW_object_type = 'ImageSetInstance'
        self.progress_status_show_function(f'Building the Hauptwerk ODF objects tree... {HW_object_type}')
        if HW_object_type in self.HW_odf_dic.keys():
            for HW_object_dic in self.HW_odf_dic[HW_object_type].values():
                if len(HW_object_dic['_parents']) == 0:
                    # this ImageSetInstance object has none parent, link it with its DisplayPage
                    self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'DisplayPageID', 'DisplayPage', TO_PARENT)
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'ImageSetID', 'ImageSet', TO_CHILD)

        # link to _General all the Division objects
        HW_object_type = 'Division'
        self.progress_status_show_function(f'Building the Hauptwerk ODF objects tree... {HW_object_type}')
        if HW_object_type in self.HW_odf_dic.keys():
            for HW_object_dic in self.HW_odf_dic[HW_object_type].values():
                self.HW_ODF_do_link_between_obj(HW_object_dic, HW_general_object_dic, TO_PARENT)

        # link to _General all the DisplayPage objects
        HW_object_type = 'DisplayPage'
        self.progress_status_show_function(f'Building the Hauptwerk ODF objects tree... {HW_object_type}')
        if HW_object_type in self.HW_odf_dic.keys():
            for HW_object_dic in self.HW_odf_dic[HW_object_type].values():
                self.HW_ODF_do_link_between_obj(HW_object_dic, HW_general_object_dic, TO_PARENT)

        # link to _General all the WindCompartment objects which have no parent
        HW_object_type = 'WindCompartment'
        self.progress_status_show_function(f'Building the Hauptwerk ODF objects tree... {HW_object_type}')
        if HW_object_type in self.HW_odf_dic.keys():
            for HW_object_dic in self.HW_odf_dic[HW_object_type].values():
                if len(HW_object_dic['_parents']) == 0:
                    self.HW_ODF_do_link_between_obj(HW_object_dic, HW_general_object_dic, TO_PARENT)

        return True

    #-------------------------------------------------------------------------------------------------
    def HW_ODF_do_link_between_obj_by_id(self, HW_object_dic, HW_attr_id_name_str, linked_object_type_str, link_type_int):
        # do a link between the given HW object dict and the given linked HW object type dict based on an ID
        # the given link_type_int must be TO_PARENT or TO_CHILD

        # recover the value of the ID permitting to establish a linkage between the two objects
        linkage_id_value_int = myint(self.HW_ODF_get_attribute_value(HW_object_dic, HW_attr_id_name_str))

        if linkage_id_value_int != None and linkage_id_value_int != 0:
            try:
                linked_object_dic = self.HW_odf_dic[linked_object_type_str][linkage_id_value_int]
            except:
                logs.add(f'INTERNAL ERROR : {HW_object_dic["_HW_uid"]} - not found reference to object type {linked_object_type_str} with ID {linkage_id_value_int}')
                return False
            else:
                return self.HW_ODF_do_link_between_obj(HW_object_dic, linked_object_dic, link_type_int)
        else:
            return False

    #-------------------------------------------------------------------------------------------------
    def HW_ODF_do_link_between_obj(self, HW_object_dic, linked_HW_object_dic, link_type_int):
        # do a link between the given HW object dict and the given linked HW object dict
        # the given link_type_int must be TO_PARENT or TO_CHILD

        if link_type_int == TO_CHILD:
            self.HW_ODF_add_attribute_value(HW_object_dic, '_children', linked_HW_object_dic)
            self.HW_ODF_add_attribute_value(linked_HW_object_dic, '_parents', HW_object_dic)
        elif link_type_int == TO_PARENT:
            self.HW_ODF_add_attribute_value(HW_object_dic, '_parents', linked_HW_object_dic)
            self.HW_ODF_add_attribute_value(linked_HW_object_dic, '_children', HW_object_dic)
        else:
            logs.add('INTERNAL ERROR : undefined link type given to HW_ODF_do_link_between_obj')
            return False

        return True

    #-------------------------------------------------------------------------------------------------
    def HW_ODF_add_attribute_value(self, HW_object_dic, attr_name, attr_value):
        # add the given attribute value to the list of the given object dictionary of the Hauptwerk ODF dictionary (for _xxx attributes which contain a list)
        # if the given value already exists in the list, it is not added to avoid doubles

        try:
            if attr_value not in HW_object_dic[attr_name]:
                HW_object_dic[attr_name].append(attr_value)
        except:
            # the attr_name doesn't exist, create it and add the value
            HW_object_dic[attr_name] = []
            HW_object_dic[attr_name].append(attr_value)

    #-------------------------------------------------------------------------------------------------
    def HW_ODF_get_attribute_value(self, HW_object_dic, attr_name, mandatory_bool=False):
        # return the string value string of the given attribute defined in the given object sub-dictionary of the Hauptwerk ODF dictionary
        # generate a log in case of attribute not found and if mandatory_bool=MANDATORY (True), mandatory_bool=False permits to get silently an attribute which the presence is optional
        # return None if the attribute name is not defined in the given dictionary

        if HW_object_dic == None:
            return None

        try:
            attr_value = HW_object_dic[attr_name]
        except:
            attr_value = None
            if mandatory_bool:
                logs.add(f'ERROR : unable to read the attribute "{attr_name}" in the sample set object {HW_object_dic["_HW_uid"]}')

        return attr_value

    #-------------------------------------------------------------------------------------------------
    def HW_ODF_get_object_dic(self, HW_object_type_or_uid, HW_object_id = None):
        # return the HW object dictionary having the given object type and ID or only the given UID (unique ID) if object_id_int = -1 or not defined
        # if the HW object type is '_General' then the object ID parameter has not to be provided
        # return None if the object has not been found with the given data

        if HW_object_type_or_uid == None:
            return None

        # define the object type and ID
        if HW_object_id == None:
            # no object ID provided : object UID is provided
            if HW_object_type_or_uid == '_General':
                HW_object_type = '_General'
                HW_object_id = 1
            else:
                HW_object_type = HW_object_type_or_uid[:-6]    # remove the last 6 digits of the UID
                HW_object_id = myint(HW_object_type_or_uid[-6:])  # keep only the last 6 digits of the UID
        else:
            # object type + ID is provided
            HW_object_type = HW_object_type_or_uid

        if HW_object_id == 0:
            return None

        try:
            # recover the dictionary of the object having the given type and ID
            return self.HW_odf_dic[HW_object_type][HW_object_id]
        except:
            # object dictionary not existing for the given type and/or ID
            return None

    #-------------------------------------------------------------------------------------------------
    def HW_ODF_get_object_dic_by_ref_id(self, HW_object_type, ref_HW_object_dic, ref_HW_attr_id_name_str):
        # return the HW object dictionary having the given object type and which the ID is defined in the given referencing object dictionary and its referencing attribute ID

        # get the ID of the referenced object
        HW_object_id = myint(self.HW_ODF_get_attribute_value(ref_HW_object_dic, ref_HW_attr_id_name_str))

        if HW_object_id != None:
            return self.HW_ODF_get_object_dic(HW_object_type, HW_object_id)
        else:
            return None

    #-------------------------------------------------------------------------------------------------
    def HW_ODF_get_linked_objects_dic_by_type(self, HW_object_dic, object_type_str, link_type_int, first_occurence=False, sorted_id_list=False, sorted_name_list=False):
        # return a list containing the dictionary of the HW objects which are parent/child (according to link_type_int) of the given object and which has the given object type
        # link_type_int must be equal to TO_PARENT or TO_CHILD
        # if sorted_id_list is equal to True, the returned objects list is sorted by object ID order
        # if sorted_name_list is equal to True (and sorted_id_list is equal to False), the returned objects list is sorted by object name order
        # if first_occurence = FIRST_ONE (True), only the first occurence of the linked object is returned as a dictionary, not as a list
        # return an empty list or None (if first_occurence=True) if there is no parent/child found

        HW_linked_objects_dic_list = []
        HW_linked_object_dic = None

        if HW_object_dic != None:
            if link_type_int == TO_PARENT:
                for HW_obj_dic in HW_object_dic['_parents']:
                    if HW_obj_dic['_HW_uid'][:-6] == object_type_str:
                        if first_occurence:
                            HW_linked_object_dic = HW_obj_dic
                            break
                        else:
                            HW_linked_objects_dic_list.append(HW_obj_dic)

            elif link_type_int == TO_CHILD:
                for HW_obj_dic in HW_object_dic['_children']:
                    if HW_obj_dic['_HW_uid'][:-6] == object_type_str:
                        if first_occurence:
                            HW_linked_object_dic = HW_obj_dic
                            break
                        else:
                            HW_linked_objects_dic_list.append(HW_obj_dic)
            else:
                logs.add('INTERNAL ERROR : undefined link type given to HW_ODF_get_linked_objects_dic_by_type')

        if first_occurence:
            return HW_linked_object_dic
        else:
            if (sorted_id_list or sorted_name_list) and len(HW_linked_objects_dic_list) > 1:
                id_list = []
                name_id_list = []
                for HW_obj_dic in HW_linked_objects_dic_list:
                    id_list.append(int(HW_obj_dic['_HW_uid'][-6:]))
                    name_id_list.append(HW_obj_dic['Name'] + '=' + HW_obj_dic['_HW_uid'][-6:])
                HW_linked_objects_dic_list = []
                if sorted_id_list:
                    for id in sorted(id_list):
                        HW_linked_objects_dic_list.append(self.HW_ODF_get_object_dic(object_type_str, id))
                else:
                    for name_id in sorted(name_id_list):
                        name, id = name_id.split('=')
                        HW_linked_objects_dic_list.append(self.HW_ODF_get_object_dic(object_type_str, int(id)))

            return HW_linked_objects_dic_list

    #-------------------------------------------------------------------------------------------------
    def HW_ODF_get_object_data_list(self, HW_object_uid_str):
        # return a list containing the object attributes name/value of the given object UID (for display purpose in the GUI)
        # or None if the given HW object doesn't exist

        HW_object_dic = self.HW_ODF_get_object_dic(HW_object_uid_str)

        if HW_object_dic != None:
            data_list = []
            for obj_attr_name_str, obj_attr_value in HW_object_dic.items():
                if obj_attr_name_str in ('_parents', '_children'):
                    # this attribute contains a list of objects dictionaries
                    obj_attr_value_str = ''
                    for HW_object_dic2 in obj_attr_value:
                        obj_attr_value_str += HW_object_dic2['_HW_uid'] + '  '
                else:
                    obj_attr_value_str = str(obj_attr_value)
                data_list.append(f'{obj_attr_name_str}={obj_attr_value_str}')
            return data_list
        else:
            return None

    #-------------------------------------------------------------------------------------------------
    def HW_ODF_get_image_attributes(self, HW_object_dic, HW_image_attr_dic, HW_image_index_in_set_int = None):
        # fill the given image dictionary with the following HW attributes of the given object dictionary (can be ImageSetInstance or ImageSet) and the related ImageSet / ImageSetElement
        # the not defined attributes are set at None
        #    Name (string)
        #    LeftXPosPixels (integer)
        #    TopYPosPixels (integer)
        #    ImageWidthPixels (integer)
        #    ImageHeightPixels (integer)
        #    ImageWidthPixelsTiling (integer)
        #    ImageHeightPixelsTiling (integer)
        #    ClickableAreaLeftRelativeXPosPixels (integer)
        #    ClickableAreaRightRelativeXPosPixels (integer)
        #    ClickableAreaTopRelativeYPosPixels (integer)
        #    ClickableAreaBottomRelativeYPosPixels (integer)
        #    InstallationPackageID (integer)
        #    BitmapFilename (string, with \ as folders separator)
        #    TransparencyMaskBitmapFilename (string, with \ as folders separator)
        # in case of an ImageSetInstance as object type, use the object default image index in set to know which ImageSetElement to recover
        # in case of an ImageSet as object type, use the given image index in set to know which ImageSetElement to recover
        # return True or False whether the operation has succeeded or not

        if HW_object_dic['_HW_uid'][:-6] == 'ImageSetInstance':
            # ImageSetInstance object provided

            HW_image_set_inst_dic = HW_object_dic

            # recover the dictionary of the associated ImageSet object
            HW_image_set_dic = self.HW_ODF_get_object_dic_by_ref_id('ImageSet', HW_image_set_inst_dic, 'ImageSetID')
            if HW_image_set_dic == None: return False

            HW_image_attr_dic['Name'] = self.HW_ODF_get_attribute_value(HW_image_set_inst_dic, 'Name')

            HW_image_attr_dic['LeftXPosPixels'] = myint(self.HW_ODF_get_attribute_value(HW_image_set_inst_dic, 'LeftXPosPixels'))
            HW_image_attr_dic['TopYPosPixels'] = myint(self.HW_ODF_get_attribute_value(HW_image_set_inst_dic, 'TopYPosPixels'))

            HW_image_attr_dic['ImageWidthPixelsTiling'] = myint(self.HW_ODF_get_attribute_value(HW_image_set_inst_dic, 'RightXPosPixelsIfTiling'))
            if HW_image_attr_dic['ImageWidthPixelsTiling'] == 0: HW_image_attr_dic['ImageWidthPixelsTiling'] = None

            HW_image_attr_dic['ImageHeightPixelsTiling'] = myint(self.HW_ODF_get_attribute_value(HW_image_set_inst_dic, 'BottomYPosPixelsIfTiling'))
            if HW_image_attr_dic['ImageHeightPixelsTiling'] == 0: HW_image_attr_dic['ImageHeightPixelsTiling'] = None

            if HW_image_index_in_set_int == None:
                # image index not provided in parameter of the function : set a default index
                HW_image_index_in_set_int = myint(self.HW_ODF_get_attribute_value(HW_image_set_inst_dic, 'DefaultImageIndexWithinSet'))
                # if the attribute ImageIndexWithinSet is not defined, set the index at 1 by default
                if HW_image_index_in_set_int == None: HW_image_index_in_set_int = 1

        elif HW_object_dic['_HW_uid'][:-6] == 'ImageSet':
            # ImageSet object provided
            HW_image_set_inst_dic = None
            HW_image_set_dic = HW_object_dic

            HW_image_attr_dic['Name'] = self.HW_ODF_get_attribute_value(HW_image_set_dic, 'Name')
            HW_image_attr_dic['LeftXPosPixels'] = None
            HW_image_attr_dic['TopYPosPixels'] = None
            HW_image_attr_dic['ImageWidthPixelsTiling'] = None
            HW_image_attr_dic['ImageHeightPixelsTiling'] = None

        else:
            return False

        # recover the data from the ImageSet
        HW_image_attr_dic['InstallationPackageID'] = myint(self.HW_ODF_get_attribute_value(HW_image_set_dic, 'InstallationPackageID', MANDATORY))

        if HW_image_attr_dic['ImageWidthPixelsTiling'] != None:
            HW_image_attr_dic['ImageWidthPixels'] = HW_image_attr_dic['ImageWidthPixelsTiling']
        else:
            HW_image_attr_dic['ImageWidthPixels'] = myint(self.HW_ODF_get_attribute_value(HW_image_set_dic, 'ImageWidthPixels'))

        if HW_image_attr_dic['ImageHeightPixelsTiling'] != None:
            HW_image_attr_dic['ImageHeightPixels'] = HW_image_attr_dic['ImageHeightPixelsTiling']
        else:
            HW_image_attr_dic['ImageHeightPixels'] = myint(self.HW_ODF_get_attribute_value(HW_image_set_dic, 'ImageHeightPixels'))

        # recover the bitmap file of the transparency image
        value = self.HW_ODF_get_attribute_value(HW_image_set_dic, 'TransparencyMaskBitmapFilename')
        if value != None:
            HW_image_attr_dic['TransparencyMaskBitmapFilename'] = self.convert_HW2GO_file_name(value, HW_image_attr_dic['InstallationPackageID'])
        else:
            HW_image_attr_dic['TransparencyMaskBitmapFilename'] = None

        # recover the bitmap file of the displayed image (from the ImageSetElement associated to the ImageSet and having the proper image index within set)
        HW_image_attr_dic['BitmapFilename'] = None
        for image_set_elem_dic in self.HW_ODF_get_linked_objects_dic_by_type(HW_image_set_dic, 'ImageSetElement', TO_CHILD):
            # parse the ImageSetElement objects which are children of the ImageSet object to find the one having the right image index
            image_index = myint(self.HW_ODF_get_attribute_value(image_set_elem_dic, 'ImageIndexWithinSet'))
            if image_index == None: image_index = 1  # if the attribute ImageIndexWithinSet is not defined, it is the index 1 by default
            if image_index == HW_image_index_in_set_int:
                # it is the expected ImageSetElement object
                value = self.HW_ODF_get_attribute_value(image_set_elem_dic, 'BitmapFilename')
                if value != None:
                    HW_image_attr_dic['BitmapFilename'] = self.convert_HW2GO_file_name(value, HW_image_attr_dic['InstallationPackageID'])
                else:
                    HW_image_attr_dic['BitmapFilename'] = None
                break

        HW_image_attr_dic['ClickableAreaLeftRelativeXPosPixels'] = myint(self.HW_ODF_get_attribute_value(HW_image_set_dic, 'ClickableAreaLeftRelativeXPosPixels'))
        HW_image_attr_dic['ClickableAreaRightRelativeXPosPixels'] = myint(self.HW_ODF_get_attribute_value(HW_image_set_dic, 'ClickableAreaRightRelativeXPosPixels'))
        HW_image_attr_dic['ClickableAreaTopRelativeYPosPixels'] = myint(self.HW_ODF_get_attribute_value(HW_image_set_dic, 'ClickableAreaTopRelativeYPosPixels'))
        HW_image_attr_dic['ClickableAreaBottomRelativeYPosPixels'] = myint(self.HW_ODF_get_attribute_value(HW_image_set_dic, 'ClickableAreaBottomRelativeYPosPixels'))

        # correct the clickable width if greater than the image width
        if (HW_image_attr_dic['ImageWidthPixels'] != None and HW_image_attr_dic['ClickableAreaRightRelativeXPosPixels'] != None and
            HW_image_attr_dic['ClickableAreaRightRelativeXPosPixels'] > HW_image_attr_dic['ImageWidthPixels'] - 1):
            HW_image_attr_dic['ClickableAreaRightRelativeXPosPixels'] = HW_image_attr_dic['ImageWidthPixels'] - 1
        # correct the clickable height if greater than the image height
        if (HW_image_attr_dic['ImageHeightPixels'] != None and HW_image_attr_dic['ClickableAreaBottomRelativeYPosPixels'] != None and
            HW_image_attr_dic['ClickableAreaBottomRelativeYPosPixels'] > HW_image_attr_dic['ImageHeightPixels'] - 1):
            HW_image_attr_dic['ClickableAreaBottomRelativeYPosPixels'] = HW_image_attr_dic['ImageHeightPixels'] - 1

        # set some default values if not defined
        if HW_image_attr_dic['LeftXPosPixels'] == None: HW_image_attr_dic['LeftXPosPixels'] = 0
        if HW_image_attr_dic['TopYPosPixels'] == None: HW_image_attr_dic['TopYPosPixels'] = 0

        return True

    #-------------------------------------------------------------------------------------------------
    def HW_ODF_get_text_attributes(self, HW_text_inst_dic, HW_text_attr_dic):
        # fill the given HW_text_attr_dic dictionary with the following HW attributes of the given TextInstance object dictionary (+ ImageSetInstance if any) and the related TextStyle
        # the not defined attributes are set at None
        #    Text (string)
        #    XPosPixels (integer)
        #    YPosPixels (integer)
        #    AttachedToAnImageSetInstance : Y or N (string)
        #    PosRelativeToTopLeftOfImage : Y or N (string)
        #    BoundingBoxWidthPixelsIfWordWrap (integer)
        #    BoundingBoxHeightPixelsIfWordWrap (integer)
        #    Face_WindowsName (string)
        #    Font_SizePixels (integer)
        #    Font_WeightCode : 1 = light, 2 = normal, 3 = bold (integer)
        #    Colour_Red (integer)
        #    Colour_Green (integer)
        #    Colour_Blue (integer)
        #    HorizontalAlignmentCode : 0 = center, 1 = left, 2 = right (integer)
        #    VerticalAlignmentCode   : 0 = center, 1 or not defined = top, 2 = bottom (integer)
        #    + the attributes returned by HW_ODF_get_image_attributes if an image is attached to this TextInstance object
        #    ImageSetInstanceDic : dictionary of the linked ImageSetInstance if any, else None

        if not HW_text_inst_dic['_HW_uid'][:-6] == 'TextInstance':
            return False

        HW_text_attr_dic['Text'] = self.HW_ODF_get_attribute_value(HW_text_inst_dic, 'Text', MANDATORY)
        HW_text_attr_dic['XPosPixels'] = myint(self.HW_ODF_get_attribute_value(HW_text_inst_dic, 'XPosPixels'))
        HW_text_attr_dic['YPosPixels'] = myint(self.HW_ODF_get_attribute_value(HW_text_inst_dic, 'YPosPixels'))
        HW_text_attr_dic['AttachedToAnImageSetInstance'] = self.HW_ODF_get_attribute_value(HW_text_inst_dic, 'AttachedToAnImageSetInstance')
        HW_text_attr_dic['PosRelativeToTopLeftOfImage'] = self.HW_ODF_get_attribute_value(HW_text_inst_dic, 'PosRelativeToTopLeftOfImageSetInstance')
        HW_text_attr_dic['BoundingBoxWidthPixelsIfWordWrap'] = myint(self.HW_ODF_get_attribute_value(HW_text_inst_dic, 'BoundingBoxWidthPixelsIfWordWrap'))
        HW_text_attr_dic['BoundingBoxHeightPixelsIfWordWrap'] = myint(self.HW_ODF_get_attribute_value(HW_text_inst_dic, 'BoundingBoxHeightPixelsIfWordWrap'))

        # recover the data from the associated TextStyle object
        HW_text_style_dic = self.HW_ODF_get_object_dic_by_ref_id('TextStyle', HW_text_inst_dic, 'TextStyleID')
        if HW_text_style_dic != None:
            HW_text_attr_dic['Face_WindowsName'] = self.HW_ODF_get_attribute_value(HW_text_style_dic, 'Face_WindowsName')
            HW_text_attr_dic['Font_SizePixels'] = myint(self.HW_ODF_get_attribute_value(HW_text_style_dic, 'Font_SizePixels'))

            HW_text_attr_dic['Font_WeightCode'] = myint(self.HW_ODF_get_attribute_value(HW_text_style_dic, 'Font_WeightCode'))

            HW_text_attr_dic['Colour_Red'] = myint(self.HW_ODF_get_attribute_value(HW_text_style_dic, 'Colour_Red'))
            HW_text_attr_dic['Colour_Green'] = myint(self.HW_ODF_get_attribute_value(HW_text_style_dic, 'Colour_Green'))
            HW_text_attr_dic['Colour_Blue'] = myint(self.HW_ODF_get_attribute_value(HW_text_style_dic, 'Colour_Blue'))

            HW_text_attr_dic['HorizontalAlignmentCode'] = myint(self.HW_ODF_get_attribute_value(HW_text_style_dic, 'HorizontalAlignmentCode'))
            HW_text_attr_dic['VerticalAlignmentCode'] = myint(self.HW_ODF_get_attribute_value(HW_text_style_dic, 'VerticalAlignmentCode'))
        else:
            HW_text_attr_dic['Face_WindowsName'] = None
            HW_text_attr_dic['Font_SizePixels'] = None
            HW_text_attr_dic['Font_WeightCode'] = None
            HW_text_attr_dic['Colour_Red'] = None
            HW_text_attr_dic['Colour_Green'] = None
            HW_text_attr_dic['Colour_Blue'] = None
            HW_text_attr_dic['HorizontalAlignmentCode'] = None
            HW_text_attr_dic['VerticalAlignmentCode'] = None

        # set some default values if not defined
        if HW_text_attr_dic['Face_WindowsName'] == None: HW_text_attr_dic['Face_WindowsName'] = 'Arial'
        if HW_text_attr_dic['Font_SizePixels'] == None: HW_text_attr_dic['Font_SizePixels'] = 10
        if HW_text_attr_dic['Font_WeightCode'] == None: HW_text_attr_dic['Font_WeightCode'] = 2
        if HW_text_attr_dic['HorizontalAlignmentCode'] == None: HW_text_attr_dic['HorizontalAlignmentCode'] = 0
        if HW_text_attr_dic['VerticalAlignmentCode'] == None: HW_text_attr_dic['VerticalAlignmentCode'] = 1
        if HW_text_attr_dic['XPosPixels'] == None: HW_text_attr_dic['XPosPixels'] = 0
        if HW_text_attr_dic['YPosPixels'] == None: HW_text_attr_dic['YPosPixels'] = 0

        # add in the HW_text_attr_dic the attributes of the associated ImageSetInstance object if one is defined
        HW_image_set_inst_dic = self.HW_ODF_get_object_dic_by_ref_id('ImageSetInstance', HW_text_inst_dic, 'AttachedToImageSetInstanceID')
        HW_text_attr_dic['ImageSetInstanceDic'] = HW_image_set_inst_dic
        if HW_image_set_inst_dic != None:
            self.HW_ODF_get_image_attributes(HW_image_set_inst_dic, HW_text_attr_dic)

        return True

    #-------------------------------------------------------------------------------------------------
    def HW_ODF_get_linked_switches_list(self, HW_object_dic, building_data_dic, linking_direction):
        # recursive function to make the list of all the HW Switch objects directly linked as parent or child to the given HW object (Stop, KeyAction or Switch)
        # the parameter building_data_dic must be an empty dictionary for the first call
        # returned values are present in this dictionary :
        #  'HW_switches_list'  : list of the HW Switch objects linked together in the given direction TO_PARENT or TO_CHILD from the given HW object
        #  'default_to_engage' : True if one of the linked HW switches has this field at 'Y', else False
        #  'inverting'         : True if one of the SwitchLinkage linking two HW switches together makes a switch state invertion, else False

        # used HW objects :
        #   Switch C> SwitchLinkage (EngageLinkActionCode=1 or undefined, DisengageLinkActionCode=2 or undefined) C> Switch
        #   SwitchLinkage other attributes :
        #     ConditionSwitchID            : if defined and condition switch is at OFF state, the destination switch is forced at OFF state
        #                                                                          ON  state, the source switch state is forwarded to the destination switch
        #     SourceSwitchLinkIfEngaged    : default 'Y', if ='N' the inverted source switch state is applied to the destination switch
        #     ConditionSwitchLinkIfEngaged : default 'Y', if ='N' the inverted conditional switch state is used for the source to destination state forwarding
        #     ReevaluateIfCondSwitchChangesState : default 'Y', if 'N' destination switch state is evaluated only if source switch state changes

        if HW_object_dic == None:
            return

        if len(building_data_dic) == 0:
            # first call of this recursive function, initialize data
            building_data_dic['HW_switches_list'] = []
            building_data_dic['default_to_engage'] = False
            building_data_dic['clickable'] = False
            building_data_dic['inverting'] = False

        HW_object_type = HW_object_dic['_HW_uid'][:-6]
        if HW_object_type == 'Switch':
            if HW_object_dic not in building_data_dic['HW_switches_list']:
                # the given HW object is a Switch and has not been already checked
                building_data_dic['HW_switches_list'].append(HW_object_dic)

                # memorize if the given HW switch is engaged by default
                if self.HW_ODF_get_attribute_value(HW_object_dic, 'DefaultToEngaged') == 'Y':
                    building_data_dic['default_to_engage'] = True

                # memorize if the given HW switch is clickable
                if self.HW_ODF_get_attribute_value(HW_object_dic, 'Clickable') == 'Y':
                    building_data_dic['clickable'] = True

                # check the HW Switch objects controlled by the given HW Switch
                for HW_switch_linkage_dic in self.HW_ODF_get_linked_objects_dic_by_type(HW_object_dic, 'SwitchLinkage', linking_direction):
                    # parse the children HW SwitchLinkage objects of the HW Switch
                    HW_engage_action_code = myint(self.HW_ODF_get_attribute_value(HW_switch_linkage_dic, 'EngageLinkActionCode'))
                    HW_disengage_action_code = myint(self.HW_ODF_get_attribute_value(HW_switch_linkage_dic, 'DisengageLinkActionCode'))
                    HW_source_switch_dic = self.HW_ODF_get_object_dic_by_ref_id('Switch', HW_switch_linkage_dic, 'SourceSwitchID')
                    HW_dest_switch_dic = self.HW_ODF_get_object_dic_by_ref_id('Switch', HW_switch_linkage_dic, 'DestSwitchID')
                    HW_cond_switch_dic = self.HW_ODF_get_object_dic_by_ref_id('Switch', HW_switch_linkage_dic, 'ConditionSwitchID')
                    if (((linking_direction == TO_PARENT and HW_object_dic == HW_dest_switch_dic) or
                         (linking_direction == TO_CHILD  and HW_object_dic == HW_source_switch_dic)) and
                        (HW_engage_action_code == None or HW_engage_action_code == 1) and
                        (HW_disengage_action_code == None or HW_disengage_action_code == 2) and
                        HW_cond_switch_dic == None):
                        # the HW Switch is the source/destination of the linkage (without a condition) and it has standard action codes

                        if self.HW_ODF_get_attribute_value(HW_switch_linkage_dic, 'SourceSwitchLinkIfEngaged') == 'N':
                            # the current SwitchLinkage object is a switch state inverting linkage
                            building_data_dic['inverting'] = True

                        if linking_direction == TO_PARENT:
                            self.HW_ODF_get_linked_switches_list(HW_source_switch_dic, building_data_dic, linking_direction)
                        else:
                            self.HW_ODF_get_linked_switches_list(HW_dest_switch_dic, building_data_dic, linking_direction)

        elif HW_object_type == 'Stop':
            # the given HW object is a Stop, recover its controlling parent switch, then recall this function with the parent switch as parameter
            if linking_direction == TO_PARENT:
                HW_cntrl_switch_dic = self.HW_ODF_get_object_dic_by_ref_id('Switch', HW_object_dic, 'ControllingSwitchID')
                self.HW_ODF_get_linked_switches_list(HW_cntrl_switch_dic, building_data_dic, linking_direction)
        elif HW_object_type == 'KeyAction':
            # the given HW object is a KeyAction, recover its controlling parent switch, then recall this function with the parent switch as parameter
            if linking_direction == TO_PARENT:
                HW_cntrl_switch_dic = self.HW_ODF_get_object_dic_by_ref_id('Switch', HW_object_dic, 'ConditionSwitchID')
                self.HW_ODF_get_linked_switches_list(HW_cntrl_switch_dic, building_data_dic, linking_direction)

    #-------------------------------------------------------------------------------------------------
    def HW_ODF_get_controlling_continuous_control(self,HW_cont_ctrl_dic):
        # returns the HW ContinuousControl object which has a graphical interface to control the given HW ContinuousControl (it can be the one given)
        # returns None if there is no such object

        HW_img_set_inst_dic = self.HW_ODF_get_object_dic_by_ref_id('ImageSetInstance', HW_cont_ctrl_dic, 'ImageSetInstanceID')
        while HW_img_set_inst_dic == None and HW_cont_ctrl_dic != None:
            # the given HW ContinuousControl has no graphical interface
            # search in its parents one having a graphical interface
            HW_cont_ctrl_link_dic = self.HW_ODF_get_linked_objects_dic_by_type(HW_cont_ctrl_dic, 'ContinuousControlLinkage', TO_PARENT, FIRST_ONE)
            HW_cont_ctrl_dic = self.HW_ODF_get_linked_objects_dic_by_type(HW_cont_ctrl_link_dic, 'ContinuousControl', TO_PARENT, FIRST_ONE)
            HW_img_set_inst_dic = self.HW_ODF_get_object_dic_by_ref_id('ImageSetInstance', HW_cont_ctrl_dic, 'ImageSetInstanceID')

        if HW_img_set_inst_dic == None and HW_cont_ctrl_dic == None:
            return None
        else:
            return HW_cont_ctrl_dic

    #-------------------------------------------------------------------------------------------------
    def HW_ODF_save2organfile(self, file_name):
        # save the Hauptwerk ODF objects dictionary into the given .organ ODF file in a GrandOrgue like format (for development/debug purpose)

        with open(file_name, 'w', encoding=ENCODING_UTF8_BOM) as f:
            f.write(';Hauptwerk ODF XML formatted in a GrandOrgue ODF manner\n')
            f.write('\n')
            for object_type_dic in self.HW_odf_dic.values():
                for HW_object_dic in object_type_dic.values():
                    f.write(f'[{HW_object_dic["_HW_uid"]}]\n')
                    for obj_attr_name_str, obj_attr_value in HW_object_dic.items():
                        if obj_attr_name_str in ('_parents', '_children'):
                            # this attribute contains a list of objects dictionaries
                            obj_attr_value_str = ''
                            for HW_object_dic2 in obj_attr_value:
                                obj_attr_value_str += HW_object_dic2['_HW_uid'] + '  '
                        else:
                            obj_attr_value_str = str(obj_attr_value)
                        f.write(f'{obj_attr_name_str}={obj_attr_value_str}\n')
                    f.write('\n')

    #-------------------------------------------------------------------------------------------------
    def GO_ODF_save2organfile(self, file_name):
        # save the GrandOrgue ODF objects dictionary into the given .organ ODF file
        # return True or False whether the saving has succeeded or not

        # check the extension of the given file name
        filename_str, file_extension_str = os.path.splitext(file_name)
        if file_extension_str != '.organ':
            logs.add(f'The file "{file_name}" does not have the expected extension .organ')
            return False

        with open(file_name, 'w', encoding=ENCODING_UTF8_BOM) as f:
            f.write('; ' + ORGAN_COMMENT + '\n')
            f.write('\n')
            for obj_uid, obj_attr_dic in self.GO_odf_dic.items():
                f.write(f'[{obj_uid}]\n')
                for obj_attr_name_str, obj_attr_value_str in obj_attr_dic.items():
                    if obj_attr_name_str[0] != '_': # it is not a temporary attribute created for HW to GO conversion
                        f.write(f'{obj_attr_name_str}={obj_attr_value_str}\n')
                f.write('\n')

        return True

    #-------------------------------------------------------------------------------------------------
    def GO_ODF_build_from_HW_ODF(self, HW_odf_file_name, GO_odf_file_name, progress_status_update_fct, build_unused_ranks_bool):
        # build and save a GrandOrgue ODF from the given Hauptwerk ODF and its associated sample set (which is not touched)
        # use the given function callback to display a progression status in the GUI
        # return False if an issue has occured, else return True

        print(build_unused_ranks_bool)

        self.progress_status_show_function = progress_status_update_fct

        # load the HW ODF in the HW ODF dictionary
        progress_status_update_fct('Loading the Hauptwerk ODF...')
        if self.HW_ODF_load_from_file(HW_odf_file_name):

            # link the HW objects together
            progress_status_update_fct('Building the Hauptwerk ODF objects tree...')
            self.HW_ODF_do_links_between_objects()

            # clear the content of the GO ODF dictionary
            self.GO_odf_dic.clear()

            # reset the content of the GO object types numbers dictionary
            self.GO_objects_type_nb_dic.clear()
            self.GO_objects_type_nb_dic['Stop'] = 0
            self.GO_objects_type_nb_dic['Coupler'] = 0
            self.silent_loop_file_used = False

            # build the various GO objects in the GO ODF dictionary from the HW ODF
            # the order of calling the below functions is important, there are dependencies between some of them

            progress_status_update_fct('Building the GrandOrgue Organ object...')
            if self.GO_ODF_build_Organ_object() == None:
                logs.add('ERROR : issue occured while building the GO Organ object')
                return False

            HW_sorted_display_pages_id_list = sorted(self.HW_odf_dic['DisplayPage'].keys())
            HW_sorted_divisions_id_list = sorted(self.HW_odf_dic['Division'].keys())

            # build the GO Panel objects by sorted HW DisplayPage ID order
            progress_status_update_fct('Building the GrandOrgue Panels...')
            for HW_disp_page_id in HW_sorted_display_pages_id_list:
                HW_disp_page_dic = self.HW_ODF_get_object_dic('DisplayPage', HW_disp_page_id)
                self.GO_ODF_build_Panel_object(HW_disp_page_dic)

            # build the GO Manual objects by sorted HW Division ID order
            progress_status_update_fct('Building the GrandOrgue Manuals...')
            HW_last_division_id = 0
            for HW_division_id in HW_sorted_divisions_id_list:
                HW_last_division_id = HW_division_id
                HW_division_dic = self.HW_odf_dic['Division'][HW_division_id]
                self.GO_ODF_build_Manual_object(HW_division_dic)

            # build the GO Coupler objects by sorted HW Division ID -> Keyboard -> KeyAction
            for HW_division_id in HW_sorted_divisions_id_list:
                HW_division_dic = self.HW_odf_dic['Division'][HW_division_id]
                for HW_keyboard_dic in self.HW_ODF_get_linked_objects_dic_by_type(HW_division_dic, 'Keyboard', TO_CHILD, sorted_id_list=True):
                    # parse the HW Keyboard objects belonging to the current HW Division
                    for HW_key_action_dic in self.HW_ODF_get_linked_objects_dic_by_type(HW_keyboard_dic, 'KeyAction', TO_CHILD, sorted_id_list=True):
                        # parse the HW KeyAction objects belonging to the current HW Keyboard
                        if self.HW_ODF_get_object_dic_by_ref_id('Switch', HW_key_action_dic, 'ConditionSwitchID') != None:
                            # the current KeyAction is controlled by a switch, it is a normally a keyboards coupler
                            progress_status_update_fct(f'Building the GrandOrgue Coupler "{HW_key_action_dic["Name"]}"...')
                            self.GO_ODF_build_Drawstop_objects(HW_key_action_dic, HW_division_dic)

            # build the GO Stop objects by sorted HW Division ID order
            for HW_division_id in HW_sorted_divisions_id_list:
                HW_division_dic = self.HW_odf_dic['Division'][HW_division_id]
                for HW_stop_dic in self.HW_ODF_get_linked_objects_dic_by_type(HW_division_dic, 'Stop', TO_CHILD, sorted_id_list=True):
                    # parse the HW Stop objects belonging to the current HW Division
                    progress_status_update_fct(f'Building the GrandOrgue Stop "{HW_stop_dic["Name"]}"...')
                    self.GO_ODF_build_Drawstop_objects(HW_stop_dic, HW_division_dic)

            # build the GO Stop objects not built before, parsing the HW switches of the display pages which have not be converted to GO object
            progress_status_update_fct('Building other GrandOrgue objects...')
            HW_division_dic = self.HW_odf_dic['Division'][HW_last_division_id] # by default the other drawstops are assigned to the last division
            for HW_disp_page_id in HW_sorted_display_pages_id_list:
                HW_disp_page_dic = self.HW_ODF_get_object_dic('DisplayPage', HW_disp_page_id)
                for HW_switch_dic in self.HW_ODF_get_linked_objects_dic_by_type(HW_disp_page_dic, 'Switch', TO_CHILD):
                    # parse the HW Switch objects displayed in the current HW DisplayPage
                    if HW_switch_dic['_GO_uid'] == '':
                        # the HW Switch is not already assigned to a GO object, try if a GO Stop can be built based on what it controls
                        self.GO_ODF_build_Drawstop_objects(HW_switch_dic, HW_division_dic)

            if build_unused_ranks_bool:
                # build the GO Ranks objects corresponding to HW Ranks of pipes not converted in GO Ranks previously
                for HW_rank_dic in self.HW_odf_dic['Rank'].values():
                    if HW_rank_dic['_GO_uid'] == '':
                        # HW Rank not converted in a GO Rank
                        progress_status_update_fct(f'Building unused GrandOrgue Rank "{HW_rank_dic["Name"]}"...')
                        self.GO_ODF_build_Rank_object(HW_rank_dic, 0, True)

            progress_status_update_fct('Completing the building operation...')

            if self.silent_loop_file_used:
                # the file SilentLoop.wav is referenced by the GO ODF for a GO drawstop noise
                # copy it in the root folder of the HW sample set
                if not(os.path.exists(self.HW_sample_set_path + os.sep + 'SilentLoop.wav')):
                    # the file is not already copied in the HW sample set root folder, copy it
                    shutil.copy(os.path.dirname(__file__) + os.sep + 'resources' + os.sep + 'SilentLoop.wav', self.HW_sample_set_path)
            else:
                # the file SilentLoop.wav is referenced by the GO ODF
                # remove it in the root folder of the HW sample set if it was placed here by a previous version of OdfEdit
                if os.path.exists(self.HW_sample_set_path + os.sep + 'SilentLoop.wav'):
                    # the file is present in the HW sample set root folder, delete it
                    os.remove(self.HW_sample_set_path + os.sep + 'SilentLoop.wav')

            # save the HW ODF data in a GO ODF format (for development/debug purpose, more easy to read than a xml file)
##            if DEV_MODE:
##                self.HW_ODF_save2organfile(HW_odf_file_name + '.organ')

            # save the built GO ODF data in a .organ file
            if self.GO_ODF_save2organfile(GO_odf_file_name):
                logs.add(f'\nGrandOrgue ODF built and saved in "{GO_odf_file_name}"')

        progress_status_update_fct('')
        return True

    #-------------------------------------------------------------------------------------------------
    def GO_ODF_build_Organ_object(self):
        # build the GO Organ object from the HW ODF
        # return None if an issue has occured, else return the UID of the created GO Organ

        # used HW objects :
        #   _General, RequiredInstallationPackage

        # get the dictionary of the HW _General object
        HW_general_dic = self.HW_ODF_get_object_dic('_General')
        if HW_general_dic == None:
            logs.add('ERROR : missing _General object in the Hauptwerk ODF dictionary')
            return None

        # check if the folders of the required installation packages are present in the folder OrganInstallationPackages
        self.available_HW_packages_id_list = []
        for HW_install_pack_dic in self.HW_odf_dic['RequiredInstallationPackage'].values():
            # parse and check the defined HW RequiredInstallationPackage objects
            HW_package_id = myint(self.HW_ODF_get_attribute_value(HW_install_pack_dic, 'InstallationPackageID', MANDATORY))
            if HW_package_id == None:
                return None

            HW_package_name = self.HW_ODF_get_attribute_value(HW_install_pack_dic, 'Name', MANDATORY)
            HW_package_supplier = self.HW_ODF_get_attribute_value(HW_install_pack_dic, 'SupplierName', MANDATORY)
            if HW_package_name == None or HW_package_supplier == None:
                return None

            folder_name = os.path.join(self.HW_sample_set_path, 'OrganInstallationPackages', str(HW_package_id).zfill(6))
            if not os.path.isdir(folder_name):
                # the folder doesn't exist in the sample set package
                logs.add(f'WARNING : The package ID {HW_package_id} named "{HW_package_name}" provided by "{HW_package_supplier}"')
                logs.add(f'WARNING : is not present in the folder {path2ospath(folder_name)}')
                logs.add( 'WARNING : Some graphical or sound elements of this organ may be not rendered in GrandOrgue')
            else:
                self.available_HW_packages_id_list.append(HW_package_id)

        # recover the main installation package ID
        HW_install_package_id = myint(self.HW_ODF_get_attribute_value(HW_general_dic, 'OrganInfo_InstallationPackageID', MANDATORY))
        if HW_install_package_id == None:
            return None

        # add an entry in the GO ODF dictionary for the Organ object
        GO_organ_uid = 'Organ'
        GO_organ_dic = self.GO_odf_dic[GO_organ_uid] = {}

        GO_organ_dic['ChurchName'] = mystr(self.HW_ODF_get_attribute_value(HW_general_dic, 'Identification_Name'))
        GO_organ_dic['ChurchAddress'] = mystr(self.HW_ODF_get_attribute_value(HW_general_dic, 'OrganInfo_Location'))
        GO_organ_dic['OrganBuilder'] = mystr(self.HW_ODF_get_attribute_value(HW_general_dic, 'OrganInfo_Builder'))
        GO_organ_dic['OrganBuildDate'] = mystr(self.HW_ODF_get_attribute_value(HW_general_dic, 'OrganInfo_BuildDate'))
        #GO_organ_dic['OrganComments'] = mystr(self.HW_ODF_get_attribute_value(HW_general_dic, 'OrganInfo_Comments'))
        GO_organ_dic['OrganComments'] = ORGAN_COMMENT
        GO_organ_dic['RecordingDetails'] = mystr(self.HW_ODF_get_attribute_value(HW_general_dic, 'Control_OrganDefinitionSupplierName', MANDATORY))

        GO_organ_dic['HasPedals'] = 'N'
        GO_organ_dic['NumberOfManuals'] = 0
        GO_organ_dic['NumberOfPanels'] = 0
        GO_organ_dic['NumberOfWindchestGroups'] = 0
        GO_organ_dic['NumberOfRanks'] = 0
        GO_organ_dic['NumberOfSwitches'] = 0
        GO_organ_dic['NumberOfEnclosures'] = 0
        GO_organ_dic['NumberOfTremulants'] = 0
        GO_organ_dic['NumberOfGenerals'] = 0
        GO_organ_dic['NumberOfDivisionalCouplers'] = 0
        GO_organ_dic['NumberOfReversiblePistons'] = 0

        GO_organ_dic['GeneralsStoreDivisionalCouplers'] = 'Y'
        GO_organ_dic['DivisionalsStoreTremulants'] = 'Y'
        GO_organ_dic['DivisionalsStoreIntermanualCouplers'] = 'Y'
        GO_organ_dic['DivisionalsStoreIntramanualCouplers'] = 'Y'
        GO_organ_dic['CombinationsStoreNonDisplayedDrawstops'] = 'N'

        GO_organ_dic['Gain'] = str(float(self.HW_ODF_get_attribute_value(HW_general_dic, 'AudioOut_AmplitudeLevelAdjustDecibels')))

        GO_organ_dic['PitchTuning'] = 0

        # recover the ID of the HW default display page (will be used in other GO_ODF_build_xxx functions)
        self.HW_default_display_page_id = myint(self.HW_ODF_get_attribute_value(HW_general_dic, 'SpecialObjects_DefaultDisplayPageID', MANDATORY))
        if self.HW_default_display_page_id == None:
            return None

        # add in the HW _General object the ID of the corresponding GO object
        HW_general_dic['_GO_uid'] = 'Organ'

        return GO_organ_uid

    #-------------------------------------------------------------------------------------------------
    def GO_ODF_build_Panel_object(self, HW_disp_page_dic):
        # build a GO Panel999 corresponding to the given HW DisplayPage
        # build also the image and label objects which are defined in this panel
        # return the UID of the created GO Panel object

        # used HW objects :
        #   _General
        #   DisplayPage
        #   DisplayPage C> Keyboard
        #   DisplayPage C> ImageSetInstance C> ImageSet C> ImageSetElement (in function GO_ODF_build_Image_object)
        #   DisplayPage C> TextInstance C> TextStyle                       (in function GO_ODF_build_Label_object)
        #   DisplayPage C> TextInstance C> ImageSetInstance C> ImageSet C> ImageSetElement  (idem as above line)

        # get the ID of the HW DisplayPage object
        HW_page_id = myint(self.HW_ODF_get_attribute_value(HW_disp_page_dic, 'PageID', MANDATORY))

        if self.HW_ODF_get_linked_objects_dic_by_type(HW_disp_page_dic, 'Keyboard', TO_CHILD, FIRST_ONE) != None:
            # the current HW DisplayPage object contains at least one Keyboard object in his children, so it is the HW console page
            self.HW_console_display_page_id = HW_page_id

        if HW_page_id == self.HW_default_display_page_id:
            # this is the HW default display page, so assigned to the GO Panel000
            GO_panel_uid = 'Panel000'
        else:
            self.GO_odf_dic['Organ']['NumberOfPanels'] += 1  # Panel000 is not counted
            GO_panel_uid = 'Panel' + str(self.GO_odf_dic['Organ']['NumberOfPanels']).zfill(3)
        # add an GO Panel 999 in the GO ODF dictionary
        GO_panel_dic = self.GO_odf_dic[GO_panel_uid] = {}

        GO_panel_dic['_GO_uid'] = GO_panel_uid
        GO_panel_dic['Name'] = self.HW_ODF_get_attribute_value(HW_disp_page_dic, 'Name')
        GO_panel_dic['HasPedals'] = 'N'
        GO_panel_dic['NumberOfGUIElements'] = 0
        GO_panel_dic['NumberOfImages'] = 0

        if HW_page_id == self.HW_console_display_page_id:
            # the current HW DisplayPage object is the HW console page, get the dimensions of the console page defined in the HW _General object
            HW_general_dic = self.HW_ODF_get_object_dic('_General')
            GO_panel_dic['DispScreenSizeHoriz'] = myint(self.HW_ODF_get_attribute_value(HW_general_dic, 'Display_ConsoleScreenWidthPixels'))
            GO_panel_dic['DispScreenSizeVert'] = myint(self.HW_ODF_get_attribute_value(HW_general_dic, 'Display_ConsoleScreenHeightPixels'))
            GO_panel_dic['HasPedals'] = self.GO_odf_dic['Organ']['HasPedals']  # value set before in GO_ODF_build_Manual_objects
        else:
            GO_panel_dic['DispScreenSizeHoriz'] = None  # will be set later while creating GO Panel999Image999 objects
            GO_panel_dic['DispScreenSizeVert'] = None   # will be set later while creating GO Panel999Image999 objects
            GO_panel_dic['HasPedals'] = 'N'

        # set the other mandatory attributes of a GO panel at a default value, no import from Hauptwerk ODF for the GO built-in console drawing
        GO_panel_dic['DispDrawstopBackgroundImageNum'] = '1'
        GO_panel_dic['DispDrawstopInsetBackgroundImageNum'] = '1'
        GO_panel_dic['DispConsoleBackgroundImageNum'] = '1'
        GO_panel_dic['DispKeyHorizBackgroundImageNum'] = '1'
        GO_panel_dic['DispKeyVertBackgroundImageNum'] = '1'
        GO_panel_dic['DispControlLabelFont'] = 'Arial'
        GO_panel_dic['DispShortcutKeyLabelFont'] = 'Arial'
        GO_panel_dic['DispShortcutKeyLabelColour'] = 'Black'
        GO_panel_dic['DispGroupLabelFont'] = 'Arial'
        GO_panel_dic['DispDrawstopCols'] = '2'
        GO_panel_dic['DispDrawstopRows'] = '1'
        GO_panel_dic['DispDrawstopColsOffset'] = 'N'
        GO_panel_dic['DispPairDrawstopCols'] = 'N'
        GO_panel_dic['DispExtraDrawstopRows'] = '0'
        GO_panel_dic['DispExtraDrawstopCols'] = '0'
        GO_panel_dic['DispButtonCols'] = '1'
        GO_panel_dic['DispExtraButtonRows'] = '0'
        GO_panel_dic['DispExtraPedalButtonRow'] = 'N'
        GO_panel_dic['DispButtonsAboveManuals'] = 'N'
        GO_panel_dic['DispExtraDrawstopRowsAboveExtraButtonRows'] = 'N'
        GO_panel_dic['DispTrimAboveManuals'] = 'N'
        GO_panel_dic['DispTrimBelowManuals'] = 'N'
        GO_panel_dic['DispTrimAboveExtraRows'] = 'N'

        # add in the HW DisplayPage object the ID of the corresponding GO object
        HW_disp_page_dic['_GO_uid'] = GO_panel_uid

        # build the GO static images of the panel by order of layer number
        HW_images_list_per_layer_dict = {}
        for HW_img_set_inst_dic in self.HW_ODF_get_linked_objects_dic_by_type(HW_disp_page_dic, 'ImageSetInstance', TO_CHILD):
            # parse the HW ImageSetInstance objects of the given HW DisplayPage
            # to store in a local dictionary the static images of the given HW DisplayPage grouped by layer number
            if len(HW_img_set_inst_dic['_parents']) == 1:
                # the current HW ImageSetInstance object has a single parent (a DisplayPage) : it is a static image
                HW_layer_nb_int = myint(self.HW_ODF_get_attribute_value(HW_img_set_inst_dic, 'ScreenLayerNumber'))
                if HW_layer_nb_int == None:
                    # there is no layer defined, set by default the layer 1
                    HW_layer_nb_int = 1
                if HW_layer_nb_int not in HW_images_list_per_layer_dict.keys():
                    # there is not yet an entry in the dictionary for the layer number of the current HW ImageSetInstance
                    # add one entry initialized with an empty list
                    HW_images_list_per_layer_dict[HW_layer_nb_int] = []
                # add the current HW ImageSetInstance to the list of the layer numbers
                HW_images_list_per_layer_dict[HW_layer_nb_int].append(HW_img_set_inst_dic)
        for HW_layer_nb_int in sorted(HW_images_list_per_layer_dict.keys()):
            # parse the HW display layers by ascending order
            for HW_img_set_inst_dic in HW_images_list_per_layer_dict[HW_layer_nb_int]:
                # parse the HW ImageSetInstance objects of the current display layer
                self.GO_ODF_build_Image_object(HW_img_set_inst_dic, GO_panel_dic)

        # build the GO labels of the panel
        for HW_text_inst_dic in self.HW_ODF_get_linked_objects_dic_by_type(HW_disp_page_dic, 'TextInstance', TO_CHILD):
            # parse the HW TextInstance objects of the given display page
            self.GO_ODF_build_Label_object(HW_text_inst_dic, GO_panel_dic)

        return GO_panel_uid

    #-------------------------------------------------------------------------------------------------
    def GO_ODF_build_Image_object(self, HW_img_set_inst_dic, GO_panel_dic):
        # build a GO Panel999Image999 object corresponding to the given HW ImageSetInstance and in the given GO Panel
        # return the UID of the created GO PanelImage object or None if no panel image created
        # sub-function of GO_ODF_build_Panel_object

        # used HW objects :
        #   ImageSetInstance C> ImageSet C> ImageSetElement

        image_attr_dic = {}
        if self.HW_ODF_get_image_attributes(HW_img_set_inst_dic, image_attr_dic) and image_attr_dic['BitmapFilename'] != None:
            # the data about the current HW ImageSetInstance object have been recovered successfully and an image file name is defined

            if image_attr_dic['ImageWidthPixels'] == None or image_attr_dic['ImageHeightPixels'] == None:
                # if one dimension of the image is not defined, get the dimensions of the image in the bitmap file
                image_filename = os.path.dirname(self.HW_odf_file_name) + os.sep + path2ospath(image_attr_dic['BitmapFilename'])
                if os.path.isfile(image_filename):
                    im = Image.open(image_filename)
                    image_attr_dic['ImageWidthPixels'] = im.size[0]
                    image_attr_dic['ImageHeightPixels'] = im.size[1]
                else:
                    image_attr_dic['ImageWidthPixels'] = None
                    image_attr_dic['ImageHeightPixels'] = None

            # define an additional GO Panel999Image999 object for the given GO Panel
            GO_panel_uid = GO_panel_dic['_GO_uid']
            self.GO_odf_dic[GO_panel_uid]['NumberOfImages'] += 1
            GO_panel_image_uid = GO_panel_uid + 'Image' + str(self.GO_odf_dic[GO_panel_uid]['NumberOfImages']).zfill(3)
            GO_panel_image_dic = self.GO_odf_dic[GO_panel_image_uid] = {}

            image_max_x_int = image_max_y_int = 0
            GO_panel_image_dic['PositionX'] = image_attr_dic['LeftXPosPixels']
            GO_panel_image_dic['PositionY'] = image_attr_dic['TopYPosPixels']
            if image_attr_dic['ImageWidthPixels'] != None:
                GO_panel_image_dic['Width'] = image_attr_dic['ImageWidthPixels']
                image_max_x_int = image_attr_dic['LeftXPosPixels'] + image_attr_dic['ImageWidthPixels']
            if image_attr_dic['ImageHeightPixels'] != None:
                GO_panel_image_dic['Height'] = image_attr_dic['ImageHeightPixels']
                image_max_y_int = image_attr_dic['TopYPosPixels'] + image_attr_dic['ImageHeightPixels']

            GO_panel_image_dic['Image'] = image_attr_dic['BitmapFilename']
            if image_attr_dic['TransparencyMaskBitmapFilename'] != None:
                GO_panel_image_dic['Mask'] = image_attr_dic['TransparencyMaskBitmapFilename']


            # increase if necessary the GO panel dimensions to display entirely the added image
            if GO_panel_dic['DispScreenSizeHoriz'] == None or image_max_x_int > GO_panel_dic['DispScreenSizeHoriz']:
                GO_panel_dic['DispScreenSizeHoriz'] = image_max_x_int
            if GO_panel_dic['DispScreenSizeVert'] == None or image_max_y_int > GO_panel_dic['DispScreenSizeVert']:
                GO_panel_dic['DispScreenSizeVert'] = image_max_y_int

            # add in the HW ImageSetInstance object the ID of the corresponding GO object
            HW_img_set_inst_dic['_GO_uid'] = GO_panel_image_uid

            return GO_panel_image_uid
        else:
            return None

    #-------------------------------------------------------------------------------------------------
    def GO_ODF_build_Label_object(self, HW_text_inst_dic, GO_panel_dic):
        # build a GO Panel999Element999 object with type=Label corresponding to the given HW TextInstance and in the given GO Panel
        # return the UID of the created GO Panel Element object, or None if no panel element created
        # sub-function of GO_ODF_build_Panel_object

        # used HW objects :
            #   TextInstance C> TextStyle
            #   TextInstance C> ImageSetInstance C> ImageSet C> ImageSetElement

        text_attr_dic = {}
        if self.HW_ODF_get_text_attributes(HW_text_inst_dic, text_attr_dic):
            # the data about the current HW TextInstance object (and his linked HW ImageSetInstance object if any) have been recovered successfully

            # define an additional GO Panel999Element999 object with label type in the given GO panel
            GO_panel_uid = GO_panel_dic['_GO_uid']
            self.GO_odf_dic[GO_panel_uid]['NumberOfGUIElements'] += 1
            GO_panel_element_uid = GO_panel_uid + 'Element' + str(self.GO_odf_dic[GO_panel_uid]['NumberOfGUIElements']).zfill(3)
            GO_panel_element_dic = self.GO_odf_dic[GO_panel_element_uid] = {}

            GO_panel_element_dic['Type'] = 'Label'
            GO_panel_element_dic['Name'] = text_attr_dic['Text']

            # recover the display dimensions of the label text according to the font name/size/weight
            text_font = tkf.Font(family=text_attr_dic['Face_WindowsName'], size=-1 * text_attr_dic['Font_SizePixels'],
                                 weight='bold' if text_attr_dic['Font_WeightCode'] == 3 else 'normal')
            text_width = text_font.measure(text_attr_dic['Text'])
            text_height = text_font.metrics('ascent') + text_font.metrics('descent')

            if text_attr_dic['Font_SizePixels'] != None:
                GO_panel_element_dic['DispLabelFontSize'] = text_attr_dic['Font_SizePixels']
            else:
                GO_panel_element_dic['DispLabelFontSize'] = 10

            if text_attr_dic['Face_WindowsName'] != None:
                GO_panel_element_dic['DispLabelFontName'] = text_attr_dic['Face_WindowsName']

            if text_attr_dic['Colour_Red'] != None and text_attr_dic['Colour_Green'] != None and text_attr_dic['Colour_Blue'] != None:
                GO_panel_element_dic['DispLabelColour'] = '#%02x%02x%02x' % (text_attr_dic['Colour_Red'],
                                                                             text_attr_dic['Colour_Green'],
                                                                             text_attr_dic['Colour_Blue'])

            if (not 'BitmapFilename' in text_attr_dic.keys()) or text_attr_dic['BitmapFilename'] == None:
                # text without bitmap or with bitmap undefined, use the default GO label background image (80x25)
                # the GO X,Y positions are the top left corner of the label background image or the bitmap

                # compute the coordinates of the center of the text according to the alignment of the text
                if text_attr_dic['HorizontalAlignmentCode'] == 0: # centered
                    xpos = text_attr_dic['XPosPixels']
                elif text_attr_dic['HorizontalAlignmentCode'] == 2: # right aligned
                    xpos = text_attr_dic['XPosPixels'] - int(text_width / 2)
                else:  # left aligned
                    xpos = text_attr_dic['XPosPixels'] + int(text_width / 2)

                if text_attr_dic['VerticalAlignmentCode'] == 0: # centered
                    ypos = text_attr_dic['YPosPixels']
                elif text_attr_dic['VerticalAlignmentCode'] == 2: # bottom aligned
                    ypos = text_attr_dic['YPosPixels'] - int(text_height / 2)
                else:  # top aligned
                    ypos = text_attr_dic['YPosPixels'] + int(text_height / 2)

                GO_panel_element_dic['DispImageNum'] = 3
                if xpos >= 40:
                    GO_panel_element_dic['DispXpos'] = xpos - 40  # 40 is the half width of the label image
                else:
                    GO_panel_element_dic['DispXpos'] = 0

                if ypos >= 13:
                    GO_panel_element_dic['DispYpos'] = ypos - 13      # 13 is the half height of the label image
                else:
                    GO_panel_element_dic['DispYpos'] = 0

                if 'LeftXPosPixels' in text_attr_dic.keys():
                    # label with image position datas but without bitmap
                    if text_attr_dic['LeftXPosPixels'] != None:
                        GO_panel_element_dic['PositionX'] = text_attr_dic['LeftXPosPixels']
                    if text_attr_dic['TopYPosPixels'] != None:
                        GO_panel_element_dic['PositionY'] = text_attr_dic['TopYPosPixels']
            else:
                # the text is not inside an image
                # compute the coordinates of the text rectangle according to the alignment of the text
                if text_attr_dic['XPosPixels'] != None:
                    if text_attr_dic['HorizontalAlignmentCode'] == 0: # centered
                        xpos = text_attr_dic['XPosPixels'] - int(text_width / 2)
                    elif text_attr_dic['HorizontalAlignmentCode'] == 2: # right aligned
                        xpos = text_attr_dic['XPosPixels'] - text_width
                    else:  # left aligned
                        xpos = text_attr_dic['XPosPixels']
                    if xpos < 0: xpos = 0
                    GO_panel_element_dic['TextRectLeft'] = xpos
                    GO_panel_element_dic['TextRectWidth'] = text_width

                if text_attr_dic['YPosPixels'] != None:
                    if text_attr_dic['VerticalAlignmentCode'] == 0: # centered
                        ypos = myint(text_attr_dic['YPosPixels']) - int(text_height / 2)
                    elif text_attr_dic['VerticalAlignmentCode'] == 2: # bottom aligned
                        ypos = myint(text_attr_dic['YPosPixels']) - text_height
                    else:  # top aligned
                        ypos = myint(text_attr_dic['YPosPixels'])
                    if ypos < 0: ypos = 0
                    GO_panel_element_dic['TextRectTop'] = ypos
                    GO_panel_element_dic['TextRectHeight'] = text_height

                # manage the image attributes of the current HW TextInstance
                if text_attr_dic['BitmapFilename'] != None:
                    GO_panel_element_dic['Image'] = text_attr_dic['BitmapFilename']

                    if text_attr_dic['ImageWidthPixels'] != None:
                        GO_panel_element_dic['Width'] = text_attr_dic['ImageWidthPixels']
                    if text_attr_dic['ImageHeightPixels'] != None:
                        GO_panel_element_dic['Height'] = text_attr_dic['ImageHeightPixels']

                if text_attr_dic['TransparencyMaskBitmapFilename'] != None:
                    GO_panel_element_dic['Mask'] = text_attr_dic['TransparencyMaskBitmapFilename']

                if text_attr_dic['BoundingBoxWidthPixelsIfWordWrap'] != None:
                    GO_panel_element_dic['TextRectWidth'] = str(int(text_attr_dic['BoundingBoxWidthPixelsIfWordWrap']) - 1)
                if text_attr_dic['BoundingBoxHeightPixelsIfWordWrap'] != None:
                    GO_panel_element_dic['TextRectHeight'] = text_attr_dic['BoundingBoxHeightPixelsIfWordWrap']

                if text_attr_dic['LeftXPosPixels'] != None:
                    GO_panel_element_dic['PositionX'] = text_attr_dic['LeftXPosPixels']
                if text_attr_dic['TopYPosPixels'] != None:
                    GO_panel_element_dic['PositionY'] = text_attr_dic['TopYPosPixels']

            # add in the HW TextInstance and ImageSetInstance objects the ID of the corresponding GO object
            HW_text_inst_dic['_GO_uid'] = GO_panel_element_uid
            if text_attr_dic['ImageSetInstanceDic'] != None:
                text_attr_dic['ImageSetInstanceDic']['_GO_uid'] = GO_panel_element_uid

            return GO_panel_element_uid
        else:
            return None

    #-------------------------------------------------------------------------------------------------
    def GO_ODF_build_Manual_object(self, HW_division_dic):
        # build a GO Manual999 object based on the given HW Division
        # return the UID of the GO Manuel object build or already existing

        # used HW objects :
        #   Division C> Keyboard C> KeyboardKey P> Switch C> ImageSetInstance C> ImageSet C> ImageSetElement  ==> keyboard_display_mode = 1
        #   Division C> Keyboard C> KeyImageSet C> ImageSet C> ImageSetElement                                ==> keyboard_display_mode = 2

        if HW_division_dic['_GO_uid'] != '':
            # a GO manual has been already assigned to the HW division, we can exit
            return HW_division_dic['_GO_uid']

        # get the first visible HW Keyboard associated to the given HW Division
        HW_keyboard_dic = None
        for HW_keyb_dic in self.HW_ODF_get_linked_objects_dic_by_type(HW_division_dic, 'Keyboard', TO_CHILD):
            # parse the HW Keyboard objects belonging to the given HW Division, to search the first one which has a KeyImageSet or KeyboardKey child
            if (self.HW_ODF_get_linked_objects_dic_by_type(HW_keyb_dic, 'KeyImageSet', TO_CHILD, FIRST_ONE) != None or
                self.HW_ODF_get_linked_objects_dic_by_type(HW_keyb_dic, 'KeyboardKey', TO_CHILD, FIRST_ONE) != None):
                HW_keyboard_dic = HW_keyb_dic
                break

        # get how the HW keyboard is graphically defined
        keyboard_display_mode = 0  # by default the keyboard is not visible
        if HW_keyboard_dic != None:
            if self.HW_ODF_get_linked_objects_dic_by_type(HW_keyboard_dic, 'KeyboardKey', TO_CHILD, FIRST_ONE) != None:
                keyboard_display_mode = 1  # the keyboard is graphically defined by KeyboardKey objects (which should be linked to a Switch + ImageSetInstance)
            elif self.HW_ODF_get_attribute_value(HW_keyboard_dic, 'KeyGen_KeyImageSetID') != None:
                keyboard_display_mode = 2  # the keyboard is graphically defined by a KeyImageSet object

        # define the GO Manual999 object to associate to this HW Division
        HW_division_id = int(HW_division_dic['_HW_uid'][-6:])
        if HW_division_id == 1:
            # Pedal division
            GO_manual_uid = 'Manual000'
        else:
            self.GO_odf_dic['Organ']['NumberOfManuals'] += 1
            GO_manual_uid = 'Manual' + str(self.GO_odf_dic['Organ']['NumberOfManuals']).zfill(3)
        GO_manual_dic = self.GO_odf_dic[GO_manual_uid] = {}
        GO_manual_dic['_GO_uid'] = GO_manual_uid

        # add in the HW Division and Keyboard objects the UID of the corresponding GO object
        HW_division_dic['_GO_uid'] = GO_manual_uid
        if HW_keyboard_dic != None:
            HW_keyboard_dic['_GO_uid'] = GO_manual_uid

        # update in the GO Organ object the HasPedal attribute value
        if GO_manual_uid == 'Manual000':
            self.GO_odf_dic['Organ']['HasPedals'] = 'Y'

        # recover the number of keys of the keyboard and its first and last MIDI note numbers
        if keyboard_display_mode == 1:
            # recover this from the HW KeyboardKey objects belonging to the HW Keyboard and being linked to an ImageSetInstance
            first_midi_note_nb_int = 999
            last_midi_note_nb_int = 0
            nb_keys_int = 0
            keys_switch_dic = {}  # dictionary with as key the MIDI note number and as value the corresponding HW Switch object
            for HW_keyboard_key_dic in self.HW_ODF_get_linked_objects_dic_by_type(HW_keyboard_dic, 'KeyboardKey', TO_CHILD):
                # parse the HW KeyboardKey objects which are children of the HW Keyboard
                # recover the HW ImageSetInstance associated to the HW Switch associated to the current HW KeyboardKey
                HW_switch_dic = self.HW_ODF_get_object_dic_by_ref_id('Switch', HW_keyboard_key_dic, 'SwitchID')
                HW_img_set_instance_id = myint(self.HW_ODF_get_attribute_value(HW_switch_dic, 'Disp_ImageSetInstanceID'))
                if HW_img_set_instance_id != None:
                    # the current HW KeyboardKey has an associated HW ImageSetInstance (in Grabowski Enerlo the highest keys have no image)
                    nb_keys_int += 1
                    # get the MIDI note number of the current HW KeyboardKey object
                    midi_note_nb_int = myint(self.HW_ODF_get_attribute_value(HW_keyboard_key_dic, 'NormalMIDINoteNumber'))
                    if midi_note_nb_int == None: midi_note_nb_int = 60 # observed with Sound Paradisi sample sets, the MIDI note 60 is not defined
                    # update the first and last MIDI note numbers
                    if midi_note_nb_int < first_midi_note_nb_int: first_midi_note_nb_int = midi_note_nb_int
                    if midi_note_nb_int > last_midi_note_nb_int:  last_midi_note_nb_int = midi_note_nb_int
                    # add an entry in the keys switch dictionary with the HW Switch associated to the current HW KeyboardKey
                    keys_switch_dic[midi_note_nb_int] = self.HW_ODF_get_object_dic_by_ref_id('Switch', HW_keyboard_key_dic, 'SwitchID')
                    # add in the HW KeyboardKey object the UID of the corresponding GO object
                    HW_keyboard_key_dic['_GO_uid'] = GO_manual_uid
        elif keyboard_display_mode == 2:
            # recover this from the KeyGen attributes of the HW Keyboard
            nb_keys_int = myint(self.HW_ODF_get_attribute_value(HW_keyboard_dic, 'KeyGen_NumberOfKeys'))
            first_midi_note_nb_int = myint(self.HW_ODF_get_attribute_value(HW_keyboard_dic, 'KeyGen_MIDINoteNumberOfFirstKey'))
            last_midi_note_nb_int = first_midi_note_nb_int + nb_keys_int - 1
        else: # keyboard_display_mode == 0 (not visible keyboards)
            # recover this from the InpGen attributes of the HW Division or the KeyGen attributes of the HW Keyboard
            nb_keys_int = myint(self.HW_ODF_get_attribute_value(HW_division_dic, 'InpGen_NumberOfInputs'))
            if nb_keys_int == None:
                nb_keys_int = myint(self.HW_ODF_get_attribute_value(HW_keyboard_dic, 'KeyGen_NumberOfKeys'))

            first_midi_note_nb_int = myint(self.HW_ODF_get_attribute_value(HW_division_dic, 'InpGen_MIDINoteNumberOfFirstInput'))
            if first_midi_note_nb_int == None:
                first_midi_note_nb_int = myint(self.HW_ODF_get_attribute_value(HW_keyboard_dic, 'KeyGen_MIDINoteNumberOfFirstKey'))

            # if still not know, try to recover from the number of HW DivisionInput objects
            if nb_keys_int == None:
                HW_div_inputs_list = self.HW_ODF_get_linked_objects_dic_by_type(HW_division_dic, 'DivisionInput', TO_CHILD)
                if len(HW_div_inputs_list) > 0:
                    nb_keys_int = len(HW_div_inputs_list)
                    first_midi_note_nb_int = 999
                    for HW_div_input_dic in HW_div_inputs_list:
                        midi_not_nb = myint(self.HW_ODF_get_attribute_value(HW_div_input_dic, 'NormalMIDINoteNumber'))
                        if midi_not_nb != None and midi_not_nb < first_midi_note_nb_int:
                            first_midi_note_nb_int = midi_not_nb

            if nb_keys_int != None and first_midi_note_nb_int != None:
                last_midi_note_nb_int = first_midi_note_nb_int + nb_keys_int - 1
            else:
                nb_keys_int = first_midi_note_nb_int = last_midi_note_nb_int = 0

        # get the HW DisplayPage in which is displayed the keyboard
        if keyboard_display_mode == 1:
            # recover this from the HW ImageSetInstance of the first key of the keyboard
            HW_img_set_instance_id = myint(self.HW_ODF_get_attribute_value(keys_switch_dic[first_midi_note_nb_int], 'Disp_ImageSetInstanceID', MANDATORY))
            HW_img_set_instance_dic = self.HW_ODF_get_object_dic('ImageSetInstance', HW_img_set_instance_id)
            keyboard_disp_page_id = myint(self.HW_ODF_get_attribute_value(HW_img_set_instance_dic, 'DisplayPageID'))
        elif keyboard_display_mode == 2:
            keyboard_disp_page_id = myint(self.HW_ODF_get_attribute_value(HW_keyboard_dic, 'KeyGen_DisplayPageID'))

        GO_manual_dic['Name'] = self.HW_ODF_get_attribute_value(HW_division_dic, 'Name')
        GO_manual_dic['NumberOfLogicalKeys'] = nb_keys_int
        GO_manual_dic['NumberOfAccessibleKeys'] = nb_keys_int
        GO_manual_dic['FirstAccessibleKeyLogicalKeyNumber'] = 1
        GO_manual_dic['FirstAccessibleKeyMIDINoteNumber'] = first_midi_note_nb_int
        GO_manual_dic['NumberOfStops'] = 0
        GO_manual_dic['NumberOfSwitches'] = 0
        GO_manual_dic['NumberOfCouplers'] = 0
        GO_manual_dic['NumberOfDivisionals'] = 0
        GO_manual_dic['NumberOfTremulants'] = 0

        if keyboard_display_mode == 0:
            # the keyboard is not visible, we can stop here the definition of the GO Manual
            return GO_manual_uid

        # define the manual graphical attributes in a Panel999Element999 object with Type = Manual

        # get the GO Panel UID in which to display the keyboard
        HW_disp_page_dic = self.HW_ODF_get_object_dic('DisplayPage', keyboard_disp_page_id)
        GO_panel_uid = HW_disp_page_dic['_GO_uid']

        # create the GO Panel999Element999 object to display the keyboard
        self.GO_odf_dic[GO_panel_uid]['NumberOfGUIElements'] += 1
        GO_panel_element_uid = GO_panel_uid + 'Element' + str(self.GO_odf_dic[GO_panel_uid]['NumberOfGUIElements']).zfill(3)
        GO_panel_element_dic = self.GO_odf_dic[GO_panel_element_uid] = {}

        GO_panel_element_dic['Type'] = 'Manual'
        GO_panel_element_dic['Manual'] = str(int(GO_manual_uid[-3:])).zfill(3)

        GO_panel_element_dic['_GO_uid'] = GO_manual_uid

        # define the graphical properties of the GO Manual
        if keyboard_display_mode == 1:
            # keys graphical aspect is defined for each key
            for midi_note_nb_int in range(first_midi_note_nb_int, last_midi_note_nb_int + 1):
                # parse the switches of the HW Keyboard by increasing MIDI note number
                GO_key_nb = midi_note_nb_int - first_midi_note_nb_int + 1

                if midi_note_nb_int < last_midi_note_nb_int:
                    # it is not the latest key of the keyboard
                    self.GO_ODF_build_Manual_keyimage_by_switch(keys_switch_dic[midi_note_nb_int], keys_switch_dic[midi_note_nb_int + 1], GO_panel_element_dic, GO_key_nb)
                else:
                    self.GO_ODF_build_Manual_keyimage_by_switch(keys_switch_dic[midi_note_nb_int], None, GO_panel_element_dic, GO_key_nb)

        else:
            # keys graphical aspect is defined for one octave + the first and last keys

            # get the HW KeyImageSet associated to the HW Keyboard
            HW_key_img_set_dic = self.HW_ODF_get_object_dic_by_ref_id('KeyImageSet', HW_keyboard_dic, 'KeyGen_KeyImageSetID')

            # set the GO Manual position
            GO_panel_element_dic['PositionX'] = self.HW_ODF_get_attribute_value(HW_keyboard_dic, 'KeyGen_DispKeyboardLeftXPos')
            GO_panel_element_dic['PositionY'] = self.HW_ODF_get_attribute_value(HW_keyboard_dic, 'KeyGen_DispKeyboardTopYPos')

            # set the GO Manual keys width
            GO_panel_element_dic['Width_A']   = self.HW_ODF_get_attribute_value(HW_key_img_set_dic, 'HorizSpacingPixels_LeftOfDASharpFromLeftOfDA')
            GO_panel_element_dic['Width_Ais'] = self.HW_ODF_get_attribute_value(HW_key_img_set_dic, 'HorizSpacingPixels_LeftOfEBFromLeftOfDASharp')
            GO_panel_element_dic['Width_B']   = self.HW_ODF_get_attribute_value(HW_key_img_set_dic, 'HorizSpacingPixels_LeftOfNaturalFromLeftOfNatural')
            GO_panel_element_dic['Width_C']   = self.HW_ODF_get_attribute_value(HW_key_img_set_dic, 'HorizSpacingPixels_LeftOfCFSharpFromLeftOfCF')
            GO_panel_element_dic['Width_Cis'] = self.HW_ODF_get_attribute_value(HW_key_img_set_dic, 'HorizSpacingPixels_LeftOfDGFromLeftOfCFSharp')
            GO_panel_element_dic['Width_D']   = self.HW_ODF_get_attribute_value(HW_key_img_set_dic, 'HorizSpacingPixels_LeftOfDASharpFromLeftOfDA')
            GO_panel_element_dic['Width_Dis'] = self.HW_ODF_get_attribute_value(HW_key_img_set_dic, 'HorizSpacingPixels_LeftOfEBFromLeftOfDASharp')
            GO_panel_element_dic['Width_E']   = self.HW_ODF_get_attribute_value(HW_key_img_set_dic, 'HorizSpacingPixels_LeftOfNaturalFromLeftOfNatural')
            GO_panel_element_dic['Width_F']   = self.HW_ODF_get_attribute_value(HW_key_img_set_dic, 'HorizSpacingPixels_LeftOfCFSharpFromLeftOfCF')
            GO_panel_element_dic['Width_Fis'] = self.HW_ODF_get_attribute_value(HW_key_img_set_dic, 'HorizSpacingPixels_LeftOfDGFromLeftOfCFSharp')
            GO_panel_element_dic['Width_G']   = self.HW_ODF_get_attribute_value(HW_key_img_set_dic, 'HorizSpacingPixels_LeftOfGSharpFromLeftOfG')
            GO_panel_element_dic['Width_Gis'] = self.HW_ODF_get_attribute_value(HW_key_img_set_dic, 'HorizSpacingPixels_LeftOfAFromLeftOfGSharp')

            # set the GO Manual keys offset
            GO_panel_element_dic['Offset_A']   = '0'
            GO_panel_element_dic['Offset_Ais'] = '0'
            GO_panel_element_dic['Offset_B']   = '0'
            GO_panel_element_dic['Offset_C']   = '0'
            GO_panel_element_dic['Offset_Cis'] = '0'
            GO_panel_element_dic['Offset_D']   = '0'
            GO_panel_element_dic['Offset_Dis'] = '0'
            GO_panel_element_dic['Offset_E']   = '0'
            GO_panel_element_dic['Offset_F']   = '0'
            GO_panel_element_dic['Offset_Fis'] = '0'
            GO_panel_element_dic['Offset_G']   = '0'
            GO_panel_element_dic['Offset_Gis'] = '0'

            # get the key up (not pressed) and key down (pressed) images index within image set if defined, else set default index
            key_up_img_index = myint(self.HW_ODF_get_attribute_value(HW_key_img_set_dic, 'ImageIndexWithinImageSets_Disengaged'))
            if key_up_img_index == None: key_up_img_index = 1
            HW_key_img_set_dic['_key_up_img_index'] = key_up_img_index

            key_down_img_index = myint(self.HW_ODF_get_attribute_value(HW_key_img_set_dic, 'ImageIndexWithinImageSets_Engaged'))
            if key_down_img_index == None: key_down_img_index = 2
            HW_key_img_set_dic['_key_down_img_index'] = key_down_img_index

            # set the GO Manual keys images
            self.GO_ODF_build_Manual_keyimage_by_keytype(HW_key_img_set_dic, 'CF', GO_panel_element_dic, 'C')
            self.GO_ODF_build_Manual_keyimage_by_keytype(HW_key_img_set_dic, 'CF', GO_panel_element_dic, 'F')
            self.GO_ODF_build_Manual_keyimage_by_keytype(HW_key_img_set_dic, 'D', GO_panel_element_dic, 'D')
            self.GO_ODF_build_Manual_keyimage_by_keytype(HW_key_img_set_dic, 'EB', GO_panel_element_dic, 'E')
            self.GO_ODF_build_Manual_keyimage_by_keytype(HW_key_img_set_dic, 'EB', GO_panel_element_dic, 'B')
            self.GO_ODF_build_Manual_keyimage_by_keytype(HW_key_img_set_dic, 'G', GO_panel_element_dic, 'G')
            self.GO_ODF_build_Manual_keyimage_by_keytype(HW_key_img_set_dic, 'A', GO_panel_element_dic, 'A')
            self.GO_ODF_build_Manual_keyimage_by_keytype(HW_key_img_set_dic, 'Sharp', GO_panel_element_dic, 'Ais')
            self.GO_ODF_build_Manual_keyimage_by_keytype(HW_key_img_set_dic, 'Sharp', GO_panel_element_dic, 'Cis')
            self.GO_ODF_build_Manual_keyimage_by_keytype(HW_key_img_set_dic, 'Sharp', GO_panel_element_dic, 'Dis')
            self.GO_ODF_build_Manual_keyimage_by_keytype(HW_key_img_set_dic, 'Sharp', GO_panel_element_dic, 'Fis')
            self.GO_ODF_build_Manual_keyimage_by_keytype(HW_key_img_set_dic, 'Sharp', GO_panel_element_dic, 'Gis')

            # set the GO Manual first key image and width
            first_note_name, octave = midi_number_to_note(int(first_midi_note_nb_int))
            if first_note_name == 'D':
                self.GO_ODF_build_Manual_keyimage_by_keytype(HW_key_img_set_dic, 'FirstKeyDA', GO_panel_element_dic, 'FirstD')
                GO_panel_element_dic['Width_FirstD'] = self.HW_ODF_get_attribute_value(HW_key_img_set_dic, 'HorizSpacingPixels_LeftOfDASharpFromLeftOfDA')
            elif first_note_name == 'A':
                self.GO_ODF_build_Manual_keyimage_by_keytype(HW_key_img_set_dic, 'FirstKeyDA', GO_panel_element_dic, 'FirstA')
                GO_panel_element_dic['Width_FirstA'] = self.HW_ODF_get_attribute_value(HW_key_img_set_dic, 'HorizSpacingPixels_LeftOfDASharpFromLeftOfDA')
            elif first_note_name == 'G':
                self.GO_ODF_build_Manual_keyimage_by_keytype(HW_key_img_set_dic, 'FirstKeyG', GO_panel_element_dic, 'FirstG')
                GO_panel_element_dic['Width_FirstG'] = self.HW_ODF_get_attribute_value(HW_key_img_set_dic, 'HorizSpacingPixels_LeftOfGSharpFromLeftOfG')
            elif first_note_name == 'C':
                self.GO_ODF_build_Manual_keyimage_by_keytype(HW_key_img_set_dic, 'CF', GO_panel_element_dic, 'FirstC')
                GO_panel_element_dic['Width_FirstC'] = self.HW_ODF_get_attribute_value(HW_key_img_set_dic, 'HorizSpacingPixels_LeftOfCFSharpFromLeftOfCF')

            # set the GO Manual last key image and width
            last_note_name, octave = midi_number_to_note(int(last_midi_note_nb_int))
            if last_note_name == 'D':
                self.GO_ODF_build_Manual_keyimage_by_keytype(HW_key_img_set_dic, 'LastKeyDG', GO_panel_element_dic, 'LastD')
                GO_panel_element_dic['Width_LastD'] = self.HW_ODF_get_attribute_value(HW_key_img_set_dic, 'HorizSpacingPixels_LeftOfNaturalFromLeftOfNatural')
            elif last_note_name == 'G':
                self.GO_ODF_build_Manual_keyimage_by_keytype(HW_key_img_set_dic, 'LastKeyDG', GO_panel_element_dic, 'LastG')
                GO_panel_element_dic['Width_LastG'] = self.HW_ODF_get_attribute_value(HW_key_img_set_dic, 'HorizSpacingPixels_LeftOfNaturalFromLeftOfNatural')
            elif last_note_name == 'A':
                self.GO_ODF_build_Manual_keyimage_by_keytype(HW_key_img_set_dic, 'LastKeyA', GO_panel_element_dic, 'LastA')
                GO_panel_element_dic['Width_LastA'] = self.HW_ODF_get_attribute_value(HW_key_img_set_dic, 'HorizSpacingPixels_LeftOfNaturalFromLeftOfNatural')
            elif last_note_name == 'C':
                self.GO_ODF_build_Manual_keyimage_by_keytype(HW_key_img_set_dic, 'WholeNatural', GO_panel_element_dic, 'LastC')
                GO_panel_element_dic['Width_LastC'] = self.HW_ODF_get_attribute_value(HW_key_img_set_dic, 'HorizSpacingPixels_LeftOfNaturalFromLeftOfNatural')
            elif last_note_name == 'F':
                self.GO_ODF_build_Manual_keyimage_by_keytype(HW_key_img_set_dic, 'WholeNatural', GO_panel_element_dic, 'LastF')
                GO_panel_element_dic['Width_LastF'] = self.HW_ODF_get_attribute_value(HW_key_img_set_dic, 'HorizSpacingPixels_LeftOfNaturalFromLeftOfNatural')

        return GO_manual_uid

    #-------------------------------------------------------------------------------------------------
    def GO_ODF_build_Manual_keyimage_by_keytype(self, HW_key_img_set_dic, HW_key_type, GO_panel_element_dic, GO_key_type):
        # add in the given GO panel element the key images attributes of the given HW key type
        # sub-function of GO_ODF_build_Manual_object

        HW_image_set_id = myint(self.HW_ODF_get_attribute_value(HW_key_img_set_dic, 'KeyShapeImageSetID_' + HW_key_type))
        if HW_image_set_id != None:
            HW_image_set_dic = self.HW_ODF_get_object_dic('ImageSet', HW_image_set_id)

            # image for key up (not pressed)
            image_attr_dic = {}
            self.HW_ODF_get_image_attributes(HW_image_set_dic, image_attr_dic, HW_key_img_set_dic['_key_up_img_index'])
            if image_attr_dic['BitmapFilename'] != None:
                GO_panel_element_dic['ImageOff_' + GO_key_type] = image_attr_dic['BitmapFilename']
            if image_attr_dic['TransparencyMaskBitmapFilename'] != None:
                GO_panel_element_dic['MaskOff_' + GO_key_type] = image_attr_dic['TransparencyMaskBitmapFilename']

            # image for key down (pressed)
            image_attr_dic = {}
            self.HW_ODF_get_image_attributes(HW_image_set_dic, image_attr_dic, HW_key_img_set_dic['_key_down_img_index'])
            if image_attr_dic['BitmapFilename'] != None:
                GO_panel_element_dic['ImageOn_' + GO_key_type] = image_attr_dic['BitmapFilename']
            if image_attr_dic['TransparencyMaskBitmapFilename'] != None:
                GO_panel_element_dic['MaskOn_' + GO_key_type] = image_attr_dic['TransparencyMaskBitmapFilename']

    #-------------------------------------------------------------------------------------------------
    def GO_ODF_build_Manual_keyimage_by_switch(self, HW_switch_dic, HW_next_switch_dic, GO_panel_element_dic, GO_key_nb):
        # add in the given GO panel element the key images attributes of the given HW Switch
        # sub-function of GO_ODF_build_Manual_object

        if HW_switch_dic == None: return

        HW_img_set_instance_id = myint(self.HW_ODF_get_attribute_value(HW_switch_dic, 'Disp_ImageSetInstanceID', MANDATORY))
        HW_img_set_instance_dic = self.HW_ODF_get_object_dic('ImageSetInstance', HW_img_set_instance_id)

        # get the key engaged and disengaged images indexes
        key_up_img_index = myint(self.HW_ODF_get_attribute_value(HW_switch_dic, 'Disp_ImageSetIndexDisengaged', MANDATORY))
        key_down_img_index = myint(self.HW_ODF_get_attribute_value(HW_switch_dic, 'Disp_ImageSetIndexEngaged', MANDATORY))

        # add in the HW Switch and ImageSetInstance objects the UID of the corresponding GO object
        HW_switch_dic['_GO_uid'] = GO_panel_element_dic['_GO_uid']
        HW_img_set_instance_dic['_GO_uid'] = GO_panel_element_dic['_GO_uid']

        key_nb_3digit_str = str(GO_key_nb).zfill(3)

        if GO_key_nb == 1:
            # set the GO keyboard position which is the position of the first key
            image_attr_dic = {}
            self.HW_ODF_get_image_attributes(HW_img_set_instance_dic, image_attr_dic, key_up_img_index)
            GO_panel_element_dic['PositionX'] = image_attr_dic['LeftXPosPixels']
            GO_panel_element_dic['PositionY'] = image_attr_dic['TopYPosPixels']

        # image for key up (not pressed)
        image_attr_dic = {}
        self.HW_ODF_get_image_attributes(HW_img_set_instance_dic, image_attr_dic, key_up_img_index)
        if image_attr_dic['BitmapFilename'] != None:
            GO_panel_element_dic['Key' + key_nb_3digit_str + 'ImageOff'] = image_attr_dic['BitmapFilename']
        if image_attr_dic['TransparencyMaskBitmapFilename'] != None:
            GO_panel_element_dic['Key' + key_nb_3digit_str + 'MaskOff'] = image_attr_dic['TransparencyMaskBitmapFilename']

        # image for key down (pressed)
        image_attr_dic = {}
        self.HW_ODF_get_image_attributes(HW_img_set_instance_dic, image_attr_dic, key_down_img_index)
        if image_attr_dic['BitmapFilename'] != None:
            GO_panel_element_dic['Key' + key_nb_3digit_str + 'ImageOn'] = image_attr_dic['BitmapFilename']
        if image_attr_dic['TransparencyMaskBitmapFilename'] != None:
            GO_panel_element_dic['Key' + key_nb_3digit_str + 'MaskOn'] = image_attr_dic['TransparencyMaskBitmapFilename']

        # width/offset of the key, width calculated by the diff of XPos of the key and its next one
        if HW_next_switch_dic != None:
            HW_next_img_set_instance_id = myint(self.HW_ODF_get_attribute_value(HW_next_switch_dic, 'Disp_ImageSetInstanceID', MANDATORY))
            HW_next_img_set_instance_dic = self.HW_ODF_get_object_dic('ImageSetInstance', HW_next_img_set_instance_id)

            next_image_dic = {}
            self.HW_ODF_get_image_attributes(HW_next_img_set_instance_dic, next_image_dic, key_up_img_index)
            key_width = int(next_image_dic['LeftXPosPixels']) - int(image_attr_dic['LeftXPosPixels'])
            GO_panel_element_dic['Key' + key_nb_3digit_str + 'Width'] = str(key_width)
            GO_panel_element_dic['Key' + key_nb_3digit_str + 'Offset'] = '0'

    #-------------------------------------------------------------------------------------------------
    def GO_ODF_build_Drawstop_objects(self, HW_object_dic, HW_division_dic):
        # build all the possible GO drawstop objects (Stop, Coupler) from the given HW object (Stop, KeyAction, Switch) and their linked HW switches

        # used HW objects for various kinds of drawstop :
        #   coupler :
        #     Switch C> KeyAction
        #   pipes stop :
        #     Switch C> Stop C> StopRank(s) (ActionTypeCode = 1, ActionEffectCode = 1) C> Rank C> Pipe_SoundEngine01 ...
        #     Switch C> Stop (Hint_PrimaryAssociatedRankID) C> Rank C> Pipe_SoundEngine01 ...
        #   drawstop engage noise stop :
        #     Switch C> Stop C> StopRank (ActionTypeCode = 21, ActionEffectCode = 2) C> Rank C> Pipe_SoundEngine01 ...
        #     Switch C> SwitchLinkage (EngageLinkActionCode=4, DisengageLinkActionCode=7) C> Switch C> Pipe_SoundEngine01 ...
        #   drawstop engage noise stop or general noise stop (i.e. blower) :
        #     Switch C> Pipe_SoundEngine01 C> Pipe_SoundEngine01Layer C> Pipe_SoundEngine01_AttackSample (no ReleaseSample) ...
        #   drawstop disengage noise stop :
        #     Switch C> Stop C> StopRank (ActionTypeCode = 21, ActionEffectCode = 3) C> Rank C> Pipe_SoundEngine01 ...
        #     Switch C> SwitchLinkage (EngageLinkActionCode=7, DisengageLinkActionCode=4) C> Switch C> Pipe_SoundEngine01 ...
        #     Switch C> SwitchLinkage (EngageLinkActionCode=1, DisengageLinkActionCode=2, SourceSwitchLinkIfEngaged=N) C> Switch C> Pipe_SoundEngine01 ...
        #     Switch C> Pipe_SoundEngine01 C> Pipe_SoundEngine01Layer C> Pipe_SoundEngine01_ReleaseSample (AttackSample ignored) ...
        #   general noise stop (i.e. blower) :
        #     Switch C> Stop C> StopRank (ActionTypeCode = 21, ActionEffectCode = 1) C> Rank C> Pipe_SoundEngine01 ...

        GO_object_name = HW_object_dic['Name']
        GO_manual_dic = self.GO_odf_dic[HW_division_dic['_GO_uid']]
        HW_object_type = HW_object_dic['_HW_uid'][:-6]

        nb_couplers = 0
        nb_pipes_stops = 0
        nb_noise_stops = 0

        # get the list of the HW switches which are linked to the given HW object
        # in case of given KeyAction or Stop object, consider the parent controlling HW switches
        # in case of given Switch object, consider the children controlled HW switches
        HW_switches_data_dic = {}
        self.HW_ODF_get_linked_switches_list(HW_object_dic, HW_switches_data_dic, TO_CHILD if HW_object_type == 'Switch' else TO_PARENT)

        # try to build GO stops from each found HW switch depending on what it is controlling
        GO_objects_list = []
        for HW_switch_dic in HW_switches_data_dic['HW_switches_list']:

            # check the Switch C> KeyAction use case
            HW_key_action_dic = self.HW_ODF_get_linked_objects_dic_by_type(HW_switch_dic, 'KeyAction', TO_CHILD, FIRST_ONE)
            if HW_key_action_dic != None and HW_key_action_dic['_GO_uid'] == '':  # and nb_couplers == 0:
                # the current HW switch is controlling a KeyAction which is not already assigned to a GO object
                # and it is the first coupler to build in link with the given HW object
                GO_coupler_dic = self.GO_ODF_build_Coupler_object(HW_key_action_dic)
                if GO_coupler_dic != None:
                    GO_coupler_dic['_object_type'] = 'Coupler'
                    nb_couplers += 1
                    GO_objects_list.append(GO_coupler_dic)

            # check the Switch C> Stop C> StopRank use cases
            pipes_stop_found = False  # flag permitting to avoid multiple pipes stop object for the given HW stop
            for HW_stop_dic in self.HW_ODF_get_linked_objects_dic_by_type(HW_switch_dic, 'Stop', TO_CHILD):
                # parse the HW Stop objects which are children of the current HW Switch object if any
                for HW_stop_rank_dic in self.HW_ODF_get_linked_objects_dic_by_type(HW_stop_dic, 'StopRank', TO_CHILD):
                    # parse the HW StopRank objects which are children of the current HW Stop object if any
                    HW_rank_dic = self.HW_ODF_get_object_dic_by_ref_id('Rank', HW_stop_rank_dic, 'RankID')
                    HW_rank_nb_pipes = len(self.HW_ODF_get_linked_objects_dic_by_type(HW_rank_dic, 'Pipe_SoundEngine01', TO_CHILD))
                    if HW_rank_nb_pipes > 0:
                        HW_action_type_code = myint(self.HW_ODF_get_attribute_value(HW_stop_rank_dic, 'ActionTypeCode'))
                        HW_action_effect_code = myint(self.HW_ODF_get_attribute_value(HW_stop_rank_dic, 'ActionEffectCode'))
                        if HW_action_type_code == 1 and HW_action_effect_code == 1 and not pipes_stop_found:
                            # matching use case for building a pipes stop object
                            GO_stop_dic = self.GO_ODF_build_Stop_pipes_object(HW_stop_dic, GO_manual_dic)
                            if GO_stop_dic != None:
                                pipes_stop_found = True
                                GO_stop_dic['_object_type'] = 'Stop'
                                nb_pipes_stops += 1
                                GO_objects_list.append(GO_stop_dic)

                        elif HW_action_type_code == 21 and HW_action_effect_code in (1, 2, 3):
                            # matching use case for building a noise stop object (general, attack, release)
                            HW_pipe_dic = None
                            # take into account a MIDI note increment if defined to use the proper Pipe_SoundEngine01 object
                            HW_div_midi_note_increment_to_rank = myint(self.HW_ODF_get_attribute_value(HW_stop_rank_dic, 'MIDINoteNumIncrementFromDivisionToRank'))
                            if HW_div_midi_note_increment_to_rank != None and HW_div_midi_note_increment_to_rank != 0:
                                # search for the Pipe_SoundEngine01 object having the given MIDI note number
                                for HW_pipe_check_dic in self.HW_ODF_get_linked_objects_dic_by_type(HW_rank_dic, 'Pipe_SoundEngine01', TO_CHILD):
                                    midi_note_nb = myint(self.HW_ODF_get_attribute_value(HW_pipe_check_dic, 'NormalMIDINoteNumber'))
                                    if midi_note_nb == None: midi_note_nb = 60
                                    if midi_note_nb == HW_div_midi_note_increment_to_rank:
                                        HW_pipe_dic = HW_pipe_check_dic
                                        break
                            if HW_pipe_dic == None:
                                # Pipe_SoundEngine01 object not found, take the first Pipe_SoundEngine01 child of the Rank
                                HW_pipe_dic = self.HW_ODF_get_linked_objects_dic_by_type(HW_rank_dic, 'Pipe_SoundEngine01', TO_CHILD, FIRST_ONE)
                            if HW_pipe_dic != None:
                                # a Pipe_SoundEngine01 can be used to build the noise stop
                                if HW_action_effect_code == 2: # drawstop engage noise
                                    attack_bool = True
                                elif HW_action_effect_code == 3: # drawstop disengage noise
                                    attack_bool = False
                                else: # general noise stop
                                    attack_bool = None
                                GO_stop_dic = self.GO_ODF_build_Stop_noise_object(HW_pipe_dic, GO_object_name, attack_bool)
                                if GO_stop_dic != None:
                                    GO_stop_dic['_object_type'] = 'Stop'
                                    nb_noise_stops += 1
                                    GO_objects_list.append(GO_stop_dic)

            # check the Switch C> Stop (Hint_PrimaryAssociatedRankID) C> Rank use cases
            if pipes_stop_found == False:
                for HW_stop_dic in self.HW_ODF_get_linked_objects_dic_by_type(HW_switch_dic, 'Stop', TO_CHILD):
                    # parse the HW Stop objects which are children of the current HW Switch object if any
                    if myint(self.HW_ODF_get_attribute_value(HW_stop_dic, 'Hint_PrimaryAssociatedRankID')) != None:
                        GO_stop_dic = self.GO_ODF_build_Stop_pipes_object(HW_stop_dic, GO_manual_dic)
                        if GO_stop_dic != None:
                            GO_stop_dic['_object_type'] = 'Stop'
                            nb_pipes_stops += 1
                            GO_objects_list.append(GO_stop_dic)

            # check the Switch C> SwitchLinkage use cases
            for HW_switch_linkage_dic in self.HW_ODF_get_linked_objects_dic_by_type(HW_switch_dic, 'SwitchLinkage', TO_CHILD):
                # parse the HW SwitchLinkage objects which are children of the current HW Switch object if any
                EngageLinkActionCode = myint(self.HW_ODF_get_attribute_value(HW_switch_linkage_dic, 'EngageLinkActionCode'))
                DisengageLinkActionCode = myint(self.HW_ODF_get_attribute_value(HW_switch_linkage_dic, 'DisengageLinkActionCode'))
                SourceSwitchLinkIfEngaged = self.HW_ODF_get_attribute_value(HW_switch_linkage_dic, 'SourceSwitchLinkIfEngaged')
                HW_dest_switch_dic = self.HW_ODF_get_object_dic_by_ref_id('Switch', HW_switch_linkage_dic, 'DestSwitchID')
                if HW_dest_switch_dic != None:
                    HW_pipe_dic = self.HW_ODF_get_linked_objects_dic_by_type(HW_dest_switch_dic, 'Pipe_SoundEngine01', TO_CHILD, FIRST_ONE)
                    if HW_pipe_dic != None:
                        GO_stop_dic = None
                        if EngageLinkActionCode == 4 and DisengageLinkActionCode == 7:
                            # matching use case for building a drawstop engage noise
                            GO_stop_dic = self.GO_ODF_build_Stop_noise_object(HW_pipe_dic, GO_object_name, True)
                        elif ((EngageLinkActionCode == 7 and DisengageLinkActionCode == 4) or
                              (EngageLinkActionCode == 1 and DisengageLinkActionCode == 2 and SourceSwitchLinkIfEngaged == 'N')):
                            # matching use case for building a drawstop disengage noise
                            GO_stop_dic = self.GO_ODF_build_Stop_noise_object(HW_pipe_dic, GO_object_name, False)
                        if GO_stop_dic != None:
                            GO_stop_dic['_object_type'] = 'Stop'
                            nb_noise_stops += 1
                            GO_objects_list.append(GO_stop_dic)

            # check the Switch C> Pipe_SoundEngine01 use cases
            for HW_pipe_dic in self.HW_ODF_get_linked_objects_dic_by_type(HW_switch_dic, 'Pipe_SoundEngine01', TO_CHILD):
                # parse the HW Pipe_SoundEngine01 objects which are children of the current HW Switch object if any
                GO_stop_dic = self.GO_ODF_build_Stop_noise_object(HW_pipe_dic, GO_object_name, None)
                if GO_stop_dic != None:
                    GO_stop_dic['_object_type'] = 'Stop'
                    nb_noise_stops += 1
                    GO_objects_list.append(GO_stop_dic)

        if len(GO_objects_list) == 0:
            # none GO object built
            return


        if DEV_MODE == False:
##            print(f'{GO_object_name} {nb_couplers} {nb_pipes_stops} {nb_noise_stops} {HW_switches_data_dic["clickable"]} {HW_switches_data_dic["default_to_engage"]}')
            if ((nb_couplers == 0 and nb_pipes_stops == 0 and int(nb_noise_stops % 2) == 0) or
                (not HW_switches_data_dic['clickable'] and not HW_switches_data_dic['default_to_engage'])):
                # don't build drawstops if there are even number of noise stops (attack / release noises only)
                # and no pipes/coupler stop (case of demo sample sets with pipes stops without pipes inside)
                # this permits to avoid having switches in the GO panels which control nothing behind
                # or no clickable switch and not engaged by default to control the coupler/stop
                # this permits to avoid having objects in the GO ODF which are not controlled by a switch
                for HW_switch_dic in HW_switches_data_dic['HW_switches_list']:
                    HW_switch_dic['_GO_uid'] = None
                return

        # build the GO switches corresponding to the visible HW switches
        GO_switch_uid = None
        for HW_switch_dic in HW_switches_data_dic['HW_switches_list']:
            GO_switch_uid  = self.GO_ODF_build_Switch_object(HW_switch_dic, GO_switch_uid , GO_object_name)

        # build the GO coupler/stop objects in the GO ODF dictionary
        for GO_obj_data_dic in GO_objects_list:
            GO_object_type = GO_obj_data_dic['_object_type']

            # create a new GO object (coupler or stop) in the GO ODF dictionary
            self.GO_objects_type_nb_dic[GO_object_type] += 1
            GO_object_uid = GO_object_type + str(self.GO_objects_type_nb_dic[GO_object_type]).zfill(3)
            GO_object_dic = self.GO_odf_dic[GO_object_uid] = {}

            # copy in it the current GO object attributes
            for key, value in GO_obj_data_dic.items():
                if key[0] != '_':
                    GO_object_dic[key] = value

            # add the GO switch in the GO object
            if GO_switch_uid != None:
                GO_object_dic['Function'] = 'And'
                GO_object_dic['SwitchCount'] = 1
                GO_object_dic['Switch001'] = GO_switch_uid[-3:]
            else:
                GO_object_dic['DefaultToEngaged'] = 'Y' if HW_switches_data_dic['default_to_engage'] else 'N'

            # add the GO object to the GO Manual to which it belongs
            GO_manual_dic['NumberOf' + GO_object_type + 's'] += 1
            GO_manual_dic[GO_object_type + str(GO_manual_dic['NumberOf' + GO_object_type + 's']).zfill(3)] = GO_object_uid[-3:]

            # write in the HW object the UID of the corresponding GO object
            HW_object_dic['_GO_uid'] = GO_object_uid

    #-------------------------------------------------------------------------------------------------
    def GO_ODF_build_Coupler_object(self, HW_key_action_dic):
        # build a GO Coupler object corresponding to the given HW KeyAction object, without assigning it an UID (i.e. not built in the GO ODF dictionary)
        # return the dictionary of the build Coupler object, or None in case of building issue

        # used HW objects :
        #   KeyAction P> Keyboard P> Division  (source division)
        #   KeyAction C> Keyboard C> Division  (destination division)
        #   KeyAction C> Division              (destination division)

        # get the HW source division of the HW KeyAction
        HW_source_keyboard_dic = self.HW_ODF_get_object_dic_by_ref_id('Keyboard', HW_key_action_dic, 'SourceKeyboardID')
        HW_source_division_dic = self.HW_ODF_get_linked_objects_dic_by_type(HW_source_keyboard_dic, 'Division', TO_PARENT, FIRST_ONE)
        if HW_source_division_dic == None:
            # no existing HW source division/keyboard of the KeyAction, the Coupler cannot be built
            return None

        # get the HW destination division of the HW KeyAction
        HW_dest_division_dic = self.HW_ODF_get_object_dic_by_ref_id('Division', HW_key_action_dic, 'DestDivisionID')
        if HW_dest_division_dic == None:
            HW_dest_keyboard_dic = self.HW_ODF_get_object_dic_by_ref_id('Keyboard', HW_key_action_dic, 'DestKeyboardID')
            if HW_dest_keyboard_dic != None:
                HW_dest_division_dic = self.HW_ODF_get_linked_objects_dic_by_type(HW_dest_keyboard_dic, 'Division', TO_PARENT, FIRST_ONE)
        if HW_dest_division_dic == None:
            # no existing HW destination division/keyboard of the KeyAction, the Coupler cannot be built
            return None

        # get the corresponding GO source and destination Manual UID
        GO_source_manual_uid = HW_source_division_dic['_GO_uid']
        if GO_source_manual_uid == '':
            logs.add(f'INTERNAL ERROR : unable to find the GO source manual for the KeyAction {self.HW_ODF_get_attribute_value(HW_key_action_dic, "Name")}')
            return None

        GO_dest_manual_uid = HW_dest_division_dic['_GO_uid']
        if GO_dest_manual_uid == '':
            logs.add(f'INTERNAL ERROR : unable to find the GO destination manual for the KeyAction {self.HW_ODF_get_attribute_value(HW_key_action_dic, "Name")}')
            return None

        GO_coupler_dic = {}

        GO_coupler_dic['Name'] = self.HW_ODF_get_attribute_value(HW_key_action_dic, 'Name')
        GO_coupler_dic['UnisonOff'] = 'N'
        GO_coupler_dic['DestinationManual'] = GO_dest_manual_uid[-3:]

        first_key = myint(self.HW_ODF_get_attribute_value(HW_key_action_dic, 'MIDINoteNumOfFirstSourceKey'))
        if first_key != None:
            GO_coupler_dic['FirstMIDINoteNumber'] = first_key

        shift = myint(self.HW_ODF_get_attribute_value(HW_key_action_dic, 'MIDINoteNumberIncrement'))
        if shift != None:
            GO_coupler_dic['DestinationKeyshift'] = shift
        else:
            GO_coupler_dic['DestinationKeyshift'] = 0

        GO_coupler_dic['NumberOfKeys'] = myint(self.HW_ODF_get_attribute_value(HW_key_action_dic, 'NumberOfKeys'))
        GO_coupler_dic['CoupleToSubsequentUnisonIntermanualCouplers'] = 'N'
        GO_coupler_dic['CoupleToSubsequentUpwardIntermanualCouplers'] = 'N'
        GO_coupler_dic['CoupleToSubsequentDownwardIntermanualCouplers'] = 'N'
        GO_coupler_dic['CoupleToSubsequentUpwardIntramanualCouplers'] = 'N'
        GO_coupler_dic['CoupleToSubsequentDownwardIntramanualCouplers'] = 'N'

        return GO_coupler_dic

    #-------------------------------------------------------------------------------------------------
    def GO_ODF_build_Stop_pipes_object(self, HW_stop_dic, GO_manual_dic):
        # build a GO Stop object linked to ranks of pipes from the given HW Stop object, without assigning it an UID (i.e. not built in the GO ODF dictionary)
        # return the dictionary of the build Stop object, or None in case of building issue
        # or if there are no pipes linked to this Stop (case of demo sample sets for some stops not included in the demo)

        # used HW objects :
        #   Stop
        #   Stop C> StopRank(s) (ActionTypeCode = 1, ActionEffectCode = 1) C> Rank C> Pipe_SoundEngine01 ... (in function GO_ODF_build_Rank_data_out_stop)

        # create a new GO Stop object
        GO_stop_dic = {}

        GO_stop_dic['Name'] = self.HW_ODF_get_attribute_value(HW_stop_dic, 'Name')

        # fill the rank attributes of the stop
        self.GO_ODF_build_Rank_data_out_stop(HW_stop_dic, GO_stop_dic, GO_manual_dic)

        if GO_stop_dic['NumberOfAccessiblePipes'] == 0:
            # no pipe accessible for the built stop
            return None
        else:
            return GO_stop_dic

    #-------------------------------------------------------------------------------------------------
    def GO_ODF_build_Stop_noise_object(self, HW_pipe_dic, object_name, attack_bool):
        # build a GO Stop object containing a noise sample from the given HW Pipe_SoundEngine01 object, without assigning it an UID (i.e. not built in the GO ODF dictionary)
        # give to the GO Stop the given object name
        # the noise sample building is made depenting on the attack status (attack or release sample)
        # return the dictionary of the build Stop object, or None if no HW pipe provided

        # used HW objects :
        #   Pipe_SoundEngine01 C> Pipe_SoundEngine01_Layer C> Pipe_SoundEngine01_AttackSample C> Sample   (in function GO_ODF_build_Rank_data_in_stop)
        #   Pipe_SoundEngine01 C> Pipe_SoundEngine01_Layer C> Pipe_SoundEngine01_ReleaseSample C> Sample  (in function GO_ODF_build_Rank_data_in_stop)

        if HW_pipe_dic != None:
            # create a new GO Stop object
            GO_stop_dic = {}
            GO_stop_dic['Name'] = ''

            # fill the GO stop dictionary with the data of the provided HW Pipe_SoundEngine01 object
            self.GO_ODF_build_Rank_data_in_stop(HW_pipe_dic, GO_stop_dic, attack_bool)

            if attack_bool == None:
                # unknown if attack or release
                if 'Pipe001ReleaseCount' in GO_stop_dic.keys():
                    # it is a release noise
                    GO_stop_dic['Name'] = object_name + ' (off noise)'
                else:
                    GO_stop_dic['Name'] = object_name + ' (on noise)'
            elif attack_bool == False:
                GO_stop_dic['Name'] = object_name + ' (off noise)'
            elif attack_bool == True:
                GO_stop_dic['Name'] = object_name + ' (on noise)'

            return GO_stop_dic
        else:
            return None

    #-------------------------------------------------------------------------------------------------
    def GO_ODF_build_Stop_keys_noise_object(self, HW_object_dic, GO_manual_dic, attack_bool):
        # try to build GO Stop data with rank data inside for keyboard keys action noise rendering from the given HW object (Stop or Keyboard)

        # used HW objects :
        #   attack noise (key press) :
        #      Stop C> StopRank(s) (ActionTypeCode = 1, ActionEffectCode = 2) C> Rank C> Pipe_SoundEngine01 ...
        #      Keyboard C> KeyboardKey P> Switch C> SwitchLinkage (EngageLinkActionCode=4, DisengageLinkActionCode=7) C> Switch C> Pipe_SoundEngine01 ...
        #      Keyboard C> KeyboardKey P> Switch C> Pipe_SoundEngine01 C> Pipe_SoundEngine01Layer C> Pipe_SoundEngine01_AttackSample ...
        #   release noise (key release) :
        #      Stop C> StopRank(s) (ActionTypeCode = 1, ActionEffectCode = 3) C> Rank C> Pipe_SoundEngine01 ...
        #      Keyboard C> KeyboardKey P> Switch C> SwitchLinkage (EngageLinkActionCode=7, DisengageLinkActionCode=4) C> Switch C> Pipe_SoundEngine01 ...
        #      Keyboard C> KeyboardKey P> Switch C> Pipe_SoundEngine01 C> Pipe_SoundEngine01Layer C> Pipe_SoundEngine01_AttackSample + Pipe_SoundEngine01_ReleaseSample ...

        pass # TO BE DONE, low priority

    #-------------------------------------------------------------------------------------------------
    def GO_ODF_build_Switch_object(self, HW_switch_dic, linked_GO_switch_uid = None, switch_name = None):
        # build a GO Switch with the properties of the given HW Switch if no linked GO switch provided, only if it is has graphical properties and is not a keyboard key switch
        # build a GO Panel999Element999 object with type=Switch corresponding to the given HW Switch and in the proper GO Panel
        # link the Panel999Element999 to the build Switch or to the linked GO switch if provided
        # give to the GO Switch the given switch name if provided
        # return the UID of the added GO Switch or the linked GO Switch if provided

        # used HW objects :
        #   Switch C> ImageSetInstance

        # get the HW ImageSetInstance object associated to the given HW Switch object if any
        HW_img_set_inst_dic = self.HW_ODF_get_object_dic_by_ref_id('ImageSetInstance', HW_switch_dic, 'Disp_ImageSetInstanceID')
        # get the ID of the HW display page in which the switch is displayed if any
        HW_switch_disp_page_id = myint(self.HW_ODF_get_attribute_value(HW_img_set_inst_dic, 'DisplayPageID', MANDATORY))
        # get the HW KeyboardKey children object of the given HW Switch object if any
        HW_keyboard_key_dic = self.HW_ODF_get_linked_objects_dic_by_type(HW_switch_dic, 'KeyboardKey', TO_CHILD, FIRST_ONE)

        if HW_switch_disp_page_id == None or HW_img_set_inst_dic == None or HW_keyboard_key_dic != None:
            # this HW Switch object has no display page ID or is not referencing a HW ImageSetInstance object or is controlling a HW KeyboardKey object
            # it is ignored
            GO_switch_uid = linked_GO_switch_uid
            return GO_switch_uid

        # if the given HW Switch is already associated to a GO Switch, consider this GO Switch as a linked switch
        if HW_switch_dic['_GO_uid'] != '' and HW_switch_dic['_GO_uid'] != None:
            linked_GO_switch_uid = HW_switch_dic['_GO_uid']

        if switch_name == None:
            switch_name = self.HW_ODF_get_attribute_value(HW_switch_dic, 'Name')

        if linked_GO_switch_uid == None:
            # new GO Switch999 to create
            self.GO_odf_dic['Organ']['NumberOfSwitches'] += 1
            GO_switch_uid = 'Switch' + str(self.GO_odf_dic['Organ']['NumberOfSwitches']).zfill(3)
            GO_switch_dic = self.GO_odf_dic[GO_switch_uid] = {}

            GO_switch_dic['Name'] = switch_name

            if self.HW_ODF_get_attribute_value(HW_switch_dic, 'DefaultToEngaged') != None:
                GO_switch_dic['DefaultToEngaged'] = self.HW_ODF_get_attribute_value(HW_switch_dic, 'DefaultToEngaged')
            else:
                GO_switch_dic['DefaultToEngaged'] = 'N'
            GO_switch_dic['StoreInDivisional'] = 'Y'
            GO_switch_dic['StoreInGeneral'] = 'Y'
            GO_switch_dic['GCState'] = 0

        else:
            # no new GO Switch999 to create, we use the UID of the given linked switch
            GO_switch_uid = linked_GO_switch_uid
            GO_switch_dic = self.GO_odf_dic[linked_GO_switch_uid]

        # build a new GO Panel999Element999 object with Type=Switch

        # recover the GO panel UID corresponding to the HW display page ID of the switch
        HW_disp_page_dic = self.HW_ODF_get_object_dic('DisplayPage', HW_switch_disp_page_id)
        GO_panel_uid = HW_disp_page_dic['_GO_uid']

        # create the GO Panel999Element999 switch object to display the switch in it
        self.GO_odf_dic[GO_panel_uid]['NumberOfGUIElements'] += 1
        GO_panel_element_uid = GO_panel_uid + 'Element' + str(self.GO_odf_dic[GO_panel_uid]['NumberOfGUIElements']).zfill(3)
        GO_panel_element_dic = self.GO_odf_dic[GO_panel_element_uid] = {}

        GO_panel_element_dic['Type'] = 'Switch'
        GO_panel_element_dic['Switch'] = str(int(GO_switch_uid[-3:])).zfill(3)
        GO_panel_element_dic['DispLabelText'] = ''

        # get the index of the switch image for OFF and ON positions
        switch_off_img_index = myint(self.HW_ODF_get_attribute_value(HW_switch_dic, 'Disp_ImageSetIndexDisengaged'))
        switch_on_img_index = myint(self.HW_ODF_get_attribute_value(HW_switch_dic, 'Disp_ImageSetIndexEngaged'))
        if switch_off_img_index == None: switch_off_img_index = '1'
        if switch_on_img_index == None: switch_on_img_index = '1'

        # set the attributes of the switch OFF image
        image_attr_dic = {}
        self.HW_ODF_get_image_attributes(HW_img_set_inst_dic, image_attr_dic, switch_off_img_index)
        GO_panel_element_dic['PositionX'] = image_attr_dic['LeftXPosPixels']
        GO_panel_element_dic['PositionY'] = image_attr_dic['TopYPosPixels']
        if image_attr_dic['ImageWidthPixels'] != None:
            GO_panel_element_dic['Width'] = image_attr_dic['ImageWidthPixels']
        if image_attr_dic['ImageHeightPixels'] != None:
            GO_panel_element_dic['Height'] = image_attr_dic['ImageHeightPixels']

        # set the mouse clickable area
        if image_attr_dic['ClickableAreaLeftRelativeXPosPixels'] != None:
            GO_panel_element_dic['MouseRectLeft'] = image_attr_dic['ClickableAreaLeftRelativeXPosPixels']
        if image_attr_dic['ClickableAreaTopRelativeYPosPixels'] != None:
            GO_panel_element_dic['MouseRectTop'] = image_attr_dic['ClickableAreaTopRelativeYPosPixels']
        if image_attr_dic['ClickableAreaRightRelativeXPosPixels'] != None:
            GO_panel_element_dic['MouseRectWidth'] = image_attr_dic['ClickableAreaRightRelativeXPosPixels']
        if image_attr_dic['ClickableAreaBottomRelativeYPosPixels'] != None:
            GO_panel_element_dic['MouseRectHeight'] = image_attr_dic['ClickableAreaBottomRelativeYPosPixels']
        GO_panel_element_dic['MouseRadius'] = 0

        if image_attr_dic['BitmapFilename'] != None:
            GO_panel_element_dic['ImageOff'] = image_attr_dic['BitmapFilename']
        if image_attr_dic['TransparencyMaskBitmapFilename'] != None:
            GO_panel_element_dic['MaskOff'] = image_attr_dic['TransparencyMaskBitmapFilename']

        # set the attributes of the switch ON image
        image_attr_dic = {}
        self.HW_ODF_get_image_attributes(HW_img_set_inst_dic, image_attr_dic, switch_on_img_index)
        if image_attr_dic['BitmapFilename'] != None:
            GO_panel_element_dic['ImageOn'] = image_attr_dic['BitmapFilename']
        if image_attr_dic['TransparencyMaskBitmapFilename'] != None:
            GO_panel_element_dic['MaskOn'] = image_attr_dic['TransparencyMaskBitmapFilename']

        # add in the HW Switch object the ID of the corresponding GO object
        HW_img_set_inst_dic['_GO_uid'] = GO_panel_element_uid

        # add in the HW Switch object the ID of the corresponding GO object
        HW_switch_dic['_GO_uid'] = GO_switch_uid

        return GO_switch_uid

    #-------------------------------------------------------------------------------------------------
    def GO_ODF_build_Rank_data_in_stop(self, HW_pipe_dic, GO_stop_dic, attack_bool):
        # build one pipe data (for noise effect) in the given GO Stop from the given HW Pipe_SoundEngine01, depending on the provided noise attack status

        # used HW objects :
        #   Pipe_SoundEngine01 C> Pipe_SoundEngine01_Layer C> Pipe_SoundEngine01_AttackSample C> Sample
        #   Pipe_SoundEngine01 C> Pipe_SoundEngine01_Layer C> Pipe_SoundEngine01_ReleaseSample C> Sample

        # get the source HW WindCompartment of the given HW Pipe
        HW_wind_comp_dic = self.HW_ODF_get_object_dic_by_ref_id('WindCompartment', HW_pipe_dic, 'WindSupply_SourceWindCompartmentID')
        # get the HW ScalingContinuousControlID of the current layer of the first pipe to use it as GO Enclosure of the whole GO Rank if any
        HW_pipe_layer_dic = self.HW_ODF_get_linked_objects_dic_by_type(HW_pipe_dic, 'Pipe_SoundEngine01_Layer', TO_CHILD, FIRST_ONE)
        HW_cont_ctrl_dic = self.HW_ODF_get_object_dic_by_ref_id('ContinuousControl', HW_pipe_layer_dic, 'AmpLvl_ScalingContinuousControlID')

        GO_windchest_uid = self.GO_ODF_build_WindchestGroup_object(HW_wind_comp_dic, HW_cont_ctrl_dic, None)
        GO_stop_dic['WindchestGroup'] = int(GO_windchest_uid[-3:])

        GO_stop_dic['FirstAccessiblePipeLogicalKeyNumber'] = 1
        GO_stop_dic['FirstAccessiblePipeLogicalPipeNumber'] = 1
        GO_stop_dic['NumberOfAccessiblePipes'] = 1
        GO_stop_dic['NumberOfLogicalPipes'] = 1
        GO_stop_dic['Percussive'] = 'N'
        GO_stop_dic['AcceptsRetuning'] = 'N'

        # get the first HW Pipe_SoundEngine01_Layer linked to the given HW Pipe_SoundEngine01 (the others if any are ignored)
        HW_pipe_layer_dic = self.HW_ODF_get_linked_objects_dic_by_type(HW_pipe_dic, 'Pipe_SoundEngine01_Layer', TO_CHILD, FIRST_ONE)

        # get the pipe gain if any
        pipe_gain = myfloat(self.HW_ODF_get_attribute_value(HW_pipe_layer_dic, 'AmpLvl_LevelAdjustDecibels'))
        if pipe_gain != None and pipe_gain != 0:
            GO_stop_dic['Pipe001Gain'] = pipe_gain

        # get the pipe harmonic number if any
        pipe_harmonic_nb = myint(self.HW_ODF_get_attribute_value(HW_pipe_dic, 'Pitch_Tempered_RankBasePitch64ftHarmonicNum'))
        if pipe_harmonic_nb != None and pipe_harmonic_nb != 0:
            GO_stop_dic['Pipe001HarmonicNumber'] = pipe_harmonic_nb

        HW_pipe_attack_samples_list = self.HW_ODF_get_linked_objects_dic_by_type(HW_pipe_layer_dic, 'Pipe_SoundEngine01_AttackSample', TO_CHILD)
        HW_pipe_release_samples_list = self.HW_ODF_get_linked_objects_dic_by_type(HW_pipe_layer_dic, 'Pipe_SoundEngine01_ReleaseSample', TO_CHILD)

        if attack_bool == False and len(HW_pipe_release_samples_list) == 0:
            # release noise but no HW release samples : use the attack samples as release samples
            HW_pipe_release_samples_list = HW_pipe_attack_samples_list
            HW_pipe_attack_samples_list = []
            # use a silent loop sample as attack sample
            GO_stop_dic['Pipe001'] = '..' + os.sep + 'SilentLoop.wav'
            self.silent_loop_file_used = True

        # define the attack pipes
        attacks_number = 0
        for HW_pipe_attack_sample_dic in HW_pipe_attack_samples_list:
            # parse the HW Pipe_SoundEngine01_AttackSample child objects of the Pipe_SoundEngine01_Layer object
            HW_sample_dic = self.HW_ODF_get_linked_objects_dic_by_type(HW_pipe_attack_sample_dic, 'Sample', TO_CHILD, FIRST_ONE)
            if HW_sample_dic != None:
                attacks_number += 1
                HW_install_package_id = myint(self.HW_ODF_get_attribute_value(HW_sample_dic, 'InstallationPackageID', MANDATORY))
                sample_file_name = self.convert_HW2GO_file_name(self.HW_ODF_get_attribute_value(HW_sample_dic, 'SampleFilename', MANDATORY), HW_install_package_id)
                if sample_file_name != None:
                    if attacks_number == 1:
                        GO_stop_dic['Pipe001'] = sample_file_name
                    else:
                        GO_stop_dic['Pipe001AttackCount'] = attacks_number - 1
                        GO_stop_dic['Pipe001Attack' + str(attacks_number - 1).zfill(3)] = sample_file_name

        if len(HW_pipe_release_samples_list) > 0:
            GO_stop_dic['Pipe001LoadRelease'] = 'N'
        else:
            GO_stop_dic['Pipe001LoadRelease'] = 'Y'

        # define the release pipes
        if len(HW_pipe_release_samples_list) > 0:
            GO_stop_dic['Pipe001ReleaseCount'] = 0
        for HW_pipe_release_sample_dic in HW_pipe_release_samples_list:
            HW_sample_dic = self.HW_ODF_get_linked_objects_dic_by_type(HW_pipe_release_sample_dic, 'Sample', TO_CHILD, FIRST_ONE)
            if HW_sample_dic != None:
                HW_install_package_id = myint(self.HW_ODF_get_attribute_value(HW_sample_dic, 'InstallationPackageID', MANDATORY))
                sample_file_name = self.convert_HW2GO_file_name(self.HW_ODF_get_attribute_value(HW_sample_dic, 'SampleFilename', MANDATORY), HW_install_package_id)
                if sample_file_name != None:
                    GO_stop_dic['Pipe001ReleaseCount'] += 1
                    GO_stop_dic['Pipe001Release' + str(GO_stop_dic['Pipe001ReleaseCount']).zfill(3)] = sample_file_name

    #-------------------------------------------------------------------------------------------------
    def GO_ODF_build_Rank_data_out_stop(self, HW_stop_dic, GO_stop_dic, GO_manual_dic):
        # build in the given GO Stop dictionary the data and links to GO Rank(s) for pipes sound generation from the given HW Stop object

        # used HW objects :
        #   Stop C> StopRank(s) (ActionTypeCode = 1, ActionEffectCode = 1) C> Rank C> Pipe_SoundEngine01 C> Pipe_SoundEngine01_Layer C> Pipe_SoundEngine01_AttackSample C> Sample
        #   Stop C> StopRank(s) (ActionTypeCode = 1, ActionEffectCode = 1) C> Rank C> Pipe_SoundEngine01 C> Pipe_SoundEngine01_Layer C> Pipe_SoundEngine01_ReleaseSample C> Sample

        # get some data about the GO manual to which is attached the GO Stop
        manual_first_midi_note = GO_manual_dic['FirstAccessibleKeyMIDINoteNumber']
        manual_nb_keys = GO_manual_dic['NumberOfLogicalKeys']

        GO_stop_dic['NumberOfAccessiblePipes'] = 0
        GO_stop_dic['FirstAccessiblePipeLogicalKeyNumber'] = 0
        GO_stop_dic['NumberOfRanks'] = 0
        GO_stop_nb_ranks = 0

        # add inside the given GO Stop references to GO Ranks
        for HW_stop_rank_dic in self.HW_ODF_get_linked_objects_dic_by_type(HW_stop_dic, 'StopRank', TO_CHILD):
            # parse the HW StopRank objects which are children of the given HW Stop object

            # get some data of the current StopRank
            HW_div_nb_mapped_inputs = myint(self.HW_ODF_get_attribute_value(HW_stop_rank_dic, 'NumberOfMappedDivisionInputNodes'))
            if HW_div_nb_mapped_inputs == None: HW_div_nb_mapped_inputs = 61  # observed with HW Augustine Lorris sample set, this data is not defined for the Larigot stop
            HW_div_midi_note_first_mapped_input = myint(self.HW_ODF_get_attribute_value(HW_stop_rank_dic, 'MIDINoteNumOfFirstMappedDivisionInputNode'))
            HW_div_midi_note_increment_to_rank = myint(self.HW_ODF_get_attribute_value(HW_stop_rank_dic, 'MIDINoteNumIncrementFromDivisionToRank'))

            if HW_div_midi_note_first_mapped_input != None and HW_div_midi_note_first_mapped_input < manual_first_midi_note:
                # the first note of the current StopRank starts before the first note of the manual
                # set it at the first note of the manual and compute accordingly the number of notes of the StopRank
                HW_div_midi_note_first_mapped_input = manual_first_midi_note
                HW_div_nb_mapped_inputs -= manual_first_midi_note - HW_div_midi_note_first_mapped_input

            # get the HW Rank linked to the current HW StopRank
            HW_rank_dic = self.HW_ODF_get_object_dic_by_ref_id('Rank', HW_stop_rank_dic, 'RankID')

            # get the list of the HW Pipe_SoundEngine01 objects which are children of the current HW Rank object
            HW_pipes_dic_list = self.HW_ODF_get_linked_objects_dic_by_type(HW_rank_dic, 'Pipe_SoundEngine01', TO_CHILD)
            if (len(HW_pipes_dic_list) > 0 and
                myint(self.HW_ODF_get_attribute_value(HW_stop_rank_dic, 'ActionTypeCode')) == 1 and
                myint(self.HW_ODF_get_attribute_value(HW_stop_rank_dic, 'ActionEffectCode')) == 1):
                # the current StopRank has normal action codes and is linked to a Rank having at least one pipe inside

                # get the number of pipes layers defined inside the first pipe of the current HW rank
                # we consider that all the pipes of the HW rank have the same number of layers as the first pipe has
                HW_pipe1_layers_dic_list = self.HW_ODF_get_linked_objects_dic_by_type(HW_pipes_dic_list[0], 'Pipe_SoundEngine01_Layer', TO_CHILD)
                nb_pipe1_layers = len(HW_pipe1_layers_dic_list)

                for pipes_layer_nb in range(0, nb_pipe1_layers):
                    # parse the pipes layers of the current HW rank, to build one GO rank for each HW rank layer

                    # get in the HW Pipe_SoundEngine01_Layer of the current layer of the first pipe the UID of the GO Rank associated to it
                    GO_rank_uid = HW_pipe1_layers_dic_list[pipes_layer_nb]['_GO_uid']
                    if GO_rank_uid == '':
                        # there is not yet a GO Rank built for the current HW rank layer
                        GO_rank_uid = self.GO_ODF_build_Rank_object(HW_rank_dic, pipes_layer_nb)
                    GO_rank_dic = self.GO_odf_dic[GO_rank_uid]

                    # add the GO Rank to the GO Stop
                    GO_stop_nb_ranks += 1
                    GO_stop_dic['Rank' + str(GO_stop_nb_ranks).zfill(3)] = GO_rank_uid[-3:]

                    # convert the current HW StopRank data into GO Stop data
                    if HW_div_midi_note_increment_to_rank != None:
                        # there is a note increment between the manual key number and the rank pipe number
                        if HW_div_midi_note_first_mapped_input != None:
                            GO_rank_first_access_key_nb = HW_div_midi_note_first_mapped_input - manual_first_midi_note + 1
                            GO_stop_rank_first_pipe_nb = HW_div_midi_note_first_mapped_input + HW_div_midi_note_increment_to_rank - GO_rank_dic['FirstMidiNoteNumber'] + 1
                        else:
                            if HW_div_midi_note_increment_to_rank < 0:
                                GO_rank_first_access_key_nb = 1 - HW_div_midi_note_increment_to_rank
                            else:
                                GO_rank_first_access_key_nb = 1
                            GO_stop_rank_first_pipe_nb = GO_rank_first_access_key_nb + HW_div_midi_note_increment_to_rank
                    elif HW_div_midi_note_first_mapped_input != None:
                        # there is no note increment defined but there is a mapping defined for the first input of the division which can act on the rank
                        GO_rank_first_access_key_nb = HW_div_midi_note_first_mapped_input - manual_first_midi_note + 1
                        GO_stop_rank_first_pipe_nb = HW_div_midi_note_first_mapped_input - GO_rank_dic['FirstMidiNoteNumber'] + 1
                    else:
                        # no increment and no mapping defined, by default the first key of the keyboard acts on the first pipe of the rank for this stop
                        GO_rank_first_access_key_nb = 1
                        GO_stop_rank_first_pipe_nb = 1

                    GO_stop_rank_pipe_count = HW_div_nb_mapped_inputs
                    if GO_stop_rank_pipe_count > GO_rank_dic['NumberOfLogicalPipes']:
                        # the stop is using more pipes than what is defined in the rank
                        GO_stop_rank_pipe_count = GO_rank_dic['NumberOfLogicalPipes']
                    if GO_rank_first_access_key_nb + GO_stop_rank_pipe_count - 1 > manual_nb_keys:
                        # the rank range is going beyond the highest key of the manual (observed with a sample set) : reduce its number of accessible pipes
                        GO_stop_rank_pipe_count = manual_nb_keys - GO_rank_first_access_key_nb + 1

                    GO_stop_dic[f'Rank{str(GO_stop_nb_ranks).zfill(3)}PipeCount'] = GO_stop_rank_pipe_count
                    GO_stop_dic[f'Rank{str(GO_stop_nb_ranks).zfill(3)}FirstAccessibleKeyNumber'] = GO_rank_first_access_key_nb
                    GO_stop_dic[f'Rank{str(GO_stop_nb_ranks).zfill(3)}FirstPipeNumber'] = GO_stop_rank_first_pipe_nb

                    # add in the HW StopRank object the UID of the corresponding GO object
                    HW_stop_rank_dic['_GO_uid'] = GO_rank_uid

        if GO_stop_nb_ranks > 0:
            # based on the Rank999xxx attributes created just before in the GO Stop for each HW StopRank, compute remaining attributes of the GO Stop
            # identify the first and last keys of the manual which can access to the ranks associated to the stop
            GO_stop_first_access_key_nb = 999
            GO_stop_last_access_key_nb = 0
            for r in range(1, GO_stop_nb_ranks + 1):
                rank_first_key = GO_stop_dic[f'Rank{str(r).zfill(3)}FirstAccessibleKeyNumber']
                rank_last_key = rank_first_key + GO_stop_dic[f'Rank{str(r).zfill(3)}PipeCount'] - 1
                if GO_stop_first_access_key_nb > rank_first_key:
                    GO_stop_first_access_key_nb = rank_first_key
                if GO_stop_last_access_key_nb < rank_last_key:
                    GO_stop_last_access_key_nb = rank_last_key

            GO_stop_dic['FirstAccessiblePipeLogicalKeyNumber'] = GO_stop_first_access_key_nb
            GO_stop_dic['NumberOfAccessiblePipes'] = GO_stop_last_access_key_nb - GO_stop_first_access_key_nb + 1
            GO_stop_dic['NumberOfRanks'] = GO_stop_nb_ranks

            # adjust the Rank999FirstAccessibleKeyNumber attributes so that it is an offset value compated to FirstAccessiblePipeLogicalKeyNumber and no more an absolute value
            for r in range(1, GO_stop_nb_ranks + 1):
                GO_stop_dic[f'Rank{str(r).zfill(3)}FirstAccessibleKeyNumber'] -= (GO_stop_dic['FirstAccessiblePipeLogicalKeyNumber'] - 1)

        else:
            # none rank build thanks to StopRank objects
            HW_rank_id = myint(self.HW_ODF_get_attribute_value(HW_stop_dic, 'Hint_PrimaryAssociatedRankID'))
            HW_rank_dic = self.HW_ODF_get_object_dic('Rank', HW_rank_id)
            if HW_rank_dic != None:
                # the given HW Stop is linked to one Rank through the Hint attribute

                # get the list of the HW Pipe_SoundEngine01 objects which are children of the HW Rank
                HW_pipes_dic_list = self.HW_ODF_get_linked_objects_dic_by_type(HW_rank_dic, 'Pipe_SoundEngine01', TO_CHILD)
                if len(HW_pipes_dic_list) > 0:
                    # the Rank has at least one pipe inside

                    # get the number of pipes layers defined inside the first pipe of the HW rank
                    # we consider that all the pipes of the HW rank have the same number of layers as the first pipe has
                    HW_pipe1_layers_dic_list = self.HW_ODF_get_linked_objects_dic_by_type(HW_pipes_dic_list[0], 'Pipe_SoundEngine01_Layer', TO_CHILD)
                    nb_pipe1_layers = len(HW_pipe1_layers_dic_list)

                    for pipes_layer_nb in range(0, nb_pipe1_layers):
                        # parse the pipes layers of the current HW rank, to build one GO rank for each HW rank layer

                        # get in the HW Pipe_SoundEngine01_Layer of the current layer of the first pipe the UID of the GO Rank associated to it
                        GO_rank_uid = HW_pipe1_layers_dic_list[pipes_layer_nb]['_GO_uid']
                        if GO_rank_uid == '':
                            # there is not yet a GO Rank built for the current HW rank layer
                            GO_rank_uid = self.GO_ODF_build_Rank_object(HW_rank_dic, pipes_layer_nb)
                        GO_rank_dic = self.GO_odf_dic[GO_rank_uid]

                        # add the GO Rank to the GO Stop
                        GO_stop_nb_ranks += 1
                        GO_stop_dic['Rank' + str(GO_stop_nb_ranks).zfill(3)] = GO_rank_uid[-3:]
                        GO_stop_dic[f'Rank{str(GO_stop_nb_ranks).zfill(3)}PipeCount'] = len(HW_pipes_dic_list)
                        GO_stop_dic[f'Rank{str(GO_stop_nb_ranks).zfill(3)}FirstAccessibleKeyNumber'] = 1
                        GO_stop_dic[f'Rank{str(GO_stop_nb_ranks).zfill(3)}FirstPipeNumber'] = 1

                        GO_stop_dic['FirstAccessiblePipeLogicalKeyNumber'] = 1
                        GO_stop_dic['NumberOfAccessiblePipes'] = len(HW_pipes_dic_list)
                        GO_stop_dic['NumberOfRanks'] = 1

    #-------------------------------------------------------------------------------------------------
    def GO_ODF_build_Rank_object(self, HW_rank_dic, pipes_layer_nb, unused_rank_bool=False):
        # build the GO Rank object from the given HW Rank object and its given layer number
        # if unused_rank_bool is set at false, manage the HW Rank as an unused rank (only pipes ranks are build in this case)
        # return the dictionary of the build GO Rank or None if not created

        # used HW objects :
        #   WindCompartment C> Pipe_SoundEngine01
        #   Rank C> Pipe_SoundEngine01 C> Pipe_SoundEngine01_Layer C> Pipe_SoundEngine01_AttackSample C> Sample
        #   Rank C> Pipe_SoundEngine01 C> Pipe_SoundEngine01_Layer C> Pipe_SoundEngine01_ReleaseSample C> Sample

        GO_rank_uid = ''

        # get the list of the HW Pipe_SoundEngine01 objects which are children of the given HW Rank
        HW_pipes_dic_list = self.HW_ODF_get_linked_objects_dic_by_type(HW_rank_dic, 'Pipe_SoundEngine01', TO_CHILD)
        if len(HW_pipes_dic_list) > 0:
            # the current HW rank has pipes defined inside

            if unused_rank_bool:
                base_tuning_scheme_code = myint(self.HW_ODF_get_attribute_value(HW_pipes_dic_list[0], 'Pitch_Tempered_BaseTuningSchemeCode'))
                base_pitch_harmonic_num = myint(self.HW_ODF_get_attribute_value(HW_pipes_dic_list[0], 'Pitch_Tempered_RankBasePitch64ftHarmonicNum'))
                if base_tuning_scheme_code == 4 or base_pitch_harmonic_num == None or 'NOISE' in HW_rank_dic['Name'].upper():
                    # it is a noise rank, this rank to ignore if unused in GO ODF
                    return ''

            # get the number of pipes layers defined inside the first pipe of the given HW rank
            # we consider that all the pipes of the HW rank have the same number of layers as the first pipe
            HW_pipe1_layers_dic_list = self.HW_ODF_get_linked_objects_dic_by_type(HW_pipes_dic_list[0], 'Pipe_SoundEngine01_Layer', TO_CHILD)
            nb_pipe1_layers = len(HW_pipe1_layers_dic_list)

            # get the first and last MIDI note numbers defined in the HW Pipe_SoundEngine01 of the given HW Rank
            first_midi_note_nb = 999
            last_midi_note_nb = 0
            pipes_dic = {}  # dictionary with as key a MIDI note number and as value the dictionary of the associated Pipe_SoundEngine01 object
            for HW_pipe_dic in HW_pipes_dic_list:
                # parse the Pipe_SoundEngine01 objects of the current HW Rank

                # get the MIDI note number of the current HW Pipe_SoundEngine01
                midi_note_nb = myint(self.HW_ODF_get_attribute_value(HW_pipe_dic, 'NormalMIDINoteNumber'))
                if midi_note_nb == None: midi_note_nb = 60 # observed with Sound Paradisi sample sets, the MIDI note 60 is not defined
                if midi_note_nb >= 36:
                    # notes under MIDI 36 are ignored
                    # update the first/last MIDI note number data
                    if midi_note_nb < first_midi_note_nb:
                        first_midi_note_nb = midi_note_nb
                    if midi_note_nb > last_midi_note_nb:
                        last_midi_note_nb = midi_note_nb

                    # associate the dictionary of the current pipe to its MIDI note number
                    pipes_dic[midi_note_nb] = HW_pipe_dic

            # create a GO Rank999 object
            self.GO_odf_dic['Organ']['NumberOfRanks'] += 1
            GO_rank_uid = 'Rank' + str(self.GO_odf_dic['Organ']['NumberOfRanks']).zfill(3)
            GO_rank_dic = self.GO_odf_dic[GO_rank_uid] = {}

            if nb_pipe1_layers < 2:
                GO_rank_dic['Name'] = self.HW_ODF_get_attribute_value(HW_rank_dic, 'Name')
            else:
                GO_rank_dic['Name'] = self.HW_ODF_get_attribute_value(HW_rank_dic, 'Name') + ' Layer' + str(pipes_layer_nb + 1)

            if unused_rank_bool:
                GO_rank_dic['Name'] += ' UNUSED'

            GO_rank_dic['NumberOfLogicalPipes'] = len(pipes_dic)
            GO_rank_dic['FirstMidiNoteNumber'] = first_midi_note_nb
            GO_rank_dic['Percussive'] = 'N'
            GO_rank_dic['AcceptsRetuning'] = 'N'

            # get the source HW WindCompartment of the first pipe to use it as GO WindchestGroup of the whole GO Rank
            HW_wind_comp_dic = self.HW_ODF_get_object_dic_by_ref_id('WindCompartment', HW_pipes_dic_list[0], 'WindSupply_SourceWindCompartmentID')
            # get the HW scaling ContinuousControl of the first pipe of the current layer to use it as GO Enclosure of the whole GO Rank if any
            HW_pipe_layers_dic_list = self.HW_ODF_get_linked_objects_dic_by_type(HW_pipes_dic_list[0], 'Pipe_SoundEngine01_Layer', TO_CHILD)
            HW_pipe_layer_dic = HW_pipe_layers_dic_list[pipes_layer_nb]
            HW_cont_ctrl_dic = self.HW_ODF_get_object_dic_by_ref_id('ContinuousControl', HW_pipe_layer_dic, 'AmpLvl_ScalingContinuousControlID')
            # get the HW Enclosure of the first pipe to use it as GO Enclosure of the whole GO Rank if any
            HW_enclosure_pipe_dic = self.HW_ODF_get_linked_objects_dic_by_type(HW_pipes_dic_list[0], 'EnclosurePipe', TO_PARENT, FIRST_ONE)
            HW_enclosure_dic = self.HW_ODF_get_object_dic_by_ref_id('Enclosure', HW_enclosure_pipe_dic, 'EnclosureID')
            # create the GO WindchestGroup corresponding to the current HW WindCompartment + ContinuousControl + Enclosure
            #   if not already existing, else recover the UID of the existing associated GO WindchestGroup
            GO_windchest_uid = self.GO_ODF_build_WindchestGroup_object(HW_wind_comp_dic, HW_cont_ctrl_dic, HW_enclosure_dic)
            GO_rank_dic['WindchestGroup'] = int(GO_windchest_uid[-3:])

            nb_pipes = 0
            for midi_note_nb in range(first_midi_note_nb, last_midi_note_nb + 1):
                # parse the HW Pipe_SoundEngine01_Layer objects by increasing MIDI note number

                if midi_note_nb in pipes_dic.keys():
                    HW_pipe_dic = pipes_dic[midi_note_nb]

                    # get the dictionary of the HW Pipe_SoundEngine01_Layer child of the current HW Pipe_SoundEngine01_Layer
                    # and corresponding to the given pipes layer number
                    HW_pipe_layers_dic_list = self.HW_ODF_get_linked_objects_dic_by_type(HW_pipe_dic, 'Pipe_SoundEngine01_Layer', TO_CHILD)
                    HW_pipe_layer_dic = HW_pipe_layers_dic_list[pipes_layer_nb]

                    # add in the HW Pipe_SoundEngine01_Layer the ID of the corresponding GO object
                    HW_pipe_layer_dic['_GO_uid'] = GO_rank_uid

                    # set the GO pipe ID
                    nb_pipes += 1
                    GO_pipe_uid = 'Pipe' + str(nb_pipes).zfill(3)

                    # get the pipe gain if any
                    pipe_gain = myfloat(self.HW_ODF_get_attribute_value(HW_pipe_layer_dic, 'AmpLvl_LevelAdjustDecibels'))
                    if pipe_gain != None and pipe_gain != 0:
                        GO_rank_dic[GO_pipe_uid + 'Gain'] = pipe_gain

                    # set the MIDI not number of the current pipe
                    GO_rank_dic[GO_pipe_uid + 'MIDIKeyNumber'] = midi_note_nb

                    # get the pipe harmonic number if any
                    pipe_harmonic_nb = myint(self.HW_ODF_get_attribute_value(HW_pipe_dic, 'Pitch_Tempered_RankBasePitch64ftHarmonicNum'))
                    if pipe_harmonic_nb != None and pipe_harmonic_nb != 0:
                        GO_rank_dic[GO_pipe_uid + 'HarmonicNumber'] = pipe_harmonic_nb

                    GO_rank_dic[GO_pipe_uid + 'LoadRelease'] = 'N'

                    # manage the attack samples
                    for HW_pipe_attack_sample_dic in self.HW_ODF_get_linked_objects_dic_by_type(HW_pipe_layer_dic, 'Pipe_SoundEngine01_AttackSample', TO_CHILD):
                        HW_sample_dic = self.HW_ODF_get_linked_objects_dic_by_type(HW_pipe_attack_sample_dic, 'Sample', TO_CHILD, FIRST_ONE)

                    HW_install_package_id = myint(self.HW_ODF_get_attribute_value(HW_sample_dic, 'InstallationPackageID', MANDATORY))
                    sample_file_name = self.convert_HW2GO_file_name(self.HW_ODF_get_attribute_value(HW_sample_dic, 'SampleFilename', MANDATORY), HW_install_package_id)
                    if sample_file_name != None:
                        GO_rank_dic[GO_pipe_uid] = sample_file_name

                    # manage the release samples
                    # get the dictionaries list of the Pipe_SoundEngine01_ReleaseSample child objects of the current Pipe_SoundEngine01_Layer object
                    HW_pipe_release_sample_dic_list = self.HW_ODF_get_linked_objects_dic_by_type(HW_pipe_layer_dic, 'Pipe_SoundEngine01_ReleaseSample', TO_CHILD)
                    if len(HW_pipe_release_sample_dic_list) > 0:
                        # there are release samples
                        GO_rank_dic[GO_pipe_uid + 'ReleaseCount'] = len(HW_pipe_release_sample_dic_list)
                        release_count = 0
                        for HW_pipe_release_sample_dic in HW_pipe_release_sample_dic_list:

                            # get the max key release time for the current release sample
                            HW_max_key_release_time_int = myint(self.HW_ODF_get_attribute_value(HW_pipe_release_sample_dic, 'ReleaseSelCriteria_LatestKeyReleaseTimeMs'))

                            # get the dictionary of the first Sample child object of the current Pipe_SoundEngine01_ReleaseSample object
                            HW_sample_dic = self.HW_ODF_get_linked_objects_dic_by_type(HW_pipe_release_sample_dic, 'Sample', TO_CHILD, FIRST_ONE)
                            release_count += 1

                            HW_install_package_id = myint(self.HW_ODF_get_attribute_value(HW_sample_dic, 'InstallationPackageID', MANDATORY))
                            sample_file_name = self.convert_HW2GO_file_name(self.HW_ODF_get_attribute_value(HW_sample_dic, 'SampleFilename', MANDATORY), HW_install_package_id)
                            if sample_file_name != None:
                                GO_rank_dic[GO_pipe_uid + 'Release' + str(release_count).zfill(3)] = sample_file_name

                            if HW_max_key_release_time_int == None or HW_max_key_release_time_int == 99999 or HW_max_key_release_time_int == -1:
                                GO_rank_dic[GO_pipe_uid + 'Release' + str(release_count).zfill(3) + 'MaxKeyPressTime'] = '-1'
                            else:
                                GO_rank_dic[GO_pipe_uid + 'Release' + str(release_count).zfill(3) + 'MaxKeyPressTime'] = HW_max_key_release_time_int

            # add in the HW Rank object the ID of the corresponding GO object
            HW_rank_dic['_GO_uid'] = GO_rank_uid

        return GO_rank_uid

    #-------------------------------------------------------------------------------------------------
    def GO_ODF_build_WindchestGroup_object(self, HW_wind_comp_dic, HW_cont_ctrl_dic, HW_enclosure_dic):
        # build the GO WindchestGroup object corresponding to the given HW WindCompartment + ContinuousControl + Enclosure (two last parameters can be at None)
        # a GO WindchestGroup corresponds to a HW WindCompartment + HW ContinuousControl (if not None) + HW Enclosure (if not None)
        # return the UID of the GO WindchestGroup built or already existing

        # used HW objects :
        #   WindCompartment

        # recover the HW ContinuousControl controlling the given HW Enclosure (linked to pipe object) and being visible if any
        HW_enc_cont_ctrl_dic = self.HW_ODF_get_linked_objects_dic_by_type(HW_enclosure_dic, 'ContinuousControl', TO_PARENT, FIRST_ONE)
        HW_enc_cont_ctrl_dic = self.HW_ODF_get_controlling_continuous_control(HW_enc_cont_ctrl_dic)

        # recover the HW ContinuousControl controlling the given HW ContinousControl (linked to pipe layer object) and being visible if any
        HW_cont_ctrl_dic = self.HW_ODF_get_controlling_continuous_control(HW_cont_ctrl_dic)

        # search if there is already a GO WindchestGroup linked to the given HW WindCompartment + Continuouscontrol + Enclosure ContinuousControl
        for GO_object_uid, GO_object_dic in self.GO_odf_dic.items():
            # parse the defined GO objects
            if GO_object_uid[0] == 'W':
                # it is a WindchestGroup object
                HW_wind_comp_uid = GO_object_dic['_HW_wc_uid']
                HW_cont_ctrl_uid = GO_object_dic['_HW_cc_uid']
                HW_enc_cont_ctrl_uid = GO_object_dic['_HW_enc_cc_uid']
                if (HW_wind_comp_dic == self.HW_ODF_get_object_dic(HW_wind_comp_uid) and
                    ((HW_cont_ctrl_dic == None and HW_cont_ctrl_uid == '') or
                     (HW_cont_ctrl_dic != None and HW_cont_ctrl_dic == self.HW_ODF_get_object_dic(HW_cont_ctrl_uid))) and
                    ((HW_enc_cont_ctrl_dic == None and HW_enc_cont_ctrl_uid == '') or
                     (HW_enc_cont_ctrl_dic != None and HW_enc_cont_ctrl_dic == self.HW_ODF_get_object_dic(HW_enc_cont_ctrl_uid)))):
                    # the current GO WindchesGroup matches with the given parameters : no need to create a new GO WindchestGroup
                    return GO_object_dic['_GO_uid']

        # create a new GO WindchestGroup
        self.GO_odf_dic['Organ']['NumberOfWindchestGroups'] += 1
        GO_windchest_uid = 'WindchestGroup' + str(self.GO_odf_dic['Organ']['NumberOfWindchestGroups']).zfill(3)
        GO_windchest_dic = self.GO_odf_dic[GO_windchest_uid] = {}
        GO_windchest_dic['_GO_uid'] = GO_windchest_uid

        GO_windchest_dic['Name'] = self.HW_ODF_get_attribute_value(HW_wind_comp_dic, 'Name')
        GO_windchest_dic['NumberOfEnclosures'] = 0
        GO_windchest_dic['NumberOfTremulants'] = 0

        # add in the HW WindCompartment the UID of the corresponding GO object
        HW_wind_comp_dic['_GO_uid'] = GO_windchest_uid
        # add in the GO WindchestGroup the UID of the corresponding HW WindCompartment
        GO_windchest_dic['_HW_wc_uid'] =  HW_wind_comp_dic['_HW_uid']

        # build a GO Enclosure if needed based on the given HW ContinuousControl
        GO_windchest_dic['_HW_cc_uid'] =  ''
        if HW_cont_ctrl_dic != None:
            GO_enclosure_uid = self.GO_ODF_build_Enclosure_object(HW_cont_ctrl_dic)
            if GO_enclosure_uid != '':
                GO_windchest_dic['_HW_cc_uid'] =  HW_cont_ctrl_dic['_HW_uid']
                GO_windchest_dic['NumberOfEnclosures'] = 1
                GO_windchest_dic['Enclosure001'] = GO_enclosure_uid[-3:]
                GO_windchest_dic['Name'] += '+' + self.GO_odf_dic[GO_enclosure_uid]['Name']
                HW_cont_ctrl_dic['_GO_uid'] = GO_enclosure_uid

        # build a GO Enclosure if needed based on the given HW Enclosure
        GO_windchest_dic['_HW_enc_cc_uid'] =  ''
        if HW_enc_cont_ctrl_dic != None:
            GO_enclosure_uid = self.GO_ODF_build_Enclosure_object(HW_enclosure_dic)
            if GO_enclosure_uid != '':
                GO_windchest_dic['_HW_enc_cc_uid'] =  HW_enc_cont_ctrl_dic['_HW_uid']
                GO_windchest_dic['NumberOfEnclosures'] += 1
                GO_windchest_dic['Enclosure' + str(GO_windchest_dic['NumberOfEnclosures']).zfill(3)] = GO_enclosure_uid[-3:]
                GO_windchest_dic['Name'] += '+' + self.GO_odf_dic[GO_enclosure_uid]['Name']
                HW_enc_cont_ctrl_dic['_GO_uid'] = GO_enclosure_uid


        return GO_windchest_uid

    #-------------------------------------------------------------------------------------------------
    def GO_ODF_build_Enclosure_object(self, HW_object_dic):
        # build a GO Enclosure object corresponding to the given HW object (ContinuousControl or Enclosure)
        # build a GO Panel999Element999 object with type=Enclosure corresponding to the given HW object and in the proper GO Panel

        # used HW objects :
        #   ContinuousControl C> ImageSetInstance C> ImageSet C> ImageSetElement
        #                                                     C> ContinuousControlImageSetStage

        HW_object_type = HW_object_dic['_HW_uid'][:-6]
        if HW_object_type == 'ContinuousControl':
            HW_cont_ctrl_dic = HW_object_dic
        elif HW_object_type == 'Enclosure':
            HW_cont_ctrl_dic = self.HW_ODF_get_linked_objects_dic_by_type(HW_object_dic, 'ContinuousControl', TO_PARENT, FIRST_ONE)
        else:
            return ''

        if HW_cont_ctrl_dic['_GO_uid'] != '':
            # there is already a GO Enclosure linked to the given HW Continuouscontrol
            return HW_cont_ctrl_dic['_GO_uid']

        # recover the HW ContinuousControl which has a graphical interface and is controlling the given HW ContinuousControl
        HW_cont_ctrl_dic = self.HW_ODF_get_controlling_continuous_control(HW_cont_ctrl_dic)
        if HW_cont_ctrl_dic == None:
            # there is no graphical control
            return ''

        self.GO_odf_dic['Organ']['NumberOfEnclosures'] += 1
        GO_enclosure_uid = 'Enclosure' + str(self.GO_odf_dic['Organ']['NumberOfEnclosures']).zfill(3)
        GO_enclosure_dic = self.GO_odf_dic[GO_enclosure_uid] = {}

        GO_enclosure_dic['Name'] = self.HW_ODF_get_attribute_value(HW_object_dic, 'Name')
        GO_enclosure_dic['AmpMinimumLevel'] = 1  # if set at 0, when the enclosure is set at its minimum, there is no sound when the enclosure position is increased

        # add the graphical attributes of the enclosure

        # get the HW ImageSetInstance object associated to the given HW ContinuousControl
        HW_img_set_inst_dic = self.HW_ODF_get_object_dic_by_ref_id('ImageSetInstance', HW_cont_ctrl_dic, 'ImageSetInstanceID')
        HW_display_page_id = myint(self.HW_ODF_get_attribute_value(HW_img_set_inst_dic, 'DisplayPageID', MANDATORY))
        HW_display_page_dic = self.HW_ODF_get_object_dic('DisplayPage', HW_display_page_id)

        # create a GO Panel999Element999 enclosure object to display the enclosure
        GO_panel_uid = HW_display_page_dic['_GO_uid']
        self.GO_odf_dic[GO_panel_uid]['NumberOfGUIElements'] += 1
        GO_panel_element_uid = GO_panel_uid + 'Element' + str(self.GO_odf_dic[GO_panel_uid]['NumberOfGUIElements']).zfill(3)
        GO_panel_element_dic = self.GO_odf_dic[GO_panel_element_uid] = {}

        GO_panel_element_dic['Type'] = 'Enclosure'
        GO_panel_element_dic['Enclosure'] = str(int(GO_enclosure_uid[-3:])).zfill(3)
        GO_panel_element_dic['DispLabelText'] = ''

        # get the image attributes of the first image index to set the attributes of the GO enclosure
        image_attr_dic = {}
        self.HW_ODF_get_image_attributes(HW_img_set_inst_dic, image_attr_dic, 1)
        GO_panel_element_dic['PositionX'] = image_attr_dic['LeftXPosPixels']
        GO_panel_element_dic['PositionY'] = image_attr_dic['TopYPosPixels']
        if image_attr_dic['ImageWidthPixels'] != None:
            GO_panel_element_dic['Width'] = image_attr_dic['ImageWidthPixels']
        if image_attr_dic['ImageHeightPixels'] != None:
            GO_panel_element_dic['Height'] = image_attr_dic['ImageHeightPixels']

        # set the mouse clickable area
        if image_attr_dic['ClickableAreaLeftRelativeXPosPixels'] != None:
            GO_panel_element_dic['MouseRectLeft'] = image_attr_dic['ClickableAreaLeftRelativeXPosPixels']
        if image_attr_dic['ClickableAreaTopRelativeYPosPixels'] != None:
            GO_panel_element_dic['MouseRectTop'] = image_attr_dic['ClickableAreaTopRelativeYPosPixels']
        else:
            GO_panel_element_dic['MouseRectTop'] = 0  # to avoid GO to set it at 13 by default
        if image_attr_dic['ClickableAreaRightRelativeXPosPixels'] != None:
            GO_panel_element_dic['MouseRectWidth'] = image_attr_dic['ClickableAreaRightRelativeXPosPixels']
        if image_attr_dic['ClickableAreaBottomRelativeYPosPixels'] != None:
            GO_panel_element_dic['MouseRectHeight'] = image_attr_dic['ClickableAreaBottomRelativeYPosPixels'] - 3  # to not have error in sample set loading in GrandOrgue

        # get the number of bitmaps of the HW ContinuousControl
        HW_img_set_dic = self.HW_ODF_get_object_dic_by_ref_id('ImageSet', HW_img_set_inst_dic, 'ImageSetID')
        HW_img_elems_list = self.HW_ODF_get_linked_objects_dic_by_type(HW_img_set_dic, 'ImageSetElement', TO_CHILD)
        bitmap_count = len(HW_img_elems_list)
        if bitmap_count > 128: bitmap_count = 128  # GO supports up to 128 bitmaps
        GO_panel_element_dic['BitmapCount'] = bitmap_count

        # add the enclosure bitmaps
        for i in range(1, bitmap_count + 1):
            image_attr_dic = {}
            self.HW_ODF_get_image_attributes(HW_img_set_inst_dic, image_attr_dic, i)
            if image_attr_dic['BitmapFilename'] != None:
                GO_panel_element_dic['Bitmap' + str(i).zfill(3)] = image_attr_dic['BitmapFilename']
            if image_attr_dic['TransparencyMaskBitmapFilename'] != None:
                GO_panel_element_dic['Mask' + str(i).zfill(3)] = image_attr_dic['TransparencyMaskBitmapFilename']

        # add in the HW ContinuousControl object the ID of the corresponding GO object
        HW_cont_ctrl_dic['_GO_uid'] = GO_enclosure_uid

        return GO_enclosure_uid

    #-------------------------------------------------------------------------------------------------
    def convert_HW2GO_file_name(self, HW_file_name, HW_install_package_id):
        # return the given file path/name (for images or sounds or info files) converted from HW to GO format with path relative to ODF folder
        # in HW format the files path starts from the root package folder (named with 6 digits) and the folders separator is either / or \
        # in GO format the files path starts from the ODF location (in the HW folder OrganDefinitions) and the folders separator is \ (it can be / as well)

        os_file_name_str = path2ospath(HW_file_name)

        if os_file_name_str[0] == os.sep:
            # the HW file name must not start by a path separator (seen on some sample sets)
            os_file_name_str = os_file_name_str[1:]

        os_file_name_str = os.path.join(self.HW_sample_set_path, 'OrganInstallationPackages', str(HW_install_package_id).zfill(6), os_file_name_str)
        actual_file_name_str = get_actual_file_name(os_file_name_str)

        # return the GO file path/name relative to the folder where is located the ODF and with the \ folders separator
        if actual_file_name_str != None:
            return '..' + actual_file_name_str[len(self.HW_sample_set_path):].replace(os.sep,'\\')
        else:
            # file not found in the sample set files
            if DEV_MODE:
                # return the given file name which comes from the HW ODF
                # permits to test HW ODF conversion without having all the files of the sample set on the computer
                return '..' + os_file_name_str[len(self.HW_sample_set_path):].replace(os.sep,'\\')
            else:
                if HW_install_package_id in self.available_HW_packages_id_list:
                    # don't show warning for file missing in the packages which are not of the sample set (i.e. standard packages of Hauptwerk)
                    logs.add(f'WARNING : file not found in the sample set : {os_file_name_str}')
                return None

#-------------------------------------------------------------------------------------------------
class C_GUI():
    # class to manage the graphical user interface of the application

    odf_data = None             # one instance of the C_GO_ODF_DATA class
    odf_conv = None             # one instance of the C_ODF_HW2GO class

    selected_object_uid = None  # UID of the object currently selected in the objects list and objects tree widgets
    selected_linked_uid = None  # UID of the linked object currently selected in the links list if any
    selected_object_app = 'GO'  # application associated to the object currently selected : 'GO' or 'HW', GO by default
    edited_object_uid = None    # UID of the edited object
    focused_object_line_nb  = None  # line number of the last item having had the focus in the objects list widget
    focused_object_node_iid = None  # iid of the last node having had the focus in the objects tree widget

    odf_data_changed = False        # flag indicating that data have been changed in the odf_data and not saved in an ODF
    selected_object_edited = False  # flag indicating that the data of an object have been edited (and not yet applied in odf_data)
    gui_events_blocked = False  # flag indicating that the GUI events are currently blocked
    text_to_search = None       # text which has to be searched in the help
    search_index = None         # last search result position in the help
    hw2go_warning_displayed = False  # flag indicating that the HW to GO conversion warning has been displayed one time
    hw2go_build_unused_ranks_bool = False # flag set by the menu to ask for the HW 2 GO conversion of the HW ranks not used by the conversion

    tag_field = "tag_field"     # tag to identify the syntax color for the fields names of the objects
    tag_comment = "tag_comment" # tag to identify the syntax color for the comments
    tag_obj_uid = "tag_obj_uid" # tag to identify the syntax color for the object UID
    tag_title = "tag_title"     # tag to identify the syntax color for the titles in the help
    tag_found = "tag_found"     # tag to identify the syntax color for the strings found by the search in the help
    tag_found2 = "tag_found2"   # tag to identify the syntax color for the found string currently highlighted

    #-------------------------------------------------------------------------------------------------
    def reset_all_data(self):
        # reset all the data of the class

        self.selected_object_uid = None
        self.selected_object_app = 'GO'
        self.edited_object_uid = None
        self.focused_object_line_nb = None
        self.focused_object_node_iid = None
        self.odf_data_changed = False
        self.selected_object_edited = False
        self.odf_data.reset_all_data()
        self.odf_conv.reset_all_data()

    #-----------------------------------------------------------------------------------------------
    def wnd_main_build(self):
        # build the main window of the application with all its GUI widgets

        # create the main window
        self.wnd_main = Tk(className='OdfEdit')
        self.wnd_main.title(MAIN_WINDOW_TITLE)
        self.wnd_main.geometry('1600x800+50+50')
        self.wnd_main.protocol("WM_DELETE_WINDOW", self.wnd_main_quit) # to ask the user to save his changed before to close the main window
        # assign an image to the main window icon
        icon = PhotoImage(file = os.path.dirname(__file__) + os.sep + 'resources' + os.sep + 'OdfEdit.png')
        self.wnd_main.iconphoto(False, icon)

        # define the styles of some widgets
        self.wnd_main.style = ttk.Style()
        self.wnd_main.style.theme_use('default')
        self.wnd_main.style.configure("Treeview", highlightthickness=3, font=('Calibri', 11), foreground="black")
        self.wnd_main.style.map('Treeview', background=[('selected', 'RoyalBlue1')])
        self.wnd_main.style.configure("TNotebook.Tab", font=('Calibri', 11), foreground="black")
        self.wnd_main.option_add("*TCombobox*Listbox*Background", 'white')
        self.wnd_main.option_add("*TCombobox*Listbox*Foreground", 'black')
        self.wnd_main.option_add('*Dialog.msg.font', 'Calibri 11')
        self.wnd_main.option_add("*Button.Font", 'Calibri 11')

        #--- create the various widgets inside the main window

        #-- top buttons bar

        # top frame to encapsulate widgets bar
        self.frm_top = Frame(self.wnd_main)
        self.frm_top.pack(side='top', fill='x')

        # button "New"
        self.btn_odf_new = Button(self.frm_top, text="New", fg="black", width=7, command=self.file_new)
        self.btn_odf_new.pack(side='left', padx=5, pady=5)

        # button "Open"
        self.btn_odf_file_open = Button(self.frm_top, text="Open", fg="black", width=7, command=self.file_open)
        self.btn_odf_file_open.pack(side='left', padx=5, pady=5)
        CreateToolTip(self.btn_odf_file_open, "Load a GrandOrgue ODF (extension .organ) or a Hauptwerk ODF (extension .Organ_Hauptwerk_xml or .xml).")

        # button "Save"
        self.btn_odf_file_save = Button(self.frm_top, text="Save", fg="black", width=7, state=DISABLED, command=self.file_save)
        self.btn_odf_file_save.pack(side='left', padx=5, pady=5)
        CreateToolTip(self.btn_odf_file_save, "Save the changes done in the last loaded GrandOrgue ODF.")

        # button "Save as..."
        self.btn_odf_file_saveas = Button(self.frm_top, text="Save as...", fg="black", width=10, state=DISABLED, command=self.file_saveas)
        self.btn_odf_file_saveas.pack(side='left', padx=5, pady=5)
        CreateToolTip(self.btn_odf_file_saveas, "Save the changes done in a new GrandOrgue ODF.")

        # button "Check ODF data"
        self.btn_data_check = Button(self.frm_top, text="Check ODF data", fg="black", width=15, state=DISABLED, command=self.odf_data_check)
        self.btn_data_check.pack(side='left', padx=5, pady=5)
        CreateToolTip(self.btn_data_check, "Execute checks in the loaded ODF data (syntax, compliance with the specification).")

        # button "Menu" and general menu
        self.btn_gen_menu = Button(self.frm_top, text="â¡", fg="black", width=2, command=self.gen_menu_open)
        self.btn_gen_menu.pack(side='left', padx=5, pady=5)
        self.hw2go_build_unused_ranks_bool = BooleanVar(self.wnd_main)
        self.general_menu = Menu(self.btn_gen_menu, tearoff=0)
        self.general_menu['bg'] = 'snow2'
        self.general_menu.add_checkbutton(label="HW to GO convert unused ranks", onvalue=True, offvalue=False, variable=self.hw2go_build_unused_ranks_bool)
        self.general_menu.add_command(label="Clear logs", command=self.logs_clear)
        self.general_menu.add_command(label="About...", command=self.gen_menu_about)
        self.general_menu.bind('<FocusOut>', self.gen_menu_close)

        # button "Quit"
        self.btn_quit_appli = Button(self.frm_top, text="Quit", fg="black", width=7, relief='groove', command=self.wnd_main_quit)
        self.btn_quit_appli.pack(side='left', padx=10, pady=5)

        # label with loaded ODF file name or to display progression status
        self.lab_odf_file_name = Label(self.frm_top, text="", fg="black", borderwidth=1, relief="solid", anchor='w', height=1)
        self.lab_odf_file_name.pack(side='left', padx=5, pady=5, ipady=3, expand=1, fill='x')

        #-- bottom area with horizontal paned window on the full window width

        # horizontal paned window at the bottom of the main window
        self.paned_wnd = PanedWindow(self.wnd_main, orient ='horizontal', relief = 'sunken', sashrelief = 'raised', sashwidth = 10)
        self.paned_wnd.pack(side='bottom', padx=5, pady=5, expand=1, fill='both')

        #-- paned window element #1 (objects list)

        # frame to occupy the full area of the element #1
        self.frm_hpaned_wnd_1 = Frame(self.wnd_main)
        self.paned_wnd.add(self.frm_hpaned_wnd_1, minsize=200, width=250)

        # label with the number of objects in the objects list, placed at the top of the parent frame
        self.lab_objects_nb = Label(self.frm_hpaned_wnd_1, text="", fg="black", borderwidth=0, relief="solid", anchor=CENTER)
        self.lab_objects_nb.pack(side = 'top', pady=10, fill='x')

        # frame to occupy the bottom area of the parent frame and to encapsulate the list box and its scroll bars
        self.frm_objects_list = Frame(self.frm_hpaned_wnd_1)
        self.frm_objects_list.pack(side = 'bottom', fill='both', expand=1)

        # list box with objects UIDs and names, with horizontal and vertical scroll bars, inside the parent frame
        scrollbarv = ttk.Scrollbar(self.frm_objects_list, orient='vertical')
        scrollbarv.pack(side=RIGHT, fill=Y)
        scrollbarh = ttk.Scrollbar(self.frm_objects_list, orient='horizontal')
        scrollbarh.pack(side=BOTTOM, fill=X)
        self.lst_objects_list = Listbox(self.frm_objects_list, bg='white', font='Calibri 11', fg="black", selectbackground='RoyalBlue1', exportselection=0, selectmode='single', activestyle='none')
        self.lst_objects_list.pack(side=LEFT, fill=BOTH, expand=1)
        self.lst_objects_list.bind('<ButtonRelease>', self.objects_list_selected)
        self.lst_objects_list.config(yscrollcommand=scrollbarv.set)
        self.lst_objects_list.config(xscrollcommand=scrollbarh.set)
        scrollbarv.config(command=self.lst_objects_list.yview)
        scrollbarh.config(command=self.lst_objects_list.xview)

        #-- paned window element #2 (objects tree)

        # frame to occupy the full area of the element #2
        self.frm_paned_wnd_2 = Frame(self.wnd_main)
        self.paned_wnd.add(self.frm_paned_wnd_2, minsize=200, width=250)

        # frame to occupy the top area of the parent frame and to encamsulate collapse/expand buttons
        self.frm_top_paned_wnd_2 = Frame(self.frm_paned_wnd_2)
        self.frm_top_paned_wnd_2.pack(side='top', fill='x')

        # button "Collapse" for the objects tree
        self.btn_collapse_all = Button(self.frm_top_paned_wnd_2, text="Collapse", fg="black", state=DISABLED, command=self.objects_tree_collapse_all)
        self.btn_collapse_all.pack(side='left', padx=1, pady=5, fill='x', expand=1)

        # button "Expand" for the objects tree
        self.btn_expand_all = Button(self.frm_top_paned_wnd_2, text="Expand", fg="black", state=DISABLED, command=self.objects_tree_expand_all)
        self.btn_expand_all.pack(side='left', padx=1, pady=5, fill='x', expand=1)

        # button "Unselect"
        self.btn_unselect = Button(self.frm_top_paned_wnd_2, text="Unselect", fg="black", state=DISABLED, command=self.object_unselect)
        self.btn_unselect.pack(side='left', padx=1, pady=5, fill='x', expand=1)

        # frame to occupy the bottom area of the parent frame and to encapsulate the tree view and its scroll bars
        self.frm_object_tree = Frame(self.frm_paned_wnd_2)
        self.frm_object_tree.pack(side = 'bottom', fill='both', expand=1)

        # treeview to display the objects hierarchy, with horizontal and vertical scroll bars
        scrollbarv = ttk.Scrollbar(self.frm_object_tree, orient='vertical')
        scrollbarv.pack(side=RIGHT, fill=Y)
        scrollbarh = ttk.Scrollbar(self.frm_object_tree, orient='horizontal')
        scrollbarh.pack(side=BOTTOM, fill=X)
        self.trv_objects_tree = ttk.Treeview(self.frm_object_tree, show="tree", selectmode='browse') #, style="myTVstyle.Treeview")
        self.trv_objects_tree.pack(side=LEFT, fill=BOTH, expand=1)
        self.trv_objects_tree.column('#0', width=500)
        self.trv_objects_tree.bind('<ButtonRelease>', self.objects_tree_selected)
        self.trv_objects_tree.config(yscrollcommand=scrollbarv.set)
        self.trv_objects_tree.config(xscrollcommand=scrollbarh.set)
        scrollbarv.config(command=self.trv_objects_tree.yview)
        scrollbarh.config(command=self.trv_objects_tree.xview)

        #-- paned window element #3 (object editor)

        # frame to occupy the full area of the element #3
        self.frm_paned_wnd_3 = Frame(self.wnd_main)
        self.paned_wnd.add(self.frm_paned_wnd_3, minsize=400, width=500)

        # vertical paned window placed inside the frame of the element #3
        self.obj_paned_wnd = PanedWindow(self.frm_paned_wnd_3, orient ='vertical', relief = 'sunken', sashrelief = 'raised', sashwidth = 10)
        self.obj_paned_wnd.pack(side='top', expand=1, fill='both')

        # frame to occupy the full area of the element #1 of the vertical paned window
        self.frm_obj_paned_wnd_1 = Frame(self.wnd_main)
        self.obj_paned_wnd.add(self.frm_obj_paned_wnd_1, minsize=120, height=150)

        # frame to occupy the top area of the parent frame and to encapsulate buttons
        self.frm_top_obj_paned_wnd_1 = Frame(self.frm_obj_paned_wnd_1)
        self.frm_top_obj_paned_wnd_1.pack(side='top', fill='x')

        # button "Apply"
        self.btn_object_apply_chg = Button(self.frm_top_obj_paned_wnd_1, text="Apply", fg="black", state=DISABLED, command=self.object_text_changes_apply)
        self.btn_object_apply_chg.pack(side='left', padx=1, pady=5, fill='x', expand=1)
        CreateToolTip(self.btn_object_apply_chg, "Apply the changes dones in the text box below.")

        # button "Add"
        self.btn_object_add = Button(self.frm_top_obj_paned_wnd_1, text="Add", fg="black", state=NORMAL, command=self.object_add)
        self.btn_object_add.pack(side='left', padx=1, pady=5, fill='x', expand=1)
        CreateToolTip(self.btn_object_add, "Add a child object to the selected object or at the root.")

        # button "Parents"
        self.btn_object_parents = Button(self.frm_top_obj_paned_wnd_1, text="Parents", fg="black", state=DISABLED, command=lambda type=TO_PARENT: self.object_link(type))
        self.btn_object_parents.pack(side='left', padx=1, pady=5, fill='x', expand=1)
        CreateToolTip(self.btn_object_parents, "Set links between the selected object and parent objects.")

        # button "Children"
        self.btn_object_children = Button(self.frm_top_obj_paned_wnd_1, text="Children", fg="black", state=DISABLED, command=lambda type=TO_CHILD: self.object_link(type))
        self.btn_object_children.pack(side='left', padx=1, pady=5, fill='x', expand=1)
        CreateToolTip(self.btn_object_children, "Set links between the selected object and child objects.")

        # button "Rename"
        self.btn_object_rename = Button(self.frm_top_obj_paned_wnd_1, text="Rename", fg="black", state=DISABLED, command=self.object_rename)
        self.btn_object_rename.pack(side='left', padx=1, pady=5, fill='x', expand=1)
        CreateToolTip(self.btn_object_rename, "Rename the last three digits of the selected object.")

        # button "Delete"
        self.btn_object_delete = Button(self.frm_top_obj_paned_wnd_1, text="Delete", fg="black", state=DISABLED, command=self.object_delete)
        self.btn_object_delete.pack(side='left', padx=1, pady=5, fill='x', expand=1)
        CreateToolTip(self.btn_object_delete, "Delete the selected object.")

        # button "Help"
        self.btn_show_help = Button(self.frm_top_obj_paned_wnd_1, text="Help", fg="black", state=DISABLED, command=self.help_search_object)
        self.btn_show_help.pack(side='left', padx=1, pady=5, fill='x', expand=1)
        CreateToolTip(self.btn_show_help, "Show in the help the part describing the selected object type.")

        # frame to occupy the bottom area of the parent frame and to encapsulate the parent/children list and its vertical scroll bar
        self.frm_bottom_obj_paned_wnd_1 = Frame(self.frm_obj_paned_wnd_1)
        self.frm_bottom_obj_paned_wnd_1.pack(side='top', fill='both', expand=1)

        # list of the selected object UID and its linked parent/children UID
        scrollbarv = ttk.Scrollbar(self.frm_bottom_obj_paned_wnd_1, orient='vertical')
        scrollbarv.pack(side='right', fill='y')
        self.lst_links_list = Listbox(self.frm_bottom_obj_paned_wnd_1, bg='white', font='Calibri 11', fg="black", selectforeground="black", selectbackground="SteelBlue1", exportselection=0, selectmode='single', activestyle='none')
        self.lst_links_list.pack(side='top', fill='both', expand=1)
        self.lst_links_list.bind('<ButtonRelease>', self.object_links_list_selected)
        self.lst_links_list.bind('<Double-1>', self.object_links_list_selected_dbl)
        self.lst_links_list.config(yscrollcommand=scrollbarv.set)
        scrollbarv.config(command=self.lst_links_list.yview)

        # frame to occupy the full area of the element #2 of the vertical paned window
        self.frm_obj_paned_wnd_2 = Frame(self.wnd_main)
        self.obj_paned_wnd.add(self.frm_obj_paned_wnd_2, minsize=200, height=200)

        # text box with the object text and with horizontal and vertical scroll bars
        scrollbarv = ttk.Scrollbar(self.frm_obj_paned_wnd_2, orient='vertical')
        scrollbarv.pack(side='right', fill=Y)
        scrollbarh = ttk.Scrollbar(self.frm_obj_paned_wnd_2, orient='horizontal')
        scrollbarh.pack(side='bottom', fill=X)
        self.txt_object_text = Text(self.frm_obj_paned_wnd_2, fg="black", bg='white', bd=3, wrap="none", font="Calibri 11", selectbackground="snow3", undo=True)
        self.txt_object_text.pack(side=LEFT, fill=BOTH, expand=1)
        self.txt_object_text.bind('<<Modified>>', self.object_text_changed)
        self.txt_object_text.bind('<KeyRelease>', self.object_text_key_pressed)
        self.txt_object_text.config(xscrollcommand=scrollbarh.set, yscrollcommand=scrollbarv.set)
        scrollbarv.config(command=self.txt_object_text.yview)
        scrollbarh.config(command=self.txt_object_text.xview)
        # define the tags for the syntax highlighting in the text box
        self.txt_object_text.tag_config(self.tag_field, foreground='red3')
        self.txt_object_text.tag_config(self.tag_comment, foreground='chartreuse4')
        self.txt_object_text.tag_config(self.tag_obj_uid, foreground='RoyalBlue1', font='Calibri 11 bold')

        #-- paned window element #4 (notebook with several tabs)

        # frame to occupy the full area of the element #4
        self.frm_paned_wnd_4 = Frame(self.wnd_main)
        self.paned_wnd.add(self.frm_paned_wnd_4, minsize=400, width=400)

        # notebook to display the events logs or the help
        self.notebook = ttk.Notebook(self.frm_paned_wnd_4)
        self.notebook.pack(side='top', fill='both', expand=1)

        # text box to display the application logs in the notebook, with horizontal/vertical scroll bars
        # a frame is used to encapsulate the text box and scroll bars
        self.frm_logs = Frame(self.notebook)
        self.frm_logs.pack(fill='both', expand=1)
        scrollbarv = ttk.Scrollbar(self.frm_logs, orient='vertical')
        scrollbarh = ttk.Scrollbar(self.frm_logs, orient='horizontal')
        scrollbarv.pack(side='right', fill=Y)
        scrollbarh.pack(side='bottom', fill=X)
        self.txt_events_log = Text(self.frm_logs, fg="black", bg='ivory2', bd=3, wrap="none", font='Calibri 11', selectbackground="grey")
        self.txt_events_log.pack(side=LEFT, fill='both', expand=1)
        self.txt_events_log.config(xscrollcommand=scrollbarh.set, yscrollcommand=scrollbarv.set)
        scrollbarv.config(command=self.txt_events_log.yview)
        scrollbarh.config(command=self.txt_events_log.xview)

        # text box to display the help in the notebook, with vertical scroll bar and search widgets
        # a main frame is used to encapsulate two other frames, one for the search widgets, one for the text box and his scroll bar
        self.frm_help = Frame(self.notebook)
        self.frm_help.pack(fill='both', expand=1)
        # widgets to search a text
        self.frm_help_top = Frame(self.frm_help)
        self.frm_help_top.pack(side='top', fill='x')
        self.lab_search = Label(self.frm_help_top, text="Search :", fg="black", borderwidth=0, relief="solid", anchor=E)
        self.lab_search.pack(side='left', padx=5, pady=5, fill='x')
        self.cmb_search_text = ttk.Combobox(self.frm_help_top, height=24, values=['[Organ]', '[Button]', '[Coupler999]', '[Divisional999]', '[DivisionalCoupler999]', '[DrawStop]', '[Enclosure999]', '[General999]', '[Image999]', '[Label999]', '[Manual999]', '[Panel999]', '[Panel999Element999]', '[Panel999Image999]', '[Panel999xxxxx999]', '[Piston]', '[PushButton]', '[Rank999]', '[ReversiblePiston999]', '[SetterElement999]', '[Stop999]', '[Switch999]', '[Tremulant999]', '[WindchestGroup999]'])
        self.cmb_search_text.pack(side='left', padx=5, pady=5, fill='x')
        self.cmb_search_text.bind('<KeyRelease>', self.help_search_text_key_pressed)
        self.cmb_search_text.bind('<<ComboboxSelected>>', self.help_search_text_key_pressed)
        self.btn_search_prev = Button(self.frm_help_top, text="<", fg="black", width=5, state=NORMAL, command=self.help_search_previous)
        self.btn_search_prev.pack(side='left', padx=5, pady=5, fill='x')
        self.btn_search_next = Button(self.frm_help_top, text=">", fg="black", width=5, state=NORMAL, command=self.help_search_next)
        self.btn_search_next.pack(side='left', padx=5, pady=5, fill='x')
        self.btn_search_clear = Button(self.frm_help_top, text="Clear", fg="black", width=10, state=NORMAL, command=self.help_search_clear)
        self.btn_search_clear.pack(side='left', padx=5, pady=5, fill='x')
        self.lab_search_occur_nb = Label(self.frm_help_top, text="", fg="black", borderwidth=0, relief="solid", anchor=W)
        self.lab_search_occur_nb.pack(side='left', padx=5, pady=5, fill='x')
        # help text box
        self.frm_help_bottom = Frame(self.frm_help)
        self.frm_help_bottom.pack(side = 'bottom', fill='both', expand=1)
        scrollbarv = ttk.Scrollbar(self.frm_help_bottom, orient='vertical')
        scrollbarv.pack(side='right', fill=Y)
        self.txt_help = Text(self.frm_help_bottom, fg="black", bg='azure', bd=3, wrap="word", font='Calibri 11', selectbackground="grey")
        self.txt_help.pack(side='bottom', fill='both', expand=1)
        self.txt_help.config(yscrollcommand=scrollbarv.set)
        scrollbarv.config(command=self.txt_help.yview)
        # define the tags for the syntax highlighting
        self.txt_help.tag_config(self.tag_field, foreground='red3')
        self.txt_help.tag_config(self.tag_comment, foreground='chartreuse4')
        self.txt_help.tag_config(self.tag_obj_uid, foreground='blue2', font='Calibri 11 bold')
        self.txt_help.tag_config(self.tag_title, foreground='red3', font='Calibri 11 bold')

        # list to search in the GrandOrgue ODF and display the search results, with vertical scroll bar
        # a main frame is used to encapsulate two other frames, one for the search widgets, one for the list box and his vertical scroll bar
        self.frm_search = Frame(self.notebook)
        self.frm_search.pack(fill='both', expand=1)
        # widgets to search a text
        self.frm_search_top = Frame(self.frm_search)
        self.frm_search_top.pack(side='top', fill='x')
        self.ent_odf_search_text = Entry(self.frm_search_top, width=35)
        self.ent_odf_search_text.pack(side='left', padx=5, pady=5, fill='x')
        self.ent_odf_search_text.bind('<Return>', self.odf_text_search)
        self.btn_odf_search = Button(self.frm_search_top, text="Search", fg="black", state=NORMAL, command=self.odf_text_search)
        self.btn_odf_search.pack(side='left', padx=5, pady=5, fill='x')
        # search results list box
        self.frm_search_bottom = Frame(self.frm_search)
        self.frm_search_bottom.pack(side = 'bottom', fill='both', expand=1)
        scrollbarv = ttk.Scrollbar(self.frm_search_bottom, orient='vertical')
        scrollbarv.pack(side=RIGHT, fill=Y)
        self.lst_odf_sresults = Listbox(self.frm_search_bottom, bg='light yellow', font='Calibri 11', fg="black", exportselection=0, selectmode='single', activestyle='none')
        self.lst_odf_sresults.pack(side=LEFT, fill='both', expand=True)
        self.lst_odf_sresults.bind('<Double-1>', self.odf_text_search_result_selected)
        self.lst_odf_sresults.config(yscrollcommand=scrollbarv.set)
        scrollbarv.config(command=self.lst_odf_sresults.yview)

        # list to navigate inside the Hauptwerk objects in the ODF, with vertical scroll bar
        # a main frame is used to encapsulate two other frames, one for the search widgets, one for the list box and his vertical scroll bar
        self.frm_hw_browser = Frame(self.notebook)
        self.frm_hw_browser.pack(fill='both', expand=True)
        # widgets to search an object UID
        self.frm_hw_browser_top = Frame(self.frm_hw_browser)
        self.frm_hw_browser_top.pack(side='top', fill='x')
        self.ent_hw_uid_search_text = Entry(self.frm_hw_browser_top, width=40)
        self.ent_hw_uid_search_text.pack(side='left', padx=5, pady=5, fill='x')
        self.btn_hw_uid_search = Button(self.frm_hw_browser_top, text="Search", fg="black", state=NORMAL, command=self.odf_text_search_hw)
        self.btn_hw_uid_search.pack(side='left', padx=5, pady=5, fill='x')
        # browser list box
        self.frm_hw_browser_bottom = Frame(self.frm_hw_browser)
        self.frm_hw_browser_bottom.pack(side = 'bottom', fill='both', expand=1)
        scrollbarv = ttk.Scrollbar(self.frm_hw_browser_bottom, orient='vertical')
        scrollbarv.pack(side=RIGHT, fill=Y)
        self.lst_hw_browser = Listbox(self.frm_hw_browser_bottom, bg='alice blue', font='Calibri 11', fg="black", exportselection=0, selectmode='single', activestyle='none')
        self.lst_hw_browser.pack(side=LEFT, fill='both', expand=True)
        self.lst_hw_browser.bind('<ButtonRelease>', self.objects_list_selected_hw)
        self.lst_hw_browser.bind('<Double-1>', self.objects_list_selected_dbl_hw)
        self.lst_hw_browser.config(yscrollcommand=scrollbarv.set)
        scrollbarv.config(command=self.lst_hw_browser.yview)

        # create the notebook tabs, and attach the frames to them
        self.notebook.add(self.frm_logs, text="    Logs    ")
        self.notebook.add(self.frm_help, text="    Help    ")
        self.notebook.add(self.frm_search, text="    Search in ODF    ")
        self.notebook.add(self.frm_hw_browser, text="    Hauptwerk objects    ")
        self.notebook.hide(self.frm_hw_browser)  # will be visible only if a Hauptwerk ODF is opened

        # create an instance of the C_GO_ODF_DATA class
        self.odf_data = C_GO_ODF_DATA()

        # create an instance of the C_ODF_HW2GO class
        self.odf_conv = C_ODF_HW2GO()

        self.reset_all_data()

        # update the status of GUI widgets
        self.gui_status_update_buttons()
        self.gui_status_update_objects_lists()
        self.gui_status_update_search()

        # display the logs resulting from the init of the application if any
        self.logs_display()

        # launch a timer to complete some initialization operations 200ms after the application start
        # to permit an application bring up as fast as possible
        self.wnd_main.after(20, self.init_complete)

        return self.wnd_main

    #-------------------------------------------------------------------------------------------------
    def wnd_main_quit(self):
        # (GUI event callback) the user has clicked on the button "Quit" or window top-right "X"

        if self.can_i_make_change(file_change_bool=True):
            # the user has saved his modifications if he wanted and has not canceled the operation
            self.wnd_main.destroy()

    #-------------------------------------------------------------------------------------------------
    def init_complete(self):
        # function to complete the initialization of the application

        # load the help text
        self.help_file_load()

        # load the GO objects templates
        self.odf_data.objects_templates_load()

        self.logs_display()

    #-------------------------------------------------------------------------------------------------
    def file_new(self):
        # (GUI event callback) the user has clicked on the button "New"
        # do a reset of the objects list/tree, edit box and ODF data

        if self.can_i_make_change(file_change_bool=True):
            # the user has saved his modifications if he wanted and has not canceled the operation

            # reset the various data
            self.reset_all_data()

            # update the various GUI widgets
            self.objects_list_update()
            self.objects_list_update_hw()
            self.objects_tree_update()
            self.object_text_update()
            self.object_links_list_update()
            self.gui_status_update_buttons()
            self.notebook.hide(self.frm_hw_browser)

    #-------------------------------------------------------------------------------------------------
    def file_open(self):
        # (GUI event callback) the user has clicked on the button "Open"

        if self.can_i_make_change(file_change_bool=True):
            # the user has saved his modifications if he wanted and has not canceled the operation

            # let the user select the ODF file to open
            file_name = fd.askopenfilename(title='Open an Organ Definition File (ODF)', filetypes=[('All supported ODF', '*.organ *.xml *.Organ_Hauptwerk_xml'), ('GrandOrgue ODF', '*.organ'), ('Hauptwerk ODF', '*.xml *.Organ_Hauptwerk_xml')])
            if len(file_name) > 0:
                # a file has been selected by the user

                # reset the various data
                self.reset_all_data()
                self.gui_status_update_buttons()

                filename_str, file_extension_str = os.path.splitext(file_name)

                # reset the data and HMI
                self.file_new()

                # select the logs tab of the notebook to show the file opening logs
                self.notebook.select(self.frm_logs)
                self.notebook.hide(self.frm_hw_browser)

                if file_extension_str in ('.xml', '.Organ_Hauptwerk_xml'):
                    # Hauptwerk ODF selected : build a GrandOrgue ODF which uses the Hauptwerk sample set

                    HW_odf_file_name = path2ospath(file_name)
                    # define the name of the built GO ODF according to the name of the HW ODF : same path and file name, only the extension is changed
                    if file_extension_str == '.xml':
                        if '.Organ.Hauptwerk.xml' in HW_odf_file_name:
                            GO_odf_file_name = HW_odf_file_name.replace('.Organ.Hauptwerk.xml', '.organ')
                        else:
                            GO_odf_file_name = HW_odf_file_name.replace('.xml', '.organ')
                    else:
                        GO_odf_file_name = HW_odf_file_name.replace('.Organ_Hauptwerk_xml', '.organ')

                    # legal message displayed to the user before to start the ODF building
                    if not self.hw2go_warning_displayed and not DEV_MODE:
                        confirm = messagebox.askokcancel(title="Hauptwerk ODF conversion to GrandOrgue format", message=HW_CONV_MSG)
                    else:
                        confirm = True
                    if confirm:
                        self.hw2go_warning_displayed = True
                        if self.odf_conv.GO_ODF_build_from_HW_ODF(HW_odf_file_name, GO_odf_file_name, self.progress_status_update, self.hw2go_build_unused_ranks_bool.get()):
                            # the GO ODF building has succeeded
                            # display the HW objects notebook tab and list inside this tab
                            self.notebook.add(self.frm_hw_browser)
                            # the built GO ODF will be then loaded
                            file_name = GO_odf_file_name
                        else:
                            logs.add('ERROR : something went wrong while converting the Hauptwerk ODF in a GrandOrgue ODF')
                            file_name = ''
                        self.logs_display()
                    else:
                        file_name = ''

                if file_name != '':
                    # GrandOrgue ODF selected or built from a Hauptwerk ODF
                    self.progress_status_update('Loading ODF...')
                    if self.odf_data.load_from_file(file_name):
                        # the file has been loaded properly
                        # update the objects list / tree / text
                        self.initial_dir = file_name

                self.objects_list_update()
                self.objects_list_update_hw()
                self.objects_tree_update()
                self.object_text_update()
                self.object_links_list_update()
                self.gui_status_update_buttons()

                self.logs_display()

    #-------------------------------------------------------------------------------------------------
    def file_save(self):
        # (GUI event callback) the user has clicked on the button "Save"
        # return True or False whether the saving has been done or not in the current loaded ODF

        return self.file_saveas(self.odf_data.odf_file_name)

    #-------------------------------------------------------------------------------------------------
    def file_saveas(self, file_name = ''):
        # (GUI event callback) the user has clicked on the button "Save as"
        # return True or False whether the saving has been done or not

        if file_name == '':
            # let the user select the ODF file in which to make the saving
            file_name = fd.asksaveasfilename(title='Save in ODF...', filetypes=[('ODF', '*.organ')])

        if file_name != '' and self.odf_data.save_to_file(file_name):
            # a file has been selected by the user
            # and the ODF data have been correctly saved
            self.odf_data_changed = False
            self.gui_status_update_buttons()
            data_saved = True
        else:
            data_saved = False

        self.logs_display()

        return data_saved

    #-------------------------------------------------------------------------------------------------
    def can_i_make_change(self, file_change_bool=False, object_change_bool=False):
        # before a file change or window closing (file_change_bool=True) or a selected object change (object_change_bool=True)
        # ask to the user if he wants to save his modifications if any, if the answer is yes then do it
        # return True if the change to do can be done

        change_ok_bool = True

        if file_change_bool:
            # the coming change will be at file level
            if self.selected_object_edited:
                # the selected object have been edited
                # ask to the user if he wants to apply changes made in the selected object and to save the changed ODF data
                confirm = messagebox.askyesnocancel(title="Apply and save changes ?", message=f"Do you want to apply changes made in {self.edited_object_uid}\nand save changes ?")
                if confirm:  # answer is yes
                    if not self.object_text_changes_apply():
                        change_ok_bool = False
                    elif not self.file_save():
                        change_ok_bool = False
                elif confirm is None:  # answer is cancel
                    change_ok_bool = False
                else:  # answer is no
                    pass

            elif self.odf_data_changed:
                # data have changed in the ODF data
                # ask to the user if he wants to save the changes done
                confirm = messagebox.askyesnocancel(title="Save changes ?", message=f"Do you want to save changes ?")
                if confirm:  # answer is yes
                    if not self.file_save():
                        change_ok_bool = False
                elif confirm is None:  # answer is cancel
                    change_ok_bool = False
                else:  # answer is no
                    pass

        elif self.selected_object_edited:
            # the coming change will be at selected object level, and the selected object have been edited
            # ask to the user if he wants to apply changes made in the selected object
            confirm = messagebox.askyesnocancel(title="Apply changes ?", message=f"Do you want to apply changes made in {self.edited_object_uid} ?")
            if confirm:  # answer is yes
                if not self.object_text_changes_apply():
                    change_ok_bool = False
            elif confirm is None:  # answer is cancel
                change_ok_bool = False
            else:  # answer is no
                pass

        return change_ok_bool

    #-------------------------------------------------------------------------------------------------
    def gui_events_block(self):
        # set the flag which blocks the GUI events processing and launch a blocking timer of 100ms

        if self.gui_events_blocked == False:
            # the events are not yet blocked
            self.gui_events_blocked = True
            # launch a timer which will unblock the events 100ms later, the time for the modified widgets to have completed their update
            self.wnd_main.after(200, self.gui_events_unblock)

    #-------------------------------------------------------------------------------------------------
    def gui_events_unblock(self):
        # (GUI event callback) end of a timer started by the function gui_events_block
        # reset the flag which blocks the GUI events processing

        self.gui_events_blocked = False

    #-------------------------------------------------------------------------------------------------
    def gui_status_update_buttons(self):
        # update the status of some GUI widgets in a single time, according to some status of the application

        # recover the number of defined objects in the ODF data
        objects_nb = self.odf_data.objects_number_get()

        # recover the list of possible parents and children objects of the selected object
        (possible_parents_list, possible_children_list) = self.odf_data.object_poss_kinship_list_get(self.edited_object_uid)
        possible_children_type_list = self.odf_data.object_poss_children_type_list_get(self.edited_object_uid)

        # button "New"
        self.btn_odf_new['state'] = NORMAL if objects_nb > 0 else DISABLED

        # button "Save"
        self.btn_odf_file_save['state'] = NORMAL if (self.odf_data.odf_file_name != '' and self.odf_data_changed) else DISABLED
        self.btn_odf_file_save['foreground'] = 'red' if (self.odf_data.odf_file_name != '' and self.odf_data_changed) else 'grey'

        # button "Save as"
        self.btn_odf_file_saveas['state'] = NORMAL if objects_nb > 0 else DISABLED
        self.btn_odf_file_saveas['foreground'] = 'red' if (self.odf_data.odf_file_name == '' and self.odf_data_changed) else 'black'

        # button "Do check"
        self.btn_data_check['state'] = NORMAL if objects_nb > 0 else DISABLED

        # button "Apply changes"
        self.btn_object_apply_chg['state'] = NORMAL if self.selected_object_edited else DISABLED
        self.btn_object_apply_chg['foreground'] = 'red' if self.selected_object_edited else 'grey'

        # button "Add"
        self.btn_object_add['state'] = NORMAL if (len(possible_children_type_list) > 0) else DISABLED

        # button "Parents"
        self.btn_object_parents['state'] = NORMAL if len(possible_parents_list) > 0 else DISABLED

        # button "Children"
        self.btn_object_children['state'] = NORMAL if len(possible_children_list) > 0 else DISABLED

        # button "Rename"
        self.btn_object_rename['state'] = NORMAL if (self.edited_object_uid != None and self.selected_object_app == 'GO' and self.edited_object_uid[-3:].isdigit()) else DISABLED

        # button "Delete"
        self.btn_object_delete['state'] = NORMAL if (self.edited_object_uid != None and self.selected_object_app == 'GO') else DISABLED

        # button "Unselect"
        self.btn_unselect['state'] = NORMAL if (self.edited_object_uid != None and self.selected_object_app == 'GO') else DISABLED

        # button "Show help"
        self.btn_show_help['state'] = NORMAL if (self.edited_object_uid not in (None, 'Header') and self.selected_object_app == 'GO') else DISABLED

        # buttons "Collapse all" and "Expand all"
        self.btn_collapse_all['state'] = NORMAL if objects_nb > 0 else DISABLED
        self.btn_expand_all['state'] = NORMAL if objects_nb > 0 else DISABLED

        # label with the loaded ODF name
        if self.odf_data.odf_file_name == '':
            if objects_nb == 0:
                self.lab_odf_file_name.config(text='Click on the button "Open" to load a GrandOrgue or Hauptwerk ODF, or "Add" to create new objects')
            else:
                self.lab_odf_file_name.config(text='Click on the button "Save as" to define a file name')
        else:
            self.lab_odf_file_name.config(text=self.odf_data.odf_file_name)
        self.lab_odf_file_name['foreground'] = 'black'

        # label with the number of objects
        if objects_nb == 0:
            self.lab_objects_nb.config(text="None object")
        elif objects_nb == 1:
            self.lab_objects_nb.config(text="1 object")
        else:
            self.lab_objects_nb.config(text=f"{objects_nb} objects")

    #-------------------------------------------------------------------------------------------------
    def gui_status_update_objects_lists(self):
        # update the status and selections of GUI lists according to status of the application

		#  print('\ngui_status_update, selected object is ' + self.selected_object_uid)
		#  print('   call stack : ' + inspect.stack()[1].function + ' / ' + inspect.stack()[2].function + ' / ' + inspect.stack()[3].function)

        # to block the GUI events triggered by the GUI updates done in this function
        self.gui_events_block()

        # GO objects list
        # clear the selected item
        self.lst_objects_list.selection_clear(0, 'end')
        if self.selected_object_app == 'GO':
            # select the item corresponding to the selected object UID
            for i in range(0, self.lst_objects_list.size()):
                if self.lst_objects_list.get(i).split(' ')[0] == self.selected_object_uid:
                    self.lst_objects_list.selection_set(i)
                    self.lst_objects_list.see(i)
                    break;

        # GO linked objects list
        # clear the selected item
        self.lst_links_list.selection_clear(0, 'end')
        if self.selected_object_app == 'GO' and self.selected_linked_uid != None:
            # select the item corresponding to the selected linked object UID
            for i in range(0, self.lst_links_list.size()):
                if self.lst_links_list.get(i).strip().split(' ')[0] == self.selected_linked_uid:
                    self.lst_links_list.selection_set(i)
                    self.lst_links_list.see(i)
                    break;

        # HW objects list
        if self.selected_object_app != 'HW':
            # clear the selected item
            self.lst_hw_browser.selection_clear(0, 'end')

        # GO objects tree
        if self.selected_object_app == 'GO':
            object_uid = self.selected_object_uid
        else:
            object_uid = None
        # select the items corresponding to the selected object UID
        for iid in self.trv_objects_tree.get_children():
            self.objects_tree_nodes_select(iid, object_uid)

    #-------------------------------------------------------------------------------------------------
    def gui_status_update_search(self):
        # update the status of some GUI widgets of the search function in the notebook

        # buttons to search previous or next or clear the search in the help
        is_search_text = (self.cmb_search_text.get() != '')
        self.btn_search_prev['state']  = NORMAL if is_search_text else DISABLED
        self.btn_search_next['state']  = NORMAL if is_search_text else DISABLED
        self.btn_search_clear['state'] = NORMAL # if is_search_text else DISABLED

    #-------------------------------------------------------------------------------------------------
    def objects_list_update(self):
        # do an update of the objects list widget content

        # clear the objects list widget content
        self.lst_objects_list.delete(0, END)

        # update the widget with the current list of sorted objects UID and name
        # puting the 'Header' and 'Organ' objects in first position of the list and excluding the Header object
        organ_text = None
        header_text = None
        for object_uid in sorted(self.odf_data.objects_list_get()):
            obj_name = self.odf_data.object_names_get(object_uid)
            if obj_name not in (None, ''):
                item_text = f'{object_uid} ({obj_name})'
            else:
                item_text = object_uid

            if object_uid == 'Organ':
                organ_text = item_text
            elif object_uid =='Header':
                header_text = item_text
            else:
                self.lst_objects_list.insert(END, item_text)

        if organ_text != None:
            self.lst_objects_list.insert(0, organ_text)
        if header_text != None:
            self.lst_objects_list.insert(0, header_text)

    #-------------------------------------------------------------------------------------------------
    def objects_list_update_hw(self, event=0):
        # do an update the Hauptwerk objects list widget

        tab = '      '

        # clear the HW objects list widget content
        self.lst_hw_browser.delete(0, END)

        # update the HW objects list widgets
        if len(self.odf_conv.HW_odf_dic):
            # there are HW ODF data in the dictionary
            if self.selected_object_uid == None or self.selected_object_app != 'HW':
                center_object_UID = "_General"
            else:
                center_object_UID = self.selected_object_uid

            selected_object_dic = self.odf_conv.HW_ODF_get_object_dic(center_object_UID)
            if selected_object_dic != None:
                # set the first element
                if center_object_UID != "_General":
                    self.lst_hw_browser.insert(END, '_General')
                self.lst_hw_browser.insert(END, '*** OBJECTS RELATIONSHIP (parents/current in red/children) ***')

                # display the parents of the selected object
                objects_uid_list = []
                for object_dic in selected_object_dic['_parents']:
                    objects_uid_list.append(object_dic['_HW_uid'])
                for object_uid in sorted(objects_uid_list):
                    object_dic = self.odf_conv.HW_ODF_get_object_dic(object_uid)
                    obj_name = self.odf_conv.HW_ODF_get_attribute_value(object_dic, 'Text')
                    if obj_name == None: obj_name = self.odf_conv.HW_ODF_get_attribute_value(object_dic, 'Name')
                    if obj_name != None:
                        self.lst_hw_browser.insert(END, object_uid + ' (' + obj_name + ')')
                    else:
                        self.lst_hw_browser.insert(END, object_uid)

                # display the selected object
                obj_name = self.odf_conv.HW_ODF_get_attribute_value(selected_object_dic, 'Text')
                if obj_name == None: obj_name = self.odf_conv.HW_ODF_get_attribute_value(selected_object_dic, 'Name')
                if obj_name != None:
                    self.lst_hw_browser.insert(END, tab + center_object_UID + ' (' + obj_name + ')')
                else:
                    self.lst_hw_browser.insert(END, tab + center_object_UID)
                self.lst_hw_browser.itemconfig(END, foreground='red')

                # display the children of the selected object
                objects_uid_list = []
                for object_dic in selected_object_dic['_children']:
                    objects_uid_list.append(object_dic['_HW_uid'])
                for object_uid in sorted(objects_uid_list):
                    item_str = tab + tab + object_uid
                    object_dic = self.odf_conv.HW_ODF_get_object_dic(object_uid)
                    obj_name = self.odf_conv.HW_ODF_get_attribute_value(object_dic, 'Text')
                    if obj_name == None:
                        obj_name = self.odf_conv.HW_ODF_get_attribute_value(object_dic, 'Name')
                    if obj_name != None:
                        item_str += ' (' + obj_name + ')'
                    if len(self.odf_conv.HW_ODF_get_attribute_value(object_dic, '_children')) > 0:
                        item_str += '  >>>'
                    self.lst_hw_browser.insert(END, item_str)

            self.lst_hw_browser.insert(END, '*** OBJECTS WITH NO PARENT (>>> means has children) ***')

            # add at the end all the objects which have no parent except some types
            objects_uid_list = []
            for HW_object_type, HW_object_type_dic in self.odf_conv.HW_odf_dic.items():
                # parse the HW object types
                if not HW_object_type.startswith(('Pi', 'Sa', 'TremulantWaveformP', 'SwitchL', '_General')):
                    # excluded objects types are : Pipe_xxx, Sample, TremulantWaveformPipe, SwitchLinkage, _General
                    # the current HW object type can be added in the list
                    for object_dic in HW_object_type_dic.values():
                        # parse the HW objects of the current HW objects type
                        if len(object_dic['_parents']) == 0:
                            # the current object has no parent
                            objects_uid_list.append(object_dic['_HW_uid'])

            for object_uid in sorted(objects_uid_list):
                item_str = object_uid
                object_dic = self.odf_conv.HW_ODF_get_object_dic(object_uid)
                obj_name = self.odf_conv.HW_ODF_get_attribute_value(object_dic, 'Text')
                if obj_name == None:
                    obj_name = self.odf_conv.HW_ODF_get_attribute_value(object_dic, 'Name')
                if obj_name != None:
                    item_str += ' (' + obj_name + ')'
                if len(self.odf_conv.HW_ODF_get_attribute_value(object_dic, '_children')) > 0:
                    item_str += '  >>>'
                self.lst_hw_browser.insert(END, item_str)

    #-------------------------------------------------------------------------------------------------
    def objects_list_selected(self, event):
        # (GUI event callback) the user has selected an item in the objects list widget

        if self.gui_events_blocked: return

        # get the line number of the selected item in the list
        cursel_tuple = self.lst_objects_list.curselection()
        if len(cursel_tuple) > 0:
            focused_line_nb = cursel_tuple[0]
        else:
            focused_line_nb = None

        if focused_line_nb != None and self.can_i_make_change(object_change_bool=True):
            # an item of the objects list widget is selected
            # the user has saved his modifications if he wanted and has not canceled the operation

            # recover in the objects list widget the UID of the selected object (before the first space in the selected item text)
            self.selected_object_app = 'GO'
            self.selected_object_uid = self.lst_objects_list.get(focused_line_nb).split(' ')[0]
            self.selected_linked_uid = None
            self.focused_object_line_nb = focused_line_nb
            self.focused_object_node_iid = None

            # update the object text box and links list
            self.object_text_update()
            self.object_links_list_update()

        # update the status of GUI widgets
        self.gui_status_update_buttons()
        self.gui_status_update_objects_lists()

    #-------------------------------------------------------------------------------------------------
    def objects_list_selected_hw(self, event):
        # (GUI event callback) the user has selected an item in the Hauptwerk objects list widget

        if self.gui_events_blocked: return

        # get the indice of the selected item in the list
        cursel_tuple = self.lst_hw_browser.curselection()
        if len(cursel_tuple) > 0:
            focused_line_nb = cursel_tuple[0]
        else:
            focused_line_nb = None

        if focused_line_nb != None and self.can_i_make_change(object_change_bool=True):
            # an item of the HW objects list widget is selected
            # recover in the objects list widget the UID of the selected object (before the first space in the selected item text)
            self.selected_object_app = 'HW'
            self.selected_object_uid = self.lst_hw_browser.get(focused_line_nb).strip().split(' ')[0]
            if self.selected_object_uid[0] == '*': # item without object UID
                self.selected_object_uid = None
            self.selected_linked_uid = None
            self.focused_object_line_nb = None
            self.focused_object_node_iid = None

            # update the object text box and links list
            self.object_text_update()
            self.object_links_list_update()

        # update the status of GUI widgets
        self.gui_status_update_buttons()
        self.gui_status_update_objects_lists()

    #-------------------------------------------------------------------------------------------------
    def objects_list_selected_dbl_hw(self, event):
        # (GUI event callback) the user has double-clicked an item in the Hauptwerk objects list widget

        if self.selected_object_uid != None:
            self.objects_list_update_hw()

    #-------------------------------------------------------------------------------------------------
    def objects_tree_update(self):
        # do an update of the objects tree widget

        # delete all the nodes of the tree
        for item in self.trv_objects_tree.get_children():
            self.trv_objects_tree.delete(item)

        odf_objects_list = self.odf_data.objects_list_get()
        if len(odf_objects_list) > 0:
            # there are existing objects

            # treeview insert syntax : insert(parent_iid or '', position (0 or 'end'), node_iid, keyword arguments...)

            self.focused_object_node_iid = None

            if 'Header' in odf_objects_list:
                # place the Header object in first position of the tree
                iid = self.trv_objects_tree.insert('', 'end', 'Header', text='Header')

            if 'Organ' in odf_objects_list:
                # place the Organ object in first or second position of the tree
                obj_name = self.odf_data.object_names_get('Organ')
                if obj_name not in (None, ''):
                    organ_node_iid = self.trv_objects_tree.insert('', 'end', 'Organ', text='Organ (' + obj_name + ')', open=True)
                else:
                    organ_node_iid = self.trv_objects_tree.insert('', 'end', 'Organ', text='Organ', open=True)
            else:
                organ_node_iid = ''

            depth = 0
            for object_uid in sorted(odf_objects_list):
                if object_uid not in ('Header', 'Organ'):
                    # the object is not Header or Organ which have been already managed before
                    object_type = self.odf_data.object_type_get(object_uid)
                    if object_type in ('General', 'Manual', 'Panel', 'WindchestGroup', 'Image', 'Label', 'ReversiblePiston', 'SetterElement'):
                        # put the object under the 'Organ' object
                        self.objects_tree_child_add(organ_node_iid, object_uid, depth)
                    elif len(self.odf_data.object_kinship_list_get(object_uid, TO_PARENT)) == 0:
                        # the object has no parent, put it at the root of the tree
                        self.objects_tree_child_add('', object_uid, depth)

    #-------------------------------------------------------------------------------------------------
    def objects_tree_child_add(self, parent_node_iid, child_object_uid, depth):
        # recursive function to insert in the objects tree widget the given child object UID under the given parent node ID

        # insert the given child object in the tree under the given parent node ID
        obj_name = self.odf_data.object_names_get(child_object_uid)
        if obj_name not in (None, ''):
            child_node_iid = self.trv_objects_tree.insert(parent_node_iid, 'end', parent_node_iid + '_' + child_object_uid, text=child_object_uid + ' (' + obj_name + ')')
        else:
            child_node_iid = self.trv_objects_tree.insert(parent_node_iid, 'end', parent_node_iid + '_' + child_object_uid, text=child_object_uid)

        # the given child becomes the parent for the next recursive call
        new_parent_node_iid = child_node_iid
        new_parent_uid = child_object_uid
        new_parent_type = self.odf_data.object_type_get(new_parent_uid)

        # parse the children of new parent to add the corresponding children nodes
        if self.odf_data.object_dic_get(new_parent_uid) != None:
            # the new parent object UID exists in the ODF dictionary
            if not(new_parent_type == 'Manual' and depth > 0):
                # it is not a Manual object at depth higher than 1 (to avoid Manual childs in the tree when Manual is not child of Organ)
                for child_uid in sorted(self.odf_data.object_kinship_list_get(new_parent_uid, TO_CHILD)):
                    self.objects_tree_child_add(new_parent_node_iid, child_uid, depth + 1)

    #-------------------------------------------------------------------------------------------------
    def objects_tree_expand_all(self):
        # (GUI event callback) the user has pressed the button "Expand all"
        # expend all the nodes of the objects tree widget

        for iid in self.trv_objects_tree.get_children(''):
            self.objects_tree_node_and_children_open(iid, True)

    #-------------------------------------------------------------------------------------------------
    def objects_tree_collapse_all(self):
        # (GUI event callback) the user has pressed the button "Collapse all"
        # collapse all the nodes of the objects tree widget except the root and the 'Organ' nodes

        for iid in self.trv_objects_tree.get_children(''):
            self.objects_tree_node_and_children_open(iid, False)

    #-------------------------------------------------------------------------------------------------
    def objects_tree_node_and_children_open(self, node_iid, open_status):
        # recursive function to open (if True, else close) the given node and his children in the objects tree

        if self.trv_objects_tree.item(node_iid, option='text').startswith('Organ'):
            # the Organ node must stay always opened
            self.trv_objects_tree.item(node_iid, open=True)
        else:
            self.trv_objects_tree.item(node_iid, open=open_status)

        # apply the open status to the child nodes
        for iid in self.trv_objects_tree.get_children(node_iid):
            self.objects_tree_node_and_children_open(iid, open_status)

    #-------------------------------------------------------------------------------------------------
    def objects_tree_node_and_parents_open(self, node_iid):
        # recursive function to open the given node and his parents in the objects tree

        if node_iid != '':
            # the node exists
            self.trv_objects_tree.item(node_iid, open=True)

            # apply the open status to the parent node of node_iid
            self.objects_tree_node_and_parents_open(self.trv_objects_tree.parent(node_iid))

    #-------------------------------------------------------------------------------------------------
    def objects_tree_nodes_select(self, node_iid, object_uid):
        # recursive function to select the nodes of the objects tree which contain the given object UID text

        if object_uid != None and self.trv_objects_tree.item(node_iid)['text'].split(' ')[0] == object_uid:
            # the node node_iid corresponds to the object UID : select it and open it
            self.trv_objects_tree.selection_add(node_iid)
            # open the parents of the node so that the object is visible
            self.objects_tree_node_and_parents_open(self.trv_objects_tree.parent(node_iid))
        else:
            # remove the selection on the node_iid if any
            self.trv_objects_tree.selection_remove(node_iid)

        # search to select the object_uid in the children of node_iid
        for iid in self.trv_objects_tree.get_children(node_iid):
            self.objects_tree_nodes_select(iid, object_uid)

    #-------------------------------------------------------------------------------------------------
    def objects_tree_selected(self, event):
        # (GUI event callback) the user has selected an item in the objects tree widget

        if self.gui_events_blocked: return

        # get the iid of the selected node in the tree
        focused_node_iid = self.trv_objects_tree.focus()

        if focused_node_iid != '' and self.can_i_make_change(object_change_bool=True):
            # the user has saved his modifications if he wanted and has not canceled the operation
            # recover the object UID
            self.selected_object_app = 'GO'
            self.selected_object_uid = self.trv_objects_tree.item(focused_node_iid, option='text').split(' ')[0]
            self.selected_linked_uid = None
            self.focused_object_line_nb = None
            self.focused_object_node_iid = focused_node_iid

            # update the object text box and links list
            self.object_text_update()
            self.object_links_list_update()

        # update the status of GUI widgets
        self.gui_status_update_buttons()
        self.gui_status_update_objects_lists()

        # make visible the selected item if it is no more visible after the execution of gui_status_update_objects_lists due to some upper nodes opening
        if self.trv_objects_tree.bbox(focused_node_iid) == '':
            self.trv_objects_tree.see(focused_node_iid)

    #-------------------------------------------------------------------------------------------------
    def object_links_list_update(self):
        # update the selected object links list

        # clear the objects list widget content
        self.lst_links_list.delete(0, END)
        self.selected_linked_uid = None

        if self.selected_object_app == 'GO' and self.selected_object_uid != None:

            # display the selected object
            obj_name = self.odf_data.object_names_get(self.selected_object_uid)
            if obj_name not in (None, ''):
                self.lst_links_list.insert('end', f'{self.selected_object_uid} ({obj_name})')
            else:
                self.lst_links_list.insert('end', f'{self.selected_object_uid}')
            self.lst_links_list.itemconfig(END, foreground='white', background='RoyalBlue1')

            # display the parents
            parents_list = sorted(self.odf_data.object_kinship_list_get(self.selected_object_uid, TO_PARENT))
            if len(parents_list) > 0:
                self.lst_links_list.insert('end', f'Parents : #{len(parents_list)}')
                for parent_uid in parents_list:
                    obj_name = self.odf_data.object_names_get(parent_uid)
                    if obj_name not in (None, ''):
                        self.lst_links_list.insert('end', f'  {parent_uid} ({obj_name})')
                    else:
                        self.lst_links_list.insert('end', f'  {parent_uid}')

            # display the children
            children_list = sorted(self.odf_data.object_kinship_list_get(self.selected_object_uid, TO_CHILD))
            if len(children_list) > 0:
                self.lst_links_list.insert('end', f'Children : #{len(children_list)}')
                for child_uid in children_list:
                    obj_name = self.odf_data.object_names_get(child_uid)
                    if obj_name not in (None, ''):
                        self.lst_links_list.insert('end', f'  {child_uid} ({obj_name})')
                    else:
                        self.lst_links_list.insert('end', f'  {child_uid}')

    #-------------------------------------------------------------------------------------------------
    def object_links_list_selected(self, event):
        # (GUI event callback) the user has selected an item in the object links list widget

        if self.gui_events_blocked: return

        # get the line number of the selected item in the list
        cursel_tuple = self.lst_links_list.curselection()
        if len(cursel_tuple) > 0:
            focused_line_nb = cursel_tuple[0]
        else:
            focused_line_nb = None

        if focused_line_nb != None and self.can_i_make_change(object_change_bool=True):
            # an item of the object links list widget is selected
            # the user has saved his modifications if he wanted and has not canceled the operation

            # recover in the list widget the UID of the selected object (before the first space in the selected item text)
            selected_object = self.lst_links_list.get(focused_line_nb).strip().split(' ')[0]
            if selected_object not in ('Parents', 'Children', self.selected_object_uid):
                self.selected_linked_uid = selected_object
            else:
                self.selected_linked_uid = None

            # update the object text box
            self.object_text_update()

        # update the status of GUI widgets
        self.gui_status_update_buttons()
        self.gui_status_update_objects_lists()

    #-------------------------------------------------------------------------------------------------
    def object_links_list_selected_dbl(self, event):
        # (GUI event callback) the user has double-clicked an item in the object links list widget

        if self.selected_linked_uid != None:
            # make the selected linked UID the selected object UID
            self.selected_object_uid = self.selected_linked_uid
            self.selected_linked_uid = None

            # update the status of GUI widgets
            self.object_links_list_update()
            self.gui_status_update_buttons()
            self.gui_status_update_objects_lists()

    #-------------------------------------------------------------------------------------------------
    def object_add(self):
        # (GUI event callback) the user has clicked on the button "Add" to create a new object

        if not self.can_i_make_change(object_change_bool=True):
            # the user has answered cancel
            return

        # recover the list of the object types which can be added as child of the selected object
        object_types_list = self.odf_data.object_poss_children_type_list_get(self.edited_object_uid)

        # let the user choose one object type to add
        if 'Header' in object_types_list or 'Organ' in object_types_list:
            if self.edited_object_uid in (None, 'Header'):
                msg = 'Choose a type of object to add at the root'
            else:
                msg = f'Choose a type of object to add as child of\n{self.edited_object_uid} or at the root'
        else:
            if self.edited_object_uid == None:
                return
            else:
                msg = f'Choose a type of object to add as child of\n{self.edited_object_uid}'
        chosen_type_list = ask_choose_list_items(self.wnd_main, 'Add object', msg, object_types_list, multiselect_bool=False)

        if chosen_type_list == None or len(chosen_type_list) == 0:
            # no chosen object type
            return

        # recover the chosen object type and its parent UID
        chosen_object_type = chosen_type_list[0]
        parent_object_uid = self.edited_object_uid

        # create the object in the ODF
        new_object_uid = self.odf_data.object_add(chosen_object_type, parent_object_uid)
        if new_object_uid != None:
            # the object has been created successfully
            # set the new object as the current selected object
            self.selected_object_app = 'GO'
            self.selected_object_uid = new_object_uid
            self.selected_linked_uid = None
            self.odf_data_changed = True
            # update the content of GUI widgets
            self.objects_list_update()
            self.objects_tree_update()
            self.object_text_update()
            self.object_links_list_update()
            # update the status of GUI widgets
            self.gui_status_update_buttons()
            self.gui_status_update_objects_lists()

        # update the events log text
        self.logs_display()

    #-------------------------------------------------------------------------------------------------
    def object_link(self, relationship):
        # (GUI event callback ) the user has clicked on the button "Parents" or "Children" to link the current selected object UID to another object
        # relationship must be TO_PARENT or TO_CHILD

        if not self.can_i_make_change(object_change_bool=True) or self.edited_object_uid == None or self.selected_object_app != 'GO':
            return

        # recover the list of the objects UID which can be possibly parents or children of the selected object
        (possible_parents_list, possible_children_list)  = self.odf_data.object_poss_kinship_list_get(self.edited_object_uid)

        # take the list corresponding to the kinship type, this will be the possible kinship objects list
        if relationship == TO_PARENT:
            if len(possible_parents_list) == 0:
                return
            else:
                possible_kinship_list = possible_parents_list
        elif relationship == TO_CHILD:
            if len(possible_children_list) == 0:
                return
            else:
                possible_kinship_list = possible_children_list
        else:
            return
        # add in the possible kinship objects list the name of each object to facilitate the objects selection
        for i, object_uid in enumerate(possible_kinship_list):
            obj_name = self.odf_data.object_names_get(object_uid)
            if obj_name not in (None, ''):
                possible_kinship_list[i] = object_uid + ' (' + obj_name + ')'

        # recover a copy of the list of the current parents/children objects of the selected object
        current_kinship_list = list(self.odf_data.object_kinship_list_get(self.edited_object_uid, relationship))
        # add in the current kinship list the name of each object to have same object names as in the possible kinship list
        for i, object_uid in enumerate(current_kinship_list):
            obj_name = self.odf_data.object_names_get(object_uid)
            if obj_name not in (None, ''):
                current_kinship_list[i] = object_uid + ' (' + obj_name + ')'

        # let the user choose the parent/children object(s) to which link the selected object
        if relationship == TO_PARENT:
            selected_kinship_list = ask_choose_list_items(self.wnd_main, 'Link to parents',
                                                          f'Select parent(s) of\n{self.edited_object_uid}',
                                                          sorted(possible_kinship_list), current_kinship_list, True)
        else:
            selected_kinship_list = ask_choose_list_items(self.wnd_main, 'Link to children',
                                                          f'Select child(ren) of\n{self.edited_object_uid}',
                                                          sorted(possible_kinship_list), current_kinship_list, True)

        if selected_kinship_list == None:
            # operation cancelled
            return

        # remove the object name in the selected kinship objects list before to give it to the function odf_data.object_link
        for i in range(len(selected_kinship_list)):
            selected_kinship_list[i] = selected_kinship_list[i].split(' ')[0]

        # link the selected object to the one of the selected kinship objects list
        object_uid = self.odf_data.object_link(self.edited_object_uid, selected_kinship_list, relationship)
        if object_uid != None:
            self.selected_object_uid = object_uid
            self.selected_linked_uid = None
            self.odf_data_changed = True
            # update the content of GUI widgets
            self.objects_list_update()
            self.objects_tree_update()
            self.object_text_update()
            self.object_links_list_update()
            # update the status of GUI widgets
            self.gui_status_update_buttons()
            self.gui_status_update_objects_lists()

        # update the events log text
        self.logs_display()

    #-------------------------------------------------------------------------------------------------
    def object_rename(self):
        # (GUI event callback) the user has clicked on the button "Rename" to rename the current selected object UID

        if (not self.can_i_make_change(object_change_bool=True) or self.edited_object_uid == None or
            self.selected_object_app != 'GO' or not self.edited_object_uid[-3:].isdigit()):
            return

        # ask to the user the new object ID to set
        answer = sd.askstring("Object identifier rename", f"Define a new value for\nthe 3 ending digits of {self.edited_object_uid} :",
                              initialvalue=int(self.edited_object_uid[-3:]), parent=self.wnd_main)
        if answer == None:
            return

        # check the given number
        if not answer.isdigit():
            messagebox.showerror(title='Naming error', message='Only digits are expected')
        elif int(answer) not in range(0,1000):
            messagebox.showerror(title='Naming error', message='A value between 0 and 999 is expected')
        else:
            # the given number is correct
            # define the new UID of the object
            new_uid = self.edited_object_uid[:-3] + str(int(answer)).zfill(3)
            # check if the new UID can be applied
            object_type = self.odf_data.object_type_get(self.edited_object_uid)
            if new_uid == self.edited_object_uid:
                messagebox.showerror(title='Naming error', message=f'{new_uid} is not a new name !')
            elif new_uid in self.odf_data.objects_list_get():
                messagebox.showerror(title='Naming error', message=f'An object named {new_uid} already exists')
            elif int(answer) == 0 and object_type not in ('Panel', 'Manual'):
                messagebox.showerror(title='Naming error', message='Only Manual and Panel can end with 000')
            elif self.odf_data.object_rename(self.edited_object_uid, new_uid) != None:
                # the object has been renamed without error
                self.selected_object_uid = new_uid
                self.selected_linked_uid = None
                self.odf_data_changed = True
                # update the content of GUI widgets
                self.objects_list_update()
                self.objects_tree_update()
                self.object_text_update()
                self.object_links_list_update()
                # update the status of GUI widgets
                self.gui_status_update_buttons()
                self.gui_status_update_objects_lists()

            # update the events log text
            self.logs_display()

    #-------------------------------------------------------------------------------------------------
    def object_delete(self):
        # (GUI event callback) the user has clicked on the button "Delete" to delete the current selected object UID

        if self.edited_object_uid == None or self.selected_object_app != 'GO':
            return

        if messagebox.askokcancel("OdfEdit", f"Do you confirm you want to delete the object {self.edited_object_uid} ?"):
            # the user confirmed the deletion

            # choose the UID of the object which will be selected after the removal of the current selected object
            if self.focused_object_line_nb != None:
                # the last object selection has been done in the objects list widget
                # choose the next or previous object in the list
                if self.focused_object_line_nb == self.lst_objects_list.size() - 1:
                    self.focused_object_line_nb -= 1
                else:
                    self.focused_object_line_nb += 1
                next_selected_object_uid = self.lst_objects_list.get(self.focused_object_line_nb).split(' ')[0]
            elif self.focused_object_node_iid != None:
                # the last object selection has been done in the objects tree widget
                # chose the next or previous object under the parent node, or the parent node
                new_focused_object_node_iid = self.trv_objects_tree.next(self.focused_object_node_iid)
                if new_focused_object_node_iid == '':
                    new_focused_object_node_iid = self.trv_objects_tree.prev(self.focused_object_node_iid)
                if new_focused_object_node_iid == '':
                    new_focused_object_node_iid = self.trv_objects_tree.parent(self.focused_object_node_iid)
                next_selected_object_uid = self.trv_objects_tree.item(new_focused_object_node_iid, option='text').split(' ')[0]
            else:
                next_selected_object_uid = None

            # remove the object in the ODF data
            if self.odf_data.object_delete(self.edited_object_uid):
                # the object has been removed without issue
                # update the current object UID
                self.selected_object_uid = next_selected_object_uid
                self.selected_linked_uid = None
                self.odf_data_changed = True
                # update the content of GUI widgets
                self.objects_list_update()
                self.objects_tree_update()
                self.object_text_update()
                self.object_links_list_update()
                # update the status of GUI widgets
                self.gui_status_update_buttons()
                self.gui_status_update_objects_lists()

            # update the events log text
            self.logs_display()

    #-------------------------------------------------------------------------------------------------
    def object_unselect(self):
        # (GUI event callback) the user has selected 'Clear all' in the context menu of the object text box

        if self.can_i_make_change(object_change_bool=True):
            # clear the current object ID
            self.selected_object_uid = None
            self.selected_object_app = 'GO'
            self.edited_object_uid = None
            self.focused_object_line_nb = None
            self.focused_object_node_iid = None
            self.selected_object_edited = True

            # update the object text and links list
            self.object_text_update()
            self.object_links_list_update()

            # reset the edit modified flag
            self.txt_object_text.edit_modified(False)
            self.selected_object_edited = False

            self.gui_status_update_buttons()
            self.gui_status_update_objects_lists()

    #-------------------------------------------------------------------------------------------------
    def object_text_update(self):
        # update the content of the object text box widget

        object_lines_list = None
        if self.selected_object_uid != None:
            if self.selected_object_app == 'GO':
                # get the data lines list of the selected GrandOrgue object UID
                if self.selected_linked_uid != None:
                    self.edited_object_uid = self.selected_linked_uid
                else:
                    self.edited_object_uid = self.selected_object_uid
                object_lines_list = self.odf_data.object_lines_read(self.edited_object_uid)
            elif self.selected_object_app == 'HW':
                # get the data lines list of the selected Hauptwerk object UID
                object_lines_list = self.odf_conv.HW_ODF_get_object_data_list(self.selected_object_uid)
                self.edited_object_uid = None

        # write the object data lines in the object text box
        self.txt_object_text.delete(1.0, "end")
        if object_lines_list != None:
            self.txt_object_text.insert(1.0, '\n'.join(object_lines_list))

        # place the insertion cursor at the beginning of the text
        self.txt_object_text.mark_set("insert", "1.0")

        # apply the syntax highlighting
        self.odf_syntax_highlight(self.txt_object_text)

        # reset the text modified flag
        self.txt_object_text.edit_modified(False)
        self.selected_object_edited = False

    #-------------------------------------------------------------------------------------------------
    def object_text_changed(self, event):
        # (GUI event callback) the user has made a change in the object text box

        if self.txt_object_text.edit_modified() and self.selected_object_edited == False and self.selected_object_app == 'GO':
            # update the status of GUI widgets
            self.selected_object_edited = True
            self.gui_status_update_buttons()

    #-------------------------------------------------------------------------------------------------
    def object_text_key_pressed(self, event):
        # (GUI event callback) the user has pressed a keyboard key in the object text box

        # update the syntax highlighting
        self.odf_syntax_highlight(self.txt_object_text)

    #-------------------------------------------------------------------------------------------------
    def object_text_changes_apply(self):
        # (GUI event callback) the user has clicked on the button "Apply" to apply the changes done in the object text box
        # return True or False whether the changes have been applied successfully or not

        # convert the object text lines in list
        object_lines_list = self.txt_object_text.get(1.0, 'end').splitlines()

        # apply the object data in the ODF data
        if self.selected_linked_uid != None:
            # the changed object is a linked object of the selected object
            object_uid = self.odf_data.object_lines_write(object_lines_list, self.selected_linked_uid)
            if object_uid != None:
                # no error in the lines writting : let unchanged the selected object UID
                object_uid = self.selected_object_uid
        else:
            object_uid = self.odf_data.object_lines_write(object_lines_list, self.selected_object_uid)

        if object_uid != None:
            # the modification has been applied with success
            self.odf_data_changed = True
            # reset the edit modified flag
            self.txt_object_text.edit_modified(False)
            self.selected_object_edited = False
            # store the object UID corresponding to the applied text
            self.selected_object_uid = object_uid
            self.selected_object_app = 'GO'
            # update the various GUI widgets
            self.objects_list_update()
            self.objects_tree_update()
            self.object_text_update()
            self.object_links_list_update()
            self.gui_status_update_buttons()
            self.gui_status_update_objects_lists()
            changes_applied = True
        else:
            changes_applied = False
            # select the Logs tab of the notebook to show the check result
            self.notebook.select(self.frm_logs)

        # update the events log text
        self.logs_display()

        return changes_applied

    #-------------------------------------------------------------------------------------------------
    def gen_menu_open(self):
        # (GUI event callback) the user has clicked on the button Menu to open the general menu

        self.general_menu.tk_popup(self.btn_gen_menu.winfo_rootx() + self.btn_gen_menu.winfo_width(), self.btn_gen_menu.winfo_rooty())

    #-------------------------------------------------------------------------------------------------
    def gen_menu_close(self, event=None):
        # (GUI event callback) the menu has lost its focus

        self.general_menu.grab_release()

    #-------------------------------------------------------------------------------------------------
    def gen_menu_about(self):
        # (GUI event callback) the user has clicked on the item About... of the general Menu

        messagebox.showinfo('OdfEdit', f'OdfEdit {APP_VERSION} - {RELEASE_DATE}\n\ngithub.com/GrandOrgue/ODFEdit')

    #-------------------------------------------------------------------------------------------------
    def odf_text_search(self, event=None):
        # (GUI event callback) the user has clicked on the button search of the ODF search results tab or pressed Enter in the entry box

        # recover the text to search
        search_text = self.ent_odf_search_text.get()

        self.lst_odf_sresults.delete(0, END)

        if search_text != '':
            results_list = []
            for object_uid, object_dic in self.odf_data.odf_data_dic.items():
                # parse the objects of the ODF data
                for line in object_dic['lines']:
                    # parse the lines of the current object
                    if search_text in line:
                        results_list.append(f'{object_uid} : {line}')
            results_list.sort()

            if len(results_list) > 0:
                self.lst_odf_sresults.insert(END, *results_list)
            else:
                messagebox.showinfo(title='Information', message=f'"{search_text}" not found (the search is case sensitive)')

    #-------------------------------------------------------------------------------------------------
    def odf_text_search_hw(self):
        # (GUI event callback) the user has clicked on the button search of the HW ODF browser

        # recover the text to search (must be a HW object UID only)
        search_text = self.ent_hw_uid_search_text.get()

        if search_text != '':
            object_dic = self.odf_conv.HW_ODF_get_object_dic(search_text)
            if object_dic != None:
                self.selected_object_uid = search_text
                self.selected_object_app = 'HW'

                # update the HW objects list
                self.objects_list_update_hw()
                # update the object text box
                self.object_text_update()
                # update the status of GUI widgets
                self.gui_status_update_buttons()
            else:
                messagebox.showerror(title="Error", message=f'"{search_text}" is not a known HW UID')

    #-------------------------------------------------------------------------------------------------
    def odf_text_search_result_selected(self, event):
        # (GUI event callback) the user has clicked on an item of the ODF search results list

        # get the selected indice
        selected_indice = self.lst_odf_sresults.curselection()

        if self.can_i_make_change(object_change_bool=True):
            # the user has saved his modifications if he wanted and has not canceled the operation

            self.selected_object_uid = self.lst_odf_sresults.get(selected_indice[0]).split(' ')[0]
            self.selected_object_app = 'GO'

            # update the object text box and links list
            self.object_text_update()
            self.object_links_list_update()

            # select in the object edition text box the line which corresponds to the selected result
            selected_search_result = self.lst_odf_sresults.get(selected_indice[0]).split(':')[1].strip()
            idx = self.txt_object_text.search(selected_search_result, '1.0', stopindex=END)
            if idx != '':
                self.txt_object_text.tag_remove('sel', '1.0', 'end')
                self.txt_object_text.tag_add('sel', idx, f'{idx} + {len(selected_search_result)} chars')
                self.txt_object_text.see(idx)
                self.txt_object_text.focus_set()

            # update the status of GUI widgets
            self.gui_status_update_buttons()
            self.gui_status_update_objects_lists()

    #-------------------------------------------------------------------------------------------------
    def logs_display(self):
        # add in the logs text box widget the content of the logs buffer then clear it

        logs_list = logs.get()
        if len(logs_list) > 0:
            self.txt_events_log.insert('end', '\n' + '\n'.join(logs_list) + '\n')
            self.txt_events_log.see('end-1c linestart')  # to see the start of the last line of the text
        self.txt_events_log.update()

        # reset the logs buffer
        logs.clear()

    #-------------------------------------------------------------------------------------------------
    def logs_clear(self):
        # (GUI event callback) the user has selected 'Clear all' in the context menu of the logs text box

        # clear the content of the logs text box
        self.txt_events_log.delete(1.0, "end")

        # reset the logs buffer
        logs.clear()

    #-------------------------------------------------------------------------------------------------
    def help_file_load(self):
        # load in the help text box widget the help file
        # done one time at the application start

        file_name = os.path.dirname(__file__) + os.sep + 'resources' + os.sep + 'Help.txt'

        try:
            with open(file_name, 'r') as f:   # errors='ignore'
                f.seek(0)
                # copy in the widget the help text
                self.txt_help.insert(1.0, f.read())
        except OSError as err:
            # it has not be possible to open the file
            messagebox.showinfo(title="ERROR", message=f'Cannot open the file "{file_name}"\n{err}')
            return False
        except IOError as e:
            messagebox.showinfo(title="ERROR", message=f'I/O error while opening the file "{file_name}"\n{e.errno}: {e.strerror}')
            return False
        except: #handle other exceptions such as attribute errors
            messagebox.showinfo(title="ERROR", message=f'Unexpected error while opening the file "{file_name}"\n{sys.exc_info()[0]}')
            return False

        # apply the ODF syntax highlighting
        self.odf_syntax_highlight(self.txt_help)
        # disable the text box to not permit its editing
        self.txt_help.configure(state='disabled')
        return True

    #-------------------------------------------------------------------------------------------------
    def help_search_next(self):
        # (GUI event callback) the user has clicked on the button '>'
        # show the next occurence of the text to search

        self.help_search_text(self.cmb_search_text.get(), True)

    #-------------------------------------------------------------------------------------------------
    def help_search_previous(self):
        # (GUI event callback) the user has clicked on the button '<'
        # show the previous occurence of the text to search

        self.help_search_text(self.cmb_search_text.get(), False)

    #-------------------------------------------------------------------------------------------------
    def help_search_clear(self):
        # (GUI event callback) the user has clicked on the button 'Clear'
        # clear the text to search (text box and highlighting)

        self.cmb_search_text.delete(0, END)
        self.help_search_text('', False)
        self.lab_search_occur_nb.config(text='')

        # update the status of some GUI widgets
        self.gui_status_update_search()

    #-------------------------------------------------------------------------------------------------
    def help_search_object(self):
        # (GUI event callback) the user has clicked on the button "Show in help"
        # search and display in the help the part describing the selected object UID

        if self.edited_object_uid not in (None, 'Header'):
            # substitute the digits by the char 9 in the object UID to create a generic object ID
            gen_object_UID = '['
            for c in self.edited_object_uid: gen_object_UID += '9' if c.isdigit() else c
            gen_object_UID += ']'

            # put the generic object UID in the search text widget
            self.cmb_search_text.delete(0, END)
            self.cmb_search_text.insert(0, gen_object_UID)

            # update the status of GUI widgets
            self.gui_status_update_search()

            # search the first occurence of the generic object ID
            self.help_search_next()

            # select the Help tab of the notebook
            self.notebook.select(self.frm_help)

    #-------------------------------------------------------------------------------------------------
    def help_search_text(self, text_to_find, search_next = True):
        # show in the help the next occurence (or previous if search_next=False) of the given text to find
        # highlight in yellow all the occurences of this text

        if text_to_find != '':
            text_len = len(text_to_find)
        else:
            text_to_find = None
            text_len = 0

        if text_to_find != self.text_to_search:
            # a new text has to be searched, highlight all its occurences in the entire help text

            # store the new text to search
            self.text_to_search = text_to_find

            # remove the highlight of the previous searched text occurences
            self.txt_help.tag_remove(self.tag_found, '1.0', END)
            self.txt_help.tag_remove(self.tag_found2, '1.0', END)
            nb_occurences = 0

            if text_to_find != None:
                # highlight the all occurences of the text to find in the entire help
                # configure the tag for the found text
                self.txt_help.tag_config(self.tag_found, foreground='black', background='yellow', font='Calibri 11')
                # get the lines of the text widget
                lines = self.txt_help.get('1.0', END).splitlines()
                # parse all the lines
                for l in range(0, len(lines)):
                    idx = 0
                    while idx != -1:
                        # check the various occurences of the searched text in the current line (if any)
                        idx = lines[l].find(text_to_find, idx)
                        if idx != -1:
                            # highlight the found occurence in the line
                            self.txt_help.tag_add(self.tag_found, f'{l+1}.{idx}', f'{l+1}.{idx} + {text_len} chars')
                            # move the search index after the found occurence
                            idx += text_len
                            nb_occurences += 1

                # display the number of occurences of the searched text
                if nb_occurences == 0:
                    self.lab_search_occur_nb.config(text='None occurence')
                elif nb_occurences == 1:
                    self.lab_search_occur_nb.config(text='1 occurence')
                else:
                    self.lab_search_occur_nb.config(text=f'{nb_occurences} occurences')

        if text_to_find != None:
            # search for the next/previous occurence of the text in the help

            # remove the highlight of the previous searched text occurence
            self.txt_help.tag_remove(self.tag_found2, '1.0', END)
            # configure the tag for the highlighted found text
            self.txt_help.tag_config(self.tag_found2, foreground='black', background='gold2', font='Calibri 11')

            if search_next and self.search_index != None:
                # if search upward, move the current search position after the previous found position
                self.search_index = f'{self.search_index} + {text_len} chars'

            # search for the next/previous occurence
            if self.search_index == None: self.search_index = '1.0'
            self.search_index = self.txt_help.search(text_to_find, self.search_index, backwards = not(search_next))
            if self.search_index == '': self.search_index = None

            if self.search_index != None:
                # show and highlight the found text
                self.txt_help.see(self.search_index)
                self.txt_help.tag_add(self.tag_found2, self.search_index, f'{self.search_index} + {text_len} chars')
            else:
                messagebox.showinfo(title="Search result", message=f'"{text_to_find}" not found (the search is case sensitive)')

    #-------------------------------------------------------------------------------------------------
    def help_search_text_key_pressed(self, event):
        # (GUI event callback) the user has pressed a keyboard key in the help text search box

        # remove the selection which appear automatically on the text when an item is selected in a combobox
        self.cmb_search_text.selection_clear()

        # update the status of GUI widgets
        self.gui_status_update_search()

        if event.keysym == 'Return' and self.cmb_search_text.get() != '':
            # the user has pressed the Return key : trigger a search next operation
            self.help_search_next()

    #-------------------------------------------------------------------------------------------------
    images_ref=[]  # list needed to keep in memory the reference to the images opened by PhotoImage and added in the text box, else they are not displayed (Python bug ?)

    def odf_syntax_highlight(self, txt_widget):
        # apply syntax highlighting to the content of the given object text box widget

        # remove the tags previously set in the text box
        txt_widget.tag_remove(self.tag_field, '1.0', END)
        txt_widget.tag_remove(self.tag_comment, '1.0', END)
        txt_widget.tag_remove(self.tag_obj_uid, '1.0', END)
        txt_widget.tag_remove(self.tag_title, '1.0', END)

        # put in a list the lines of the text box
        lines = txt_widget.get('1.0', END).splitlines()

        # parse all the characters of the text box lines
        for l in range(0, len(lines)):
            c0 = None
            for c in range(0, len(lines[l])):
                if lines[l][c] == ';':
                    # comment : apply the comment color until the end of the line
                    txt_widget.tag_add(self.tag_comment, f'{l+1}.{c}', f'{l+1}.0 lineend')
                    break  # skip the rest of the line
                elif lines[l][c] == '[':
                    # start of an object UID
                    c0 = c
                elif lines[l][c] == ']':
                    # end of an object UID : apply the UID color between the opening and closing brackets
                    if c0 != None:
                        txt_widget.tag_add(self.tag_obj_uid, f'{l+1}.{c0}', f'{l+1}.{c+1}')
                        c0 = None
                elif txt_widget.get(f'{l + 1}.{c}') == '=':
                    # equal character : apply the field color before the '='
                    txt_widget.tag_add(self.tag_field, f'{l+1}.0', f'{l + 1}.{c}')
                elif lines[l][:2] == 'Â§Â§' :
                    # image file to insert (in the help)
                    # recover the file name after the 'Â§Â§' tag
                    file_name = lines[l][2:]
                    # remove the file name in the widget
                    txt_widget.delete(f'{l+1}.0', f'{l+1}.0 lineend')
                    try:
                        # open the image file
                        photo = PhotoImage(file = os.path.dirname(__file__) + os.sep + 'resources' + os.sep + file_name)
                        # add the reference of the image in the list to store these references
                        self.images_ref.append(photo)
                        # insert the image in the text box
                        txt_widget.image_create(f'{l+1}.0', image=photo, padx=10, pady=10)
                    except:
                        # insert a message indicating that the image has not been opened
                        txt_widget.insert(f'{l+1}.0', f'!!! cannot open the image resources{os.sep + file_name}')
                    break
                elif lines[l][:2] == '>>' :
                    # title line (in the help) : apply the title color to the whole line
                    txt_widget.delete(f'{l+1}.0', f'{l+1}.3')
                    txt_widget.tag_add(self.tag_title, f'{l+1}.0', f'{l+1}.0 lineend')
                    break  # skip the rest of the line

    #-------------------------------------------------------------------------------------------------
    def odf_data_check(self):
        # check the consistency of the ODF data

        # ask to the user to apply his object data change before to launch the check
        if self.can_i_make_change(object_change_bool=True):
            # the user has not cancelled the operation

            # do the check
            self.odf_data.check_odf_data(self.progress_status_update)

            # update the events log text
            self.logs_display()

            # select the Logs tab of the notebook to show the check result
            self.notebook.select(self.frm_logs)

            self.gui_status_update_buttons()

    #-------------------------------------------------------------------------------------------------
    def progress_status_update(self, message):
        # callback function called by the C_GO_ODF_DATA.check_odf_data or C_ODF_HW2GO.GO_ODF_build_from_HW_ODF function
        # to display in the object links label widget a progress status message

        self.lab_odf_file_name.config(text=message)
        self.lab_odf_file_name['foreground'] = 'red3'
        self.lab_odf_file_name.update()

#-------------------------------------------------------------------------------------------------
class CreateToolTip(object):
    # class to create a tooltip for a given widget
    # tk_ToolTip_class101.py
    # gives a Tkinter widget a tooltip as the mouse is above the widget
    # tested with Python27 and Python34  by  vegaseat  09sep2014
    # www.daniweb.com/programming/software-development/code/484591/a-tooltip-class-for-tkinter
    # Modified to include a delay time by Victor Zaccardo, 25mar16
    # example of usage : tooltip = CreateToolTip(parend_widget, "string to display")
    def __init__(self, widget, text='widget info'):
        self.waittime = 500     #miliseconds
        self.wraplength = 180   #pixels
        self.widget = widget
        self.text = text
        self.widget.bind("<Enter>", self.enter)
        self.widget.bind("<Leave>", self.leave)
        self.widget.bind("<ButtonPress>", self.leave)
        self.id = None
        self.tw = None
    def enter(self, event=None):
        self.schedule()
    def leave(self, event=None):
        self.unschedule()
        self.hidetip()
    def schedule(self):
        self.unschedule()
        self.id = self.widget.after(self.waittime, self.showtip)
    def unschedule(self):
        id = self.id
        self.id = None
        if id: self.widget.after_cancel(id)
    def showtip(self, event=None):
        x = y = 0
        x, y, cx, cy = self.widget.bbox("insert")
        x += self.widget.winfo_rootx() + 25
        y += self.widget.winfo_rooty() + 20
        # creates a toplevel window
        self.tw = Toplevel(self.widget)
        # Leaves only the label and removes the app window
        self.tw.wm_overrideredirect(True)
        self.tw.wm_geometry("+%d+%d" % (x, y))
        label = Label(self.tw, text=self.text, justify='left',
        background="#ffffff", relief='solid', borderwidth=1,
        wraplength = self.wraplength)
        label.pack(ipadx=1)
    def hidetip(self):
        tw = self.tw
        self.tw= None
        if tw: tw.destroy()

#-------------------------------------------------------------------------------------------------
NOTES = ['C', 'Cis', 'D', 'Dis', 'E', 'F', 'Fis', 'G', 'Gis', 'A', 'Ais', 'B']
OCTAVES = list(range(11))
NOTES_IN_OCTAVE = len(NOTES)

def midi_number_to_note(number: int) -> tuple:
    # convert the given MIDI note number to note and octave numbers
    octave = number // NOTES_IN_OCTAVE
    assert octave in OCTAVES, f'Wrong octave {octave} number in midi_number_to_note function'
    assert 0 <= number <= 127, f'Wrong MIDI note number {number} in midi_number_to_note function'
    note = NOTES[number % NOTES_IN_OCTAVE]
    return note, octave

def midi_note_to_number(note: str, octave: int) -> int:
    # convert the given note and octave numbers to a MIDI note number
    assert note in NOTES, f'Wrong note name {note} in midi_note_to_number function input'
    assert octave in OCTAVES, f'Wrong octave number {octave} in midi_note_to_number function input'
    note = NOTES.index(note)
    note += (NOTES_IN_OCTAVE * octave)
    assert 0 <= note <= 127, f'Wrong note number {note} in midi_note_to_number function'
    return note

#-------------------------------------------------------------------------------------------------
def myint(data):
    # return the given data in integer format, or None if it cannot be converted to integer or is not defined

    if data == None:
        return None

    try:
        return int(data)
    except:
        return None

#-------------------------------------------------------------------------------------------------
def myfloat(data):
    # return the given data in float format, or None if it cannot be converted to float or is not defined

    if data == None:
        return None

    try:
        return float(data)
    except:
        return None

#-------------------------------------------------------------------------------------------------
def mystr(data):
    # return the given data in string format, or None if the given data cannot be converted to string or '' if it is not defined

    if data == None:
        return ''

    try:
        return str(data)
    except:
        return None

#-------------------------------------------------------------------------------------------------
prev_actual_file_name = ''  # variable to keep in memory the previous found actual file name, to speed up the processing of the next one if there are common parts
def get_actual_file_name(file_name):
    # return the given file path/name with the actual characters case as they are defined on the storage
    # return None if the given file name doesn't exist
    # the given file path/name must have the path separator of the OS on which is running the script

    global prev_actual_file_name

    # split the given file name by elements separated by the OS path separator
    file_name_split = file_name.split(os.sep)
    file_name_split_len = len(file_name_split)

    i = 0
    if prev_actual_file_name != '':
        # recover from the previous actual file name the path elements which are equal to the one of the given file name (to spend less time in the next while loop)
        # split the previous actual file name by elements separated by the OS path separator
        prev_actual_file_name_split = prev_actual_file_name.split(os.sep)
        actual_file_name = ''
        while i < file_name_split_len and file_name_split[i].lower() == prev_actual_file_name_split[i].lower():
            actual_file_name += prev_actual_file_name_split[i] + os.sep
            i += 1
        if i == file_name_split_len:
            # the entire previous actual file name has been recovered, remove the last separator
            actual_file_name = actual_file_name[:-1]

    if i == 0:
        # nothing to recover from the previous actual file name or it is empty
        # we consider that the root folder of the given file name has the actual case
        actual_file_name = file_name_split[0] + os.sep
        i = 1

    # recover from the storage the actual name of the remaining elements of the given file path/name
    while i < file_name_split_len:
        found = False
        for actual_element in os.listdir(actual_file_name):
            if actual_element.lower() == file_name_split[i].lower():
                found = True
                break
        if not found:
            return None
        actual_file_name = os.path.join(actual_file_name, actual_element)
        i += 1

    prev_actual_file_name = actual_file_name
    return actual_file_name

#-------------------------------------------------------------------------------------------------
def path2ospath(file_name):
    # replace the / or \ in the given file name by the OS separator

    if os.sep == '/':
        return file_name.replace('\\', os.sep)
    else:
        return file_name.replace('/', os.sep)

#-------------------------------------------------------------------------------------------------
dialog_wnd_w = 300
dialog_wnd_h = 450

def ask_choose_list_items(parent_wnd, title, message, choice_items_list, preselect_items_list = [], multiselect_bool=False, resizable_wnd_bool=True):
    # opens a dialog box to ask the user to select items in the given choice items list
    # if items are provided in preselect_items_list and they are present in choice_items_list, they are pre-selected in the list
    # returns a list containing the items selected in the given choice items list, or None if the user clicked on Cancel or close button

    global dialog_wnd_w
    global dialog_wnd_h

    # disable the parent window so that the dialog box is modal (only possible in Windows OS)
    if os.name == 'nt':
        parent_wnd.wm_attributes("-disabled", True)

    # create the toplevel modal dialog window
    dialog_wnd = Toplevel(parent_wnd, takefocus=True)
    dialog_wnd.title(title)
    if not resizable_wnd_bool:
        dialog_wnd.resizable(False, False)

    # place the dialog window at the center of the parent window
    parent_wnd_x = parent_wnd.winfo_x()
    parent_wnd_y = parent_wnd.winfo_y()
    parent_wnd_w = parent_wnd.winfo_width()
    parent_wnd_h = parent_wnd.winfo_height()
    dialog_wnd_x = parent_wnd_x + int(parent_wnd_w/2) - int(dialog_wnd_w/2)
    dialog_wnd_y = parent_wnd_y + int(parent_wnd_h/2) - int(dialog_wnd_h/2)
    if dialog_wnd_x < 0: dialog_wnd_x = 0
    if dialog_wnd_y < 0: dialog_wnd_y = 0
    dialog_wnd.geometry(f"{dialog_wnd_w}x{dialog_wnd_h}+{dialog_wnd_x}+{dialog_wnd_y}")

    # tell the window manager this is the child window of the parent window, permits to let the child window flash if one clicks onto parent
    dialog_wnd.transient(parent_wnd)
    dialog_wnd.focus_force()

    # string var permitting to know the reason of the dialog box closure
    closure_reason = StringVar()
    closure_reason.set('none')

    # link to the callback to manage the window closure
    dialog_wnd.protocol("WM_DELETE_WINDOW",  lambda reason='cancel': closure_reason.set(reason))

    # create the top label widget
    listdialog_label = Label(dialog_wnd, text=message, fg="black", anchor='center', wraplength=dialog_wnd_w - 10, height=2)
    listdialog_label.pack(side='top', padx=5, pady=5, fill='x')

    # frame to occupy the bottom area of the dialog window and to encapsulate OK and Cancel buttons
    listdialog_frm1 = Frame(dialog_wnd)
    listdialog_frm1.pack(side='bottom', fill='x')

    # OK button
    toplevel_dialog_yes_button = Button(listdialog_frm1, text='OK', command=lambda reason='ok': closure_reason.set(reason))
    toplevel_dialog_yes_button.pack(side='left', padx=5, pady=5, fill='x', expand=1)

    # Cancel button
    toplevel_dialog_no_button = Button(listdialog_frm1, text='Cancel', command=lambda reason='cancel': closure_reason.set(reason))
    toplevel_dialog_no_button.pack(side='left', padx=5, pady=5, fill='x', expand=1)

    # frame to occupy the middle area of the window and to encapsulate the list and its vertical scroll bar
    listdialog_frm2 = Frame(dialog_wnd)
    listdialog_frm2.pack(side='top', fill='both', padx=5, expand=1)

    # list box widget with its vertical scroll bar
    scrollbarv = ttk.Scrollbar(listdialog_frm2, orient='vertical')
    scrollbarv.pack(side='right', fill='y')
    listdialog_list = Listbox(listdialog_frm2, selectmode=('multiple' if multiselect_bool else 'single'))
    listdialog_list.pack(side='left', fill='both', expand=1)
    listdialog_list.config(yscrollcommand=scrollbarv.set)
    scrollbarv.config(command=listdialog_list.yview)

    # fill the list box
    see_used_bool = False
    for item in choice_items_list:
        # parse the items of the choice list
        # add the current item to the list widget
        listdialog_list.insert('end', item)
        if item in preselect_items_list:
            # the current has to be selected
            listdialog_list.selection_set('end')
            if not see_used_bool:
                # make visible the first selected item
                listdialog_list.see('end')
                see_used_bool = True

    # wait for the change of the StringVar closure_reason
    dialog_wnd.wait_variable(closure_reason)

    if closure_reason.get() == 'ok':
        # the user has clicked on the OK button, recover the list of the selected items
        selected_items_list = []
        for i in listdialog_list.curselection():
            selected_items_list.append(listdialog_list.get(i))
    else:
        selected_items_list = None

    # store the dialog window current dimensions
    dialog_wnd_w = dialog_wnd.winfo_width()
    dialog_wnd_h = dialog_wnd.winfo_height()

    # re-enable the parent window
    if os.name == 'nt':
        parent_wnd.wm_attributes("-disabled", False)
    # destroy this dialog box
    dialog_wnd.destroy()
    # restore the parent window if it was in icon state
    parent_wnd.deiconify()

    return selected_items_list

#-------------------------------------------------------------------------------------------------
def main():
    # main function of the application

    # initiate a C_GUI class instance, display the main window based on this instance, start the main loop of this window
    C_GUI().wnd_main_build().mainloop()

#-------------------------------------------------------------------------------------------------
# first line of code executed at the launch of the script
# if we are in the main execution environment, call the main function of the application
if __name__ == '__main__': main()
