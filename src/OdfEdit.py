"""
-------------------------------------------------------------------------------
 Name:        OdfEdit
 Purpose:     Application helping to edit an organ definition file (ODF) in plain text
              and permitting to convert a Hauptwerk ODF into GrandOrgue ODF
              The ODF can be used in the GrandOrgue application
              Implemented with Python 3.1x
              Tested in Windows 10 and Ubuntu 21.10
              It is contains 6 classes :
                   C_LOGS to manage the logs generated by the various fonctions of the application
                   C_ODF_DATA_CHECK to check the syntax and the consistency of the edited ODF data
                   C_ODF_DATA to manage the edited ODF data
                   C_ODF_HW2GO to manage the convertion from a Hauptwerk ODF to a GrandOrgue ODF
                   C_GUI to manage the graphical user interface of the application
                   CreateToolTip to display a tool tip on a GUI widget
 Author:      Eric Turpault (France, Châtellerault)
 Copyright:   open source
 Licence:     free to modify, please share the modification with the author

 The considered GrandOrgue ODF syntax is :
    [object_uid]  ; comment
    ; comment line, empty lines are ignored
    ; object_uid can contain only alphanumeric characters
    attribute1=value1  ; comment
    attribute2=value2
    ; attribute can contain only alphanumeric or '_' characters

 The new panel format is detected if the Panel000 object is present and contains the attribute NumberOfGUIElements

 Versions history :
   v1.0 - 15 April 2022 - initial version
   v1.1 - 16 April 2022 - minor changes to be Linux compatible, minor GUI fixes
   v1.2 - 27 April 2022 - some GUI behavior improvements, minor improvements in the help and the objects checks
   v1.3 - 19 May   2022 - data management improvement, change in the way to define the parent-child relations between the objects,
                          completed some attributes values maximum check, added a tab to search a string in the whole ODF
   v2.0 - 23 Dec.  2022 - fix made in the function check_object_Manual around the key_type checks
                          fix made in the function check_attribute_value to not change out of range integer value and better check HTML color code
                          use the PIL library instead of Tk to check the sample set images sizes
                          first implementation of the Hauptwerk to GrandOrgue ODF conversion feature
   v2.1 - 22 Dec.  2023 - HW2GO : fix for files path separator management in various OS
                          HW2GO : get the actual files path/name/extension case from the HW sample set instead of from the HW ODF
                          HW2GO : some design changes without functional impact
                          HW2GO : added general sound stops (blower, bells, ...) and stop action noise support
   v2.2 - 12 Jan. 2023  - HW2GO : improved and more robust way to detect Stop / Coupler / Switch objects to build
                          HW2GO : fix of issues observed with some newly tested HW sample sets
                          HW2GO : added support of HW continuous control and enclosure objects, converted into GO enclosure objects
                          GUI : graphical user interface rework with resizable width for lists and notebook areas
                          GUI : Organ object placed systematically at the top of the objects list
   v2.3 - 08 April 2023 - fix for help text not loaded with Windows OdfEdit.exe (fix in file Help.txt due to characters 0x81 not supported by unicode format)
                          add the support of comments at the end of the lines in the ODF
                          add the support of the separator / in the files path in the ODF
                          improved display and selection of parents/children objects of the selected object
                          improved several behaviors in the GUI management
                          ODF saving in a file places the objects by alphabetical UID order, but Header and Organ which are placed in first position
                          new buttons to add, link to parents/children or rename an object, with automatical update of the object referencing
                             and the total number in other objects, new panel format only is supported
                          HW2GO : visual elements of the main panel are now defined in Panel999Element999 objects
                          HW2GO : Switches have by default StoreInDivisional=Y, StoreInGeneral=Y, GCState=0
                          HW2GO : added a menu item checkbox to ask to convert to GO ranks the HW ranks not used by OdfEdit
   v2.4 - 30 May 2023   - objects having child(ren) cannot be deleted with the button Delete
                          added a menu item checkbox to select the file format to use when saving an ODF (ISO_8859_1 or UTF-8 BOM)
                          added a menu item checkbox to disable the automatic objects tree expand on object selection
                          added a menu item checkbox to enable the wave based tremulants convertion from HW to GO
                          added a menu item checkbox to enable the unused ranks convertion from HW to GO
                          configuration data of the application (last ODF folder, options of the menu) are saved in a file OdfEdit.cfg
                          improvements made in the objects list/tree behavior on object selection or change
                          the parents/children of the selected object can be selected and edited in the central list (above the text editor)
                          a double-click on a parent/child object makes it the selected object in the list/tree
                          ctrl+s keys permits to save changes in the edited object and to save changed data in the ODF
                          escape key permits to close the pop-up windows permitting to select parent/children objects
                          added the possiblity to search a text inside the loaded HW ODF
                          HW2GO : removed the attribute AcceptRetuning=N in ranks of pipes
                          HW2GO : pitch tuning attribute used for pipes which the sample has a different native frequency
                          HW2GO : convert the conditional switches (switches which the state depends on the state of other switches)
                          HW2GO : convert the synthetized and wave based tremulants
                          HW2GO : the stop and coupler objects are numeroted according to the manual number to which they belong to
                          several bugs fixing as at each release
   v2.5 -               - manage drag&drop of one object (type : Coupler, Enclosure, PanelElement, PanelImage, Rank, Stop, Tremulant)
                            between the objects lists or tree, in order to move it under another parent object
                          drag&drop with Control key pressed adds a copy of the dragged object as child of the object on which the drop has been done
                          Ctrl-a in the object edition or the logs text boxes permits to selected all the text (needed for Linux)
                          Paste in the object edition text box replaces the current selected text if any (needed for Linux)
                          HW2GO : do not generate optional attributes which are equal to their default value
                          HW2GO : check that the mouse or text rectangle doesn't exceed the image size of a switch or label
                          HW2GO : unused HW noise ranks are converted to GO ranks if the convertion option is enabled in the menu
                          some bugs fixing and improvements as at each release

TO DO in next releases :
    problème du past dans zone d'édition d'objet si ODF vierge (CLIPBOARD selection doesn't exist or form "STRING" not defined)
    le General Cancel de Smecno est converti en switch et non en GC
    include the label text without background in the switch DispLabelText if it overlaps the switch rectangle
    définir le text rectangle en fonction de la position du texte par rapport au rectangle de l'objet recouvert
    use the MIDI note number to calculate the shift between division to ranks (exemple avec le sample set positif)
    add a manual compass extension feature
    manage the keyboard noises
-------------------------------------------------------------------------------
"""

APP_VERSION = 'v2.5 Beta1'
RELEASE_DATE = 'June 17th 2023'

DEV_MODE = False
LOG_HW2GO_drawstop = False
LOG_HW2GO_coupler = False
LOG_HW2GO_tremulant = False
LOG_HW2GO_ctrl_switch = False

MAIN_WINDOW_TITLE = 'OdfEdit - ' + APP_VERSION + (' - DEV MODE' if DEV_MODE else '')

import os
import shutil
import math
import inspect

from tkinter import *
from tkinter import filedialog as fd
from tkinter import simpledialog as sd
from tkinter import messagebox, ttk
import tkinter.font as tkf

from PIL import Image   # install with : pip install pillow
from lxml import etree  # install with : pip install lxml


# warning message displayed before to start a HW to GO ODF conversion
HW_CONV_MSG = """An ODF will be built in order to use the selected Hauptwerk sample set in the GrandOrgue application. None file of the Hauptwerk sample set will be modified.
ATTENTION :
- Please do this operation only with a free Hauptwerk sample set or a not-free sample set that you have duly paid for, and if the editor of this sample set does not preclude its use outside Hauptwerk application.
- Don't expect to have necessarily with GrandOrgue the sound quality and all control possibilities that this sample set can have with Hauptwerk.
"""

ODF_COMMENT = 'GrandOrgue ODF automatically generated from a Hauptwerk ODF by OdfEdit ' + APP_VERSION + ' (see github.com/GrandOrgue/ODFEdit)'

ENCODING_ISO_8859_1 = 'ISO-8859-1'  # ISO-8859-1 encoding for ODF file saving
ENCODING_UTF8_BOM   = 'utf_8_sig'   # UTF-8 encoding for ODF file saving

ALLOWED_CHARS_4_FIELDS = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_'  # characters allowed in a attribute name

# data types used in the attributes of the objects, used in the check object/attribute functions
ATTR_TYPE_INTEGER = 1
ATTR_TYPE_FLOAT = 2
ATTR_TYPE_BOOLEAN = 3
ATTR_TYPE_STRING = 4
ATTR_TYPE_COLOR = 5            # used in Button, Enclosure, Label, Panel
ATTR_TYPE_FONT_SIZE = 6        # used in Button, Enclosure, Label
ATTR_TYPE_PANEL_SIZE = 7       # used in Panel
ATTR_TYPE_COUPLER_TYPE = 8     # used in Coupler
ATTR_TYPE_ELEMENT_TYPE = 9     # used in Panel Element
ATTR_TYPE_TREMULANT_TYPE = 10  # used in Tremulant
ATTR_TYPE_PISTON_TYPE = 11     # used in Piston
ATTR_TYPE_DRAWSTOP_FCT = 12    # used in DrawStop
ATTR_TYPE_FILE_NAME = 13       # used in many objects for bitmap or wav files
ATTR_TYPE_OBJECT_REF = 14      # used in many objects to make a reference to another object ID
ATTR_TYPE_PIPE_WAVE = 15       # used in Rank

# tags for the text syntax highlighting in the object edition textbox and help
TAG_FIELD   = 'tag_field'      # tag to color the fields names of the objects
TAG_COMMENT = 'tag_comment'    # tag to color the comments
TAG_OBJ_UID = 'tag_obj_uid'    # tag to color the object UID
TAG_TITLE   = 'tag_title'      # tag to color the titles in the help
TAG_FOUND   = 'tag_found'      # tag to color the strings found by the search in the help
TAG_FOUND2  = 'tag_found2'     # tag to color the found string currently highlighted

TAG_SAME_UID = 'tag_same_uid'  # tag to color in the objects tree the items having the same UID as the selected one

COLOR_SELECTED_ITEM = 'RoyalBlue1'  # background color for the selected object UID in the lists or tree
COLOR_OBJ_UID_ITEM  = 'LightBlue1'  # background color for the objects of the lists or tree having the selected object UID

# constants to identify the type of link between two objects
TO_PARENT = 1
TO_CHILD = 2

# constants to make the functions parameters more understandable
FIRST_ONE = True
MANDATORY = True

#-------------------------------------------------------------------------------------------------
class C_LOGS:
    # class to manage logs

    logs_list = [] # list of logs strings (errors or messages resulting from file operation or syntax check)

    #-------------------------------------------------------------------------------------------------
    def add(self, log_string):
        # add the given string to the events log list
        self.logs_list.append(log_string)

    #-------------------------------------------------------------------------------------------------
    def get(self):
        # recover the logs list
        return self.logs_list

    #-------------------------------------------------------------------------------------------------
    def nb_get(self):
        # recover the number of logs present in the list
        return len(self.logs_list)

    #-------------------------------------------------------------------------------------------------
    def clear(self):
        # clear the log list
        self.logs_list.clear()

# create an instance of the C_LOGS class
logs = C_LOGS()

#-------------------------------------------------------------------------------------------------
class C_ODF_DATA_CHECK:
    # class to check the data contained in the GO ODF data

    check_files_names_bool = None  # flag storing the choice of the user to check or not the files names in the ODF (None if not defined, False, True)
    checked_attr_nb = 0            # number of attributes checked during the checking operation

    #-------------------------------------------------------------------------------------------------
    def check_odf_data(self, progress_status_update_fct):
        # check the consistency of the data which are present in ODF data of the C_ODF_DATA class

        if self.check_files_names_bool == None:
            # ask the user if he wants to check the files names (to make a faster check)
            self.check_files_names_bool = messagebox.askyesno("ODF Editor", "Do you want to check the files names (to have a faster check or to test only the ODF content) ? \nThis choice will be kept until the next ODF opening")

        self.checked_attr_nb = 0

        logs.add("ODF data check report :")

        # check the presence of the Organ object
        if 'Organ' not in self.odf_data_dic.keys():
            logs.add("ERROR the Organ object is not defined")

        for object_uid, object_dic in sorted(self.odf_data_dic.items()):
            # scan the objects of the ODF data

            # recover a copy of the lines of the current object
            object_lines_list = list(object_dic['lines'])

            # update in the GUI the name of the checked object
            progress_status_update_fct(f'Checking {object_uid}...')

            if len(object_lines_list) > 0:
                # lines have been recovered for the current object

                # sort the lines list to make faster the search which is done in check_attribute_value
                object_lines_list.sort()

                # remove the first line while it is empty (after the sorting the empty lines are all in first positions)
                while len(object_lines_list) > 0 and object_lines_list[0] == '':
                    object_lines_list.pop(0)

                # check if the attributes are all uniques in the object
                self.check_attributes_unicity(object_uid, object_lines_list)

                # check the attributes and values of the object by type
                object_type = self.object_type_get(object_uid)
                if object_type == 'Header':
                    pass
                elif object_type == 'Organ':
                    self.check_object_Organ(object_uid, object_lines_list)
                elif object_type == 'Coupler':
                    self.check_object_Coupler(object_uid, object_lines_list)
                elif object_type == 'Divisional':
                    self.check_object_Divisional(object_uid, object_lines_list)
                elif object_type == 'DivisionalCoupler':
                    self.check_object_DivisionalCoupler(object_uid, object_lines_list)
                elif object_type == 'Enclosure':
                    self.check_object_Enclosure(object_uid, object_lines_list)
                elif object_type == 'General':
                    self.check_object_General(object_uid, object_lines_list)
                elif object_type == 'Image':
                    self.check_object_Image(object_uid, object_lines_list)
                elif object_type == 'Label':
                    self.check_object_Label(object_uid, object_lines_list)
                elif object_type == 'Manual':
                    self.check_object_Manual(object_uid, object_lines_list)
                elif object_type == 'Panel':
                    self.check_object_Panel(object_uid, object_lines_list)
                elif object_type == 'PanelElement':
                    self.check_object_PanelElement(object_uid, object_lines_list)
                elif object_type[:5] == 'Panel': # Panel999Coupler999, Panel999Divisional999, Panel999Image999, ...
                    self.check_object_PanelOther(object_uid, object_lines_list)
                elif object_type == 'Rank':
                    self.check_object_Rank(object_uid, object_lines_list)
                elif object_type == 'ReversiblePiston':
                    self.check_object_ReversiblePiston(object_uid, object_lines_list)
                elif object_type == 'SetterElement':
                    self.check_object_SetterElement(object_uid, object_lines_list)
                elif object_type == 'Stop':
                    self.check_object_Stop(object_uid, object_lines_list)
                elif object_type == 'Switch':
                    self.check_object_Switch(object_uid, object_lines_list)
                elif object_type == 'Tremulant':
                    self.check_object_Tremulant(object_uid, object_lines_list)
                elif object_type == 'WindchestGroup':
                    self.check_object_WindchestGroup(object_uid, object_lines_list)
                else:
                    # the object UID has not been recognized
                    logs.add(f"WARNING the object type of {object_uid} is unknown")
                    # empty the lines list of the object which is not recognized, to not display in the log its attributes which have not been checked
                    object_lines_list = []

                # check the lines not checked by the function check_attribute_value() (that is which are still present in the lines list)
                for line in object_lines_list:
                    (error_msg, attr_name, attr_value, comment) = self.object_line_split(line)
                    if error_msg != None:
                        logs.add(f'ERROR in {object_uid} section, line "{line}" : {error_msg}')

                    if attr_name not in (None, 'uid'):
                        # the current line is an attribute line
                        self.checked_attr_nb += 1
                        logs.add(f"WARNING in {object_uid} : the attribute {attr_name} is not expected in this object section or is misspelled")

        # display in the log the number of checked attributes
        logs.add(f"{self.checked_attr_nb:,} attributes checked")

        # update the panel format flag
        self.check_panel_format()

        # display in the log if none error has been detected
        if logs.nb_get() <= 3:  # 3 log lines when no error : check start message + detected panel format + number of checked attributes
            logs.add("None error found")

    #-------------------------------------------------------------------------------------------------
    def check_panel_format(self):
        # check which is the panel format used in the ODF (new or old) and update the flag

        value = self.object_attr_value_get('Panel000', 'NumberOfGUIElements')
        if value != None:
            self.new_panel_format_bool = (value.isdigit() and int(value) >= 0)
        else:
            self.new_panel_format_bool = False

        if self.new_panel_format_bool:
            logs.add(f'New panel format')
        else:
            logs.add(f'Old panel format')

    #-------------------------------------------------------------------------------------------------
    def check_object_uid(self, object_uid):
        # return an error message if an issue has been detected in the given object UID, else None

        error_msg = None

        object_type = self.object_type_get(object_uid)

        if not object_uid.isalnum():
            error_msg = 'an object identifier must contain only alphanumeric characters'
        elif object_type not in self.go_objects_children_dic.keys():
            error_msg = f'{object_type} is an unknown object type'
        elif object_type not in ('Organ', 'Header'):
            if not object_uid[-3:].isdigit():
                error_msg = f'three digits are expected at the end of "{object_uid}"'
            elif int(object_uid[-3:]) == 0 and not object_type in ('Panel', 'Manual'):
                error_msg = f"{object_uid} cannot have the index 000"
            elif object_uid[:5] == 'Panel' and len(object_uid) > 8 and not object_uid[5:8].isdigit():
                # Panel999xxxxx999 object
                error_msg = f'three digits are expected after "Panel" in "{object_uid}"'

        return error_msg

    #-------------------------------------------------------------------------------------------------
    def check_object_line(self, line):
        # check the syntax of the given object line and extract from it the attribute name + attribute value + comment
        # return a tuple containing : (error message, attribute name, attribute value, comment)
        # attribute name = 'uid' if the given line contains an object UID between brackets, the UID is in the attribute value
        # error message = an error description message in case a syntax error has been detected in the given line, or None if no error found

        error_msg = attr_name = attr_value = comment = None

        if len(line) > 0: # not an empty line
            if line[0] == "[":
                # line with an object UID inside normally
                pos = line.find(']', 1)
                if pos == -1:  # object ID without closing bracket
                    error_msg = 'character "]" is missing to define an object ID'
                    comment = line
                elif pos == 1: # object ID with no string between the brackets
                    error_msg = 'no object identifier defined between the brackets'
                    comment = line
                else:
                    attr_name = 'uid'
                    attr_value = line[1:pos]
                    # check the coherency of the UID
                    error_msg = self.check_object_uid(attr_value)

                    if error_msg == None and len(line) > pos + 1:
                        # there are characters after the ]
                        comment = line[pos+1:]
                        if comment.lstrip()[0] != ';':
                            error_msg = 'only text beginning by ; is allowed after the ] character'

            elif line[0] != ";":  # not a comment line
                pos = line.find('=', 0)
                if pos == -1:  # no equal character in the line
                    error_msg = 'character ";" missing at the beginning of the line to make it a comment line'
                    comment = line
                elif pos == 0:  # the line starts by an equal character
                    error_msg = 'the character "=" cannot start a line'
                    comment = line
                elif line.find('=', pos+1) > pos:  # another equal character is present in the line
                    error_msg = 'more than one character "=" is defined'
                    comment = line
                else:
                    attr_name = line[0:pos]
                    for char in attr_name:
                        if char not in ALLOWED_CHARS_4_FIELDS:
                            # the attribute name has a forbiden character
                            error_msg = f'the attribute "{attr_name}" can contain only alphanumeric or "_" characters'
                            break

                    posc = line.find(';', pos + 1)
                    if posc != -1:
                        # there is a comment after the attribute value
                        while line[posc-1] == ' ': posc -= 1
                        attr_value = line[pos+1:posc]
                        comment = line[posc:]
                    else:
                        attr_value = line[pos+1:]
                    attr_value = attr_value.rstrip()

            else: # comment or empty line
                comment = line

        return (error_msg, attr_name, attr_value, comment)


    #-------------------------------------------------------------------------------------------------
    def check_object_Organ(self, object_uid, lines_list):
        # check the data of an Organ object section which the lines are in the given lines list

        # required attributes
        self.check_attribute_value(object_uid, lines_list, 'ChurchName', ATTR_TYPE_STRING, True)
        self.check_attribute_value(object_uid, lines_list, 'ChurchAddress', ATTR_TYPE_STRING, True)

        value = self.check_attribute_value(object_uid, lines_list, 'HasPedals', ATTR_TYPE_BOOLEAN, True)
        if value != None and value == "Y" and not ('Manual000' in self.odf_data_dic):
            logs.add(f"ERROR in {object_uid} : HasPedals=Y but no Manual000 object is defined")
        elif value == "N" and ('Manual000' in self.odf_data_dic):
            logs.add(f"ERROR in {object_uid} : HasPedals=N whereas a Manual000 object is defined")

        value = self.check_attribute_value(object_uid, lines_list, 'NumberOfDivisionalCouplers', ATTR_TYPE_INTEGER, True, 0, 8)
        if value != None and value.isdigit() and int(value) >= 0:
            count = self.objects_type_number_get('DivisionalCoupler')
            if count != int(value):
                logs.add(f"ERROR in {object_uid} : NumberOfDivisionalCouplers={value} whereas {count} DivisionalCoupler object(s) defined")

        value = self.check_attribute_value(object_uid, lines_list, 'NumberOfEnclosures', ATTR_TYPE_INTEGER, True, 0, 999)
        if value != None and value.isdigit() and int(value) >= 0:
            count = self.objects_type_number_get('Enclosure')
            if count != int(value):
                logs.add(f"ERROR in {object_uid} : NumberOfEnclosures={value} whereas {count} Enclosure object(s) defined")

        value = self.check_attribute_value(object_uid, lines_list, 'NumberOfGenerals', ATTR_TYPE_INTEGER, True, 0, 99)
        if value != None and value.isdigit() and int(value) >= 0:
            count = self.objects_type_number_get('General')
            if count != int(value):
                logs.add(f"ERROR in {object_uid} : NumberOfGenerals={value} whereas {count} General object(s) defined")

        value = self.check_attribute_value(object_uid, lines_list, 'NumberOfManuals', ATTR_TYPE_INTEGER, True, 1, 16)
        if value != None and value.isdigit() and int(value) >= 0:
            count = self.objects_type_number_get('Manual')
            if 'Manual000' in self.odf_data_dic.keys(): count -= 1
            if count != int(value):
                logs.add(f"ERROR in {object_uid} : NumberOfManuals={value} whereas {count} Manual object(s) defined")

        value = self.check_attribute_value(object_uid, lines_list, 'NumberOfPanels', ATTR_TYPE_INTEGER, self.new_panel_format_bool, 0, 100)
        if value != None and value.isdigit() and int(value) >= 0:
            count = self.objects_type_number_get('Panel')
            if 'Panel000' in self.odf_data_dic.keys(): count -= 1
            if count != int(value):
                logs.add(f"ERROR in {object_uid} : NumberOfPanels={value} whereas {count} Panel object(s) defined")

        if self.new_panel_format_bool and not ('Panel000' in self.odf_data_dic):
            logs.add("ERROR new panel format used but no Panel000 object is defined")
        elif not self.new_panel_format_bool and ('Panel000' in self.odf_data_dic):
            logs.add(f"ERROR in {object_uid} : old panel format used whereas a Panel000 is defined")

        value = self.check_attribute_value(object_uid, lines_list, 'NumberOfReversiblePistons', ATTR_TYPE_INTEGER, True, 0, 32)
        if value != None and value.isdigit() and int(value) >= 0:
            count = self.objects_type_number_get('ReversiblePiston')
            if count != int(value):
                logs.add(f"ERROR in {object_uid} : NumberOfReversiblePistons={value} whereas {count} ReversiblePiston object(s) defined")

        value = self.check_attribute_value(object_uid, lines_list, 'NumberOfTremulants', ATTR_TYPE_INTEGER, True, 0, 10)
        if value != None and value.isdigit() and int(value) >= 0:
            count = self.objects_type_number_get('Tremulant')
            if count != int(value):
                logs.add(f"ERROR in {object_uid} : NumberOfTremulants={value} whereas {count} Tremulant object(s) defined")

        value = self.check_attribute_value(object_uid, lines_list, 'NumberOfWindchestGroups', ATTR_TYPE_INTEGER, True, 1, 999)
        if value != None and value.isdigit() and int(value) >= 0:
            count = self.objects_type_number_get('WindchestGroup')
            if count != int(value):
                logs.add(f"ERROR in {object_uid} : NumberOfWindchestGroups={value} whereas {count} WindchestGroup object(s) defined")

        self.check_attribute_value(object_uid, lines_list, 'DivisionalsStoreIntermanualCouplers', ATTR_TYPE_BOOLEAN, True)
        self.check_attribute_value(object_uid, lines_list, 'DivisionalsStoreIntramanualCouplers', ATTR_TYPE_BOOLEAN, True)
        self.check_attribute_value(object_uid, lines_list, 'DivisionalsStoreTremulants', ATTR_TYPE_BOOLEAN, True)
        self.check_attribute_value(object_uid, lines_list, 'GeneralsStoreDivisionalCouplers', ATTR_TYPE_BOOLEAN, True)

        # optional attributes
        self.check_attribute_value(object_uid, lines_list, 'OrganBuilder', ATTR_TYPE_STRING, False)
        self.check_attribute_value(object_uid, lines_list, 'OrganBuildDate', ATTR_TYPE_STRING, False)
        self.check_attribute_value(object_uid, lines_list, 'OrganComments', ATTR_TYPE_STRING, False)
        self.check_attribute_value(object_uid, lines_list, 'RecordingDetails', ATTR_TYPE_STRING, False)
        self.check_attribute_value(object_uid, lines_list, 'InfoFilename', ATTR_TYPE_STRING, False)

        value = self.check_attribute_value(object_uid, lines_list, 'NumberOfImages', ATTR_TYPE_INTEGER, False, 0, 999) # old panel format
        if value != None and value.isdigit() and int(value) >= 0:
            count = self.objects_type_number_get('Image')
            if count != int(value):
                logs.add(f"ERROR in {object_uid} : NumberOfImages={value} whereas {count} Image object(s) defined")

        value = self.check_attribute_value(object_uid, lines_list, 'NumberOfLabels', ATTR_TYPE_INTEGER, False, 0, 999)  # old panel format
        if value != None and value.isdigit() and int(value) >= 0:
            count = self.objects_type_number_get('Label')
            if count != int(value):
                logs.add(f"ERROR in {object_uid} : NumberOfLabels={value} whereas {count} Label object(s) defined")

        value = self.check_attribute_value(object_uid, lines_list, 'NumberOfRanks', ATTR_TYPE_INTEGER, False, 0, 999)
        if value != None and value.isdigit() and int(value) >= 0:
            count = self.objects_type_number_get('Rank')
            if count != int(value):
                logs.add(f"ERROR in {object_uid} : NumberOfRanks={value} whereas {count} Rank object(s) defined")

        value = self.check_attribute_value(object_uid, lines_list, 'NumberOfSetterElements', ATTR_TYPE_INTEGER, False, 0, 999)  # old panel format
        if value != None and value.isdigit() and int(value) >= 0:
            count = self.objects_type_number_get('SetterElement')
            if count != int(value):
                logs.add(f"ERROR in {object_uid} : NumberOfSetterElements={value} whereas {count} SetterElement object(s) defined")

        value = self.check_attribute_value(object_uid, lines_list, 'NumberOfSwitches', ATTR_TYPE_INTEGER, False, 0, 999)
        if value != None and value.isdigit() and int(value) >= 0:
            count = self.objects_type_number_get('Switch')
            if count != int(value):
                logs.add(f"ERROR in {object_uid} : NumberOfSwitches={value} whereas {count} Switch object(s) defined")

        self.check_attribute_value(object_uid, lines_list, 'CombinationsStoreNonDisplayedDrawstops', ATTR_TYPE_BOOLEAN, False)
        self.check_attribute_value(object_uid, lines_list, 'AmplitudeLevel', ATTR_TYPE_FLOAT, False, 0, 1000)
        self.check_attribute_value(object_uid, lines_list, 'Gain', ATTR_TYPE_FLOAT, False, -120, 40)
        self.check_attribute_value(object_uid, lines_list, 'PitchTuning', ATTR_TYPE_FLOAT, False, -1200, 1200)
        self.check_attribute_value(object_uid, lines_list, 'TrackerDelay', ATTR_TYPE_FLOAT, False, 0, 10000)

        if not self.new_panel_format_bool:
            # if old parnel format, the Organ object contains panel attributes
            self.check_object_Panel(object_uid, lines_list)

    #-------------------------------------------------------------------------------------------------
    def check_object_Button(self, object_uid, lines_list):
        # check the data of a Button object section which the lines are in the given lines list

        # optional attributes
        self.check_attribute_value(object_uid, lines_list, 'Name', ATTR_TYPE_STRING, False)
        self.check_attribute_value(object_uid, lines_list, 'ShortcutKey', ATTR_TYPE_INTEGER, False, 0, 255)
        self.check_attribute_value(object_uid, lines_list, 'StopControlMIDIKeyNumber', ATTR_TYPE_INTEGER, False, 0, 127)
        self.check_attribute_value(object_uid, lines_list, 'MIDIProgramChangeNumber', ATTR_TYPE_INTEGER, False, 1, 128)
        self.check_attribute_value(object_uid, lines_list, 'Displayed', ATTR_TYPE_BOOLEAN, False)
        self.check_attribute_value(object_uid, lines_list, 'DisplayInInvertedState', ATTR_TYPE_BOOLEAN, False)

        display_as_piston = self.check_attribute_value(object_uid, lines_list, 'DisplayAsPiston', ATTR_TYPE_BOOLEAN, False)
        if display_as_piston == '':
            # attribute not defined, set its default value
            if (object_uid.startwith(('Divisional', 'General')) or
                (object_uid[8:15] == 'Element' and self.object_attr_value_get(object_uid, 'Type') in ('Divisional', 'General'))):
                # the object is a Divisional or General button or a panel element of Divisional or General type, so it must be displayed as a piston by default
                display_as_piston = 'Y'
            else:
                display_as_piston = 'N'

        self.check_attribute_value(object_uid, lines_list, 'DispLabelColour', ATTR_TYPE_COLOR, False)
        self.check_attribute_value(object_uid, lines_list, 'DispLabelFontSize', ATTR_TYPE_FONT_SIZE, False)
        self.check_attribute_value(object_uid, lines_list, 'DispLabelFontName', ATTR_TYPE_STRING, False)
        self.check_attribute_value(object_uid, lines_list, 'DispLabelText', ATTR_TYPE_STRING, False)
        self.check_attribute_value(object_uid, lines_list, 'DispKeyLabelOnLeft', ATTR_TYPE_BOOLEAN, False)
        self.check_attribute_value(object_uid, lines_list, 'DispImageNum', ATTR_TYPE_INTEGER, False, 1, 5 if display_as_piston == 'Y' else 6)
        self.check_attribute_value(object_uid, lines_list, 'DispButtonRow', ATTR_TYPE_INTEGER, False, 0, 199)
        self.check_attribute_value(object_uid, lines_list, 'DispButtonCol', ATTR_TYPE_INTEGER, False, 1, 32)
        self.check_attribute_value(object_uid, lines_list, 'DispDrawstopRow', ATTR_TYPE_INTEGER, False, 1, 199)
        self.check_attribute_value(object_uid, lines_list, 'DispDrawstopCol', ATTR_TYPE_INTEGER, False, 1, 12)
        image_on = self.check_attribute_value(object_uid, lines_list, 'ImageOn', ATTR_TYPE_FILE_NAME, False)
        self.check_attribute_value(object_uid, lines_list, 'ImageOff', ATTR_TYPE_FILE_NAME, False)
        self.check_attribute_value(object_uid, lines_list, 'MaskOn', ATTR_TYPE_FILE_NAME, False)
        self.check_attribute_value(object_uid, lines_list, 'MaskOff', ATTR_TYPE_FILE_NAME, False)

        # get the dimensions of the parent panel
        panel_uid = self.object_parent_panel_get(object_uid)
        value = self.object_attr_value_get(panel_uid, 'DispScreenSizeHoriz')
        panel_width = int(value) if value != None and value.isdigit() else 3000
        value = self.object_attr_value_get(panel_uid, 'DispScreenSizeVert')
        panel_height = int(value) if value != None and value.isdigit() else 2000

        self.check_attribute_value(object_uid, lines_list, 'PositionX', ATTR_TYPE_INTEGER, False, 0, panel_width)
        self.check_attribute_value(object_uid, lines_list, 'PositionY', ATTR_TYPE_INTEGER, False, 0, panel_height)
        width = self.check_attribute_value(object_uid, lines_list, 'Width', ATTR_TYPE_INTEGER, False, 0, panel_width)
        height = self.check_attribute_value(object_uid, lines_list, 'Height', ATTR_TYPE_INTEGER, False, 0, panel_height)
        max_width = int(width) if width != None and width.isdigit() else panel_width
        max_height = int(height) if height != None and height.isdigit() else panel_height

        # get the dimensions of the button bitmap
        if image_on != None and image_on != '':
            # an image is defined to display the button
            if self.check_files_names_bool:
                # get the sizes of the image in the file which is existing
                im = Image.open(os.path.dirname(self.odf_file_name) + os.sep + path2ospath(image_on))
                bitmap_width = im.size[0]
                bitmap_height = im.size[1]
            else:
                bitmap_width = 500  # arbritrary default value
                bitmap_height = 200 # arbritrary default value
        else:
            # no image file defined, get the dimensions of the internal bitmap (piston or drawstop)
            if display_as_piston == 'Y':
                bitmap_width = bitmap_height = 32
            else:
                bitmap_width = bitmap_height = 62

        self.check_attribute_value(object_uid, lines_list, 'TileOffsetX', ATTR_TYPE_INTEGER, False, 0, bitmap_width)
        self.check_attribute_value(object_uid, lines_list, 'TileOffsetY', ATTR_TYPE_INTEGER, False, 0, bitmap_height)

        self.check_attribute_value(object_uid, lines_list, 'MouseRectLeft', ATTR_TYPE_INTEGER, False, 0, max_width)
        self.check_attribute_value(object_uid, lines_list, 'MouseRectTop', ATTR_TYPE_INTEGER, False, 0, max_height)
        mouse_rect_width = self.check_attribute_value(object_uid, lines_list, 'MouseRectWidth', ATTR_TYPE_INTEGER, False, 0, max_width)
        mouse_rect_height = self.check_attribute_value(object_uid, lines_list, 'MouseRectHeight', ATTR_TYPE_INTEGER, False, 0, max_height)

        if mouse_rect_width != None and mouse_rect_width.isdigit() and mouse_rect_height != None and  mouse_rect_height.isdigit():
            mouse_radius = max(int(mouse_rect_width), int(mouse_rect_height))
        else:
            mouse_radius = max(bitmap_width, bitmap_height)
        self.check_attribute_value(object_uid, lines_list, 'MouseRadius', ATTR_TYPE_INTEGER, False, 0, mouse_radius)

        self.check_attribute_value(object_uid, lines_list, 'TextRectLeft', ATTR_TYPE_INTEGER, False, 0, max_width)
        self.check_attribute_value(object_uid, lines_list, 'TextRectTop', ATTR_TYPE_INTEGER, False, 0, max_height)
        text_rect_width = self.check_attribute_value(object_uid, lines_list, 'TextRectWidth', ATTR_TYPE_INTEGER, False, 0, max_width)
        self.check_attribute_value(object_uid, lines_list, 'TextRectHeight', ATTR_TYPE_INTEGER, False, 0, max_height)

        if text_rect_width != None and text_rect_width.isdigit():
            text_break_width = int(text_rect_width)
        else:
            text_break_width = bitmap_width
        self.check_attribute_value(object_uid, lines_list, 'TextBreakWidth', ATTR_TYPE_INTEGER, False, 0, text_break_width)

    #-------------------------------------------------------------------------------------------------
    def check_object_Coupler(self, object_uid, lines_list):
        # check the data of a Coupler object section which the lines are in the given lines list

        # required attributes
        ret1 = self.check_attribute_value(object_uid, lines_list, 'UnisonOff', ATTR_TYPE_BOOLEAN, True)
        ret2 = self.check_attribute_value(object_uid, lines_list, 'CouplerType', ATTR_TYPE_COUPLER_TYPE, False)  # optional but here to recover its value used after
        self.check_attribute_value(object_uid, lines_list, 'DestinationManual', ATTR_TYPE_INTEGER, True if ret1 == 'N' else False, 0, 16) # conditional required/optional
        self.check_attribute_value(object_uid, lines_list, 'DestinationKeyshift', ATTR_TYPE_INTEGER, True if ret1 == 'N' else False, -24, 24) # conditional required/optional

        is_required = (ret1 != None and ret2 != None and ret1 == 'N' and not(ret2.upper() in ('MELODY', 'BASS')))
        self.check_attribute_value(object_uid, lines_list, 'CoupleToSubsequentUnisonIntermanualCouplers', ATTR_TYPE_BOOLEAN, is_required)
        self.check_attribute_value(object_uid, lines_list, 'CoupleToSubsequentUpwardIntermanualCouplers', ATTR_TYPE_BOOLEAN, is_required)
        self.check_attribute_value(object_uid, lines_list, 'CoupleToSubsequentDownwardIntermanualCouplers', ATTR_TYPE_BOOLEAN, is_required)
        self.check_attribute_value(object_uid, lines_list, 'CoupleToSubsequentUpwardIntramanualCouplers', ATTR_TYPE_BOOLEAN, is_required)
        self.check_attribute_value(object_uid, lines_list, 'CoupleToSubsequentDownwardIntramanualCouplers', ATTR_TYPE_BOOLEAN, is_required)

        # optional attributes
        self.check_attribute_value(object_uid, lines_list, 'FirstMIDINoteNumber', ATTR_TYPE_INTEGER, False, 0, 127)
        self.check_attribute_value(object_uid, lines_list, 'NumberOfKeys', ATTR_TYPE_INTEGER, False, 0, 127)

        # a Coupler has in addition the attributes of a DrawStop
        self.check_object_DrawStop(object_uid, lines_list)

    #-------------------------------------------------------------------------------------------------
    def check_object_Divisional(self, object_uid, lines_list):
        # check the data of a Divisional object section which the lines are in the given lines list

        # recover the ID of manual in which is referenced this Divisional
        parent_manual_uid = self.object_parent_manual_get(object_uid)

        # required attributes
        value = self.object_attr_value_get(parent_manual_uid, 'NumberOfCouplers')
        max = int(value) if value != None and value.isdigit() else 999
        value = self.check_attribute_value(object_uid, lines_list, 'NumberOfCouplers', ATTR_TYPE_INTEGER, True, 0, max)
        if value != None and value.isdigit():
            for idx in range(1, int(value)+1):
                self.check_attribute_value(object_uid, lines_list, f'Coupler{str(idx).zfill(3)}', ATTR_TYPE_OBJECT_REF, True)

        value = self.object_attr_value_get(parent_manual_uid, 'NumberOfStops')
        max = int(value) if value != None and value.isdigit() else 999
        value = self.check_attribute_value(object_uid, lines_list, 'NumberOfStops', ATTR_TYPE_INTEGER, True, 0, max)
        if value != None and value.isdigit():
            for idx in range(1, int(value)+1):
                self.check_attribute_value(object_uid, lines_list, f'Stop{str(idx).zfill(3)}', ATTR_TYPE_OBJECT_REF, True)

        value = self.object_attr_value_get(parent_manual_uid, 'NumberOfTremulants')
        max = int(value) if value != None and value.isdigit() else 10
        value = self.check_attribute_value(object_uid, lines_list, 'NumberOfTremulants', ATTR_TYPE_INTEGER, True, 0, max)
        if value != None and value.isdigit():
            for idx in range(1, int(value)+1):
                self.check_attribute_value(object_uid, lines_list, f'Tremulant{str(idx).zfill(3)}', ATTR_TYPE_OBJECT_REF, True)

        # optional attributes
        self.check_attribute_value(object_uid, lines_list, 'Protected', ATTR_TYPE_BOOLEAN, False)

        value = self.object_attr_value_get(parent_manual_uid, 'NumberOfSwitches')
        max = int(value) if value != None and value.isdigit() else 999
        value = self.check_attribute_value(object_uid, lines_list, 'NumberOfSwitches', ATTR_TYPE_INTEGER, False, 0, max)
        if value != None and value.isdigit():
            for idx in range(1, int(value)+1):
                self.check_attribute_value(object_uid, lines_list, f'Switch{str(idx).zfill(3)}', ATTR_TYPE_OBJECT_REF, True)

        # a Divisional has in addition the attributes of a Push Button
        self.check_object_PushButton(object_uid, lines_list)

    #-------------------------------------------------------------------------------------------------
    def check_object_DivisionalCoupler(self, object_uid, lines_list):
        # check the data of a Divisional Coupler object section which the lines are in the given lines list

        # required attributes
        self.check_attribute_value(object_uid, lines_list, 'BiDirectionalCoupling', ATTR_TYPE_BOOLEAN, True)

        value = self.object_attr_value_get('Organ', 'NumberOfManuals')
        max = int(value) if value != None and value.isdigit() else 16
        value = self.check_attribute_value(object_uid, lines_list, 'NumberOfManuals', ATTR_TYPE_INTEGER, True, 1, max)
        if value != None and value.isdigit():
            for idx in range(1, int(value)+1):
                self.check_attribute_value(object_uid, lines_list, f"Manual{str(idx).zfill(3)}", ATTR_TYPE_OBJECT_REF, True)

        # a Divisional Coupler has in addition the attributes of a DrawStop
        self.check_object_DrawStop(object_uid, lines_list)

    #-------------------------------------------------------------------------------------------------
    def check_object_DrawStop(self, object_uid, lines_list):
        # check the data of a DrawStop object section which the lines are in the given lines list

        # optional attributes
        self.check_attribute_value(object_uid, lines_list, 'Function', ATTR_TYPE_DRAWSTOP_FCT, False)

        value = self.object_attr_value_get('Organ', 'NumberOfSwitches')
        max = int(value) if value != None and value.isdigit() else 999
        switch_id = int(object_uid[-3:]) if (object_uid[-3:].isdigit() and object_uid[:-3] == 'Switch') else 999
        value = myint(self.check_attribute_value(object_uid, lines_list, 'SwitchCount', ATTR_TYPE_INTEGER, False, 1, max))
        if value != None:
            for idx in range(1, value+1):
                attr_value = self.check_attribute_value(object_uid, lines_list, f"Switch{str(idx).zfill(3)}", ATTR_TYPE_OBJECT_REF, True)
                if switch_id != 999 and int(attr_value) >= switch_id:
                    # the given object is a Switch and it refers to another switch which has an higher ID than it
                    logs.add(f'ERROR in {object_uid} section, cannot reference switches with an equal or higher number')

        self.check_attribute_value(object_uid, lines_list, 'DefaultToEngaged', ATTR_TYPE_BOOLEAN, False)
        self.check_attribute_value(object_uid, lines_list, 'GCState', ATTR_TYPE_INTEGER, False, -1, 1)
        self.check_attribute_value(object_uid, lines_list, 'StoreInDivisional', ATTR_TYPE_BOOLEAN, False)
        self.check_attribute_value(object_uid, lines_list, 'StoreInGeneral', ATTR_TYPE_BOOLEAN, False)

        # a Drawstop has in addition the attributes of a Button
        self.check_object_Button(object_uid, lines_list)

    #-------------------------------------------------------------------------------------------------
    def check_object_Enclosure(self, object_uid, lines_list):
        # check the data of an Enclosure object section which the lines are in the given lines list

        # required attributes
        # none required attribute

        # optional attributes
        self.check_attribute_value(object_uid, lines_list, 'Name', ATTR_TYPE_STRING, False)
        self.check_attribute_value(object_uid, lines_list, 'AmpMinimumLevel', ATTR_TYPE_INTEGER, False, 0, 100)
        self.check_attribute_value(object_uid, lines_list, 'MIDIInputNumber', ATTR_TYPE_INTEGER, False, 0, 100)
        self.check_attribute_value(object_uid, lines_list, 'Displayed', ATTR_TYPE_BOOLEAN, False)
        self.check_attribute_value(object_uid, lines_list, 'DispLabelColour', ATTR_TYPE_COLOR, False)
        self.check_attribute_value(object_uid, lines_list, 'DispLabelFontSize', ATTR_TYPE_FONT_SIZE, False)
        self.check_attribute_value(object_uid, lines_list, 'DispLabelFontName', ATTR_TYPE_STRING, False)
        self.check_attribute_value(object_uid, lines_list, 'DispLabelText', ATTR_TYPE_STRING, False)
        self.check_attribute_value(object_uid, lines_list, 'EnclosureStyle', ATTR_TYPE_INTEGER, False, 1, 4)

        value = self.check_attribute_value(object_uid, lines_list, 'BitmapCount', ATTR_TYPE_INTEGER, False, 1, 128)
        if value != None and value.isdigit():
            image = None
            for idx in range(1, int(value)+1):
                image = self.check_attribute_value(object_uid, lines_list, f'Bitmap{str(idx).zfill(3)}', ATTR_TYPE_FILE_NAME, True)
                self.check_attribute_value(object_uid, lines_list, f'Mask{str(idx).zfill(3)}', ATTR_TYPE_FILE_NAME, False)
            # get the dimensions of the last enclosure bitmap
            if image != None and image != '' and self.check_files_names_bool:
                # an image is defined to display the enclosure
                # get the sizes of the image in the file which is existing
                im = Image.open(os.path.dirname(self.odf_file_name) + os.sep + path2ospath(image))
                bitmap_width = im.size[0]
                bitmap_height = im.size[1]
            else:
                bitmap_width = 100  # arbitrary default value
                bitmap_height = 200 # arbitrary default value
        else:
            # no image file defined, get the dimensions of the internal bitmap
            bitmap_width = 46
            bitmap_height = 61

        # get the dimensions of the parent panel
        panel_uid = self.object_parent_panel_get(object_uid)
        value = self.object_attr_value_get(panel_uid, 'DispScreenSizeHoriz')
        panel_width = int(value) if value != None and value.isdigit() else 3000
        value = self.object_attr_value_get(panel_uid, 'DispScreenSizeVert')
        panel_height = int(value) if value != None and value.isdigit() else 2000

        self.check_attribute_value(object_uid, lines_list, 'PositionX', ATTR_TYPE_INTEGER, False, 0, panel_width)
        self.check_attribute_value(object_uid, lines_list, 'PositionY', ATTR_TYPE_INTEGER, False, 0, panel_height)
        width = self.check_attribute_value(object_uid, lines_list, 'Width', ATTR_TYPE_INTEGER, False, 0, panel_width)
        height = self.check_attribute_value(object_uid, lines_list, 'Height', ATTR_TYPE_INTEGER, False, 0, panel_height)
        max_width = int(width) if width != None and width.isdigit() else panel_width
        max_height = int(height) if height != None and height.isdigit() else panel_height

        self.check_attribute_value(object_uid, lines_list, 'TileOffsetX', ATTR_TYPE_INTEGER, False, 0, bitmap_width)
        self.check_attribute_value(object_uid, lines_list, 'TileOffsetY', ATTR_TYPE_INTEGER, False, 0, bitmap_height)

        self.check_attribute_value(object_uid, lines_list, 'MouseRectLeft', ATTR_TYPE_INTEGER, False, 0, max_width)
        self.check_attribute_value(object_uid, lines_list, 'MouseRectTop', ATTR_TYPE_INTEGER, False, 0, max_height)
        self.check_attribute_value(object_uid, lines_list, 'MouseRectWidth', ATTR_TYPE_INTEGER, False, 0, max_width)
        mouse_rect_height = self.check_attribute_value(object_uid, lines_list, 'MouseRectHeight', ATTR_TYPE_INTEGER, False, 0, max_height)

        if mouse_rect_height != None and mouse_rect_height.isdigit():
            max_start = int(mouse_rect_height)
        else:
            max_start = 200
        mouse_axis_start = self.check_attribute_value(object_uid, lines_list, 'MouseAxisStart', ATTR_TYPE_INTEGER, False, 0, max_start)

        if mouse_axis_start != None and mouse_axis_start.isdigit():
            min_end = int(mouse_axis_start)
        else:
            min_end = 200
        self.check_attribute_value(object_uid, lines_list, 'MouseAxisEnd', ATTR_TYPE_INTEGER, False, min_end, max_start)

        self.check_attribute_value(object_uid, lines_list, 'TextRectLeft', ATTR_TYPE_INTEGER, False, 0, max_width)
        self.check_attribute_value(object_uid, lines_list, 'TextRectTop', ATTR_TYPE_INTEGER, False, 0, max_height)
        text_rect_width = self.check_attribute_value(object_uid, lines_list, 'TextRectWidth', ATTR_TYPE_INTEGER, False, 0, max_width)
        self.check_attribute_value(object_uid, lines_list, 'TextRectHeight', ATTR_TYPE_INTEGER, False, 0, max_height)

        if text_rect_width != None and text_rect_width.isdigit():
            text_break_width = int(text_rect_width)
        else:
            text_break_width = bitmap_width
        self.check_attribute_value(object_uid, lines_list, 'TextBreakWidth', ATTR_TYPE_INTEGER, False, 0, text_break_width)

    #-------------------------------------------------------------------------------------------------
    def check_object_General(self, object_uid, lines_list):
        # check the data of a General object section which the lines are in the given lines list

        is_general_obj = (self.object_type_get(object_uid) == 'General') # some mandatory attributes are not mandatory for objects which inherit the General attributes

        # required attributes
        max = self.objects_type_number_get('Coupler')
        value = self.check_attribute_value(object_uid, lines_list, 'NumberOfCouplers', ATTR_TYPE_INTEGER, is_general_obj, 0, max)
        if value != None and value.isdigit():
            for idx in range(1, int(value)+1):
                self.check_attribute_value(object_uid, lines_list, f'CouplerNumber{str(idx).zfill(3)}', ATTR_TYPE_OBJECT_REF, True)
                self.check_attribute_value(object_uid, lines_list, f'CouplerManual{str(idx).zfill(3)}', ATTR_TYPE_OBJECT_REF, True)

        max = self.objects_type_number_get('DivisionalCoupler')
        value = self.check_attribute_value(object_uid, lines_list, 'NumberOfDivisionalCouplers', ATTR_TYPE_INTEGER, False, 0, max)
        if value != None and value.isdigit():
            for idx in range(1, int(value)+1):
                self.check_attribute_value(object_uid, lines_list, f'DivisionalCouplerNumber{str(idx).zfill(3)}', ATTR_TYPE_OBJECT_REF, True)

        max = self.objects_type_number_get('Stop')
        value = self.check_attribute_value(object_uid, lines_list, 'NumberOfStops', ATTR_TYPE_INTEGER, is_general_obj, 0, max)
        if value != None and value.isdigit():
            for idx in range(1, int(value)+1):
                self.check_attribute_value(object_uid, lines_list, f'StopNumber{str(idx).zfill(3)}', ATTR_TYPE_OBJECT_REF, True)
                self.check_attribute_value(object_uid, lines_list, f'StopManual{str(idx).zfill(3)}', ATTR_TYPE_OBJECT_REF, True)

        max = self.objects_type_number_get('Tremulant')
        value = self.check_attribute_value(object_uid, lines_list, 'NumberOfTremulants', ATTR_TYPE_INTEGER, is_general_obj, 0, max)
        if value != None and value.isdigit():
            for idx in range(1, int(value)+1):
                self.check_attribute_value(object_uid, lines_list, f'TremulantNumber{str(idx).zfill(3)}', ATTR_TYPE_OBJECT_REF, True)

        # optional attributes
        max = self.objects_type_number_get('Switch')
        value = self.check_attribute_value(object_uid, lines_list, 'NumberOfSwitches', ATTR_TYPE_INTEGER, False, 0, max)
        if value != None and value.isdigit():
            for idx in range(1, int(value)+1):
                self.check_attribute_value(object_uid, lines_list, f'SwitchNumber{str(idx).zfill(3)}', ATTR_TYPE_OBJECT_REF, True)

        self.check_attribute_value(object_uid, lines_list, 'Protected', ATTR_TYPE_BOOLEAN, False)

        # a General has in addition the attributes of a Push Button
        self.check_object_PushButton(object_uid, lines_list)

    #-------------------------------------------------------------------------------------------------
    def check_object_Image(self, object_uid, lines_list):
        # check the data of an Image object section which the lines are in the given lines list

        # required attributes
        image = self.check_attribute_value(object_uid, lines_list, 'Image', ATTR_TYPE_FILE_NAME, True)

        # get the dimensions of the parent panel
        parent_panel_uid = self.object_parent_panel_get(object_uid)
        value = self.object_attr_value_get(parent_panel_uid, 'DispScreenSizeHoriz')
        panel_width = int(value) if value != None and value.isdigit() else 3000
        value = self.object_attr_value_get(parent_panel_uid, 'DispScreenSizeVert')
        panel_height = int(value) if value != None and value.isdigit() else 2000

        # optional attributes
        self.check_attribute_value(object_uid, lines_list, 'Mask', ATTR_TYPE_FILE_NAME, False)
        self.check_attribute_value(object_uid, lines_list, 'PositionX', ATTR_TYPE_INTEGER, False, 0, panel_width)
        self.check_attribute_value(object_uid, lines_list, 'PositionY', ATTR_TYPE_INTEGER, False, 0, panel_height)
        self.check_attribute_value(object_uid, lines_list, 'Width', ATTR_TYPE_INTEGER, False, 0, panel_width)
        self.check_attribute_value(object_uid, lines_list, 'Height', ATTR_TYPE_INTEGER, False, 0, panel_height)

        # get the dimensions of the image bitmap
        if image != None and image != '':
            # an image is defined
            if self.check_files_names_bool:
                # get the sizes of the image in the file which is existing
                im = Image.open(os.path.dirname(self.odf_file_name) + os.sep + path2ospath(image))
                bitmap_width = im.size[0]
                bitmap_height = im.size[1]
            else:
                bitmap_width = panel_width
                bitmap_height = panel_height
        else:
            # no image file defined
            bitmap_width = panel_width
            bitmap_height = panel_height

        self.check_attribute_value(object_uid, lines_list, 'TileOffsetX', ATTR_TYPE_INTEGER, False, 0, bitmap_width)
        self.check_attribute_value(object_uid, lines_list, 'TileOffsetY', ATTR_TYPE_INTEGER, False, 0, bitmap_height)

    #-------------------------------------------------------------------------------------------------
    def check_object_Label(self, object_uid, lines_list):
        # check the data of a Label object section which the lines are in the given lines list

        # optional attributes
        self.check_attribute_value(object_uid, lines_list, 'Name', ATTR_TYPE_STRING, False)
        ret1 = self.check_attribute_value(object_uid, lines_list, 'FreeXPlacement', ATTR_TYPE_BOOLEAN, False)
        ret2 = self.check_attribute_value(object_uid, lines_list, 'FreeYPlacement', ATTR_TYPE_BOOLEAN, False)

        # get the dimensions of the parent panel
        parent_panel_uid = self.object_parent_panel_get(object_uid)
        value = self.object_attr_value_get(parent_panel_uid, 'DispScreenSizeHoriz')
        panel_width = int(value) if value != None and value.isdigit() else 3000
        value = self.object_attr_value_get(parent_panel_uid, 'DispScreenSizeVert')
        panel_height = int(value) if value != None and value.isdigit() else 2000

        self.check_attribute_value(object_uid, lines_list, 'DispXpos', ATTR_TYPE_INTEGER, False, 0, panel_width)
        self.check_attribute_value(object_uid, lines_list, 'DispYpos', ATTR_TYPE_INTEGER, False, 0, panel_height)

        self.check_attribute_value(object_uid, lines_list, 'DispAtTopOfDrawstopCol', ATTR_TYPE_BOOLEAN, ret2 == 'N')

        # get the number of drawstop columns in the parent panel
        value = self.object_attr_value_get(parent_panel_uid, 'DispDrawstopCols')
        columns_nb = int(value) if value != None and value.isdigit() else 12
        self.check_attribute_value(object_uid, lines_list, 'DispDrawstopCol', ATTR_TYPE_INTEGER, ret1 == 'N', 1, columns_nb)

        self.check_attribute_value(object_uid, lines_list, 'DispSpanDrawstopColToRight', ATTR_TYPE_BOOLEAN, True if ret1 == 'N' else False)
        self.check_attribute_value(object_uid, lines_list, 'DispLabelColour', ATTR_TYPE_COLOR, False)
        self.check_attribute_value(object_uid, lines_list, 'DispLabelFontSize', ATTR_TYPE_FONT_SIZE, False)
        self.check_attribute_value(object_uid, lines_list, 'DispLabelFontName', ATTR_TYPE_STRING, False)
        image_num = self.check_attribute_value(object_uid, lines_list, 'DispImageNum', ATTR_TYPE_INTEGER, False, 0, 12)
        image = self.check_attribute_value(object_uid, lines_list, 'Image', ATTR_TYPE_FILE_NAME, False)
        self.check_attribute_value(object_uid, lines_list, 'Mask', ATTR_TYPE_FILE_NAME, False)

        self.check_attribute_value(object_uid, lines_list, 'PositionX', ATTR_TYPE_INTEGER, False, 0, panel_width)
        self.check_attribute_value(object_uid, lines_list, 'PositionY', ATTR_TYPE_INTEGER, False, 0, panel_height)
        width = self.check_attribute_value(object_uid, lines_list, 'Width', ATTR_TYPE_INTEGER, False, 0, panel_width)
        height = self.check_attribute_value(object_uid, lines_list, 'Height', ATTR_TYPE_INTEGER, False, 0, panel_height)
        max_width = int(width) if width != None and width.isdigit() else panel_width
        max_height = int(height) if height != None and height.isdigit() else panel_height

        # get the dimensions of the label bitmap
        if image != None and image != '':
            # an image is defined to display the label
            if self.check_files_names_bool:
                # get the sizes of the image in the file which is existing
                im = Image.open(os.path.dirname(self.odf_file_name) + os.sep + path2ospath(image))
                bitmap_width = im.size[0]
                bitmap_height = im.size[1]
            else:
                bitmap_width = 400  # arbritrary default value
                bitmap_height = 100 # arbritrary default value
        else:
            if   image_num == '1':  bitmap_width = 80; bitmap_height = 25
            elif image_num == '2':  bitmap_width = 80; bitmap_height = 50
            elif image_num == '3':  bitmap_width = 80; bitmap_height = 25
            elif image_num == '4':  bitmap_width = 160; bitmap_height = 25
            elif image_num == '5':  bitmap_width = 200; bitmap_height = 50
            elif image_num == '6':  bitmap_width = 80; bitmap_height = 50
            elif image_num == '7':  bitmap_width = 80; bitmap_height = 25
            elif image_num == '8':  bitmap_width = 160; bitmap_height = 25
            elif image_num == '9':  bitmap_width = 80; bitmap_height = 50
            elif image_num == '10': bitmap_width = 80; bitmap_height = 25
            elif image_num == '11': bitmap_width = 160; bitmap_height = 25
            else:                   bitmap_width = 200; bitmap_height = 50


        self.check_attribute_value(object_uid, lines_list, 'TileOffsetX', ATTR_TYPE_INTEGER, False, 0, bitmap_width)
        self.check_attribute_value(object_uid, lines_list, 'TileOffsetY', ATTR_TYPE_INTEGER, False, 0, bitmap_height)

        self.check_attribute_value(object_uid, lines_list, 'TextRectLeft', ATTR_TYPE_INTEGER, False, 0, max_width)
        self.check_attribute_value(object_uid, lines_list, 'TextRectTop', ATTR_TYPE_INTEGER, False, 0, max_height)
        text_rect_width = self.check_attribute_value(object_uid, lines_list, 'TextRectWidth', ATTR_TYPE_INTEGER, False, 0, max_width)
        self.check_attribute_value(object_uid, lines_list, 'TextRectHeight', ATTR_TYPE_INTEGER, False, 0, max_height)

        if text_rect_width != None and text_rect_width.isdigit():
            text_break_width = int(text_rect_width)
        else:
            text_break_width = bitmap_width
        self.check_attribute_value(object_uid, lines_list, 'TextBreakWidth', ATTR_TYPE_INTEGER, False, 0, text_break_width)

    #-------------------------------------------------------------------------------------------------
    def check_object_Manual(self, object_uid, lines_list):
        # check the data of a Manual object section which the lines are in the given lines list

        is_manual_obj = (self.object_type_get(object_uid) == 'Manual') # some mandatory attributes are not mandatory for objects which inherit the Manual attributes

        if not is_manual_obj:
            # object_uid is a PanelElement object with Type=Manual, get the UID of the linked Manual
            manual_uid = self.object_attr_value_get(object_uid, 'Manual')
            if manual_uid != None:
                manual_uid = 'Manual' + str(int(manual_uid)).zfill(3)
        else:
            manual_uid = None

        # required attributes
        self.check_attribute_value(object_uid, lines_list, 'Name', ATTR_TYPE_STRING, is_manual_obj)
        value = self.check_attribute_value(object_uid, lines_list, 'NumberOfLogicalKeys', ATTR_TYPE_INTEGER, is_manual_obj, 1, 192)
        if value == None and manual_uid != None:
            # recover the number of logical keys in the linked Manual object
            value = self.object_attr_value_get(manual_uid, 'NumberOfLogicalKeys')

        if value != None and value.isdigit() and int(value) > 0:
            for idx in range(1, int(value) + 1):
                # attributes Key999xxx
                image = self.check_attribute_value(object_uid, lines_list, f'Key{str(idx).zfill(3)}ImageOn', ATTR_TYPE_FILE_NAME, False)
                if image != None and image != '':
                    # check the other attributes for this key only if an image on is defined
                    self.check_attribute_value(object_uid, lines_list, f'Key{str(idx).zfill(3)}ImageOff', ATTR_TYPE_FILE_NAME, False)
                    self.check_attribute_value(object_uid, lines_list, f'Key{str(idx).zfill(3)}MaskOn', ATTR_TYPE_FILE_NAME, False)
                    self.check_attribute_value(object_uid, lines_list, f'Key{str(idx).zfill(3)}MaskOff', ATTR_TYPE_FILE_NAME, False)
                    self.check_attribute_value(object_uid, lines_list, f'Key{str(idx).zfill(3)}Width', ATTR_TYPE_INTEGER, False, 0, 500)
                    self.check_attribute_value(object_uid, lines_list, f'Key{str(idx).zfill(3)}Offset', ATTR_TYPE_INTEGER, False, -500, 500)
                    self.check_attribute_value(object_uid, lines_list, f'Key{str(idx).zfill(3)}YOffset', ATTR_TYPE_INTEGER, False, -500, 500)

                    # get the dimensions of the key bitmap
                    # an image is defined to display the key
                    if self.check_files_names_bool:
                        # get the sizes of the image in the file which is existing
                        im = Image.open(os.path.dirname(self.odf_file_name) + os.sep + path2ospath(image))
                        bitmap_width = im.size[0]
                        bitmap_height = im.size[1]
                    else:
                        bitmap_width = 100  # arbritrary default value
                        bitmap_height = 300 # arbritrary default value

                    self.check_attribute_value(object_uid, lines_list, f'Key{str(idx).zfill(3)}MouseRectLeft', ATTR_TYPE_INTEGER, False, 0, bitmap_width)
                    self.check_attribute_value(object_uid, lines_list, f'Key{str(idx).zfill(3)}MouseRectTop', ATTR_TYPE_INTEGER, False, 0, bitmap_height)
                    self.check_attribute_value(object_uid, lines_list, f'Key{str(idx).zfill(3)}MouseRectWidth', ATTR_TYPE_INTEGER, False, 0, bitmap_width)
                    self.check_attribute_value(object_uid, lines_list, f'Key{str(idx).zfill(3)}MouseRectHeight', ATTR_TYPE_INTEGER, False, 0, bitmap_height)

        logical_keys_nb = int(value) if value != None and value.isdigit() else 192
        self.check_attribute_value(object_uid, lines_list, 'FirstAccessibleKeyLogicalKeyNumber', ATTR_TYPE_INTEGER, is_manual_obj, 1, logical_keys_nb)
        self.check_attribute_value(object_uid, lines_list, 'FirstAccessibleKeyMIDINoteNumber', ATTR_TYPE_INTEGER, is_manual_obj, 0, 127)

        value = self.check_attribute_value(object_uid, lines_list, 'NumberOfAccessibleKeys', ATTR_TYPE_INTEGER, is_manual_obj, 0, 85)
        accessible_keys_nb = int(value) if value != None and value.isdigit() else 85

        value = self.check_attribute_value(object_uid, lines_list, 'NumberOfCouplers', ATTR_TYPE_INTEGER, False, 0, 999)
        if value != None and value.isdigit() and int(value) > 0:
            for idx in range(1, int(value)+1):
                self.check_attribute_value(object_uid, lines_list, f'Coupler{str(idx).zfill(3)}', ATTR_TYPE_OBJECT_REF, True)

        value = self.check_attribute_value(object_uid, lines_list, 'NumberOfDivisionals', ATTR_TYPE_INTEGER, False, 0, 999)
        if value != None and value.isdigit() and int(value) > 0:
            for idx in range(1, int(value)+1):
                self.check_attribute_value(object_uid, lines_list, f'Divisional{str(idx).zfill(3)}', ATTR_TYPE_OBJECT_REF, True)

        value = self.check_attribute_value(object_uid, lines_list, 'NumberOfStops', ATTR_TYPE_INTEGER, False, 0, 999)
        if value != None and value.isdigit() and int(value) > 0:
            for idx in range(1, int(value)+1):
                self.check_attribute_value(object_uid, lines_list, f'Stop{str(idx).zfill(3)}', ATTR_TYPE_OBJECT_REF, True)

        max = self.objects_type_number_get('Switch')
        value = self.check_attribute_value(object_uid, lines_list, 'NumberOfSwitches', ATTR_TYPE_INTEGER, False, 0, max)
        if value != None and value.isdigit() and int(value) > 0:
            for idx in range(1, int(value)+1):
                self.check_attribute_value(object_uid, lines_list, f'Switch{str(idx).zfill(3)}', ATTR_TYPE_OBJECT_REF, True)

        max = self.objects_type_number_get('Tremulant')
        value = self.check_attribute_value(object_uid, lines_list, 'NumberOfTremulants', ATTR_TYPE_INTEGER, False, 0, max)
        if value != None and value.isdigit() and int(value) > 0:
            for idx in range(1, int(value)+1):
                self.check_attribute_value(object_uid, lines_list, f'Tremulant{str(idx).zfill(3)}', ATTR_TYPE_OBJECT_REF, True)

        # optional attributes
        for idx in range(0, 128):
            self.check_attribute_value(object_uid, lines_list, f'MIDIKey{str(idx).zfill(3)}', ATTR_TYPE_INTEGER, False, 0, 127)

        self.check_attribute_value(object_uid, lines_list, 'MIDIInputNumber', ATTR_TYPE_INTEGER, False, 0, 200)
        self.check_attribute_value(object_uid, lines_list, 'Displayed', ATTR_TYPE_BOOLEAN, False)

        # get the dimensions of the parent panel
        parent_panel_uid = self.object_parent_panel_get(object_uid)
        value = self.object_attr_value_get(parent_panel_uid, 'DispScreenSizeHoriz')
        panel_width = int(value) if value != None and value.isdigit() else 3000
        value = self.object_attr_value_get(parent_panel_uid, 'DispScreenSizeVert')
        panel_height = int(value) if value != None and value.isdigit() else 2000

        self.check_attribute_value(object_uid, lines_list, 'PositionX', ATTR_TYPE_INTEGER, False, 0, panel_width)
        self.check_attribute_value(object_uid, lines_list, 'PositionY', ATTR_TYPE_INTEGER, False, 0, panel_height)

        self.check_attribute_value(object_uid, lines_list, 'DispKeyColourInverted', ATTR_TYPE_BOOLEAN, False)
        self.check_attribute_value(object_uid, lines_list, 'DispKeyColourWooden', ATTR_TYPE_BOOLEAN, False)
        self.check_attribute_value(object_uid, lines_list, 'DisplayFirstNote', ATTR_TYPE_INTEGER, False, 0, 127)

        value = self.check_attribute_value(object_uid, lines_list, 'DisplayKeys', ATTR_TYPE_INTEGER, False, 1, accessible_keys_nb)
        if value != None and value.isdigit() and int(value) > 0:
            for idx in range(1, int(value)+1):
                self.check_attribute_value(object_uid, lines_list, f'DisplayKey{str(idx).zfill(3)}', ATTR_TYPE_INTEGER, False, 0, 127)
                self.check_attribute_value(object_uid, lines_list, f'DisplayKey{str(idx).zfill(3)}Note', ATTR_TYPE_INTEGER, False, 0, 127)

        # optional attributes with the KEYTYPE format
        ImageOn_First_keytype = None # variable to store if the first attribute have been already checked for the ImageOn key type
        ImageOff_First_keytype = None
        MaskOn_First_keytype = None
        MaskOff_First_keytype = None
        Width_First_keytype = None
        Offset_First_keytype = None
        YOffset_First_keytype = None

        ImageOn_Last_keytype = None
        ImageOff_Last_keytype = None
        MaskOn_Last_keytype = None
        MaskOff_Last_keytype = None
        Width_Last_keytype = None
        Offset_Last_keytype = None
        YOffset_Last_keytype = None

        if object_uid == 'Panel000Element001':
            pass

        for keytype in ('C', 'Cis', 'D', 'Dis', 'E', 'F', 'Fis', 'G', 'Gis', 'A', 'Ais', 'B'):
            self.check_attribute_value(object_uid, lines_list, f'ImageOn_{keytype}', ATTR_TYPE_FILE_NAME, False)
            self.check_attribute_value(object_uid, lines_list, f'ImageOff_{keytype}', ATTR_TYPE_FILE_NAME, False)
            self.check_attribute_value(object_uid, lines_list, f'MaskOn_{keytype}', ATTR_TYPE_FILE_NAME, False)
            self.check_attribute_value(object_uid, lines_list, f'MaskOff_{keytype}', ATTR_TYPE_FILE_NAME, False)
            self.check_attribute_value(object_uid, lines_list, f'Width_{keytype}', ATTR_TYPE_INTEGER, False, 0, 500)
            self.check_attribute_value(object_uid, lines_list, f'Offset_{keytype}', ATTR_TYPE_INTEGER, False, -500, 500)
            self.check_attribute_value(object_uid, lines_list, f'YOffset_{keytype}', ATTR_TYPE_INTEGER, False, -500, 500)
            # the First and Last attributes are checked only once for each key property
            # so if there is more than one First or Last definition it will appear in the warning logs because it will not have been checked here
            if ImageOn_First_keytype == None : ImageOn_First_keytype = self.check_attribute_value(object_uid, lines_list, f'ImageOn_First{keytype}', ATTR_TYPE_FILE_NAME, False)
            if ImageOff_First_keytype == None : ImageOff_First_keytype = self.check_attribute_value(object_uid, lines_list, f'ImageOff_First{keytype}', ATTR_TYPE_FILE_NAME, False)
            if MaskOn_First_keytype == None : MaskOn_First_keytype = self.check_attribute_value(object_uid, lines_list, f'MaskOn_First{keytype}', ATTR_TYPE_FILE_NAME, False)
            if MaskOff_First_keytype == None : MaskOff_First_keytype = self.check_attribute_value(object_uid, lines_list, f'MaskOff_First{keytype}', ATTR_TYPE_FILE_NAME, False)
            if Width_First_keytype == None : Width_First_keytype = self.check_attribute_value(object_uid, lines_list, f'Width_First{keytype}', ATTR_TYPE_INTEGER, False, 0, 500)
            if Offset_First_keytype == None : Offset_First_keytype = self.check_attribute_value(object_uid, lines_list, f'Offset_First{keytype}', ATTR_TYPE_INTEGER, False, -500, 500)
            if YOffset_First_keytype == None : YOffset_First_keytype = self.check_attribute_value(object_uid, lines_list, f'YOffset_First{keytype}', ATTR_TYPE_INTEGER, False, 0, 500)

            if ImageOn_Last_keytype == None : ImageOn_Last_keytype = self.check_attribute_value(object_uid, lines_list, f'ImageOn_Last{keytype}', ATTR_TYPE_FILE_NAME, False)
            if ImageOff_Last_keytype == None : ImageOff_Last_keytype = self.check_attribute_value(object_uid, lines_list, f'ImageOff_Last{keytype}', ATTR_TYPE_FILE_NAME, False)
            if MaskOn_Last_keytype == None : MaskOn_Last_keytype = self.check_attribute_value(object_uid, lines_list, f'MaskOn_Last{keytype}', ATTR_TYPE_FILE_NAME, False)
            if MaskOff_Last_keytype == None : MaskOff_Last_keytype = self.check_attribute_value(object_uid, lines_list, f'MaskOff_Last{keytype}', ATTR_TYPE_FILE_NAME, False)
            if Width_Last_keytype == None : Width_Last_keytype = self.check_attribute_value(object_uid, lines_list, f'Width_Last{keytype}', ATTR_TYPE_INTEGER, False, 0, 500)
            if Offset_Last_keytype == None : Offset_Last_keytype = self.check_attribute_value(object_uid, lines_list, f'Offset_Last{keytype}', ATTR_TYPE_INTEGER, False, -500, 500)
            if YOffset_Last_keytype == None : YOffset_Last_keytype = self.check_attribute_value(object_uid, lines_list, f'YOffset_Last{keytype}', ATTR_TYPE_INTEGER, False, 0, 500)

    #-------------------------------------------------------------------------------------------------
    def check_object_Panel(self, object_uid, lines_list):
        # check the data of a Panel object section which the lines are in the given lines list

        is_additional_panel = not(object_uid in ('Panel000', 'Organ')) # it is an additional panel, in addition to the Panel000 or Organ (old format) panel

        if self.new_panel_format_bool:

            # required attributes (new panel format)
            self.check_attribute_value(object_uid, lines_list, 'Name', ATTR_TYPE_STRING, is_additional_panel)
            self.check_attribute_value(object_uid, lines_list, 'HasPedals', ATTR_TYPE_BOOLEAN, True)

            value = self.check_attribute_value(object_uid, lines_list, 'NumberOfGUIElements', ATTR_TYPE_INTEGER, True, 0, 999)
            if value != None and value.isdigit() and int(value) >= 0:
                count = self.objects_type_number_get(f'{object_uid}Element')
                if count != int(value):
                    logs.add(f"ERROR in {object_uid} : NumberOfGUIElements={value} whereas {count} {object_uid}Element object(s) defined")

            # optional attributes (new panel format)
            self.check_attribute_value(object_uid, lines_list, 'Group', ATTR_TYPE_STRING, False)

            value = self.check_attribute_value(object_uid, lines_list, 'NumberOfImages', ATTR_TYPE_INTEGER, False, 0, 999)
            if value != None and value.isdigit() and int(value) >= 0:
                count = self.objects_type_number_get(f'{object_uid}Image')
                if count != int(value):
                    logs.add(f"ERROR in {object_uid} : NumberOfImages={value} whereas {count} {object_uid}Image object(s) defined")

        elif is_additional_panel:  # additional panel in the old panel format (for the main panel, the non display metrics attributes are defined in the Organ object)

            # required attributes (old panel format, additional panel)
            self.check_attribute_value(object_uid, lines_list, 'Name', ATTR_TYPE_STRING, True)
            self.check_attribute_value(object_uid, lines_list, 'HasPedals', ATTR_TYPE_BOOLEAN, True)

            value = self.check_attribute_value(object_uid, lines_list, 'NumberOfCouplers', ATTR_TYPE_INTEGER, True, 0, 999)
            if value != None and value.isdigit() and int(value) >= 0:
                for idx in range(1, int(value)+1):
                    self.check_attribute_value(object_uid, lines_list, f"Coupler{str(idx).zfill(3)}", ATTR_TYPE_OBJECT_REF, True)
                    self.check_attribute_value(object_uid, lines_list, f"Coupler{str(idx).zfill(3)}Manual", ATTR_TYPE_OBJECT_REF, True)
                count = self.objects_type_number_get(f'{object_uid}Coupler')
                if count != int(value):
                    logs.add(f"ERROR in {object_uid} : NumberOfCouplers={value} whereas {count} {object_uid}Coupler object(s) defined")

            value = self.check_attribute_value(object_uid, lines_list, 'NumberOfDivisionals', ATTR_TYPE_INTEGER, True, 0, 999)
            if value != None and value.isdigit() and int(value) >= 0:
                for idx in range(1, int(value)+1):
                    self.check_attribute_value(object_uid, lines_list, f"Divisional{str(idx).zfill(3)}", ATTR_TYPE_OBJECT_REF, True)
                    self.check_attribute_value(object_uid, lines_list, f"Divisional{str(idx).zfill(3)}Manual", ATTR_TYPE_OBJECT_REF, True)
                count = self.objects_type_number_get(f'{object_uid}Divisional')
                if count != int(value):
                    logs.add(f"ERROR in {object_uid} : NumberOfDivisionals={value} whereas {count} {object_uid}Divisional object(s) defined")

            value = self.check_attribute_value(object_uid, lines_list, 'NumberOfDivisionalCouplers', ATTR_TYPE_INTEGER, True, 0, 8)
            if value != None and value.isdigit() and int(value) >= 0:
                for idx in range(1, int(value)+1):
                    self.check_attribute_value(object_uid, lines_list, f"DivisionalCoupler{str(idx).zfill(3)}", ATTR_TYPE_OBJECT_REF, True)
                count = self.objects_type_number_get(f'{object_uid}DivisionalCoupler')
                if count != int(value):
                    logs.add(f"ERROR in {object_uid} : NumberOfDivisionalCouplers={value} whereas {count} {object_uid}DivisionalCoupler object(s) defined")

            value = self.check_attribute_value(object_uid, lines_list, 'NumberOfEnclosures', ATTR_TYPE_INTEGER, True, 0, 50)
            if value != None and value.isdigit() and int(value) >= 0:
                for idx in range(1, int(value)+1):
                    self.check_attribute_value(object_uid, lines_list, f"Enclosure{str(idx).zfill(3)}", ATTR_TYPE_OBJECT_REF, True)
                count = self.objects_type_number_get(f'{object_uid}Enclosure')
                if count != int(value):
                    logs.add(f"ERROR in {object_uid} : NumberOfEnclosures={value} whereas {count} {object_uid}Enclosure object(s) defined")

            value = self.check_attribute_value(object_uid, lines_list, 'NumberOfGenerals', ATTR_TYPE_INTEGER, True, 0, 99)
            if value != None and value.isdigit() and int(value) >= 0:
                for idx in range(1, int(value)+1):
                    self.check_attribute_value(object_uid, lines_list, f"General{str(idx).zfill(3)}", ATTR_TYPE_OBJECT_REF, True)
                count = self.objects_type_number_get(f'{object_uid}General')
                if count != int(value):
                    logs.add(f"ERROR in {object_uid} : NumberOfGenerals={value} whereas {count} {object_uid}General object(s) defined")

            value = self.check_attribute_value(object_uid, lines_list, 'NumberOfImages', ATTR_TYPE_INTEGER, True, 0, 999)
            if value != None and value.isdigit() and int(value) >= 0:
                count = self.objects_type_number_get(f'{object_uid}Image')
                if count != int(value):
                    logs.add(f"ERROR in {object_uid} : NumberOfImages={value} whereas {count} {object_uid}Image object(s) defined")

            value = self.check_attribute_value(object_uid, lines_list, 'NumberOfLabels', ATTR_TYPE_INTEGER, True, 0, 999)
            if value != None and value.isdigit() and int(value) >= 0:
                count = self.objects_type_number_get(f'{object_uid}Label')
                if count != int(value):
                    logs.add(f"ERROR in {object_uid} : NumberOfLabels={value} whereas {count} {object_uid}Label object(s) defined")

            value = self.check_attribute_value(object_uid, lines_list, 'NumberOfManuals', ATTR_TYPE_INTEGER, True, 0, 16)
            if value != None and value.isdigit() and int(value) >= 0:
                for idx in range(1, int(value)+1):
                    self.check_attribute_value(object_uid, lines_list, f"Manual{str(idx).zfill(3)}", ATTR_TYPE_OBJECT_REF, True)

            value = self.check_attribute_value(object_uid, lines_list, 'NumberOfReversiblePistons', ATTR_TYPE_INTEGER, True, 0, 32)
            if value != None and value.isdigit() and int(value) >= 0:
                for idx in range(1, int(value)+1):
                    self.check_attribute_value(object_uid, lines_list, f"ReversiblePiston{str(idx).zfill(3)}", ATTR_TYPE_OBJECT_REF, True)
                count = self.objects_type_number_get(f'{object_uid}ReversiblePiston')
                if count != int(value):
                    logs.add(f"ERROR in {object_uid} : NumberOfReversiblePistons={value} whereas {count} {object_uid}ReversiblePiston object(s) defined")

            value = self.check_attribute_value(object_uid, lines_list, 'NumberOfStops', ATTR_TYPE_INTEGER, True, 0, 999)
            if value != None and value.isdigit() and int(value) >= 0:
                for idx in range(1, int(value)+1):
                    self.check_attribute_value(object_uid, lines_list, f"Stop{str(idx).zfill(3)}", ATTR_TYPE_OBJECT_REF, True)
                    self.check_attribute_value(object_uid, lines_list, f"Stop{str(idx).zfill(3)}Manual", ATTR_TYPE_OBJECT_REF, True)
                count = self.objects_type_number_get(f'{object_uid}Stop')
                if count != int(value):
                    logs.add(f"ERROR in {object_uid} : NumberOfStops={value} whereas {count} {object_uid}Stop object(s) defined")

            value = self.check_attribute_value(object_uid, lines_list, 'NumberOfTremulants', ATTR_TYPE_INTEGER, True, 0, 10)
            if value != None and value.isdigit() and int(value) >= 0:
                for idx in range(1, int(value)+1):
                    self.check_attribute_value(object_uid, lines_list, f"Tremulant{str(idx).zfill(3)}", ATTR_TYPE_OBJECT_REF, True)
                count = self.objects_type_number_get(f'{object_uid}Tremulant')
                if count != int(value):
                    logs.add(f"ERROR in {object_uid} : NumberOfTremulants={value} whereas {count} {object_uid}Tremulant object(s) defined")

            # optional attributes (old panel format, additional panel)
            self.check_attribute_value(object_uid, lines_list, 'Group', ATTR_TYPE_STRING, False)

            value = self.check_attribute_value(object_uid, lines_list, 'NumberOfSetterElements', ATTR_TYPE_INTEGER, False, 0, 8)
            if value != None and value.isdigit() and int(value) >= 0:
                count = self.objects_type_number_get(f'{object_uid}SetterElement')
                if count != int(value):
                    logs.add(f"ERROR in {object_uid} : NumberOfSetterElements={value} whereas {count} {object_uid}SetterElement object(s) defined")

            value = self.check_attribute_value(object_uid, lines_list, 'NumberOfSwitches', ATTR_TYPE_INTEGER, False, 0, 999)
            if value != None and value.isdigit() and int(value) >= 0:
                for idx in range(1, int(value)+1):
                    self.check_attribute_value(object_uid, lines_list, f"Switch{str(idx).zfill(3)}", ATTR_TYPE_OBJECT_REF, True)
                count = self.objects_type_number_get(f'{object_uid}Switch')
                if count != int(value):
                    logs.add(f"ERROR in {object_uid} : NumberOfSwitches={value} whereas {count} {object_uid}Switch object(s) defined")


        # display metrics (common to old and new panel formats)

        # required attributes (panel display metrics)
        self.check_attribute_value(object_uid, lines_list, 'DispScreenSizeHoriz', ATTR_TYPE_PANEL_SIZE, True)
        self.check_attribute_value(object_uid, lines_list, 'DispScreenSizeVert', ATTR_TYPE_PANEL_SIZE, True)
        self.check_attribute_value(object_uid, lines_list, 'DispDrawstopBackgroundImageNum', ATTR_TYPE_INTEGER, True, 1, 64)
        self.check_attribute_value(object_uid, lines_list, 'DispConsoleBackgroundImageNum', ATTR_TYPE_INTEGER, True, 1, 64)
        self.check_attribute_value(object_uid, lines_list, 'DispKeyHorizBackgroundImageNum', ATTR_TYPE_INTEGER, True, 1, 64)
        self.check_attribute_value(object_uid, lines_list, 'DispKeyVertBackgroundImageNum', ATTR_TYPE_INTEGER, True, 1, 64)
        self.check_attribute_value(object_uid, lines_list, 'DispDrawstopInsetBackgroundImageNum', ATTR_TYPE_INTEGER, True, 1, 64)
        self.check_attribute_value(object_uid, lines_list, 'DispControlLabelFont', ATTR_TYPE_STRING, True)
        self.check_attribute_value(object_uid, lines_list, 'DispShortcutKeyLabelFont', ATTR_TYPE_STRING, True)
        self.check_attribute_value(object_uid, lines_list, 'DispShortcutKeyLabelColour', ATTR_TYPE_COLOR, True)
        self.check_attribute_value(object_uid, lines_list, 'DispGroupLabelFont', ATTR_TYPE_STRING, True)
        self.check_attribute_value(object_uid, lines_list, 'DispDrawstopCols', ATTR_TYPE_INTEGER, True, 2, 12)
        self.check_attribute_value(object_uid, lines_list, 'DispDrawstopRows', ATTR_TYPE_INTEGER, True, 1, 20)
        cols_offset = self.check_attribute_value(object_uid, lines_list, 'DispDrawstopColsOffset', ATTR_TYPE_BOOLEAN, True)
        self.check_attribute_value(object_uid, lines_list, 'DispPairDrawstopCols', ATTR_TYPE_BOOLEAN, True)
        self.check_attribute_value(object_uid, lines_list, 'DispExtraDrawstopRows', ATTR_TYPE_INTEGER, True, 0, 99)
        self.check_attribute_value(object_uid, lines_list, 'DispExtraDrawstopCols', ATTR_TYPE_INTEGER, True, 0, 40)
        self.check_attribute_value(object_uid, lines_list, 'DispButtonCols', ATTR_TYPE_INTEGER, True, 1, 32)
        self.check_attribute_value(object_uid, lines_list, 'DispExtraButtonRows', ATTR_TYPE_INTEGER, True, 0, 99)
        extra_pedal_buttons = self.check_attribute_value(object_uid, lines_list, 'DispExtraPedalButtonRow', ATTR_TYPE_BOOLEAN, True)
        self.check_attribute_value(object_uid, lines_list, 'DispButtonsAboveManuals', ATTR_TYPE_BOOLEAN, True)
        self.check_attribute_value(object_uid, lines_list, 'DispExtraDrawstopRowsAboveExtraButtonRows', ATTR_TYPE_BOOLEAN, True)
        self.check_attribute_value(object_uid, lines_list, 'DispTrimAboveManuals', ATTR_TYPE_BOOLEAN, True)
        self.check_attribute_value(object_uid, lines_list, 'DispTrimBelowManuals', ATTR_TYPE_BOOLEAN, True)
        self.check_attribute_value(object_uid, lines_list, 'DispTrimAboveExtraRows', ATTR_TYPE_BOOLEAN, True)

        # optional attributes (panel display metrics)
        self.check_attribute_value(object_uid, lines_list, 'DispDrawstopWidth', ATTR_TYPE_INTEGER, False, 1, 150)
        self.check_attribute_value(object_uid, lines_list, 'DispDrawstopHeight', ATTR_TYPE_INTEGER, False, 1, 150)
        self.check_attribute_value(object_uid, lines_list, 'DispDrawstopOuterColOffsetUp', ATTR_TYPE_BOOLEAN, True if cols_offset != None and cols_offset == 'Y' else False)
        self.check_attribute_value(object_uid, lines_list, 'DispExtraPedalButtonRowOffset', ATTR_TYPE_BOOLEAN, True if extra_pedal_buttons != None and extra_pedal_buttons == 'Y' else False)
        self.check_attribute_value(object_uid, lines_list, 'DispExtraPedalButtonRowOffsetRight', ATTR_TYPE_BOOLEAN, False)
        self.check_attribute_value(object_uid, lines_list, 'DispPistonWidth', ATTR_TYPE_INTEGER, False, 1, 150)
        self.check_attribute_value(object_uid, lines_list, 'DispPistonHeight', ATTR_TYPE_INTEGER, False, 1, 150)
        self.check_attribute_value(object_uid, lines_list, 'DispEnclosureWidth', ATTR_TYPE_INTEGER, False, 1, 150)
        self.check_attribute_value(object_uid, lines_list, 'DispEnclosureHeight', ATTR_TYPE_INTEGER, False, 1, 150)
        self.check_attribute_value(object_uid, lines_list, 'DispPedalHeight', ATTR_TYPE_INTEGER, False, 1, 500)
        self.check_attribute_value(object_uid, lines_list, 'DispPedalKeyWidth', ATTR_TYPE_INTEGER, False, 1, 500)
        self.check_attribute_value(object_uid, lines_list, 'DispManualHeight', ATTR_TYPE_INTEGER, False, 1, 500)
        self.check_attribute_value(object_uid, lines_list, 'DispManualKeyWidth', ATTR_TYPE_INTEGER, False, 1, 500)

    #-------------------------------------------------------------------------------------------------
    def check_object_PanelElement(self, object_uid, lines_list):
        # check the data of a Panel Element object section which the lines are in the given lines list

        # required attributes
        type = self.check_attribute_value(object_uid, lines_list, 'Type', ATTR_TYPE_ELEMENT_TYPE, True)

        if type == None:
            pass
        elif type == 'Coupler':
            self.check_attribute_value(object_uid, lines_list, 'Manual', ATTR_TYPE_OBJECT_REF, True)
            self.check_attribute_value(object_uid, lines_list, 'Coupler', ATTR_TYPE_OBJECT_REF, True)
            self.check_object_Coupler(object_uid, lines_list)
        elif type == 'Divisional':
            self.check_attribute_value(object_uid, lines_list, 'Manual', ATTR_TYPE_OBJECT_REF, True)
            self.check_attribute_value(object_uid, lines_list, 'Divisional', ATTR_TYPE_OBJECT_REF, True)
            self.check_object_Divisional(object_uid, lines_list)
        elif type == 'DivisionalCoupler':
            self.check_attribute_value(object_uid, lines_list, 'DivisionalCoupler', ATTR_TYPE_OBJECT_REF, True)
            self.check_object_DivisionalCoupler(object_uid, lines_list)
        elif type == 'Enclosure':
            self.check_attribute_value(object_uid, lines_list, 'Enclosure', ATTR_TYPE_OBJECT_REF, True)
            self.check_object_Enclosure(object_uid, lines_list)
        elif type == 'General':
            self.check_attribute_value(object_uid, lines_list, 'General', ATTR_TYPE_OBJECT_REF, True)
            self.check_object_General(object_uid, lines_list)
        elif type == 'Label':
            self.check_object_Label(object_uid, lines_list)
        elif type == 'Manual':
            self.check_attribute_value(object_uid, lines_list, 'Manual', ATTR_TYPE_OBJECT_REF, True)
            self.check_object_Manual(object_uid, lines_list)
        elif type == 'ReversiblePiston':
            self.check_attribute_value(object_uid, lines_list, 'ReversiblePiston', ATTR_TYPE_OBJECT_REF, True)
            self.check_object_ReversiblePiston(object_uid, lines_list)
        elif type == 'Stop':
            self.check_attribute_value(object_uid, lines_list, 'Manual', ATTR_TYPE_OBJECT_REF, True)
            self.check_attribute_value(object_uid, lines_list, 'Stop', ATTR_TYPE_OBJECT_REF, True)
            self.check_object_Stop(object_uid, lines_list)
        elif type == 'Swell':
            self.check_object_Enclosure(object_uid, lines_list)
        elif type == 'Switch':
            self.check_attribute_value(object_uid, lines_list, 'Switch', ATTR_TYPE_OBJECT_REF, True)
            self.check_object_Switch(object_uid, lines_list)
        elif type == 'Tremulant':
            self.check_attribute_value(object_uid, lines_list, 'Tremulant', ATTR_TYPE_OBJECT_REF, True)
            self.check_object_Tremulant(object_uid, lines_list)
        else:
            self.check_object_SetterElement(object_uid, lines_list, type)

    #-------------------------------------------------------------------------------------------------
    def check_object_PanelOther(self, object_uid, lines_list):
        # check the data of an other kind of Panel object section (Panel999Coupler999, Panel999Divisional999, ...) which the lines are in the given lines list

        # get the panel elemnt type from the object UID (for example Coupler from Panel999Coupler999)
        panel_element_type = object_uid[8:-3]

        # check the attributes of the object depending on the object type
        if panel_element_type == 'Coupler':
            self.check_object_Coupler(object_uid, lines_list)
        elif panel_element_type == 'Divisional':
            self.check_object_Divisional(object_uid, lines_list)
        elif panel_element_type == 'DivisionalCoupler':
            self.check_object_DivisionalCoupler(object_uid, lines_list)
        elif panel_element_type == 'Enclosure':
            self.check_object_Enclosure(object_uid, lines_list)
        elif panel_element_type == 'General':
            self.check_object_General(object_uid, lines_list)
        elif panel_element_type == 'Image':
            self.check_object_Image(object_uid, lines_list)
        elif panel_element_type == 'Label':
            self.check_object_Label(object_uid, lines_list)
        elif panel_element_type == 'ReversiblePiston':
            self.check_object_ReversiblePiston(object_uid, lines_list)
        elif panel_element_type == 'SetterElement':
            self.check_object_SetterElement(object_uid, lines_list)
        elif panel_element_type == 'Stop':
            self.check_object_Stop(object_uid, lines_list)
        elif panel_element_type == 'Switch':
            self.check_object_Switch(object_uid, lines_list)
        elif panel_element_type == 'Tremulant':
            self.check_object_Tremulant(object_uid, lines_list)

    #-------------------------------------------------------------------------------------------------
    def check_object_Piston(self, object_uid, lines_list):
        # check the data of a Piston object section which the lines are in the given lines list

        # required attributes
        value = self.check_attribute_value(object_uid, lines_list, 'ObjectType', ATTR_TYPE_PISTON_TYPE, True)
        self.check_attribute_value(object_uid, lines_list, 'ManualNumber', ATTR_TYPE_OBJECT_REF, value in ('STOP', 'COUPLER'))
        self.check_attribute_value(object_uid, lines_list, 'ObjectNumber', ATTR_TYPE_INTEGER, False, 1, 200)

        # a Piston has also the attributes of a Push Button
        self.check_object_PushButton(object_uid, lines_list)

    #-------------------------------------------------------------------------------------------------
    def check_object_PushButton(self, object_uid, lines_list):
        # check the data of a Push Button object section which the lines are in the given lines list

        # a Push Button has only the attributes of a Button
        self.check_object_Button(object_uid, lines_list)

    #-------------------------------------------------------------------------------------------------
    def check_object_Rank(self, object_uid, lines_list):
        # check the data of a Rank object section which the lines are in the given lines list

        is_rank_obj = (self.object_type_get(object_uid) == 'Rank') # some mandatory attributes are not mandatory for objects which inherit the Rank attributes (like Stop)

        # required attributes
        self.check_attribute_value(object_uid, lines_list, 'Name', ATTR_TYPE_STRING, True)
        self.check_attribute_value(object_uid, lines_list, 'FirstMidiNoteNumber', ATTR_TYPE_INTEGER, is_rank_obj, 0, 256)
        self.check_attribute_value(object_uid, lines_list, 'WindchestGroup', ATTR_TYPE_OBJECT_REF, True)
        self.check_attribute_value(object_uid, lines_list, 'Percussive', ATTR_TYPE_BOOLEAN, True)

        # optional attributes
        self.check_attribute_value(object_uid, lines_list, 'AmplitudeLevel', ATTR_TYPE_FLOAT, False, 0, 1000)
        self.check_attribute_value(object_uid, lines_list, 'Gain', ATTR_TYPE_FLOAT, False, -120, 40)
        self.check_attribute_value(object_uid, lines_list, 'PitchTuning', ATTR_TYPE_FLOAT, False, -1200, 1200)
        self.check_attribute_value(object_uid, lines_list, 'TrackerDelay', ATTR_TYPE_INTEGER, False, 0, 10000)
        self.check_attribute_value(object_uid, lines_list, 'HarmonicNumber', ATTR_TYPE_FLOAT, False, 1, 1024)
        self.check_attribute_value(object_uid, lines_list, 'PitchCorrection', ATTR_TYPE_FLOAT, False, -1200, 1200)
        self.check_attribute_value(object_uid, lines_list, 'MinVelocityVolume', ATTR_TYPE_FLOAT, False, 0, 1000)
        self.check_attribute_value(object_uid, lines_list, 'MaxVelocityVolume', ATTR_TYPE_FLOAT, False, 0, 1000)
        self.check_attribute_value(object_uid, lines_list, 'AcceptsRetuning', ATTR_TYPE_BOOLEAN, False)

        value = self.check_attribute_value(object_uid, lines_list, 'NumberOfLogicalPipes', ATTR_TYPE_INTEGER, is_rank_obj, 1, 192)
        if value != None and value.isdigit():
            for idx in range(1, int(value)+1):  # Pipe999xxx attributes
                self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}', ATTR_TYPE_PIPE_WAVE, True)
                self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}Percussive', ATTR_TYPE_BOOLEAN, False)
                self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}AmplitudeLevel', ATTR_TYPE_FLOAT, False, 0, 1000)
                self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}Gain', ATTR_TYPE_FLOAT, False, -120, 40)
                self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}PitchTuning', ATTR_TYPE_FLOAT, False, -1200, 1200)
                self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}TrackerDelay', ATTR_TYPE_FLOAT, False, 0, 10000)
                self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}LoadRelease', ATTR_TYPE_BOOLEAN, False)
                self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}AttackVelocity', ATTR_TYPE_INTEGER, False, 0, 127)
                self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}MaxTimeSinceLastRelease', ATTR_TYPE_INTEGER, False, -1, 100000)
                self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}IsTremulant', ATTR_TYPE_INTEGER, False, -1, 1)
                self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}MaxKeyPressTime', ATTR_TYPE_INTEGER, False, -1, 100000)
                self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}AttackStart', ATTR_TYPE_INTEGER, False, 0, 158760000)
                self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}CuePoint', ATTR_TYPE_INTEGER, False, -1, 158760000)
                self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}ReleaseEnd', ATTR_TYPE_INTEGER, False, -1, 158760000)
                self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}HarmonicNumber', ATTR_TYPE_FLOAT, False, 1, 1024)
                self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}MIDIKeyNumber', ATTR_TYPE_INTEGER, False, -1, 127)
                self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}PitchCorrection', ATTR_TYPE_FLOAT, False, -1200, 1200)
                self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}AcceptsRetuning', ATTR_TYPE_BOOLEAN, False)
                self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}WindchestGroup', ATTR_TYPE_OBJECT_REF, False)
                self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}MinVelocityVolume', ATTR_TYPE_FLOAT, False, 0, 1000)
                self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}MaxVelocityVolume', ATTR_TYPE_FLOAT, False, 0, 1000)

                ret1 = self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}LoopCount', ATTR_TYPE_INTEGER, False, 1, 100)
                if ret1 != None and ret1.isdigit():
                    for idx1 in range(1, int(ret1)+1):  # Pipe999Loop999xxx attributes
                        value = self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}Loop{str(idx1).zfill(3)}Start', ATTR_TYPE_INTEGER, False, 0, 158760000)
                        loop_start = int(value) if value.isdigit() else 1
                        self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}Loop{str(idx1).zfill(3)}End', ATTR_TYPE_INTEGER, False, loop_start + 1, 158760000)

                ret1 = self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}AttackCount', ATTR_TYPE_INTEGER, False, 1, 100)
                if ret1 != None and ret1.isdigit():
                    for idx1 in range(1, int(ret1)+1):  # Pipe999Attack999xxx attributes
                        self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}Attack{str(idx1).zfill(3)}', ATTR_TYPE_FILE_NAME, True)
                        self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}Attack{str(idx1).zfill(3)}LoadRelease', ATTR_TYPE_BOOLEAN, False)
                        self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}Attack{str(idx1).zfill(3)}AttackVelocity', ATTR_TYPE_INTEGER, False, 0, 127)
                        self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}Attack{str(idx1).zfill(3)}MaxTimeSinceLastRelease', ATTR_TYPE_INTEGER, False, -1, 100000)
                        self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}Attack{str(idx1).zfill(3)}IsTremulant', ATTR_TYPE_INTEGER, False, -1, 1)
                        self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}Attack{str(idx1).zfill(3)}MaxKeyPressTime', ATTR_TYPE_INTEGER, False, -1, 100000)
                        self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}Attack{str(idx1).zfill(3)}AttackStart', ATTR_TYPE_INTEGER, False, 0, 158760000)
                        self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}Attack{str(idx1).zfill(3)}CuePoint', ATTR_TYPE_INTEGER, False, -1, 158760000)
                        self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}Attack{str(idx1).zfill(3)}ReleaseEnd', ATTR_TYPE_INTEGER, False, -1, 158760000)

                        ret2 = self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}Attack{str(idx1).zfill(3)}LoopCount', ATTR_TYPE_INTEGER, False, 1, 100)
                        if ret2 != None and ret2.isdigit():
                            for idx2 in range(1, int(ret2)+1):  # Pipe999Attack999Loop999xxx attributes
                                value = self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}Attack{str(idx1).zfill(3)}Loop{str(idx2).zfill(3)}Start', ATTR_TYPE_INTEGER, True, 0, 158760000)
                                loop_start = int(value) if value != None and value.isdigit() else 1
                                self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}Attack{str(idx1).zfill(3)}Loop{str(idx2).zfill(3)}End', ATTR_TYPE_INTEGER, True, loop_start + 1, 158760000)

                ret1 = self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}ReleaseCount', ATTR_TYPE_INTEGER, False, 1, 100)
                if ret1 != None and ret1.isdigit():
                    for idx1 in range(1, int(ret1)+1):  # Pipe999Release999xxx attributes
                        self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}Release{str(idx1).zfill(3)}', ATTR_TYPE_FILE_NAME, True)
                        self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}Release{str(idx1).zfill(3)}IsTremulant', ATTR_TYPE_INTEGER, False, -1, 1)
                        self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}Release{str(idx1).zfill(3)}MaxKeyPressTime', ATTR_TYPE_INTEGER, False, -1, 100000)
                        self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}Release{str(idx1).zfill(3)}CuePoint', ATTR_TYPE_INTEGER, False, -1, 158760000)
                        self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}Release{str(idx1).zfill(3)}ReleaseEnd', ATTR_TYPE_INTEGER, False, -1, 158760000)

                self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}LoopCrossfadeLength', ATTR_TYPE_INTEGER, False, 0, 120)
                self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}ReleaseCrossfadeLength', ATTR_TYPE_INTEGER, False, 0, 120)

    #-------------------------------------------------------------------------------------------------
    def check_object_ReversiblePiston(self, object_uid, lines_list):
        # check the data of a Reversible Piston object section which the lines are in the given lines list

        # unkown expected attributes...
        pass

     #-------------------------------------------------------------------------------------------------
    def check_object_SetterElement(self, object_uid, lines_list, type = None):
        # check the data of a Setter Element object section which the lines are in the given lines list

        # required attributes
        if type == None:
            # type not provided by the caller, recover it from the object lines list
            type = self.check_attribute_value(object_uid, lines_list, 'Type', ATTR_TYPE_ELEMENT_TYPE, True)

        if type == None:
            pass
        elif type == 'CrescendoLabel':
            self.check_object_Label(object_uid, lines_list)
        elif type in ('CrescendoA', 'CrescendoB', 'CrescendoC', 'CrescendoD'):
            self.check_object_Button(object_uid, lines_list)
        elif type in ('CrescendoPrev', 'CrescendoNext', 'CrescendoCurrent'):
            self.check_object_Button(object_uid, lines_list)
        elif type in ('Current', 'Full', 'GC'):
            self.check_object_Button(object_uid, lines_list)
        elif type[:7] == "General" and len(type) == 9 and type[7:9].isdigit() and int(type[7:9]) in range(1, 51):
            self.check_object_Button(object_uid, lines_list)
        elif type == 'GeneralLabel':
            self.check_object_Label(object_uid, lines_list)
        elif type in ('GeneralPrev', 'GeneralNext', 'Home', 'Insert', 'Delete'):
            self.check_object_Button(object_uid, lines_list)
        elif type[:1] == "L" and len(type) == 2 and type[1:2].isdigit() and int(type[1:2]) in range(0, 10):
            self.check_object_Button(object_uid, lines_list)
        elif type in ('M100', 'M10', 'M1', 'P1', 'P10', 'P100'):
            self.check_object_Button(object_uid, lines_list)
        elif type == 'PitchLabel':
            self.check_object_Label(object_uid, lines_list)
        elif type in ('PitchM100', 'PitchM10', 'PitchM1', 'PitchP1', 'PitchP10', 'PitchP100'):
            self.check_object_Button(object_uid, lines_list)
        elif type in ('Prev', 'Next', 'Set'):
            self.check_object_Button(object_uid, lines_list)
        elif type in ('Regular', 'Scope', 'Scoped', 'Save'):
            self.check_object_Button(object_uid, lines_list)
        elif type in ('SequencerLabel', 'TemperamentLabel'):
            self.check_object_Label(object_uid, lines_list)
        elif type in ('TemperamentPrev', 'TemperamentNext'):
            self.check_object_Button(object_uid, lines_list)
        elif type in ('TransposeDown', 'TransposeUp'):
            self.check_object_Button(object_uid, lines_list)
        elif type == 'TransposeLabel':
            self.check_object_Label(object_uid, lines_list)

    #-------------------------------------------------------------------------------------------------
    def check_object_Stop(self, object_uid, lines_list):
        # check the data of a Stop object section which the lines are in the given lines list

        is_stop_obj = (self.object_type_get(object_uid) == 'Stop') # some mandatory attributes are not mandatory for objects which inherit the Stop attributes

        # optional attribute
        value = self.check_attribute_value(object_uid, lines_list, 'NumberOfRanks', ATTR_TYPE_INTEGER, False, 0, 999)
        if value == None or (value != None and not value.isdigit()):
            # number of ranks not defined or not a number
            nb_ranks = 0
        else:
            nb_ranks = int(value)

        # required attributes
        self.check_attribute_value(object_uid, lines_list, 'FirstAccessiblePipeLogicalKeyNumber', ATTR_TYPE_INTEGER, is_stop_obj, 1, 128)
        self.check_attribute_value(object_uid, lines_list, 'FirstAccessiblePipeLogicalPipeNumber', ATTR_TYPE_INTEGER, nb_ranks == 0, 1, 192)

        value = self.check_attribute_value(object_uid, lines_list, 'NumberOfAccessiblePipes', ATTR_TYPE_INTEGER, True, 1, 192)
        nb_pipes = int(value) if value != None and value.isdigit() else 192

        # optional attributes
        if nb_ranks > 0:
            for idx in range(1, nb_ranks+1):
                self.check_attribute_value(object_uid, lines_list, f'Rank{str(idx).zfill(3)}', ATTR_TYPE_OBJECT_REF, True)
                self.check_attribute_value(object_uid, lines_list, f'Rank{str(idx).zfill(3)}FirstPipeNumber', ATTR_TYPE_INTEGER, False, 1, nb_pipes)
                self.check_attribute_value(object_uid, lines_list, f'Rank{str(idx).zfill(3)}PipeCount', ATTR_TYPE_INTEGER, False, 0, nb_pipes)
                self.check_attribute_value(object_uid, lines_list, f'Rank{str(idx).zfill(3)}FirstAccessibleKeyNumber', ATTR_TYPE_INTEGER, False, 1, nb_pipes)
        elif nb_ranks == 0:
            # number of ranks set at 0, the Stop must contain rank attributes
            self.check_object_Rank(object_uid, lines_list)

        # a Stop has also the attributes of a Drawstop
        self.check_object_DrawStop(object_uid, lines_list)

    #-------------------------------------------------------------------------------------------------
    def check_object_Switch(self, object_uid, lines_list):
        # check the data of a Switch object section which the lines are in the given lines list

        # a Switch has only the attributes of a Drawstop
        self.check_object_DrawStop(object_uid, lines_list)

    #-------------------------------------------------------------------------------------------------
    def check_object_Tremulant(self, object_uid, lines_list):
        # check the data of a Tremulant object section which the lines are in the given lines list

        # optional attributes
        value = self.check_attribute_value(object_uid, lines_list, 'TremulantType', ATTR_TYPE_TREMULANT_TYPE, False)
        is_synth = (value == 'Synth')
        self.check_attribute_value(object_uid, lines_list, 'Period', ATTR_TYPE_INTEGER, is_synth, 32, 44100)
        self.check_attribute_value(object_uid, lines_list, 'StartRate', ATTR_TYPE_INTEGER, is_synth, 1, 100)
        self.check_attribute_value(object_uid, lines_list, 'StopRate', ATTR_TYPE_INTEGER, is_synth, 1, 100)
        self.check_attribute_value(object_uid, lines_list, 'AmpModDepth', ATTR_TYPE_INTEGER, is_synth, 1, 100)

        # a Tremulant has also the attributes of a Drawstop
        self.check_object_DrawStop(object_uid, lines_list)

    #-------------------------------------------------------------------------------------------------
    def check_object_WindchestGroup(self, object_uid, lines_list):
        # check the data of a WindChest Group object section which the lines are in the given lines list

        # required attributes
        max = self.objects_type_number_get('Enclosure')
        value = self.check_attribute_value(object_uid, lines_list, 'NumberOfEnclosures', ATTR_TYPE_INTEGER, True, 0, max)
        if value != None and value.isdigit():
            for idx in range(1, int(value)+1):
                self.check_attribute_value(object_uid, lines_list, f'Enclosure{str(idx).zfill(3)}', ATTR_TYPE_OBJECT_REF, True)

        max = self.objects_type_number_get('Tremulant')
        value = self.check_attribute_value(object_uid, lines_list, 'NumberOfTremulants', ATTR_TYPE_INTEGER, True, 0, max)
        if value != None and value.isdigit():
            for idx in range(1, int(value)+1):
                self.check_attribute_value(object_uid, lines_list, f'Tremulant{str(idx).zfill(3)}', ATTR_TYPE_OBJECT_REF, True)

        # optional attributes
        self.check_attribute_value(object_uid, lines_list, 'Name', ATTR_TYPE_STRING, False)

    #-------------------------------------------------------------------------------------------------
    def check_attribute_value(self, object_uid, lines_list, attribute_name, attribute_value_type, required_attribute_bool, attribute_value_min=0, attribute_value_max=0):
        # check if the given attribute name is present in the given object lines list (sorted)
        # and if its value is correct for its value type and min/max values
        # the min and max values are ignored if max <= min. The given lines list is considered to be sorted
        # returns the value of the attribute if it has been found and without error, else return None

        # check that the given max value is higher or equal to the min value (this should never happen)
        if attribute_value_max < attribute_value_max:
            logs.add(f"INTERNAL ERROR check_attribute_value called with max < min for {object_uid} / {attribute_name} : min={attribute_value_min}, max={attribute_value_max}")
            return None

        # search in the given lines list the line with the attribute to check
        attr_value = None
        line = None
        for i, line in enumerate(lines_list):
            if line[:len(attribute_name)] > attribute_name:
                # the given lines list being sorted, exit the loop if the current line starts by a string higher than the one of the attribute name
                break
            if line.startswith(attribute_name + '='):
                # line found
                (error_msg, attr_name, attr_value, comment) = self.object_line_split(line)
                if error_msg != None:
                    logs.add(f'ERROR in {object_uid} section, line "{line}" : {error_msg}')
                if attr_name != None and attr_value != None:
                    # the current line contains the attribute to check
                    self.checked_attr_nb += 1
                     # remove the line of the found attribute, to know at the end of the object check which of its attributes have not been checked
                    lines_list.pop(i)
                    break

        if attr_value != None:
            # the attribute has been found

            # check the attribute value according to the given type

            if attribute_value_type == ATTR_TYPE_INTEGER:
                if (not attr_value.lstrip("-+").isdigit() or
                    ((int(attr_value) < attribute_value_min or int(attr_value) > attribute_value_max))):
                    logs.add(f"ERROR in {object_uid} {line} : the assigned value must be an integer in the range [{attribute_value_min} - {attribute_value_max}]")

            elif attribute_value_type == ATTR_TYPE_FLOAT:
                if (not(attr_value.lstrip("-+").replace('.', '', 1).isdigit()) or
                    ((float(attr_value) < attribute_value_min or float(attr_value) > attribute_value_max))):
                    logs.add(f"ERROR in {object_uid} {line} : the assigned value must be an integer or decimal in the range [{attribute_value_min} - {attribute_value_max}]")
                    attr_value = ''

            elif attribute_value_type == ATTR_TYPE_BOOLEAN:
                if attr_value.upper() not in ('Y', 'N'):
                    logs.add(f"ERROR in {object_uid} {line} : the assigned value must be Y or N (boolean attribute)")
                    attr_value = ''

            elif attribute_value_type == ATTR_TYPE_STRING:
                pass # nothing to check in case of string value

            elif attribute_value_type == ATTR_TYPE_COLOR:
                if (not(attr_value.upper() in ('BLACK', 'BLUE', 'DARK BLUE', 'GREEN', 'DARK GREEN', 'CYAN', 'DARK CYAN', 'RED', 'DARK RED',
                                               'MAGENTA', 'DARK MAGENTA', 'YELLOW', 'DARK YELLOW', 'LIGHT GREY', 'DARK GREY', 'WHITE', 'BROWN')) and
                    not(len(attr_value) == 7 and attr_value[0] == '#' and attr_value[1:].isalnum())):  # check of the HTML format #RRGGBB
                    logs.add(f"ERROR in {object_uid} {line} : the assigned value is not a valid color (look at the help)")
                    attr_value = ''

            elif attribute_value_type == ATTR_TYPE_FONT_SIZE:
                if (not(attr_value.upper() in ('SMALL', 'NORMAL', 'LARGE')) and
                    not(attr_value.isdigit() and int(attr_value) >= 1 and int(attr_value) <= 50)):
                    logs.add(f"ERROR in {object_uid} {line} : the assigned value is not a valid font size (look at the help)")
                    attr_value = ''

            elif attribute_value_type == ATTR_TYPE_PANEL_SIZE:
                if (not(attr_value.upper() in ('SMALL', 'MEDIUM', 'MEDIUM LARGE', 'LARGE')) and
                    not(attr_value.isdigit() and int(attr_value) >= 100 and int(attr_value) <= 4000)):
                    logs.add(f"ERROR in {object_uid} {line} : the assigned value is not a valid panel size (look at the help)")
                    attr_value = ''

            elif attribute_value_type == ATTR_TYPE_OBJECT_REF:  # for example Switch002=12 or ManualNumber=2 or Stop003Manual=2 or Pipe015WindchestGroup=1
                if attribute_name[-3:].isdigit():
                    attribute_name = attribute_name[:-3]   # remove the three digits at the end of the attribute name to get the object name

                if attribute_name[-6:] == 'Number':
                    attribute_name = attribute_name[:-6]   # remove the 'Number' string at the end, used in General and Piston objects
                elif attribute_name[-6:] == 'Manual':
                    attribute_name = 'Manual'         # keep only the 'Manual' string, used in General object
                elif attribute_name[-14:] == 'WindchestGroup':
                    attribute_name = 'WindchestGroup' # keep only the 'WindchestGroup' string, used in Rank object

                attr_value = attr_value.lstrip("+-") # remove possible + or - at the beginning of the value, used in General or Divisional objects

                if not(attribute_name + attr_value.zfill(3)) in self.odf_data_dic:
                    logs.add(f"ERROR in {object_uid} {line} : the object {attribute_name + attr_value.zfill(3)} does not exist")
                    attr_value = ''

            elif attribute_value_type == ATTR_TYPE_ELEMENT_TYPE:
                if (not(attr_value in ('Coupler', 'Divisional', 'DivisionalCoupler', 'Enclosure', 'General', 'Label', 'Manual', 'ReversiblePiston', 'Stop', 'Swell',
                                      'Switch', 'Tremulant', 'CrescendoA', 'CrescendoB', 'CrescendoC', 'CrescendoD', 'CrescendoPrev', 'CrescendoNext', 'CrescendoCurrent',
                                      'Current', 'Full', 'GC', 'GeneralLabel', 'GeneralPrev', 'GeneralNext', 'Home', 'Insert', 'Delete', 'M100', 'M10', 'M1', 'P1', 'P10', 'P100',
                                      'PitchLabel', 'PitchP1', 'PitchP10', 'PitchP100', 'PitchM1', 'PitchM10', 'PitchM100', 'Prev', 'Next', 'Set', 'Regular', 'Scope', 'Scoped',
                                      'Save', 'SequencerLabel', 'TemperamentLabel', 'TemperamentPrev', 'TemperamentNext', 'TransposeDown', 'TransposeUp', 'TransposeLabel')) and
                    not(attr_value[0] == 'L' and attr_value[1].isdigit() and int(attr_value[1]) in range(0, 10)) and
                    not(attr_value[:14] == 'CrescendoLabel' and attr_value[14:].isdigit() and int(attr_value[14:]) in range(1, 33)) and
                    not(attr_value[:7] == 'General' and attr_value[7:].isdigit() and int(attr_value[7:]) in range(1, 51))):
                    logs.add(f"ERROR in {object_uid} {line} : the assigned value is not a valid panel element type (look at the help)")
                    attr_value = ''
                pass

            elif attribute_value_type == ATTR_TYPE_COUPLER_TYPE:
                if not(attr_value.upper() in ('NORMAL', 'BASS', 'MELODY')):
                    logs.add(f"ERROR in {object_uid} {line} : the assigned value is not a valid coupler type (look at the help)")
                    attr_value = ''

            elif attribute_value_type == ATTR_TYPE_TREMULANT_TYPE:
                if not(attr_value.upper() in ('SYNTH', 'WAVE')):
                    logs.add(f"ERROR in {object_uid} {line} : the assigned value is not a valid tremulant type (look at the help)")
                    attr_value = ''

            elif attribute_value_type == ATTR_TYPE_PISTON_TYPE:
                if not(attr_value.upper() in ('STOP', 'COUPLER', 'SWITCH', 'TREMULANT')):
                    logs.add(f"ERROR in {object_uid} {line} : the assigned value is not a valid piston type (look at the help)")
                    attr_value = ''

            elif attribute_value_type == ATTR_TYPE_DRAWSTOP_FCT:
                if not(attr_value in ('Input', 'Not', 'And', 'Xor', 'Nand', 'Nor', 'Or')):
                    logs.add(f"ERROR in {object_uid} {line} : the assigned value is not a valid drawstop function (look at the help)")
                    attr_value = ''

            elif attribute_value_type == ATTR_TYPE_FILE_NAME:
                if self.check_files_names_bool and not os.path.isfile(os.path.dirname(self.odf_file_name) + os.sep + path2ospath(attr_value)):
                    logs.add(f"ERROR in {object_uid} {line} : file does not exist")
                    attr_value = ''

            elif attribute_value_type == ATTR_TYPE_PIPE_WAVE and self.check_files_names_bool :
                if attr_value.upper()[-4:] == '.WAV':
                    if self.check_files_names_bool and not os.path.isfile(os.path.dirname(self.odf_file_name) + os.sep + path2ospath(attr_value)):
                        logs.add(f"ERROR in {object_uid} {line} : file not found")
                        attr_value = ''
                elif attr_value[:4] == 'REF:':  # for example REF:001:005:007
                    if not (attr_value[5:7].isdigit and attr_value[7] == ':' and
                            attr_value[8:11].isdigit and attr_value[11] == ':' and
                            attr_value[12:15].isdigit and len(attr_value) == 15):
                        logs.add(f"ERROR in {object_uid} {line} : wrong pipe referencing, expected REF:999:999:999")
                        attr_value = ''
                elif attr_value != 'EMPTY':
                    logs.add(f"ERROR in {object_uid} {line} : wrong pipe definition")
                    attr_value = ''

        elif required_attribute_bool:
            # the attribute has not been found and it is required
            logs.add(f"ERROR in {object_uid} : the attribute {attribute_name} is expected, it is missing or misspelled")

        return attr_value

    #-------------------------------------------------------------------------------------------------
    def check_attributes_unicity(self, object_uid, lines_list):
        # check in the given object lines list if each attribute is unique

        # copy the attributes names of the given lines list in an attributes list
        attributes_list = []
        for line in lines_list:
            pos = line.find('=', 1)
            if pos != -1 and line[0] != ';':
                # line with an attribute
                attributes_list.append(line[:pos])

        # sort the attributes list
        attributes_list.sort()

        # check if there are consecutive names in the sorted list
        for i in range(0, len(attributes_list) - 1):
            if attributes_list[i] == attributes_list[i+1]:
                logs.add(f"ERROR in {object_uid} : the attribute {attributes_list[i]} is defined more than once")

#-------------------------------------------------------------------------------------------------
class C_ODF_MISC:
    # class containing miscellaneous functions to manage data of GO ODF objects

    def manual_compass_get(manual_uid):
        # returns in a tuple the minimum and maximum MIDI notes of the given GO manual UID
        pass

    def manual_compass_extend(manual_uid, new_max_midi_note):
        # extends the compass of the given manual of the ODF up to the given MIDI note included

        manual_dic = self.object_dic_get(manual_uid)
        if manual_dic != None:
            min_midi_note = self.object_attr_value_get(manual_dic, 'FirstAccessibleKeyMIDINoteNumber')
            midi_note_nb = self.object_attr_value_get(manual_dic, 'NumberOfAccessibleKeys')

        # TBD

#-------------------------------------------------------------------------------------------------
class C_ODF_DATA(C_ODF_DATA_CHECK, C_ODF_MISC):
    # class to store and manage GO ODF data

    odf_file_name = ""      # name of the ODF which the data have been loaded
    odf_file_encoding = ""  # encoding type of the loaded ODF

    new_panel_format_bool = False  # flag indicating if the ODF data use the new panel format or not

    odf_data_dic = {}  # dictionary in which are stored the data of the loaded GrandOrgue ODF
                       # it has the following structure with two nested dictionaries :
                       #   {object UID: string (for example Organ, Panel001, Rank003)
                       #       {"names": list of strings (names to identify better the object)
                       #        "parents": list of strings (UID)
                       #        "children": list of strings (UID)
                       #        "lines": list of strings (data lines of the object), the first line contains the object UID
                       #       }
                       #    ...
                       #   }

    # dictionary containing the possible GO objects types and their possible child objects types
    go_objects_children_dic = {
        'Header': [],
        'Organ': ['General', 'Manual', 'Panel', 'WindchestGroup'],
        'Coupler': ['Switch'],
        'Divisional': ['Coupler', 'Stop', 'Switch', 'Tremulant'],
        'DivisionalCoupler': ['Manual', 'Switch'],
        'Enclosure': [],
        'General': ['Coupler', 'DivisionalCoupler', 'Stop', 'Switch', 'Tremulant'],
        'Manual': ['Coupler', 'Divisional', 'Stop', 'Switch', 'Tremulant'],
        'Panel': ['PanelElement', 'PanelImage'],
        'PanelElement': ['Coupler', 'Divisional', 'DivisionalCoupler', 'Enclosure', 'General', 'Manual', 'Stop', 'Switch', 'Tremulant'],
        'PanelImage': [],
        'Rank': [],
        'Stop': ['Rank', 'Switch'],
        'Switch': ['Switch'],
        'Tremulant': ['Switch'],
        'WindchestGroup': ['Enclosure', 'Stop', 'Rank', 'Tremulant'],
        # old panel format
        'Image': [],
        'Label': [],
        'SetterElement': [],
        'PanelCoupler': ['Coupler'],
        'PanelDivisional': ['Divisional'],
        'PanelDivisionalCoupler': ['DivisionalCoupler'],
        'PanelEnclosure': ['Enclosure'],
        'PanelGeneral': ['General'],
        'PanelLabel': ['Label'],
        'PanelSetterElement': ['SetterElement'],
        'PanelStop': ['Stop'],
        'PanelSwitch': ['Switch'],
        'PanelTremulant': ['Tremulant'],
        }

    # dictionary containing the possible GO objects types and their possible parent objects types
    # it is built automatically from go_objects_children_dic in the function objects_templates_load
    go_objects_parents_dic = {}

    # dictionary in which are stored the GO objects templates (loaded from the file GoObjectsTemplates.txt located in the resources sub-folder)
    go_templates_dic = {}

    #-------------------------------------------------------------------------------------------------
    def reset_all_data(self):
        # reset all the data of the class

        self.odf_file_name = ''
        self.odf_file_encoding = ENCODING_ISO_8859_1
        self.new_panel_format_bool = False
        self.odf_data_dic.clear()

    #-------------------------------------------------------------------------------------------------
    def objects_templates_load(self):
        # load the GO objects templates from the file GoObjectsTemplates.txt (if it is present and there is no error)
        # return True or False whether the operation has succeeded or not

        # initialize the go_objects_parents_dic dictionary from the keys of the go_objects_children_dic dictionary
        for object_type in self.go_objects_children_dic.keys():
            self.go_objects_parents_dic[object_type] = []
        # build the go_objects_parents_dic dictionary from the go_objects_children_dic dictionary content (create the opposite kinship)
        for parent_object_type, object_children_list in self.go_objects_children_dic.items():
            # scan the objects types of the object children dictionary
            for child_object_type in object_children_list:
                if parent_object_type not in ('Organ'): # do not include Organ in the parents
                    self.go_objects_parents_dic[child_object_type].append(parent_object_type)

        if len(self.go_templates_dic) == 0:
            # the dictionary has not been loaded yet

            file_name = os.path.dirname(__file__) + os.sep + 'resources' + os.sep + 'GoObjectsTemplates.txt'

            try:
                with open(file_name, 'r') as f:
                    self.go_templates_dic = eval(f.read())

            except OSError as err:
                # it has not be possible to open the file
                logs.add(f'ERROR Cannot open the file "{file_name}" : {err}')
            except SyntaxError as err:
                # syntax error in the dictionary structure which is in the file
                logs.add(f'ERROR Syntax error in the file "{file_name}" : {err}')
                logs.add( 'ERROR Fix the issue in the file then restart OdfEdit')
            except:
                # other error
                logs.add(f'ERROR while opening the file "{file_name}"')
            return False
        else:
            return True

    #-----------------------------------------------------------------------------------------------
    def load_from_file(self, file_name):
        # load the data of the given ODF
        # returns True/False whether the file has been loaded correctly or not

        file_name = path2ospath(file_name)

        # open the given ODF in read mode, and check its encoding format
        try:
            file = open(file_name, mode='r', encoding=ENCODING_ISO_8859_1)
        except OSError as err:
            # it has not be possible to open the file
            logs.add(f"Cannot open the file. {err}")
            valid_odf_file_bool = False
        else:
            if file.readline(3) == "ï»¿":  # UTF-8 BOM file encoding header
                # close the file
                file.close()
                # reopen the file with the proper encoding format
                file = open(file_name, mode='r', encoding=ENCODING_UTF8_BOM)
                self.odf_file_encoding = ENCODING_UTF8_BOM
            else:
                file.seek(0)  # reset the position of the cursor at the beginning of the file
                self.odf_file_encoding = ENCODING_ISO_8859_1
            # store the name of the ODF
            self.odf_file_name = file_name
            valid_odf_file_bool = True

            # clear data before to scan the file
            self.odf_data_dic.clear()

            object_types_list = []  # list containing the types of objects loaded from the ODF, to display statistics
            object_uid = 'Header'   # UID of the object currently recovered, header section by default
            object_dic = self.object_new(object_uid)    # dictionary of the object currently recovered
            total_attr_nb = 0       # number of whole attributes in the loaded ODF
            file_lines_nb = 0       # number of lines in the loaded ODF
            max_new_id = 999

            for line in file:
                # scan the lines of the ODF to load
                file_lines_nb += 1

                # remove the ending \n character if present in the current line
                if line[-1:] == '\n': line = line[:-1]

                # recover and check the syntax of the data present in the current line
                (error_msg, attr_name, attr_value, comment) = self.object_line_split(line)
                if error_msg != None:
                    logs.add(f'ERROR in {object_uid} section, line "{line}" : {error_msg}')
                    line = ';!!! ' + line
                    attr_name = None

                if attr_name == 'uid':
                    # line containing an object UID

                    # add in the ODF data the object in construction for the previous UID, if it has lines inside
                    # in case of Header the UID line is not considered, so 2 lines min are expected
                    if (object_uid == 'Header' and len(object_dic['lines']) > 1) or len(object_dic['lines']) > 0:
                        self.odf_data_dic[object_uid] = object_dic

                    object_uid = attr_value

                    while object_uid in self.odf_data_dic.keys() and max_new_id > 0:
                        object_uid = object_uid[:-3] + str(max_new_id).zfill(3)
                        max_new_id -= 1
                    if object_uid != attr_value:
                        logs.add(f"WARNING : another occurence of the object {attr_value} is present in the ODF, it has been renamed in {object_uid}")

                    # create the next object in construction
                    object_dic = self.object_new(object_uid)

                    # store the object type for statistics
                    object_type = self.object_type_get(object_uid)
                    if not object_type in object_types_list:
                        object_types_list.append(object_type)

                elif attr_name != None and object_uid == 'Header':
                    # attribute line in the header : it is an error
                    logs.add('ERROR only comments are allowed in the header section')
                    line = ';!!! ' + line
                    attr_name = None

                elif attr_name != None :
                    total_attr_nb += 1

                # add the current line to the object in construction
                if len(line) > 0:
                    object_dic['lines'].append(line)

            # add in the ODF dictionary the dictionary of the last loaded object
            if len(object_dic) > 0:
                self.odf_data_dic[object_uid] = object_dic

            # close the ODF
            file.close()

            # update the kinship links between the objects
            self.objects_kinship_update()

            # reset the check files names flag
            self.check_files_names_bool = None

            if self.odf_file_encoding == ENCODING_UTF8_BOM:
                file_encoding = 'UTF-8-BOM'
            else:
                file_encoding = 'ISO_8859_1'

            logs.add(f'GrandOrgue ODF loaded "{file_name}"')
            logs.add(f'{file_lines_nb:,} lines, file encoding {file_encoding}')

            logs.add(f'{total_attr_nb:,} attributes among {len(self.odf_data_dic)-1:,} objects among {len(object_types_list)} object types')

            # update the panel format flag from the ODF data content
            self.check_panel_format()

        return valid_odf_file_bool

    #-------------------------------------------------------------------------------------------------
    def save_to_file(self, file_name, file_encoding):
        # save the odf_data_dic in the given ODF and with the given encoding format (ENCODING_ISO_8859_1 or ENCODING_UTF8_BOM)
        # if no file name is given, the saving is done in the already loaded ODF file ('Save as' feature)
        # returns True/False whether the writting in file has been done correctly or not

        if file_encoding not in (ENCODING_ISO_8859_1, ENCODING_UTF8_BOM):
            logs.add(f"INTERNAL ERROR wrong encoding {file_encoding} given to save_to_file")
            return False

        file_saved_bool = False

        if len(self.odf_data_dic) == 0:
            # the ODF dictionary is empty, there are no data to save
            logs.add(f"None data to save in the file {file_name}")
        elif file_name == '' and self.odf_file_name == '':
            # no file name known, should not occur, so no possibility to make the save operation
            pass
        else:
            # open the given ODF in write mode
            if file_name == '':
                # no given file name, make the saving in the already loaded ODF
                file_name = self.odf_file_name

            # check if the file name has an extension, if not add the .organ extension
            if file_name[-6:] != '.organ':
                file_name += '.organ'

            try:
                file = open(file_name, mode='w', encoding=file_encoding)
            except OSError as err:
                logs.add(f"Cannot write in the file. {err}")
            else:
                # write the ODF data dictionary content in the ODF
                # eliminating the blank lines and ensuring a blanck line before each object section start
                # write the Header and Organ objects if defined
                for object_uid in ('Header', 'Organ'):
                    if object_uid in self.odf_data_dic.keys():
                        for line in self.odf_data_dic[object_uid]['lines']:
                            if line != '':
                                if line[0] == '[':
                                    # start of a section : add a blank line before
                                    file.write('\n\n' + line)
                                else:
                                    file.write('\n' + line)
                # write the other objects by UID ascending order
                for object_uid in sorted(self.odf_data_dic.keys()):
                    # scan the sorted objects of the ODF data
                    if object_uid not in ('Header', 'Organ'):
                        for line in self.odf_data_dic[object_uid]['lines']:
                            # scan the lines of the current object
                            if line != '':
                                if line[0] == '[':
                                    # start of a section : add a blank line before
                                    file.write('\n\n' + line)
                                else:
                                    file.write('\n' + line)

                file.close()
                file_saved_bool = True

                # store the name of the ODF file
                self.odf_file_name = file_name

                if file_encoding == ENCODING_UTF8_BOM:
                    file_enc = 'UTF-8-BOM'
                else:
                    file_enc = 'ISO_8859_1'

                logs.add(f'Data saved in file "{self.odf_file_name}" with encoding {file_enc}')

        return file_saved_bool

    #-------------------------------------------------------------------------------------------------
    def object_line_split(self, line):
        # check the syntax of the given object line and extract from it the attribute name + attribute value + comment
        # return a tuple containing : (error message, attribute name, attribute value, comment)
        # attribute name = 'uid' if the given line contains an object UID between brackets, the UID is in the attribute value
        # error message = an error description message in case a syntax error has been detected in the given line, or None if no error found

        return self.check_object_line(line)

    #-------------------------------------------------------------------------------------------------
    def object_line_join(self, attr_name, attr_value, comment=None):
        # join in a single string line in ODF format the provided data, return this line

        attr_value = str(attr_value)
        line = ''

        if attr_name == 'uid':
            # UID of the object, start of a section
            if comment != None:
                line = '[' + attr_value + ']' + comment
            else:
                line = '[' + attr_value + ']'

        elif attr_name != None:
            # attribute line
            if comment != None:
                line = attr_name + '=' + attr_value + comment
            else:
                line = attr_name + '=' + attr_value

        elif comment != None:
            # comment line
            line = comment

        return line

    #-------------------------------------------------------------------------------------------------
    def object_lines_read(self, object_uid):
        # return in a list the attribute lines of the given object UID (the first line contains the object UID in brackets)
        # or an empty list if the object UID doesn't exist

        object_dic = self.object_dic_get(object_uid)
        if object_dic != None:
            return list(object_dic['lines'])
        else:
            return []

    #-------------------------------------------------------------------------------------------------
    def object_lines_write(self, object_lines_list, expected_object_uid=None, parent_object_uid=None):
        # write the given object attributes lines in the ODF
        # the first line of the list must contain an object UID between brackets else the lines are considered as being the Header section
        # if expected_object_uid is given, it is the UID expected in the first line of the given lines list
        # if parent_object_uid is given, link the object defined in the lines (if is new in the ODF) to this parent
        # return the UID of the added/updated/renamed object or None if a syntax error has been detected

        # expected_object_uid | object_uid (defined in lines)    | action in the ODF
        # --------------------|----------------------------------|------------------------------------
        # None                | Object999 (not in ODF)           | Object999 added
        # None                | Object999 (in ODF)               | Object999 updated
        # Object999           | Object999 (not in ODF)           | Object999 added
        # Object999           | Object999 (in ODF)               | Object999 updated
        # Object999           | Object888 (different type)       | error, Object999 cannot be renamed in Object888 which has different object type
        # Object999           | Object888 (same type in ODF)     | error, Object999 cannot be renamed in Object888 which already exists
        # Object999           | Object888 (same type not in ODF) | Object999 renamed in Object888 and Object888 updated

        # set the initial object UID before to scan the given lines lise
        if expected_object_uid == None:
            object_uid = 'Header'   # Header object by default if no expected UID
        else:
            object_uid = expected_object_uid

        tmp_object_dic = self.object_new(object_uid)  # object to store the provided lines and their UID

        for i, line in enumerate(object_lines_list):
            # scan the lines of the given list to check them, to recover the UID and store them in tmp_object_dic

            # recover and check the data present in the current line
            (error_msg, attr_name, attr_value, comment) = self.object_line_split(line)

            if error_msg != None:
                logs.add(f'ERROR in line "{line}" : {error_msg}')
                return None
            elif i == 0 and attr_name != 'uid' and object_uid != 'Header':
                logs.add('ERROR : an object identifier is expected in the first line')
                return None
            elif i > 0 and attr_name == 'uid':
                logs.add('ERROR : an object identifier can be defined only in the first line')
                return None
            elif i == 0 and attr_name == 'uid' and attr_value != None:
                # there is a valid UID in first line
                object_uid = attr_value
            elif object_uid == 'Header' and attr_name != None:
                logs.add('ERROR : only comments are allowed in the header section')
                return None

            # add the current line to the temporary object
            tmp_object_dic['lines'].append(line)

        # recover the object corresponding to the UID defined in the first of the given lines if defined in the ODF
        object_dic = self.object_dic_get(object_uid)

        if expected_object_uid != None and self.object_type_get(expected_object_uid) != self.object_type_get(object_uid):
            logs.add(f'ERROR : {expected_object_uid} cannot be renamed in {object_uid} which is of different type')
            object_uid = None

        elif expected_object_uid != None and expected_object_uid != object_uid and object_dic != None:
            logs.add(f'ERROR : {expected_object_uid} cannot be renamed in {object_uid} which is already defined in the ODF')
            object_uid = None

        elif object_dic == None and (expected_object_uid == None or expected_object_uid == object_uid):
            # the object UID defined in the given lines is not present in the ODF
            # and there is no expected UID or it is equal to the UID defined in the given lines
            # add an object in the ODF with the given lines
            self.odf_data_dic[object_uid] = tmp_object_dic
            logs.add(f"{object_uid} : added")

            if parent_object_uid != None:
                # link the new object to its parent if provided
                self.object_parent2child_link(parent_object_uid, object_uid, 'link')
            elif self.object_type_get(object_uid) in ('PanelElement', 'PanelImage'):
                # link the new object to its parent panel if it is PanelElement or PanelImage object
                self.object_parent2child_link(object_uid[:8], object_uid, 'link')

        else:
            # other cases
            if expected_object_uid != None and expected_object_uid != object_uid:
                # the UID defined in the lines is not the expected one
                # rename the expected object UID to the UID defined in the lines
                object_uid = self.object_rename(expected_object_uid, object_uid)
                object_dic = self.object_dic_get(object_uid)

            if object_dic != None:
                # update the object having the UID defined in the lines
                object_dic['lines'] = tmp_object_dic['lines']
                logs.add(f"{object_uid} : updated")

        # update the kinship links between the objects
        self.objects_kinship_update()
        # update the number of object type in the Organ object if necessary
        self.object_organ_numbers_update(object_uid)

        return object_uid

    #-------------------------------------------------------------------------------------------------
    def object_new(self, object_uid):
        # return the dictionary of a new object having the given UID and all other fields void

        object_dic = {}
        object_dic['names'] = []    # list with the various names of the object
        object_dic['parents'] = []  # list with the UID of parent objects
        object_dic['children'] = [] # list with the UID of children objects
        object_dic['lines'] = [] # list with the data lines (including the UID) of the object

        return object_dic

    #-------------------------------------------------------------------------------------------------
    def object_add(self, object_type, parent_uid, object_lines_list=[]):
        # add in the ODF data an object corresponding to the given object type
        # and having the attributes of the given lines list if provided or of the template if defined
        # return the UID of the created object, or None if an error occured

        if not object_type in self.go_objects_children_dic.keys():
            logs.add(f'INTERNAL ERROR in object_add : object type {object_type} is unknown')
            return None

        if len(object_lines_list) == 0:
            # no object lines list provided, recover the one from the template if defined
            if object_type in self.go_templates_dic.keys():
                # the given object type has a template defined
                # recover the lines of the template
                object_lines_list = list(self.go_templates_dic[object_type])

        # define the UID of the object to add
        object_uid = self.object_type_free_uid_get(object_type, parent_uid)

        if object_uid != None:
            # a new object can be added
            # add the object UID in first line of the attribute lines list if it is not the Header
            if object_uid != 'Header':
                object_lines_list.insert(0, '[' + object_uid + ']')

            # add the object and its attribute lines in the ODF and recover the result (can be None in case of error in the lines)
            object_uid = self.object_lines_write(object_lines_list, object_uid, parent_uid)

        return object_uid

    #-------------------------------------------------------------------------------------------------
    def object_copy(self, copied_object_uid, parent_uid):
        # make a copy of the given copied object UID and place it as child of the given parent object UID (can be None)
        # return the UID of the copied object, or None if an error occured

        # recover the lines of the object to copy
        attribute_lines_list = self.object_lines_read(copied_object_uid)
        if len(attribute_lines_list) > 0:
            # remove the first line which contains the original object UID (the new UID will be added in object_add)
            attribute_lines_list.pop(0)
            # add a copy of the copied object
            copied_object_type = self.object_type_get(copied_object_uid)
            new_object_uid = self.object_add(copied_object_type, parent_uid, attribute_lines_list)
        else:
            new_object_uid = None

        if new_object_uid != None:
            logs.add(f'{new_object_uid} : copied from {copied_object_uid}')
        else:
            logs.add(f'ERROR cannot make a copy of {copied_object_uid}')

        return new_object_uid

    #-------------------------------------------------------------------------------------------------
    def object_link(self, object_uid, kinship_objects_list, relationship):
        # link the given object to the objects of the given kinship objects list with the given relationship (TO_PARENT or TO_CHILD)
        # return the object_uid (which can have be renamed in case of children of a Panel or Manual) or None if an issue occured

        if relationship not in (TO_PARENT, TO_CHILD):
            logs.add(f'INTERNAL ERROR in object_link : wrong given relationship {relationship}')

        object_dic = self.object_dic_get(object_uid)
        if object_dic == None:
            return None
        object_type = self.object_type_get(object_uid)

        # recover the list of the current kinship list (parents or children) of the given object
        current_kinship_list = sorted(self.object_kinship_list_get(object_uid, relationship))

        # build a dictionary with as keys the object types which are present in the given kinship objects list
        #                     and as values their number in the list
        kinship_objects_types_dic = {}
        for obj_uid in kinship_objects_list:
            obj_type = self.object_type_get(obj_uid)
            if obj_type not in kinship_objects_types_dic.keys():
                kinship_objects_types_dic[obj_type] = 0
            kinship_objects_types_dic[obj_type] += 1

        # check if the given kinship list contains more parents/children type than allowed for the given object type
        if relationship == TO_PARENT:
            if object_type in ('PanelElement', 'PanelImage'):
                if 'Panel' in kinship_objects_types_dic.keys():
                    if kinship_objects_types_dic['Panel'] > 1:
                        # PanelElement or PanelImage with more than one Panel parent
                        messagebox.showerror(title='Selection error', message=f'A {object_type} object cannot have more than one parent Panel, please select a single parent Panel.')
                        return None
                else:
                    # PanelElement or PanelImage with none Panel parent
                    messagebox.showerror(title='Selection error', message=f'A {object_type} object must have one parent Panel, please select a parent Panel.')
                    return None
            elif (object_type in ('Rank', 'Stop') and
                  'WindchestGroup' in kinship_objects_types_dic.keys() and kinship_objects_types_dic['WindchestGroup'] > 1):
                # Rank and Stop object with more than one parent WindchestGroup
                messagebox.showerror(title='Selection error', message=f'A {object_type} object cannot have more than one parent WindchestGroup, please select a single parent WindchestGroup.')
                return None
        else: # TO_CHILD
            if object_type == 'PanelElement' and len(kinship_objects_list) > 1:
                # a PanelElement with more than one child object
                messagebox.showerror(title='Selection error', message=f'A {object_type} object can have only one child object, please select a single child for {object_uid}.')
                return None

        ret_object_uid = object_uid  # UID which will be returned by the function
        if relationship == TO_PARENT:
            # unlink the given object from its current parents which have no more to be a parent
            if object_type not in ('PanelElement', 'PanelImage'):
                # no need to unlink PanelElement and PanelImage
                for parent_uid in current_kinship_list:
                    # scan the current parent objects of the given object
                    if parent_uid not in kinship_objects_list:
                        # the current parent has no more to be a parent : remove the link
                        self.object_parent2child_link(parent_uid, object_uid, 'unlink')

            # link the given object to the objects which must be now a parent
            for parent_uid in kinship_objects_list:
                # scan the given parent objects
                if parent_uid not in current_kinship_list:
                    # it is not yet a parent : add the link
                    ret_object_uid = self.object_parent2child_link(parent_uid, object_uid, 'link')
        else:
            # unlink the given object from its current children which have no more to be a child
            if object_type != 'Panel':
                # no need to unlink PanelElement and PanelImage
                for child_uid in current_kinship_list:
                    # scan the current child objects of the given object
                    if child_uid not in kinship_objects_list:
                        # the current child has no more to be a child : remove the link
                        self.object_parent2child_link(object_uid, child_uid, 'unlink')

            # link the given object to the objects which must be now a child
            for child_uid in kinship_objects_list:
                # scan the given children objects
                if child_uid not in current_kinship_list:
                    # it is not yet a child : add the link
                    self.object_parent2child_link(object_uid, child_uid, 'link')

        # update the kinship links between the objects of the ODF
        self.objects_kinship_update()

        return ret_object_uid

    #-------------------------------------------------------------------------------------------------
    def object_rename(self, old_object_uid, new_object_uid, update_links_bool=True):
        # rename in the ODF data the object having the given UID to the given new UID (only the three last digits of the UID can be changed)
        # return the new UID of the object, or None if failure

        # check the provided object UIDs
        object_dic = self.object_dic_get(new_object_uid)
        if object_dic != None:
            logs.add(f"Warning : cannot rename {old_object_uid} in {new_object_uid} which already exits")
            return None

        object_dic = self.object_dic_get(old_object_uid)
        if object_dic == None:
            logs.add(f"INTERNAL ERROR in object_rename : object {old_object_uid} does not exit")
            return None

        object_type = self.object_type_get(old_object_uid)
        if object_type != self.object_type_get(new_object_uid):
            logs.add(f"INTERNAL ERROR in object_rename : old object type {old_object_uid} and new object type {new_object_uid} are not the same")
            return None

        # rename the reference to the new object UID in its parents or children objects if necessary
        if object_type == 'Panel':
            # rename the UID of the children of the renamed panel (PanelElement and PanelImage)
            for old_child_uid in object_dic['children']:
                # scan the children of the renamed Panel
                new_child_uid = new_object_uid + old_child_uid[8:]   # for example from Panel000Element001 to Panel001Element001
                # move the child object data under another key which has its new UID
                self.odf_data_dic[new_child_uid] = self.odf_data_dic.pop(old_child_uid)
                # update the UID in the first line of the child object
                (error_msg, attr_name, attr_value, comment) = self.object_line_split(self.odf_data_dic[new_child_uid]['lines'][0])
                if attr_name == 'uid':
                    self.odf_data_dic[new_child_uid]['lines'][0] = self.object_line_join(attr_name, new_child_uid, comment)
                logs.add(f"{old_child_uid} : renamed in {new_child_uid}")

        elif object_type == 'WindchestGroup':
            # rename the reference to the new WindchestGroup UID in its children objects Stop or Rank
            windchest_id = self.object_id_get(new_object_uid)
            if windchest_id != None:
                for child_uid in object_dic['children']:
                    # scan the children of the renamed WindchestGroup
                    if self.object_type_get(child_uid) in ('Stop', 'Rank'):
                        self.object_attr_value_set(child_uid, 'WindchestGroup', int(windchest_id))
                        logs.add(f"{child_uid} : attribute WindchestGroup set to {windchest_id}")

        elif object_type not in ('PanelElement', 'PanelImage'):
            # other kinds of objects (but PanelElement and PanelImage) : rename the reference to the new object UID in its parents
            for parent_uid in sorted(object_dic['parents']):
                # scan the parents of the renamed object

                parent_type = self.object_type_get(parent_uid)
                parent_dic = self.object_dic_get(parent_uid)
                if parent_dic != None:

                    # define the name of the attribute in the parent which refers to the type of the renamed object
                    ref_attr_name = object_type
                    if parent_type == 'General':
                        ref_attr_name += 'Number'

                    parent_lines_list = parent_dic['lines']
                    for i in range(len(parent_lines_list)):
                        # scan the lines of the parent object to recover the references to objects of the type of the renamed object
                        if parent_lines_list[i].startswith(ref_attr_name):
                            # the current line contains a reference to the renamed object type
                            (error_msg, attr_name, attr_value, comment) = self.object_line_split(parent_lines_list[i])
                            if (attr_name != None and attr_value != '' and (attr_name == ref_attr_name or attr_name[:-3] == ref_attr_name) and
                                abs(int(attr_value)) == int(old_object_uid[-3:])):
                                # the current line contains a reference to the renamed object
                                # write in this line the new reference ID
                                sign = '-' if attr_value[0] == '-' else ''
                                self.object_attr_value_set(parent_dic, attr_name, sign + new_object_uid[-3:])
                                logs.add(f"{parent_uid} : reference to {old_object_uid} changed to {new_object_uid}")
                                break

            if object_type == 'Manual':
                # if a manual is renamed, rename the StopManual and CouplerManual attributes value in General objects
                for obj_uid in self.odf_data_dic.keys():
                    # scan the objects of the ODF data
                    if obj_uid.startswith('General'):
                        # the current object is a General
                        obj_dic = self.object_dic_get(obj_uid)
                        lines_list = obj_dic['lines']
                        for i in range(len(lines_list)):
                            # scan the lines of the current General object
                            if lines_list[i].startswith(('StopManual', 'CouplerManual')):
                                # the current line contains a reference to a manual
                                (error_msg, attr_name, attr_value, comment) = self.object_line_split(lines_list[i])
                                if attr_name != None and int(attr_value) == int(old_object_uid[-3:]):
                                    # the current line contains a reference to the old UID of the renamed Manual
                                    self.object_attr_value_set(obj_dic, attr_name, new_object_uid[-3:])
                                    logs.add(f"{obj_uid} : attribute {attr_name} updated")

                # rename as well the ID of the children Coupler, Divisional, Stop objects to align it on the new manual ID (first digit of the ID)
                manual_id = int(new_object_uid[-3:])
                for child_uid in list(object_dic['children']):
                    # scan the children of the renamed Manual
                    if self.object_type_get(child_uid) in ('Coupler', 'Divisional', 'Stop'):
                        # rename the current object UID by changing the first digit of its ID with the number of the parent manual
                        self.object_rename(child_uid, child_uid[:-3] + str(manual_id) + child_uid[-2:], False)

        # move the given object under another key in the ODF data dictionary which has the new UID
        object_dic = self.odf_data_dic[new_object_uid] = self.odf_data_dic.pop(old_object_uid)

        # update the UID in the first line with the new object UID
        (error_msg, attr_name, attr_value, comment) = self.object_line_split(object_dic['lines'][0])
        if attr_name == 'uid':
            object_dic['lines'][0] = self.object_line_join(attr_name, new_object_uid, comment)

        logs.add(f"{old_object_uid} : renamed in {new_object_uid}")

        if update_links_bool:
            # update in the Organ object the number of objects type corresponding to the rename object if needed
            self.object_organ_numbers_update(new_object_uid)

            # update the kinship links between the objects
            self.objects_kinship_update()

        return new_object_uid

    #-------------------------------------------------------------------------------------------------
    def object_delete(self, object_uid):
        # delete in the ODF data the object having the given UID
        # return True or False whether the deletion has been done or not

        object_dic = self.object_dic_get(object_uid)
        if object_dic != None:
            # unlink the given object with its parents
            for parent_uid in object_dic['parents']:
                self.object_parent2child_link(parent_uid, object_uid, 'unlink')

            # delete the given object in the ODF data
            del self.odf_data_dic[object_uid]
            logs.add(f"{object_uid} : deleted")

            # update the number of object type in the Organ object if necessary
            self.object_organ_numbers_update(object_uid)

            # update the kinship links between the objects
            self.objects_kinship_update()

            return True
        else:
            logs.add(f"ERROR {object_uid} cannot be deleted because not found")
            return False

    #-------------------------------------------------------------------------------------------------
    def object_id_get(self, object_uid):
        # return the ID (integer) of the given object UID (for example from Stop012 will return 12)
        # return None if the ID is not valid : there are not 3 digits at the end of the UID

        if not(object_uid[-3:].isdigit()):
            # the last 3 characters are not all digits
            return None
        else:
            return int(object_uid[-3:])

    #-------------------------------------------------------------------------------------------------
    def object_type_get(self, object_uid):
        # return the type (string) of the given object UID (for example from Panel012 will return Panel) or None if not type provided

        if object_uid not in (None, ''):
            # remove the digits which are inside the UID string
            object_type = ''
            for c in object_uid:
                if not c.isdigit():
                    object_type += c
        else:
            object_type = None

        return object_type

    #-------------------------------------------------------------------------------------------------
    def object_type_free_uid_get(self, object_type, parent_uid=None):
        # return the first unused object UID for the given object type and being child of the given parent UID if provided (required for Manual and Panel parents)

        if object_type in ('Header', 'Organ'):
            if object_type in self.odf_data_dic.keys():
                # there is already a Header or Organ object in the ODF
                return None
            else:
                return object_type

        if object_type in ('Manual', 'Panel'):
            # Manual and Panel ID can start from 0 and need a given parent UID
            free_id = 0
        else:
            free_id = 1
        id_size = 3

        parent_type = self.object_type_get(parent_uid)
        if parent_type == 'Panel':
            object_type = parent_uid + object_type[5:]   # it gives for example Panel0001Element or Panel002Image
        elif parent_type == 'Manual' and object_type in ('Coupler', 'Divisional', 'Stop'):
            object_type = object_type + parent_uid[-1]   # it gives for example Stop1, only the last two digits can be set
            id_size = 2

        while free_id <= 999 :
            free_uid = object_type + str(free_id).zfill(id_size)
            if free_uid not in self.odf_data_dic.keys():
                # the current UID is not present in the ODF
                return free_uid
            else:
                free_id += 1
        return None

    #-------------------------------------------------------------------------------------------------
    def object_dic_get(self, object_uid):
        # return the dictionary of the object of the ODF dictionary having the given UID

        try:
            return self.odf_data_dic[object_uid]
        except:
            # object not existing
            return None

    #-------------------------------------------------------------------------------------------------
    def object_names_get(self, object_uid):
        # return the UID followed by the names between parenthesis (if defined) of the given object UID

        object_dic = self.object_dic_get(object_uid)
        if object_dic != None and len(object_dic['names']) > 0:
            return object_uid + ' (' + ' | '.join(object_dic['names']) + ')'
        else:
            return object_uid

    #-------------------------------------------------------------------------------------------------
    def object_attr_value_get(self, object_dic_or_uid, attribute_name):
        # return the value of the given attribute defined in the given object dictionary or UID
        # return None if the given object or the attribute doesn't exist

        if object_dic_or_uid == None:
            return None

        elif isinstance(object_dic_or_uid, str):
            # the given parameter is a string, so an UID
            object_dic = self.object_dic_get(object_dic_or_uid)
        else:
            # the given parameter is not a string, so an object dictionary
            object_dic = object_dic_or_uid

        if object_dic != None:
            for line in object_dic['lines']:
                # scan the attribute lines of the object
                (error_msg, attr_name, attr_value, comment) = self.object_line_split(line)
                if attr_name == attribute_name:
                    # given attribute found : return its value
                    return attr_value

        return None

    #-------------------------------------------------------------------------------------------------
    def object_attr_value_set(self, object_dic_or_uid, attribute_name, attribute_value):
        # write the given value in the given attribute defined in the given object dictionary or UID
        # return True or False whether it has been possible or not to the set the value

        if isinstance(object_dic_or_uid, str):
            # the given parameter is a string, so an UID
            object_dic = self.object_dic_get(object_dic_or_uid)
        else:
            # the given parameter is not a string, so an object dictionary
            object_dic = object_dic_or_uid

        if object_dic != None:
            comment = None # no comment put in the line
            for i, line in enumerate(object_dic['lines']):
                # scan the attribute lines of the object
                (error_msg, attr_name, attr_value, comment) = self.object_line_split(line)
                if attr_name == attribute_name:
                    # given attribute found : update its value
                    object_dic['lines'][i] = self.object_line_join(attribute_name, attribute_value, comment)
                    return True

            # attribute not present in the object lines, add a line for it
            object_dic['lines'].append(self.object_line_join(attribute_name, attribute_value, comment))
            return True
        else:
            return False

    #-------------------------------------------------------------------------------------------------
    def object_parent2child_link(self, parent_object_uid, child_object_uid, operation):
        # link/unlink the given child object to the given parent object (both must already exist in the ODF data)
        # operation parameter can be 'link' or 'unlink'
        # return the UID of the child object (can be renamed in case of child of Panel) or None if an error occured

        # types of referencing parent to child :
        #   WindchestGroup -> Stop (rank inside) or Rank : WindchestGroup ID is set in the attribute WindchestGroup of the Stop or Rank object
        #   Panel -> PanelElement or PanelImage : PanelElement or PanelImage UID starts with the parent Panel UID
        #   PanelElement -> Coupler/General/Manual/... : only one child can be defined
        #   Stop -> Switch (example) : the value of the attribute Switchxxx of the Stop is the Rank ID

        if (parent_object_uid == None or child_object_uid == None):
            return None

        if operation not in ('link', 'unlink'):
            logs.add(f'INTERNAL ERROR in object_parent2child_link : wrong requested operation name "{operation}"')
            return None

        # recover the dictionary, type and ID of the given parent
        parent_object_dic = self.object_dic_get(parent_object_uid)
        if parent_object_dic == None:
            logs.add(f"INTERNAL ERROR in object_parent2child_link : parent object {parent_object_uid} does not exit")
            return None
        parent_object_type = self.object_type_get(parent_object_uid)
        parent_object_id = self.object_id_get(parent_object_uid)
        if parent_object_type in ('Organ', 'Header'):
            # the Organ and Header objects cannot be linked to a child
            return None

        # recover the dictionary, type and ID of the given child
        child_object_dic = self.object_dic_get(child_object_uid)
        if child_object_dic == None:
            logs.add(f"INTERNAL ERROR in object_parent2child_link : child object {child_object_uid} does not exit")
            return None
        child_object_type = self.object_type_get(child_object_uid)
        child_object_id = self.object_id_get(child_object_uid)

        # check that the given parent object can have the given child object as a child
        if not child_object_type in self.go_objects_children_dic[parent_object_type]:
            logs.add(f"INTERNAL ERROR in object_parent2child_link : the object type {parent_object_type} cannot have the object type {child_object_type} as a child")
            return None

        if parent_object_type == 'WindchestGroup' and child_object_type in ('Rank', 'Stop'):
            # link change between parent WindchestGroup and child Rank or Stop object, the referencing is done in the Rank or Stop object
            # set or erase the ID of the parent WindchestGroup in the attribute WindchestGroup of the child Rank or Stop object
            if operation == 'link':
                self.object_attr_value_set(child_object_dic, 'WindchestGroup', int(parent_object_id))
                logs.add(f"{child_object_uid} : reference to {parent_object_uid} added")
            else:
                self.object_attr_value_set(child_object_dic, 'WindchestGroup', '')
                logs.add(f"{child_object_uid} : reference to {parent_object_uid} removed")
            return child_object_uid

        elif parent_object_type == 'Panel':
            # link change between parent Panel and child PanelElement or PanelImage object
            # store the parent panel UID present in the child UID before to rename it
            prev_parent_panel_uid = child_object_uid[:8]
            if operation == 'link' and parent_object_uid != prev_parent_panel_uid:
                # link to do and the given child PanelElement or PanelImage doesn't refer already to the given parent panel UID
                # get a free new UID for the child
                new_child_object_uid = self.object_type_free_uid_get(child_object_type, parent_object_uid)

                # move the object data of the child object under another key which has the new child UID
                new_object_dic = self.odf_data_dic[new_child_object_uid] = self.odf_data_dic.pop(child_object_uid)

                # write the new UID in the first line of the new object
                (error_msg, attr_name, attr_value, comment) = self.object_line_split(new_object_dic['lines'][0])
                if attr_name == 'uid':
                    new_object_dic['lines'][0] = self.object_line_join(attr_name, new_child_object_uid, comment)

                logs.add(f"{child_object_uid} : renamed in {new_child_object_uid}")

                # update the NumberOf attribute of the previous parent Panel object which doesn't contain anymore the child object
                if child_object_type == 'PanelElement':
                    nb = self.objects_type_number_get(prev_parent_panel_uid + 'Element')
                    self.object_attr_value_set(prev_parent_panel_uid, 'NumberOfGUIElements', nb)
                    logs.add(f"{prev_parent_panel_uid} : attribute NumberOfGUIElements updated")
                else:
                    nb = self.objects_type_number_get(prev_parent_panel_uid + 'Image')
                    self.object_attr_value_set(prev_parent_panel_uid, 'NumberOfImages', nb)
                    logs.add(f"{prev_parent_panel_uid} : attribute NumberOfImages updated")

                child_object_uid = new_child_object_uid

            # unlink to parent panel is possible only if the child object PanelElement or PanelImage is going to be deleted

            # update the NumberOf attribute of the parent Panel object to take into account the link change
            if child_object_type == 'PanelElement':
                nb = self.objects_type_number_get(parent_object_uid + 'Element')
                if operation == 'unlink': nb -= 1  # remove 1 to take into account the child which will be deleted later
                self.object_attr_value_set(parent_object_uid, 'NumberOfGUIElements', nb)
                logs.add(f"{parent_object_uid} : attribute NumberOfGUIElements updated")
            else:
                nb = self.objects_type_number_get(parent_object_uid + 'Image')
                if operation == 'unlink': nb -= 1  # remove 1 to take into account the child which will be deleted later
                self.object_attr_value_set(parent_object_uid, 'NumberOfImages', nb)
                logs.add(f"{parent_object_uid} : attribute NumberOfImages updated")

            return child_object_uid

        elif parent_object_type == 'PanelElement':
            # link change between a parent PanelElement and a child object which has to be unique
            # remove in the PanelElement object all the lines with Type or referencing attributes
            i = 0
            parent_lines_list = parent_object_dic['lines']
            while i < len(parent_lines_list):
                # scan the lines of the parent object
                (error_msg, attr_name, attr_value, comment) = self.object_line_split(parent_lines_list[i])
                if attr_name != None and (attr_name in self.go_objects_children_dic['PanelElement'] or attr_name == 'Type'):
                    # the current line contains an attribute to remove
                    del parent_object_dic['lines'][i]
                    i -= 1
                i += 1
            if operation == 'link':
                # add the type and reference to the child object to link to the parent
                parent_object_dic['lines'].insert(1, f'Type={child_object_type}')
                parent_object_dic['lines'].insert(2, f'{child_object_type}={str(child_object_id).zfill(3)}')
                logs.add(f"{parent_object_uid} : link to {child_object_uid} added")
            else:
                # add an empty "Type=" attribute
                parent_object_dic['lines'].insert(1, 'Type=')
                logs.add(f"{parent_object_uid} : link to {child_object_uid} removed")

            return child_object_uid

        else:
            # management of the other types of objects links
            # add/remove in the parent object the attribute which refers to the child object and update the NumberOf attribute of the parent for the child type

            # if the parent is a Manual and the child a Coupler/Divisional/Stop, rename the ID of the child to be aligned to the parent manual ID
            if operation == 'link' and parent_object_type == 'Manual' and child_object_type in ('Coupler', 'Divisional', 'Stop'):
                manual_id = int(parent_object_uid[-3:])
                if int(child_object_uid[-3]) != manual_id:
                    new_child_object_uid = self.object_type_free_uid_get(child_object_type, parent_object_uid)
                    if self.object_rename(child_object_uid, new_child_object_uid) != None:
                        child_object_uid = new_child_object_uid
                        child_object_id = self.object_id_get(child_object_uid)

            # define the name of the attribute in the parent object which defines the number of child objects type
            if parent_object_type in ('Coupler', 'DivisionalCoupler', 'Stop', 'Switch', 'Tremulant') and child_object_type == 'Switch':
                nb_of_attr_name = 'SwitchCount'
            else:
                if child_object_type == 'Switch':
                    nb_of_attr_name = 'NumberOfSwitches'
                else:
                    nb_of_attr_name = 'NumberOf' + child_object_type + 's'

            # define the name of the attributes in the parent object which refers to the child objects type
            if parent_object_type == 'General':
                object_type_attr_name = child_object_type + 'Number'
                if child_object_type in ('Coupler', 'Stop'):
                    object_type_attr_name2 = child_object_type + 'Manual'
                else:
                    object_type_attr_name2 = None
            else:
                object_type_attr_name = child_object_type
                object_type_attr_name2 = None

            # make the list of the references to the child object type in the parent object and delete the lines having these references
            references_list = []
            nb_of_attr_name_line_nb = None  # line number in the parent where is located the NumberOf attributes
            i = 0
            parent_lines_list = parent_object_dic['lines']
            while i < len(parent_lines_list):
                # scan the lines of the parent object
                if parent_lines_list[i].startswith(child_object_type):
                    # the current line should contain a reference to the child object type
                    (error_msg, attr_name, attr_value, comment) = self.object_line_split(parent_lines_list[i])
                    if attr_name != None and attr_value not in ('', None):
                        # the current line contains a not empty attribute
                        if attr_name[:-3] == object_type_attr_name:
                            # the attribute is referencing a child object
                            if abs(int(attr_value)) != child_object_id:
                                # store the reference of the child object and the comment if the current line doesn't refer to the child object ID
                                references_list.append((attr_value, comment))
                            # delete the referencing line
                            del parent_object_dic['lines'][i]
                            i -= 1
                        elif attr_name[:-3] == object_type_attr_name2:
                            # the attribute is referencing a manual to which contains a child object
                            # delete the referencing line
                            del parent_object_dic['lines'][i]
                            i -= 1

                if parent_lines_list[i].startswith(nb_of_attr_name + '='):
                    # line containing the NumberOf or Count attribute
                    nb_of_attr_name_line_nb = i
                i += 1

            if nb_of_attr_name_line_nb == None:
                # attribute NumberOf or Count not found : add it in the last line of the parent object
                parent_object_dic['lines'].append(nb_of_attr_name + '=0')
                nb_of_attr_name_line_nb = len(parent_object_dic['lines']) - 1

            # add the reference to the child object in the references list without comment
            if operation == 'link':
                references_list.append((str(child_object_id).zfill(3), None))

            # set in the parent object the new references number
            self.object_attr_value_set(parent_object_dic, nb_of_attr_name, len(references_list))

            # insert all the references in the parent object after the NumberOf line
            insert_idx = nb_of_attr_name_line_nb + 1
            for ref_idx in range(len(references_list)):
                line = self.object_line_join(object_type_attr_name + str(ref_idx + 1).zfill(3), references_list[ref_idx][0], references_list[ref_idx][1])
                parent_object_dic['lines'].insert(insert_idx, line)
                insert_idx += 1
                if object_type_attr_name2 != None:
                    # need to add an attribute CouplerManual999 or StopManual999 after the attribute CouplerNumber999 or StopNumber999
                    # recover the referenced Coupler or Manual
                    ref_object_dic = self.object_dic_get(child_object_type + str(references_list[ref_idx][0]).zfill(3))
                    if ref_object_dic != None:
                        # recover the UID of the parent Manual object if any
                        for parent_uid in ref_object_dic['parents']:
                            if parent_uid[:6] == 'Manual':
                                # add a line with the reference to the Manual
                                line = self.object_line_join(object_type_attr_name2 + str(ref_idx + 1).zfill(3), parent_uid[-3:])
                                parent_object_dic['lines'].insert(insert_idx, line)
                                insert_idx += 1

            if operation == 'link':
                logs.add(f"{parent_object_uid} : reference to {child_object_uid} added")
            else:
                logs.add(f"{parent_object_uid} : reference to {child_object_uid} removed")
            logs.add(f"{parent_object_uid} : attribute {nb_of_attr_name} updated")

            return child_object_uid

        return None

    #-------------------------------------------------------------------------------------------------
    def object_parent_panel_get(self, object_uid):
        # returns the UID of the panel (Panel999 or Organ if old panel format) to which belongs the given object UID
        # returns None if it has no parent panel

        if object_uid[:5] == 'Panel':
            if len(object_uid) == 8:
                # Panel999 : it has no parent panel
                parent_panel_uid = None
            else:
                # Panel999NNNNN999
                parent_panel_uid = object_uid[:8]
        else:
            # the object UID is not Panel999 or Panel999Element999, so it is necessarily displayed in the main panel
            if self.new_panel_format_bool:
                parent_panel_uid = 'Panel000'
            else:
                parent_panel_uid = 'Organ'

        return parent_panel_uid

    #-------------------------------------------------------------------------------------------------
    def object_parent_manual_get(self, object_uid):
        # returns the UID of the manual (Manual999) to which belongs the given object UID
        # returns None if it has no parent manuel

        for parent_uid in self.object_kinship_list_get(object_uid, TO_PARENT):
            if parent_uid[:6] == 'Manual':
                return parent_uid

        return None

    #-------------------------------------------------------------------------------------------------
    def object_kinship_list_add(self, object_uid, ref_object_uid, relationship):
        # add in the parents/children list of the given object UID the given referenced object UID
        # the given relationship must be TO_PARENT or TO_CHILD

        object_dic = self.object_dic_get(object_uid)
        if object_dic != None:
            ref_object_dic = self.object_dic_get(ref_object_uid)
            if ref_object_dic != None:
                # both the given object and referenced object are defined
                if relationship == TO_CHILD:
                    # the target object is child of the given object
                    if ref_object_uid not in object_dic['children']: object_dic['children'].append(ref_object_uid)
                    if object_uid     not in ref_object_dic['parents']:  ref_object_dic['parents'].append(object_uid)
                elif relationship == TO_PARENT:
                    # the target object is parent of the given object
                    if ref_object_uid not in object_dic['parents']:  object_dic['parents'].append(ref_object_uid)
                    if object_uid     not in ref_object_dic['children']: ref_object_dic['children'].append(object_uid)
                else:
                    logs.add('INTERNAL ERROR undefined link type given to object_kinship_list_add')
            else:
                logs.add(f'WARNING cannot link {object_uid} to {ref_object_uid} which does not exist')

    #-------------------------------------------------------------------------------------------------
    def object_kinship_list_get(self, object_uid, relationship):
        # get the parents/children list of the given object UID
        # the given relationship must be TO_PARENT or TO_CHILD

        object_dic = self.object_dic_get(object_uid)
        if object_dic != None:
            if relationship == TO_PARENT:
                return object_dic['parents']
            elif relationship == TO_CHILD:
                return object_dic['children']
            else:
                logs.add('INTERNAL ERROR undefined link type given to object_kinship_link_get')
                return []
        else:
            return []

    #-------------------------------------------------------------------------------------------------
    def objects_kinship_update(self):
        # update the kinship links between the objects of the ODF dictionary

        for object_uid, object_dic in self.odf_data_dic.items():
            # scan the objects of the ODF dictionary to reset their internal attributes
            object_dic['names'] = []
            object_dic['parents'] = []
            object_dic['children'] = []

        for object_uid, object_dic in self.odf_data_dic.items():
            # scan the objects of the ODF dictionary to define their parent/child kinship links and their name to display in the objects list/tree
            object_type = self.object_type_get(object_uid)

            for line in object_dic['lines']:
                # scan the lines of the current object to detect links toward other objects or names to display
                (error_msg, attr_name, attr_value, comment) = self.object_line_split(line)
                if attr_name != None and attr_value != None and attr_value != '':
                    # the attribute has a name and a value

                    # get possible names to display in the objects list/tree
                    if attr_name in ['Name', 'ChurchName', 'Comment'] or attr_name[-4:] == 'Text':
                        object_name = attr_value
                    elif object_type == 'PanelImage' and attr_name == 'Image':
                        # image attribute, the value is the path of the image : keep from the image path only the file name (string after the last separator character)
                        object_name = path2ospath(attr_value)
                        path_elements_list = object_name.split(os.sep)
                        object_name = path_elements_list[len(path_elements_list)-1]
                    else:
                        object_name = None
                    # add the found name in the names list of the current object
                    if object_name != None:
                        object_dic['names'].append(object_name)

                    if attr_name[-3:].isdigit() and (attr_value.isdigit() or (len(attr_value) > 0 and attr_value[0] == '-' and attr_value[1:].isdigit())):
                        # attribute which ends with 3 digits (like Coupler999) : it contains in its value the reference to another object
                        # link the current object to the referenced object as child
                        ref_object_type = attr_name[:-3]
                        if object_type == 'General':
                            if ref_object_type[-6:] == 'Number'  : ref_object_type = ref_object_type[:-6]  # remove the string 'Number'
                            elif ref_object_type[-6:] == 'Manual': ref_object_type = None
                        if ref_object_type != None:
                            ref_object_uid = ref_object_type + str(abs(int(attr_value))).zfill(3)
                            self.object_kinship_list_add(object_uid, ref_object_uid, TO_CHILD)

                    elif attr_name == 'WindchestGroup' and attr_value.isdigit():
                        # attribute WindchestGroup : it contains in its value the reference to a WindchestGroup
                        # link the current object to the referenced WindchestGroup as parent
                        ref_object_uid = attr_name + str(int(attr_value)).zfill(3)
                        self.object_kinship_list_add(object_uid, ref_object_uid, TO_PARENT)

                    elif object_type == 'PanelElement' and attr_name in self.go_objects_children_dic['PanelElement']:
                        # Panel999Element999 object with a reference to a child object
                        # link the current object to the child object
                        ref_object_uid = attr_name + str(int(attr_value)).zfill(3)
                        self.object_kinship_list_add(object_uid, ref_object_uid, TO_CHILD)

                    elif object_type == 'Coupler' and attr_name == 'DestinationManual':
                        # link the coupler to the destination manual as child
                        ref_object_uid = 'Manual' + str(int(attr_value)).zfill(3)
                        self.object_kinship_list_add(object_uid, ref_object_uid, TO_CHILD)

            if object_type.startswith('Panel') and len(object_type) > 5:
                # Panel999xxxx object type
                # link the current object to its Panel parent
                panel_uid = object_uid[:8]
                self.object_kinship_list_add(object_uid, panel_uid, TO_PARENT)

                # add to the object names the name of its parent panel
                panel_dic = self.object_dic_get(panel_uid)
                if panel_dic != None:
                    name = self.object_attr_value_get(panel_dic, 'Name')
                    if name not in (None, ''):
                        object_dic['names'].append(name)

                # add to the object names the UID of the referenced child object element if any or the type of the element
                if object_type == 'PanelElement':
                    ref_object_type = self.object_attr_value_get(object_dic, 'Type')
                    ref_object_id = self.object_attr_value_get(object_dic, ref_object_type)
                    if ref_object_id != None:
                        # generate the UID of the referenced object
                        ref_object_uid = ref_object_type + str(int(ref_object_id)).zfill(3)
                        ref_object_dic = self.object_dic_get(ref_object_uid)
                        if ref_object_dic != 'None':
                            # get the name of the referenced object
                            ref_object_name = self.object_attr_value_get(ref_object_dic, 'Name')
                            if ref_object_name != None:
                                # add this name to the PanelElement names list
                                object_dic['names'].insert(0, ref_object_name)
                                object_dic['names'].insert(0, ref_object_uid)
                    else:
                        object_dic['names'].insert(0, ref_object_type)

    #-------------------------------------------------------------------------------------------------
    def object_organ_numbers_update(self, object_uid):
        # update in the Organ object the NumberOf attribute corresponding to the given object

        object_type = self.object_type_get(object_uid)

        if object_type == 'Switch':
            nb_of_attr_name = 'NumberOfSwitches'
        elif object_type in ('Enclosure', 'General', 'Manual', 'Panel', 'Rank', 'Tremulant', 'WindchestGroup'):
            nb_of_attr_name = 'NumberOf' + object_type + 's'
        else:
            nb_of_attr_name = None

        if nb_of_attr_name != None:
            nb = self.objects_type_number_get(object_type)
            if ((object_type == 'Manual' and 'Manual000' in self.odf_data_dic.keys()) or
                (object_type == 'Panel' and 'Panel000' in self.odf_data_dic.keys())):
                # Manual000 and Panel000 are not counted
                    nb -= 1
            if self.object_attr_value_set('Organ', nb_of_attr_name, nb):
                logs.add(f'Organ : attribute {nb_of_attr_name} updated')

    #-------------------------------------------------------------------------------------------------
    def objects_number_get(self):
        # return the total number of objects defined in the ODF data

        return len(self.odf_data_dic)

    #-------------------------------------------------------------------------------------------------
    def objects_type_number_get(self, object_type):
        # return the number of objects defined in the ODF data having the given type (Manual, Enclosure, PanelElement, PanelImage, ...)
        # if the given type is Panel999Element or Panel999Image, returns the number of defined Panel999Element or Panel999Image objects

        # check if Panel999Element or Panel999Image type is given
        nb_in_panel_bool = (object_type[:5] == 'Panel' and object_type[5:8].isdigit and len(object_type) > 8)

        number = 0
        for object_uid in self.odf_data_dic.keys():
            # scan the objects of the ODF data
            if ((nb_in_panel_bool and object_uid.startswith(object_type)) or
                (not nb_in_panel_bool and self.object_type_get(object_uid) == object_type)):
                number += 1

        return number

    #-------------------------------------------------------------------------------------------------
    def objects_list_get(self):
        # return the list of the objects UID of the ODF data

        return list(self.odf_data_dic.keys())

    #-------------------------------------------------------------------------------------------------
    def object_poss_kinship_list_get(self, object_uid):
        # return two lists in a tuple : the one with the objects UID of the ODF data which can be possibly parent of the given object UID
        #                               the one with the objects UID of the ODF data which can be possibly children of the given object UID

        object_dic = self.object_dic_get(object_uid)
        if object_dic == None: return ([], [])

        object_type = self.object_type_get(object_uid)
        parents_list = []
        children_list = []

        if object_type in ('Header', 'Organ'):
            # no parent and no child for these object types
            return (parents_list, children_list)

        # recover the lists of possible parents/children object types for the given object type
        parent_types_list = list(self.go_objects_parents_dic[object_type])
        child_types_list = list(self.go_objects_children_dic[object_type])

        # if the given object is a Stop not refering to a WindchestGroup (it has not a rank defined inside), remove the WindchestGroup parent
        if object_type == 'Stop' and self.object_attr_value_get(object_dic, 'WindchestGroup') == None:
            parent_types_list.remove('WindchestGroup')

        # recover from the ODF data the objects UID which have a type which can be parent/child of the given object
        for obj_uid in self.odf_data_dic.keys():
            # scan the objects of the ODF dictionary
            obj_type = self.object_type_get(obj_uid)
            if obj_type in parent_types_list and obj_uid != object_uid:
                # the current object has a type which can be parent of the given object
                if obj_type == 'PanelElement':
                    if self.object_attr_value_get(obj_uid, 'Type') == object_type:
                        parents_list.append(obj_uid)
                else:
                    parents_list.append(obj_uid)
            if obj_type in child_types_list and obj_uid != object_uid:
                # the current object has a type which can be child of the given object
                children_list.append(obj_uid)

        return (parents_list, children_list)

    #-------------------------------------------------------------------------------------------------
    def object_poss_children_type_list_get(self, object_uid):
        # return the list of the object types which can be possibly children of the given object or which doesn't need a parent (Header and Organ if not already existing)

        object_dic = self.object_dic_get(object_uid)
        object_type = self.object_type_get(object_uid)

        # define the objects types which can be created as child of the given object type
        if   object_type == 'Organ':   child_types_list = ['General', 'Manual', 'Panel', 'WindchestGroup']
        elif object_type == 'Coupler': child_types_list = ['Switch']
        elif object_type == 'General': child_types_list = ['Switch']
        elif object_type == 'Manual':  child_types_list = ['Coupler', 'Divisional', 'Stop', 'Switch', 'Tremulant']
        elif object_type == 'Panel':   child_types_list = ['PanelElement', 'PanelImage']
        elif object_type == 'PanelElement': child_types_list = ['Coupler', 'Divisional', 'DivisionalCoupler', 'Enclosure', 'General', 'Manual', 'Stop', 'Tremulant']
        elif object_type == 'Stop':    child_types_list =   ['Rank', 'Switch']
        elif object_type == 'Switch':  child_types_list = ['Switch']
        elif object_type == 'Tremulant':      child_types_list = ['Switch']
        elif object_type == 'WindchestGroup': child_types_list = ['Enclosure', 'Stop', 'Rank', 'Tremulant']
        else: child_types_list = []

        # if the given object is a Stop refering to a WindchestGroup (it has a rank defined inside), remove the Rank child
        if object_type == 'Stop' and self.object_attr_value_get(object_dic, 'WindchestGroup') != None:
            child_types_list.remove('Rank')

        # if the given object is a PanelElement with a type defined and it is the type of an object, let only this type in the child types list
        if object_type == 'PanelElement':
            element_type = self.object_attr_value_get(object_dic, 'Type')
            if element_type != None:
                if element_type in child_types_list:
                    # the element type is one of the possible children of a PanelElement
                    child_types_list.clear()
                    child_types_list.append(element_type)
                else:
                    child_types_list.clear()

        return child_types_list

#-------------------------------------------------------------------------------------------------
class C_ODF_HW2GO():
    # class to manage the conversion of a Hauptwerk ODF in a GrandOrgue ODF

    HW_sample_set_path = ''     # path of the folder containing the loaded Hauptwerk sample set (which contains the sub-folders OrganDefinitions and OrganInstallationPackages)
    HW_sample_set_odf_path = '' # path of the folder containing the ODF of the loaded Hauptwerk sample set (folder OrganDefinitions)
    HW_odf_file_name = ''   # path of the loaded Hauptwerk ODF (which is inside the sub-folder OrganDefinitions)

    silent_loop_file_used = False  # flag to indicate that the file SilentLoop.wav is used by a built GO Stop

    HW_odf_dic = {}  # dictionary in which are stored the data of the loaded Hauptwerk ODF file (XML file)
                     # it has the following structure with three nested dictionaries :
                     #   {ObjectType:                      -> string, for example _General, KeyImageSet, DisplayPage
                     #       {ObjectID:                    -> integer, from 1 to 999999, recovered from the HW ODF objects ID when possible, else set by increment
                     #           {Attribute: Value, ...},  -> string: string
                     #        ...
                     #       },
                     #       ...
                     #    ...
                     #   }
                     # the ObjectUID (unique ID) is a string made by the concatenation of the ObjectType and the ObjectID on 6 digits, for example DisplayPage000006
                     # exception : the ObjectType _General has the ObjectUID _General

    GO_odf_dic = {}  # dictionary in which are stored the data of the GrandOrgue ODF built from the Hauptwerk ODF dictionary
                     # it has the following structure with two nested dictionaries :
                     #   {ObjectUID:                   -> string, for example Organ, Panel001, Rank003
                     #       {Attribute: Value, ...}   -> string: string or integer if number / dimension / code
                     #    ...
                     #   }

    HW_odf_attr_dic = {} # dictionary which contains the definition of the various HW object types and their attributes (loaded from the file HwObjectsAttributesDict.txt)
                         # it has the following structure with two nested dictionaries :
                         #   {ObjectType:                                  -> string, for example _General, KeyImageSet, DisplayPage
                         #       {AttributeLetter: AttributeFullName, ...} -> string: string
                         #    ...
                         #   }

    HW_looping_switches_lists = []  # list containing sub-lists with the ensemble of HW switch which are controlling each other in loop

    available_HW_packages_id_list = []  # list storing the ID of the installation packages which are actually accessible in the sample set package

    HW_default_display_page_dic = None # dictionary of the HW default display page (which is displayed by default on organ loading and will be the GO Panel000)
    HW_console_display_page_dic = None # dictionary of the HW console display page (which contains the displayed keyboards, can be different from the default display page)

    HW_general_dic = None  # dictionary of the HW _General object
    HW_organ_pitch = None  # base pitch of the organ, if defined in the _General object (i.e. the frequency of the A4 note)

    convert_alt_ranks_bool = False  # flag indicating if the alternate ranks have to be converted from HW to GO (for wave based tremulants)

    progress_status_show_function = None # address of a callback function to call to show a progression message during the ODF building

    #-------------------------------------------------------------------------------------------------
    def reset_all_data(self):
        # reset all the data of the class, except the HW_odf_attr_dic dictionary

        self.HW_odf_dic.clear()
        self.HW_looping_switches_lists.clear()
        self.GO_odf_dic.clear()
        self.available_HW_packages_id_list = []
        self.HW_odf_file_name = ''
        self.HW_sample_set_path = ''
        self.HW_organ_pitch = None
        self.silent_loop_file_used = False

    #-------------------------------------------------------------------------------------------------
    def HW_ODF_load_from_file(self, file_name):
        # fill the Hauptwerk ODF dictionary from the data of the given Hauptwerk ODF XML file
        # return True or False whether the operation has succeeded or not

        """
        the considered Hauptwerk ODF XML syntax is :

        <Hauptwerk FileFormat="Organ" FileFormatVersion="xxxxxx">
            <ObjectList ObjectType="ObjectTypeName">
                <"ObjectTypeName">
                    <"Attribute1">Value</"Attribute1">
                    <"Attribute2">Value</"Attribute2">
                    ...
                </"ObjectTypeName">
                ...
                <o>                    -> compressed format
                    <a>Value</a>
                    <b>Value</b>
                    ...
                </o>
                ...
            </ObjectList>
               ...
        </Hauptwerk>

        the attributes letters are converted to attributes full name thanks to the dictionary HW_odf_attr_dic
        """

        file_name = path2ospath(file_name)

        # check the extension of the given file name
        filename_str, file_extension_str = os.path.splitext(file_name)
        if file_extension_str != '.Organ_Hauptwerk_xml' and file_extension_str != '.xml':
            logs.add(f'ERROR : The file "{file_name}" does not have the expected extension .xml or .Organ_Hauptwerk_xml')
            return False

        # check the existence of the given file name
        if not(os.path.isfile(file_name)):
            logs.add(f'ERROR : The file "{file_name}" does not exist')
            return False

        # load the dictionary HwObjectsAttributesDict if not already loaded
        if not self.HW_ODF_attr_dic_file_load():
            # error occurred while loading the dictionary
            return False

        # load the content of the HW XML file as an elements tree
        HW_ODF_xml_tree = etree.parse(file_name, etree.XMLParser(remove_comments=True))

        # check that it is actually an Hauptwerk ODF and recover the file format version
        HW_xml_id_tag_str = HW_ODF_xml_tree.xpath("/Hauptwerk")
        HW_file_format_str = HW_xml_id_tag_str[0].get("FileFormat")
        HW_file_format_version_str = HW_xml_id_tag_str[0].get("FileFormatVersion")
        if HW_file_format_str != 'Organ':
            # it is not an ODF
            logs.add(f'ERROR : The file "{file_name}" is not a supported Hauptwerk organ definition file')
            return False

        object_type_nb_int = 0  # total number of object types found
        object_elem_nb_int = 0  # total number of object elements found
        object_attr_nb_int = 0  # total number of object attributes found
        for xml_object_type in HW_ODF_xml_tree.xpath("/Hauptwerk/ObjectList"):
            # scan the object types defined in the XML file (in the tags <ObjectList ObjectType="xxxx">)
            object_type_nb_int += 1

            # recover the name of the current object type
            HW_object_type = xml_object_type.get("ObjectType")

            if HW_object_type not in self.HW_odf_attr_dic.keys():
                # the recovered HW object type is not known in the HW ODF types/attributes dictionary
                # it can be due to a problem of characters case in the XML, tries to recover the correct object name characters case from the dictionary
                for HW_obj_type in self.HW_odf_attr_dic.keys():
                    if HW_object_type.upper() == HW_obj_type.upper():
                        HW_object_type = HW_obj_type
                        break

            self.progress_status_show_function(f'Loading the Hauptwerk ODF... {HW_object_type}')

            # create an entry in the HW dictionary for the current object type
            object_type_dic = self.HW_odf_dic[HW_object_type] = {}

            if HW_object_type in self.HW_odf_attr_dic.keys():
                # the current object type is defined in the HW attributes dictionary
                # get the dictionary defining the attributes of the current object type
                object_type_attr_dic = self.HW_odf_attr_dic[HW_object_type]
                # recover the name of the attribute of the object elements of the current object type which define the ID of each element, if it exists
                object_id_attr_name_str = object_type_attr_dic['IDattr']

                object_id_counter_int = 0  # ID which can be assigned to the current object element inside the current object type if it has not an ID defined in the attributes
                for xml_object_element in xml_object_type:
                    # scan the object elements defined in the current object type
                    object_elem_nb_int += 1
                    object_id_counter_int += 1
                    object_id_int = 0

                    # create a new object element dictionary
                    object_dic = {}

                    # add at the beginning of the current object element dictionary some custom attributes used for the GO ODF building
                    object_dic['_HW_uid'] = ''  # Unique ID of the HW object
                    object_dic['_GO_uid'] = ''  # Unique ID of the corresponding built GO object
                    object_dic['_parents'] = []   # list of the parent HW objects dictionaries
                    object_dic['_children'] = []  # list of the children HW objects dictionaries

                    for xml_object_attribute in xml_object_element:
                        # scan the attributes defined in the current object element
                        object_attr_nb_int += 1
                        attribute_name_str = xml_object_attribute.tag
                        attribute_value_str = xml_object_attribute.text

                        if attribute_value_str != '' and attribute_value_str != None:
                            # the attributes with an empty or undefined value are ignored
                            if len(attribute_name_str) <= 2:
                                # the attribute name is defined by a tag of one or two characters (this is the Hauptwerk XML compressed format)
                                # recover the attribute long name corresponding to this tag
                                try:
                                    attribute_name_str = object_type_attr_dic[attribute_name_str]
                                except:
                                    # no attribute long name known
                                    attribute_name_str = attribute_name_str + '???'

                            # add the current attribute name and value to the current object
                            object_dic[attribute_name_str] = attribute_value_str

                            if object_id_int == 0 and object_id_attr_name_str != '' and attribute_name_str == object_id_attr_name_str:
                                # the current attribute is the attribute which contains the ID of the object in the current object type
                                if not attribute_value_str.isnumeric():
                                    logs.add(f'ERROR : attribute {attribute_name_str}={attribute_value_str} has not a numeric value in the object {HW_object_type} #{object_id_counter_int}')
                                else:
                                    object_id_int = int(attribute_value_str)

                    if object_id_int == 0:
                        # no object ID recovered from the attributes
                        if object_id_attr_name_str != '':
                            # the object should have had an ID attribute
                            logs.add(f'ERROR : attribute {object_id_attr_name_str} not found in the object {HW_object_type} #{object_id_counter_int}')
                        # use as object ID the objects counter
                        object_id_int = object_id_counter_int

                    # store in the object its UID (unique ID)
                    if HW_object_type == '_General':
                        object_dic['_HW_uid'] = '_General'
                    else:
                        object_dic['_HW_uid'] = HW_object_type + str(object_id_int).zfill(6)

                    if object_id_int in object_type_dic.keys():
                        logs.add(f'WARNING: HW object {object_dic["_HW_uid"]} has an ID which is not unique !')

                    # add the object dictionary to the current object type dictionary
                    object_type_dic[object_id_int] = object_dic

            else:
                logs.add(f'INTERNAL ERROR : object type {HW_object_type} unknown in the HW attributes dictionary')

        logs.add(f'Hauptwerk ODF loaded "{file_name}"')
        logs.add(f'Hauptwerk organ file format version {HW_file_format_version_str}')
        logs.add(f'{object_attr_nb_int:,} attributes among {object_elem_nb_int:,} objects among {object_type_nb_int} object types')

        self.HW_odf_file_name = path2ospath(file_name)
        self.HW_sample_set_path = path2ospath(os.path.dirname(os.path.dirname(file_name)))
        self.HW_sample_set_odf_path = self.HW_sample_set_path + os.sep + 'OrganDefinitions'

        return True

    #-------------------------------------------------------------------------------------------------
    def HW_ODF_attr_dic_file_load(self):
        # load the Hauptwerk attributes dictionary from the file HwObjectsAttributesDict.txt (if it is present and there is no error)
        # return True or False whether the operation has succeeded or not

        if len(self.HW_odf_attr_dic) == 0:
            # the dictionary has not been loaded yet

            file_name = os.path.dirname(__file__) + os.sep + 'resources' + os.sep + 'HwObjectsAttributesDict.txt'

            try:
                with open(file_name, 'r') as f:
                    self.HW_odf_attr_dic = eval(f.read())
                    return True
            except OSError as err:
                # it has not be possible to open the file
                logs.add(f'ERROR Cannot open the file "{file_name}" : {err}')
            except SyntaxError as err:
                # syntax error in the dictionary structure which is in the file
                logs.add(f'ERROR Syntax error in the file "{file_name}" : {err}')
            except:
                # other error
                logs.add(f'ERROR while opening the file "{file_name}"')

            return False

        else:
            return True

    #-------------------------------------------------------------------------------------------------
    def HW_ODF_do_links_between_objects(self):
        # set in the Hauptwerk ODF dictionary the relationships (parent, children) between the various objects
        # add in the objects of the HW_odf_dic the attributes "_parents" and "_children" with as value the list of the respective parent or child objects

        HW_general_object_dic = None
        HW_object_type = '_General'
        self.progress_status_show_function(f'Building the Hauptwerk ODF objects tree... {HW_object_type}')
        if HW_object_type in self.HW_odf_dic.keys():
            for HW_object_dic in self.HW_odf_dic[HW_object_type].values():
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'OrganInfo_InstallationPackageID', 'RequiredInstallationPackage', TO_CHILD)
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'SpecialObjects_DefaultDisplayPageID', 'DisplayPage', TO_CHILD)
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'SpecialObjects_MasterCaptureSwitchID', 'Switch', TO_CHILD)
                HW_general_object_dic = HW_object_dic
        if HW_general_object_dic == None:
            logs.add('ERROR : no _General object defined in the Hauptwerk ODF')
            return False

        HW_object_type = 'DivisionInput'
        self.progress_status_show_function(f'Building the Hauptwerk ODF objects tree... {HW_object_type}')
        if HW_object_type in self.HW_odf_dic.keys():
            for HW_object_dic in self.HW_odf_dic[HW_object_type].values():
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'DivisionID', 'Division', TO_PARENT)
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'SwitchID', 'Switch', TO_PARENT)

        HW_object_type = 'Keyboard'
        self.progress_status_show_function(f'Building the Hauptwerk ODF objects tree... {HW_object_type}')
        if HW_object_type in self.HW_odf_dic.keys():
            for HW_object_dic in self.HW_odf_dic[HW_object_type].values():
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'KeyGen_DisplayPageID', 'DisplayPage', TO_PARENT)
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'KeyGen_KeyImageSetID', 'KeyImageSet',  TO_CHILD)
                # link the keyboard to its division
                HW_division_dic = self.HW_ODF_get_object_by_ref_id('Division', HW_object_dic, 'Hint_PrimaryAssociatedDivisionID')
                if HW_division_dic == None:
                    # find the division ID from the keyboard code, supposing to the following matching :
                    #     keyboard code 1 = division 1 = Pedal
                    #     keyboard code 2 = division 2 = Manual 1
                    #     keyboard code 3 = division 3 = Manual 2
                    #     ...
                    HW_division_dic = self.HW_ODF_get_object_by_ref_id('Division', HW_object_dic, 'DefaultInputOutputKeyboardAsgnCode')
                if HW_division_dic != None:
                    self.HW_ODF_do_link_between_obj(HW_object_dic, HW_division_dic, TO_PARENT)

        HW_object_type = 'KeyAction'
        self.progress_status_show_function(f'Building the Hauptwerk ODF objects tree... {HW_object_type}')
        if HW_object_type in self.HW_odf_dic.keys():
            for HW_object_dic in self.HW_odf_dic[HW_object_type].values():
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'SourceKeyboardID', 'Keyboard', TO_PARENT)
                HW_cond_switch_dic = self.HW_ODF_get_attribute_value(HW_object_dic, 'ConditionSwitchID')
                if self.HW_ODF_get_attribute_value(HW_object_dic, 'DestDivisionID') != None:
                    # the key action destination is a division
                    self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'DestDivisionID', 'Division', TO_CHILD)
                    # link directly the source keyboard to the destination division if there is no conditional switch
                    # this link may have been done already while processing the Keyboard objects above
                    if HW_cond_switch_dic == None:
                        HW_source_keyboard_dic = self.HW_ODF_get_object_by_ref_id('Keyboard', HW_object_dic, 'SourceKeyboardID')
                        HW_dest_division_dic = self.HW_ODF_get_object_by_ref_id('Division', HW_object_dic, 'DestDivisionID')
                        self.HW_ODF_do_link_between_obj(HW_source_keyboard_dic, HW_dest_division_dic, TO_PARENT)
                else:
                    # the key action destination is a keyboard
                    self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'DestKeyboardID', 'Keyboard', TO_CHILD)
                    # link directly the source keyboard to the destination keyboard
                    # this link may have been done already while processing the Keyboard objects above
                    if HW_cond_switch_dic == None:
                        HW_source_keyboard_dic = self.HW_ODF_get_object_by_ref_id('Keyboard', HW_object_dic, 'SourceKeyboardID')
                        HW_dest_keyboard_dic = self.HW_ODF_get_object_by_ref_id('Keyboard', HW_object_dic, 'DestKeyboardID')
                        self.HW_ODF_do_link_between_obj(HW_source_keyboard_dic, HW_dest_keyboard_dic, TO_CHILD)
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'ConditionSwitchID', 'Switch', TO_PARENT)

        HW_object_type = 'KeyboardKey'
        self.progress_status_show_function(f'Building the Hauptwerk ODF objects tree... {HW_object_type}')
        if HW_object_type in self.HW_odf_dic.keys():
            for HW_object_dic in self.HW_odf_dic[HW_object_type].values():
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'KeyboardID', 'Keyboard', TO_PARENT)
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'SwitchID', 'Switch', TO_PARENT)

        HW_object_type = 'KeyImageSet'
        self.progress_status_show_function(f'Building the Hauptwerk ODF objects tree... {HW_object_type}')
        if HW_object_type in self.HW_odf_dic.keys():
            for HW_object_dic in self.HW_odf_dic[HW_object_type].values():
                for obj_attr_name in list(HW_object_dic.keys()):
                    if obj_attr_name.startswith('KeyShapeImageSetID'):
                        self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, obj_attr_name, 'ImageSet', TO_CHILD)

        HW_object_type = 'ImageSetElement'
        self.progress_status_show_function(f'Building the Hauptwerk ODF objects tree... {HW_object_type}')
        if HW_object_type in self.HW_odf_dic.keys():
            for HW_object_dic in self.HW_odf_dic[HW_object_type].values():
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'ImageSetID', 'ImageSet', TO_PARENT)

        HW_object_type = 'TextInstance'
        self.progress_status_show_function(f'Building the Hauptwerk ODF objects tree... {HW_object_type}')
        if HW_object_type in self.HW_odf_dic.keys():
            for HW_object_dic in self.HW_odf_dic[HW_object_type].values():
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'DisplayPageID', 'DisplayPage', TO_PARENT)
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'TextStyleID', 'TextStyle', TO_CHILD)
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'AttachedToImageSetInstanceID', 'ImageSetInstance', TO_CHILD)

        HW_object_type = 'Switch'
        self.progress_status_show_function(f'Building the Hauptwerk ODF objects tree... {HW_object_type}')
        if HW_object_type in self.HW_odf_dic.keys():
            for HW_object_dic in self.HW_odf_dic[HW_object_type].values():
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'Disp_ImageSetInstanceID', 'ImageSetInstance', TO_CHILD)
                # if the Switch is linked to an ImageSetInstance object, link it to the DisplayPage in which it is displayed
                HW_image_set_inst_dic = self.HW_ODF_get_object_by_ref_id('ImageSetInstance', HW_object_dic, 'Disp_ImageSetInstanceID')
                if HW_image_set_inst_dic != None:
                    HW_display_page_dic = self.HW_ODF_get_object_by_ref_id('DisplayPage', HW_image_set_inst_dic, 'DisplayPageID')
                    self.HW_ODF_do_link_between_obj(HW_object_dic, HW_display_page_dic, TO_PARENT)

        HW_object_type = 'SwitchLinkage'
        self.progress_status_show_function(f'Building the Hauptwerk ODF objects tree... {HW_object_type}')
        if HW_object_type in self.HW_odf_dic.keys():
            for HW_object_dic in self.HW_odf_dic[HW_object_type].values():
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'SourceSwitchID', 'Switch', TO_PARENT)
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'DestSwitchID', 'Switch', TO_CHILD)
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'ConditionSwitchID', 'Switch', TO_PARENT)
                if DEV_MODE:
                    # only in development mode to speed up the links creation in application mode, this parent/child association is not used to convert the HW to GO ODF
                    # make direct link between source and destination switches
                    HW_source_switch_dic = self.HW_ODF_get_object_by_ref_id('Switch', HW_object_dic, 'SourceSwitchID')
                    HW_dest_switch_dic = self.HW_ODF_get_object_by_ref_id('Switch', HW_object_dic, 'DestSwitchID')
                    HW_cond_switch_dic = self.HW_ODF_get_object_by_ref_id('Switch', HW_object_dic, 'ConditionSwitchID')
                    if HW_source_switch_dic != None and HW_dest_switch_dic != None :
                        self.HW_ODF_do_link_between_obj(HW_source_switch_dic, HW_dest_switch_dic, TO_CHILD)
                        if HW_cond_switch_dic != None:
                            self.HW_ODF_do_link_between_obj(HW_cond_switch_dic, HW_dest_switch_dic, TO_CHILD)

        HW_object_type = 'SwitchExclusiveSelectGroupElement'
        self.progress_status_show_function(f'Building the Hauptwerk ODF objects tree... {HW_object_type}')
        if HW_object_type in self.HW_odf_dic.keys():
            for HW_object_dic in self.HW_odf_dic[HW_object_type].values():
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'SwitchID', 'Switch', TO_CHILD)
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'GroupID', 'SwitchExclusiveSelectGroup', TO_PARENT)

        HW_object_type = 'WindCompartment'
        self.progress_status_show_function(f'Building the Hauptwerk ODF objects tree... {HW_object_type}')
        if HW_object_type in self.HW_odf_dic.keys():
            for HW_object_dic in self.HW_odf_dic[HW_object_type].values():
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'PressureOutputContinuousControlID', 'ContinuousControl', TO_PARENT)

        HW_object_type = 'WindCompartmentLinkage'
        self.progress_status_show_function(f'Building the Hauptwerk ODF objects tree... {HW_object_type}')
        if HW_object_type in self.HW_odf_dic.keys():
            for HW_object_dic in self.HW_odf_dic[HW_object_type].values():
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'FirstWindCompartmentID', 'WindCompartment', TO_PARENT)
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'SecondWindCompartmentID', 'WindCompartment', TO_CHILD)
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'ValveControllingContinuousControlID', 'ContinuousControl', TO_PARENT)
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'ValveControllingSwitchID', 'Switch', TO_PARENT)
                if DEV_MODE:
                    # make direct link between source and destination wind compartments
                    HW_first_wind_comp_dic = self.HW_ODF_get_object_by_ref_id('WindCompartment', HW_object_dic, 'FirstWindCompartmentID')
                    HW_second_wind_comp_dic = self.HW_ODF_get_object_by_ref_id('WindCompartment', HW_object_dic, 'SecondWindCompartmentID')
                    if HW_first_wind_comp_dic != None and HW_second_wind_comp_dic != None :
                        self.HW_ODF_do_link_between_obj(HW_first_wind_comp_dic, HW_second_wind_comp_dic, TO_CHILD)

        HW_object_type = 'Stop'
        self.progress_status_show_function(f'Building the Hauptwerk ODF objects tree... {HW_object_type}')
        if HW_object_type in self.HW_odf_dic.keys():
            for HW_object_dic in self.HW_odf_dic[HW_object_type].values():
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'DivisionID', 'Division', TO_PARENT)
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'ControllingSwitchID', 'Switch', TO_PARENT)
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'Hint_PrimaryAssociatedRankID', 'Rank', TO_CHILD)

        HW_object_type = 'StopRank'
        self.progress_status_show_function(f'Building the Hauptwerk ODF objects tree... {HW_object_type}')
        if HW_object_type in self.HW_odf_dic.keys():
            for HW_object_dic in self.HW_odf_dic[HW_object_type].values():
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'StopID', 'Stop', TO_PARENT)
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'RankID', 'Rank', TO_CHILD)
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'SwitchIDToSwitchToAlternateRank', 'Switch', TO_PARENT)
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'AlternateRankID', 'Rank', TO_CHILD)

        HW_object_type = 'Combination'
        self.progress_status_show_function(f'Building the Hauptwerk ODF objects tree... {HW_object_type}')
        if HW_object_type in self.HW_odf_dic.keys():
            for HW_object_dic in self.HW_odf_dic[HW_object_type].values():
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'ActivatingSwitchID', 'Switch', TO_PARENT)

        HW_object_type = 'CombinationElement'
        self.progress_status_show_function(f'Building the Hauptwerk ODF objects tree... {HW_object_type}')
        if HW_object_type in self.HW_odf_dic.keys():
            for HW_object_dic in self.HW_odf_dic[HW_object_type].values():
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'CombinationID', 'Combination', TO_PARENT)
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'ControlledSwitchID', 'Switch', TO_CHILD)
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'CapturedSwitchID', 'Switch', TO_CHILD)
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'MemorySwitchID', 'Switch', TO_CHILD)

        HW_object_type = 'Pipe_SoundEngine01'
        self.progress_status_show_function(f'Building the Hauptwerk ODF objects tree... {HW_object_type}')
        if HW_object_type in self.HW_odf_dic.keys():
            for HW_object_dic in self.HW_odf_dic[HW_object_type].values():
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'RankID', 'Rank', TO_PARENT)
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'ControllingPalletSwitchID', 'Switch', TO_PARENT)
                if DEV_MODE:
                    # only in development mode to speed up the links creation in application mode, this parent/child association is not used to convert the HW to GO ODF
                    self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'WindSupply_SourceWindCompartmentID', 'WindCompartment', TO_PARENT)
                    self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'WindSupply_OutputWindCompartmentID', 'WindCompartment', TO_CHILD)

        HW_object_type = 'Pipe_SoundEngine01_Layer'
        self.progress_status_show_function(f'Building the Hauptwerk ODF objects tree... {HW_object_type}')
        if HW_object_type in self.HW_odf_dic.keys():
            for HW_object_dic in self.HW_odf_dic[HW_object_type].values():
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'PipeID', 'Pipe_SoundEngine01', TO_PARENT)
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'AmpLvl_ScalingContinuousControlID', 'ContinuousControl', TO_PARENT)

        HW_object_type = 'Pipe_SoundEngine01_AttackSample'
        self.progress_status_show_function(f'Building the Hauptwerk ODF objects tree... {HW_object_type}')
        if HW_object_type in self.HW_odf_dic.keys():
            for HW_object_dic in self.HW_odf_dic[HW_object_type].values():
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'LayerID', 'Pipe_SoundEngine01_Layer', TO_PARENT)
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'SampleID', 'Sample', TO_CHILD)

        HW_object_type = 'Pipe_SoundEngine01_ReleaseSample'
        self.progress_status_show_function(f'Building the Hauptwerk ODF objects tree... {HW_object_type}')
        if HW_object_type in self.HW_odf_dic.keys():
            for HW_object_dic in self.HW_odf_dic[HW_object_type].values():
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'LayerID', 'Pipe_SoundEngine01_Layer', TO_PARENT)
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'SampleID', 'Sample', TO_CHILD)

        HW_object_type = 'ContinuousControlStageSwitch'
        self.progress_status_show_function(f'Building the Hauptwerk ODF objects tree... {HW_object_type}')
        if HW_object_type in self.HW_odf_dic.keys():
            for HW_object_dic in self.HW_odf_dic[HW_object_type].values():
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'ContinuousControlID', 'ContinuousControl', TO_PARENT)
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'ControlledSwitchID', 'Switch', TO_CHILD)

        HW_object_type = 'ContinuousControlLinkage'
        self.progress_status_show_function(f'Building the Hauptwerk ODF objects tree... {HW_object_type}')
        if HW_object_type in self.HW_odf_dic.keys():
            for HW_object_dic in self.HW_odf_dic[HW_object_type].values():
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'SourceControlID', 'ContinuousControl', TO_PARENT)
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'DestControlID', 'ContinuousControl', TO_CHILD)
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'ConditionSwitchID', 'Switch', TO_PARENT)

        HW_object_type = 'ContinuousControl'
        self.progress_status_show_function(f'Building the Hauptwerk ODF objects tree... {HW_object_type}')
        if HW_object_type in self.HW_odf_dic.keys():
            for HW_object_dic in self.HW_odf_dic[HW_object_type].values():
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'ImageSetInstanceID', 'ImageSetInstance', TO_CHILD)
                # if the ContinuousControl is linked to an ImageSetInstance object, link it to the DisplayPage in which it is displayed
                HW_image_set_inst_dic = self.HW_ODF_get_object_by_ref_id('ImageSetInstance', HW_object_dic, 'ImageSetInstanceID')
                if HW_image_set_inst_dic != None:
                    HW_display_page_dic = self.HW_ODF_get_object_by_ref_id('DisplayPage', HW_image_set_inst_dic, 'DisplayPageID')
                    self.HW_ODF_do_link_between_obj(HW_object_dic, HW_display_page_dic, TO_PARENT)

        HW_object_type = 'ContinuousControlImageSetStage'
        self.progress_status_show_function(f'Building the Hauptwerk ODF objects tree... {HW_object_type}')
        if HW_object_type in self.HW_odf_dic.keys():
            for HW_object_dic in self.HW_odf_dic[HW_object_type].values():
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'ImageSetID', 'ImageSet', TO_PARENT)

        HW_object_type = 'ContinuousControlDoubleLinkage'
        self.progress_status_show_function(f'Building the Hauptwerk ODF objects tree... {HW_object_type}')
        if HW_object_type in self.HW_odf_dic.keys():
            for HW_object_dic in self.HW_odf_dic[HW_object_type].values():
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'FirstSourceControl_UID', 'ContinuousControl', TO_PARENT)
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'SecondSourceControl_UID', 'ContinuousControl', TO_PARENT)
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'DestControl_UID', 'ContinuousControl', TO_CHILD)

        HW_object_type = 'Enclosure'
        self.progress_status_show_function(f'Building the Hauptwerk ODF objects tree... {HW_object_type}')
        if HW_object_type in self.HW_odf_dic.keys():
            for HW_object_dic in self.HW_odf_dic[HW_object_type].values():
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'ShutterPositionContinuousControlID', 'ContinuousControl', TO_PARENT)

        HW_object_type = 'EnclosurePipe'
        self.progress_status_show_function(f'Building the Hauptwerk ODF objects tree... {HW_object_type}')
        if HW_object_type in self.HW_odf_dic.keys():
            for HW_object_dic in self.HW_odf_dic[HW_object_type].values():
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'EnclosureID', 'Enclosure', TO_PARENT)
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'PipeID', 'Pipe_SoundEngine01', TO_CHILD)

        HW_object_type = 'TremulantWaveformPipe'
        if HW_object_type in self.HW_odf_dic.keys():
            for HW_object_dic in self.HW_odf_dic[HW_object_type].values():
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'PipeID', 'Pipe_SoundEngine01', TO_CHILD)
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'TremulantWaveformID', 'TremulantWaveform', TO_PARENT)

        HW_object_type = 'Tremulant'
        self.progress_status_show_function(f'Building the Hauptwerk ODF objects tree... {HW_object_type}')
        if HW_object_type in self.HW_odf_dic.keys():
            for HW_object_dic in self.HW_odf_dic[HW_object_type].values():
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'ControllingSwitchID', 'Switch', TO_PARENT)

        HW_object_type = 'TremulantWaveform'
        self.progress_status_show_function(f'Building the Hauptwerk ODF objects tree... {HW_object_type}')
        if HW_object_type in self.HW_odf_dic.keys():
            for HW_object_dic in self.HW_odf_dic[HW_object_type].values():
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'TremulantID', 'Tremulant', TO_PARENT)
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'PitchAndFundamentalWaveformSampleID', 'Sample', TO_CHILD)

        HW_object_type = 'ImageSetInstance'
        self.progress_status_show_function(f'Building the Hauptwerk ODF objects tree... {HW_object_type}')
        if HW_object_type in self.HW_odf_dic.keys():
            for HW_object_dic in self.HW_odf_dic[HW_object_type].values():
                if len(HW_object_dic['_parents']) == 0:
                    # this ImageSetInstance object has none parent, link it with its DisplayPage
                    self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'DisplayPageID', 'DisplayPage', TO_PARENT)
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'ImageSetID', 'ImageSet', TO_CHILD)

        # link to _General all the Division objects
        HW_object_type = 'Division'
        self.progress_status_show_function(f'Building the Hauptwerk ODF objects tree... {HW_object_type}')
        if HW_object_type in self.HW_odf_dic.keys():
            for HW_object_dic in self.HW_odf_dic[HW_object_type].values():
                self.HW_ODF_do_link_between_obj(HW_object_dic, HW_general_object_dic, TO_PARENT)

        # link to _General all the DisplayPage objects
        HW_object_type = 'DisplayPage'
        self.progress_status_show_function(f'Building the Hauptwerk ODF objects tree... {HW_object_type}')
        if HW_object_type in self.HW_odf_dic.keys():
            for HW_object_dic in self.HW_odf_dic[HW_object_type].values():
                self.HW_ODF_do_link_between_obj(HW_object_dic, HW_general_object_dic, TO_PARENT)

        # link to _General all the Tremulant objects (to find them more easily in the objects tree)
        HW_object_type = 'Tremulant'
        if HW_object_type in self.HW_odf_dic.keys():
            for HW_object_dic in self.HW_odf_dic[HW_object_type].values():
                self.HW_ODF_do_link_between_obj(HW_object_dic, HW_general_object_dic, TO_PARENT)

        # link to _General all the WindCompartment objects which have no parent
        HW_object_type = 'WindCompartment'
        self.progress_status_show_function(f'Building the Hauptwerk ODF objects tree... {HW_object_type}')
        if HW_object_type in self.HW_odf_dic.keys():
            for HW_object_dic in self.HW_odf_dic[HW_object_type].values():
                if len(HW_object_dic['_parents']) == 0:
                    self.HW_ODF_do_link_between_obj(HW_object_dic, HW_general_object_dic, TO_PARENT)

        return True

    #-------------------------------------------------------------------------------------------------
    def HW_ODF_do_link_between_obj_by_id(self, HW_object_dic, HW_attr_id_name_str, linked_object_type_str, link_type_int):
        # do a link between the given HW object dict and the given linked HW object type dict based on an ID
        # the given link_type_int must be TO_PARENT or TO_CHILD

        # recover the value of the ID permitting to establish a linkage between the two objects
        linkage_id_value_int = myint(self.HW_ODF_get_attribute_value(HW_object_dic, HW_attr_id_name_str), 0)

        if linkage_id_value_int != 0:
            try:
                linked_object_dic = self.HW_odf_dic[linked_object_type_str][linkage_id_value_int]
            except:
                logs.add(f'INTERNAL ERROR : {HW_object_dic["_HW_uid"]} - not found reference to object type {linked_object_type_str} with ID {linkage_id_value_int}')
                return False
            else:
                return self.HW_ODF_do_link_between_obj(HW_object_dic, linked_object_dic, link_type_int)
        else:
            return False

    #-------------------------------------------------------------------------------------------------
    def HW_ODF_do_link_between_obj(self, HW_object_dic, linked_HW_object_dic, link_type_int):
        # do a link between the given HW object dict and the given linked HW object dict
        # the given link_type_int must be TO_PARENT or TO_CHILD

        if link_type_int == TO_CHILD:
            self.HW_ODF_add_attribute_value(HW_object_dic, '_children', linked_HW_object_dic)
            self.HW_ODF_add_attribute_value(linked_HW_object_dic, '_parents', HW_object_dic)
        elif link_type_int == TO_PARENT:
            self.HW_ODF_add_attribute_value(HW_object_dic, '_parents', linked_HW_object_dic)
            self.HW_ODF_add_attribute_value(linked_HW_object_dic, '_children', HW_object_dic)
        else:
            logs.add('INTERNAL ERROR : undefined link type given to HW_ODF_do_link_between_obj')
            return False

        return True

    #-------------------------------------------------------------------------------------------------
    def HW_ODF_add_attribute_value(self, HW_object_dic, attr_name, attr_value):
        # add the given attribute value to the list of the given object dictionary of the Hauptwerk ODF dictionary (for _xxx attributes which contain a list)
        # if the given value already exists in the list, it is not added to avoid doubles

        try:
            if attr_value not in HW_object_dic[attr_name]:
                HW_object_dic[attr_name].append(attr_value)
        except:
            # the attr_name doesn't exist, create it and add the value
            HW_object_dic[attr_name] = []
            HW_object_dic[attr_name].append(attr_value)

    #-------------------------------------------------------------------------------------------------
    def HW_ODF_get_attribute_value(self, HW_object_dic, attr_name, mandatory_bool=False):
        # return the string value string of the given attribute defined in the given object sub-dictionary of the Hauptwerk ODF dictionary
        # generate a log in case of attribute not found and if mandatory_bool=MANDATORY (True), mandatory_bool=False permits to get silently an attribute which the presence is optional
        # return None if the attribute name is not defined in the given dictionary

        if HW_object_dic == None:
            return None

        try:
            attr_value = HW_object_dic[attr_name]
        except:
            attr_value = None
            if mandatory_bool:
                logs.add(f'ERROR : unable to read the attribute "{attr_name}" in the sample set object {HW_object_dic["_HW_uid"]}')

        return attr_value

    #-------------------------------------------------------------------------------------------------
    def HW_ODF_get_object_dic(self, HW_object_type_or_uid, HW_object_id = None):
        # return the HW object dictionary having the given object type and ID or only the given UID (unique ID) if object_id_int = -1 or not defined
        # if the HW object type is '_General' then the object ID parameter has not to be provided
        # return None if the object has not been found with the given data

        if HW_object_type_or_uid == None:
            return None

        # define the object type and ID
        if HW_object_id == None:
            # no object ID provided : object UID is provided
            if HW_object_type_or_uid == '_General':
                HW_object_type = '_General'
                HW_object_id = 1
            elif HW_object_type_or_uid[-6:].isdigit():
                HW_object_type = HW_object_type_or_uid[:-6]    # remove the last 6 digits of the UID
                HW_object_id = int(HW_object_type_or_uid[-6:])  # keep only the last 6 digits of the UID
            else:
                HW_object_id = 0
        else:
            # object type + ID is provided
            HW_object_type = HW_object_type_or_uid

        if HW_object_id == 0:
            return None

        try:
            # recover the dictionary of the object having the given type and ID
            return self.HW_odf_dic[HW_object_type][HW_object_id]
        except:
            # object dictionary not existing for the given type and/or ID
            return None

    #-------------------------------------------------------------------------------------------------
    def HW_ODF_get_object_by_ref_id(self, HW_object_type, ref_HW_object_dic, ref_HW_attr_id_name_str):
        # return the HW object dictionary having the given object type and which the ID is defined in the given referencing object dictionary and its referencing attribute ID

        # get the ID of the referenced object
        HW_object_id = myint(self.HW_ODF_get_attribute_value(ref_HW_object_dic, ref_HW_attr_id_name_str))

        if HW_object_id != None:
            return self.HW_ODF_get_object_dic(HW_object_type, HW_object_id)
        else:
            return None

    #-------------------------------------------------------------------------------------------------
    def HW_ODF_get_linked_objects_by_type(self, HW_object_dic, object_type_str, link_type_int, first_occurence=False, sorted_id_list=False, sorted_name_list=False):
        # return a list containing the dictionary of the HW objects which are parent/child (according to link_type_int) of the given object and which has the given object type
        # link_type_int must be equal to TO_PARENT or TO_CHILD
        # if sorted_id_list is equal to True, the returned objects list is sorted by object ID order
        # if sorted_name_list is equal to True (and sorted_id_list is equal to False), the returned objects list is sorted by object name order
        # if first_occurence = FIRST_ONE (True), only the first occurence of the linked object is returned as a dictionary, not as a list
        # return an empty list or None (if first_occurence=True) if there is no parent/child found

        HW_linked_objects_dic_list = []
        HW_linked_object_dic = None

        if HW_object_dic != None:
            if link_type_int == TO_PARENT:
                for HW_obj_dic in HW_object_dic['_parents']:
                    if HW_obj_dic['_HW_uid'][:-6] == object_type_str:
                        if first_occurence:
                            HW_linked_object_dic = HW_obj_dic
                            break
                        else:
                            HW_linked_objects_dic_list.append(HW_obj_dic)

            elif link_type_int == TO_CHILD:
                for HW_obj_dic in HW_object_dic['_children']:
                    if HW_obj_dic['_HW_uid'][:-6] == object_type_str:
                        if first_occurence:
                            HW_linked_object_dic = HW_obj_dic
                            break
                        else:
                            HW_linked_objects_dic_list.append(HW_obj_dic)
            else:
                logs.add('INTERNAL ERROR : undefined link type given to HW_ODF_get_linked_objects_by_type')

        if first_occurence:
            return HW_linked_object_dic
        else:
            if (sorted_id_list or sorted_name_list) and len(HW_linked_objects_dic_list) > 1:
                id_list = []
                name_id_list = []
                for HW_obj_dic in HW_linked_objects_dic_list:
                    id_list.append(int(HW_obj_dic['_HW_uid'][-6:]))
                    name_id_list.append(HW_obj_dic['Name'] + '=' + HW_obj_dic['_HW_uid'][-6:])
                HW_linked_objects_dic_list = []
                if sorted_id_list:
                    for id in sorted(id_list):
                        HW_linked_objects_dic_list.append(self.HW_ODF_get_object_dic(object_type_str, id))
                else:
                    for name_id in sorted(name_id_list):
                        name, id = name_id.split('=')
                        HW_linked_objects_dic_list.append(self.HW_ODF_get_object_dic(object_type_str, int(id)))

            return HW_linked_objects_dic_list

    #-------------------------------------------------------------------------------------------------
    def HW_ODF_get_object_data_list(self, HW_object_uid):
        # return a list containing the object attributes name/value of the given object UID (for display purpose in the GUI)
        # or None if the given HW object doesn't exist

        HW_object_dic = self.HW_ODF_get_object_dic(HW_object_uid)

        if HW_object_dic != None:
            data_list = []
            for obj_attr_name, obj_attr_value in HW_object_dic.items():
                if obj_attr_name in ('_parents', '_children'):
                    # this attribute value contains a list of objects dictionaries
                    relations = ''
                    for HW_object_dic2 in obj_attr_value:
                        relations += (HW_object_dic2['_HW_uid'] + ' ')
                    obj_attr_value = relations
                data_list.append(f'{obj_attr_name}={obj_attr_value}')
            return data_list
        else:
            return None

    #-------------------------------------------------------------------------------------------------
    def HW_ODF_get_image_attributes(self, HW_object_dic, HW_image_attr_dic, HW_image_index_in_set_int = None):
        # fill the given image dictionary with the following HW attributes of the given object dictionary (can be ImageSetInstance or ImageSet) and the related ImageSet / ImageSetElement
        # the not defined attributes are set at None
        #    Name (string)
        #    LeftXPosPixels (integer)
        #    TopYPosPixels (integer)
        #    ImageWidthPixels (integer)
        #    ImageHeightPixels (integer)
        #    ImageWidthPixelsTiling (integer)
        #    ImageHeightPixelsTiling (integer)
        #    ClickableAreaLeftRelativeXPosPixels (integer)
        #    ClickableAreaRightRelativeXPosPixels (integer)
        #    ClickableAreaTopRelativeYPosPixels (integer)
        #    ClickableAreaBottomRelativeYPosPixels (integer)
        #    InstallationPackageID (integer)
        #    BitmapFilename (string)
        #    TransparencyMaskBitmapFilename (string)
        # in case of an ImageSetInstance as object type, use the object default image index in set to know which ImageSetElement to recover
        # in case of an ImageSet as object type, use the given image index in set to know which ImageSetElement to recover
        # return True or False whether the operation has succeeded or not

        if HW_object_dic['_HW_uid'][:-6] == 'ImageSetInstance':
            # ImageSetInstance object provided

            HW_image_set_inst_dic = HW_object_dic

            # recover the dictionary of the associated ImageSet object
            HW_image_set_dic = self.HW_ODF_get_object_by_ref_id('ImageSet', HW_image_set_inst_dic, 'ImageSetID')
            if HW_image_set_dic == None: return False

            HW_image_attr_dic['Name'] = self.HW_ODF_get_attribute_value(HW_image_set_inst_dic, 'Name')

            HW_image_attr_dic['LeftXPosPixels'] = myint(self.HW_ODF_get_attribute_value(HW_image_set_inst_dic, 'LeftXPosPixels'))
            HW_image_attr_dic['TopYPosPixels'] = myint(self.HW_ODF_get_attribute_value(HW_image_set_inst_dic, 'TopYPosPixels'))

            HW_image_attr_dic['ImageWidthPixelsTiling'] = myint(self.HW_ODF_get_attribute_value(HW_image_set_inst_dic, 'RightXPosPixelsIfTiling'))
            if HW_image_attr_dic['ImageWidthPixelsTiling'] == 0: HW_image_attr_dic['ImageWidthPixelsTiling'] = None

            HW_image_attr_dic['ImageHeightPixelsTiling'] = myint(self.HW_ODF_get_attribute_value(HW_image_set_inst_dic, 'BottomYPosPixelsIfTiling'))
            if HW_image_attr_dic['ImageHeightPixelsTiling'] == 0: HW_image_attr_dic['ImageHeightPixelsTiling'] = None

            if HW_image_index_in_set_int == None:
                # image index not provided in parameter of the function : set a default index
                HW_image_index_in_set_int = myint(self.HW_ODF_get_attribute_value(HW_image_set_inst_dic, 'DefaultImageIndexWithinSet'))
                # if the attribute ImageIndexWithinSet is not defined, set the index at 1 by default
                if HW_image_index_in_set_int == None: HW_image_index_in_set_int = 1

        elif HW_object_dic['_HW_uid'][:-6] == 'ImageSet':
            # ImageSet object provided
            HW_image_set_inst_dic = None
            HW_image_set_dic = HW_object_dic

            HW_image_attr_dic['Name'] = self.HW_ODF_get_attribute_value(HW_image_set_dic, 'Name')
            HW_image_attr_dic['LeftXPosPixels'] = None
            HW_image_attr_dic['TopYPosPixels'] = None
            HW_image_attr_dic['ImageWidthPixelsTiling'] = None
            HW_image_attr_dic['ImageHeightPixelsTiling'] = None

        else:
            return False

        # recover the data from the ImageSet
        HW_image_attr_dic['InstallationPackageID'] = myint(self.HW_ODF_get_attribute_value(HW_image_set_dic, 'InstallationPackageID', MANDATORY))

        if HW_image_attr_dic['ImageWidthPixelsTiling'] != None:
            HW_image_attr_dic['ImageWidthPixels'] = myint(HW_image_attr_dic['ImageWidthPixelsTiling'])
        else:
            HW_image_attr_dic['ImageWidthPixels'] = myint(self.HW_ODF_get_attribute_value(HW_image_set_dic, 'ImageWidthPixels'))

        if HW_image_attr_dic['ImageHeightPixelsTiling'] != None:
            HW_image_attr_dic['ImageHeightPixels'] = myint(HW_image_attr_dic['ImageHeightPixelsTiling'])
        else:
            HW_image_attr_dic['ImageHeightPixels'] = myint(self.HW_ODF_get_attribute_value(HW_image_set_dic, 'ImageHeightPixels'))

        # recover the bitmap file of the transparency image
        value = self.HW_ODF_get_attribute_value(HW_image_set_dic, 'TransparencyMaskBitmapFilename')
        if value != None:
            HW_image_attr_dic['TransparencyMaskBitmapFilename'] = self.convert_HW2GO_file_name(value, HW_image_attr_dic['InstallationPackageID'])
        else:
            HW_image_attr_dic['TransparencyMaskBitmapFilename'] = None

        # recover the bitmap file of the displayed image (from the ImageSetElement associated to the ImageSet and having the proper image index within set)
        HW_image_attr_dic['BitmapFilename'] = None
        for image_set_elem_dic in self.HW_ODF_get_linked_objects_by_type(HW_image_set_dic, 'ImageSetElement', TO_CHILD):
            # scan the ImageSetElement objects which are children of the ImageSet object to find the one having the right image index
            image_index = myint(self.HW_ODF_get_attribute_value(image_set_elem_dic, 'ImageIndexWithinSet'), 1)  # default to 1
            if image_index == HW_image_index_in_set_int:
                # it is the expected ImageSetElement object
                value = self.HW_ODF_get_attribute_value(image_set_elem_dic, 'BitmapFilename')
                if value != None:
                    HW_image_attr_dic['BitmapFilename'] = self.convert_HW2GO_file_name(value, HW_image_attr_dic['InstallationPackageID'])
                else:
                    HW_image_attr_dic['BitmapFilename'] = None
                break

        HW_image_attr_dic['ClickableAreaLeftRelativeXPosPixels'] = myint(self.HW_ODF_get_attribute_value(HW_image_set_dic, 'ClickableAreaLeftRelativeXPosPixels'))
        HW_image_attr_dic['ClickableAreaRightRelativeXPosPixels'] = myint(self.HW_ODF_get_attribute_value(HW_image_set_dic, 'ClickableAreaRightRelativeXPosPixels'))
        HW_image_attr_dic['ClickableAreaTopRelativeYPosPixels'] = myint(self.HW_ODF_get_attribute_value(HW_image_set_dic, 'ClickableAreaTopRelativeYPosPixels'))
        HW_image_attr_dic['ClickableAreaBottomRelativeYPosPixels'] = myint(self.HW_ODF_get_attribute_value(HW_image_set_dic, 'ClickableAreaBottomRelativeYPosPixels'))

        # correct the clickable width if greater than the image width
        if (HW_image_attr_dic['ImageWidthPixels'] != None and HW_image_attr_dic['ClickableAreaRightRelativeXPosPixels'] != None and
            HW_image_attr_dic['ClickableAreaRightRelativeXPosPixels'] > HW_image_attr_dic['ImageWidthPixels'] - 1):
            HW_image_attr_dic['ClickableAreaRightRelativeXPosPixels'] = HW_image_attr_dic['ImageWidthPixels'] - 1
        # correct the clickable height if greater than the image height
        if (HW_image_attr_dic['ImageHeightPixels'] != None and HW_image_attr_dic['ClickableAreaBottomRelativeYPosPixels'] != None and
            HW_image_attr_dic['ClickableAreaBottomRelativeYPosPixels'] > HW_image_attr_dic['ImageHeightPixels'] - 1):
            HW_image_attr_dic['ClickableAreaBottomRelativeYPosPixels'] = HW_image_attr_dic['ImageHeightPixels'] - 1

        # set some default values if not defined
        if HW_image_attr_dic['LeftXPosPixels'] == None: HW_image_attr_dic['LeftXPosPixels'] = 0
        if HW_image_attr_dic['TopYPosPixels'] == None: HW_image_attr_dic['TopYPosPixels'] = 0

        return True

    #-------------------------------------------------------------------------------------------------
    def HW_ODF_get_text_attributes(self, HW_text_inst_dic, HW_text_attr_dic):
        # fill the given HW_text_attr_dic dictionary with the following HW attributes of the given TextInstance object dictionary (+ ImageSetInstance if any) and the related TextStyle
        # the not defined attributes are set at None
        #    Text (string)
        #    XPosPixels (integer)
        #    YPosPixels (integer)
        #    AttachedToAnImageSetInstance : Y or N (string)
        #    PosRelativeToTopLeftOfImage : Y or N (string)
        #    WordWrapWithinABoundingBox : Y or N (string)
        #    BoundingBoxWidthPixelsIfWordWrap (integer)
        #    BoundingBoxHeightPixelsIfWordWrap (integer)
        #    Face_WindowsName (string)
        #    Font_SizePixels (integer)
        #    Font_WeightCode : 1 = light, 2 = normal, 3 = bold (integer)
        #    Colour_Red (integer)
        #    Colour_Green (integer)
        #    Colour_Blue (integer)
        #    HorizontalAlignmentCode : 0 or not defined = center, 1 = left, 2 = right (integer)
        #    VerticalAlignmentCode   : 0 = center, 1 or not defined = top, 2 = bottom (integer)
        #    + the attributes returned by HW_ODF_get_image_attributes if an image is attached to this TextInstance object
        #    ImageSetInstanceDic : dictionary of the linked ImageSetInstance if any, else None

        if not HW_text_inst_dic['_HW_uid'][:-6] == 'TextInstance':
            return False

        HW_text_attr_dic['Text'] = self.HW_ODF_get_attribute_value(HW_text_inst_dic, 'Text', MANDATORY)
        HW_text_attr_dic['XPosPixels'] = myint(self.HW_ODF_get_attribute_value(HW_text_inst_dic, 'XPosPixels'))
        HW_text_attr_dic['YPosPixels'] = myint(self.HW_ODF_get_attribute_value(HW_text_inst_dic, 'YPosPixels'))
        HW_text_attr_dic['AttachedToAnImageSetInstance'] = self.HW_ODF_get_attribute_value(HW_text_inst_dic, 'AttachedToAnImageSetInstance')
        HW_text_attr_dic['PosRelativeToTopLeftOfImage'] = self.HW_ODF_get_attribute_value(HW_text_inst_dic, 'PosRelativeToTopLeftOfImageSetInstance')
        HW_text_attr_dic['WordWrapWithinABoundingBox'] = myint(self.HW_ODF_get_attribute_value(HW_text_inst_dic, 'WordWrapWithinABoundingBox'))
        HW_text_attr_dic['BoundingBoxWidthPixelsIfWordWrap'] = myint(self.HW_ODF_get_attribute_value(HW_text_inst_dic, 'BoundingBoxWidthPixelsIfWordWrap'))
        HW_text_attr_dic['BoundingBoxHeightPixelsIfWordWrap'] = myint(self.HW_ODF_get_attribute_value(HW_text_inst_dic, 'BoundingBoxHeightPixelsIfWordWrap'))

        # recover the data from the associated TextStyle object
        HW_text_style_dic = self.HW_ODF_get_object_by_ref_id('TextStyle', HW_text_inst_dic, 'TextStyleID')
        if HW_text_style_dic != None:
            HW_text_attr_dic['Face_WindowsName'] = self.HW_ODF_get_attribute_value(HW_text_style_dic, 'Face_WindowsName')
            HW_text_attr_dic['Font_SizePixels'] = myint(self.HW_ODF_get_attribute_value(HW_text_style_dic, 'Font_SizePixels'))

            HW_text_attr_dic['Font_WeightCode'] = myint(self.HW_ODF_get_attribute_value(HW_text_style_dic, 'Font_WeightCode'))

            HW_text_attr_dic['Colour_Red'] = myint(self.HW_ODF_get_attribute_value(HW_text_style_dic, 'Colour_Red'))
            HW_text_attr_dic['Colour_Green'] = myint(self.HW_ODF_get_attribute_value(HW_text_style_dic, 'Colour_Green'))
            HW_text_attr_dic['Colour_Blue'] = myint(self.HW_ODF_get_attribute_value(HW_text_style_dic, 'Colour_Blue'))

            HW_text_attr_dic['HorizontalAlignmentCode'] = myint(self.HW_ODF_get_attribute_value(HW_text_style_dic, 'HorizontalAlignmentCode'))
            HW_text_attr_dic['VerticalAlignmentCode'] = myint(self.HW_ODF_get_attribute_value(HW_text_style_dic, 'VerticalAlignmentCode'))
        else:
            HW_text_attr_dic['Face_WindowsName'] = None
            HW_text_attr_dic['Font_SizePixels'] = None
            HW_text_attr_dic['Font_WeightCode'] = None
            HW_text_attr_dic['Colour_Red'] = None
            HW_text_attr_dic['Colour_Green'] = None
            HW_text_attr_dic['Colour_Blue'] = None
            HW_text_attr_dic['HorizontalAlignmentCode'] = None
            HW_text_attr_dic['VerticalAlignmentCode'] = None

        # set some default values if not defined
        if HW_text_attr_dic['Face_WindowsName'] == None: HW_text_attr_dic['Face_WindowsName'] = 'Arial'
        if HW_text_attr_dic['Font_SizePixels'] == None: HW_text_attr_dic['Font_SizePixels'] = 10
        if HW_text_attr_dic['Font_WeightCode'] == None: HW_text_attr_dic['Font_WeightCode'] = 2
        if HW_text_attr_dic['HorizontalAlignmentCode'] == None: HW_text_attr_dic['HorizontalAlignmentCode'] = 0  # center
        if HW_text_attr_dic['VerticalAlignmentCode'] == None: HW_text_attr_dic['VerticalAlignmentCode'] = 1      # top
        if HW_text_attr_dic['XPosPixels'] == None: HW_text_attr_dic['XPosPixels'] = 0
        if HW_text_attr_dic['YPosPixels'] == None: HW_text_attr_dic['YPosPixels'] = 0

        # add in the HW_text_attr_dic the attributes of the associated ImageSetInstance object if one is defined
        HW_image_set_inst_dic = self.HW_ODF_get_object_by_ref_id('ImageSetInstance', HW_text_inst_dic, 'AttachedToImageSetInstanceID')
        HW_text_attr_dic['ImageSetInstanceDic'] = HW_image_set_inst_dic
        if HW_image_set_inst_dic != None:
            self.HW_ODF_get_image_attributes(HW_image_set_inst_dic, HW_text_attr_dic)

        return True

    #-------------------------------------------------------------------------------------------------
    def HW_ODF_get_linked_controlling_switches(self, HW_switchlinkage_dic, main_branch_switches_list, current_branch_switches_list, main_branch_bool):
        # function called by HW_ODF_get_controlling_switches which returns the logical formula applyed by the given HW SwitchLinkage and its source and condition switches
        # the state of the source and condition switch can be inverted, and a logical AND is applied between them if a condition is present

        if HW_switchlinkage_dic == None:
            return None

        # check the action codes of the given SwitchLinkage
        engage_action_code = myint(self.HW_ODF_get_attribute_value(HW_switchlinkage_dic, 'EngageLinkActionCode'), 1)
        disengage_action_code = myint(self.HW_ODF_get_attribute_value(HW_switchlinkage_dic, 'DisengageLinkActionCode'), 2)
##        if engage_action_code != 1 or disengage_action_code != 2:
        if engage_action_code != 1 or disengage_action_code not in (2, 6):
            # ignore the linkages which have not the standard action codes
            if LOG_HW2GO_ctrl_switch: print(f"          {HW_switchlinkage_dic['_HW_uid']} has other action codes : engage {engage_action_code}, disengage {disengage_action_code}, ====> SKIPPED")
            return None

        # recover the inputs of the given SwitchLinkage
        source_switch_dic = self.HW_ODF_get_object_by_ref_id('Switch', HW_switchlinkage_dic, 'SourceSwitchID')
        cond_switch_dic = self.HW_ODF_get_object_by_ref_id('Switch', HW_switchlinkage_dic, 'ConditionSwitchID')
        source_switch_link_if_engaged = self.HW_ODF_get_attribute_value(HW_switchlinkage_dic, 'SourceSwitchLinkIfEngaged')
        cond_switch_link_if_engaged = self.HW_ODF_get_attribute_value(HW_switchlinkage_dic, 'ConditionSwitchLinkIfEngaged')

        # get the formula coming from the condition switch (in the conditional branch so not in main branch) and apply it a NOT if necessary
        cond_formula = self.HW_ODF_get_controlling_switches(cond_switch_dic, main_branch_switches_list, current_branch_switches_list, False)
        if cond_formula != None and cond_switch_link_if_engaged == 'N':
            cond_formula = {'*Not': [cond_formula]}

        # get the formula coming from the source switch (in the same branch as the one of the SwitchLinkage) and apply it a NOT if necessary
        source_formula = self.HW_ODF_get_controlling_switches(source_switch_dic, main_branch_switches_list, current_branch_switches_list, main_branch_bool)
        if source_formula != None and source_switch_link_if_engaged == 'N':
            source_formula = {'*Not': [source_formula]}

        if cond_formula == None:
            # SwitchLinkage without condition, return the source switch formula
            formula = source_formula
        elif source_formula != None:
            # SwitchLinkage with condition, return an AND of the source and condition switches formula
            # since source and condition formulas will be inserted in an And condition, if they are themself an And condition as well, remove the condition
            formula = {'*And':[]}
            if isinstance(source_formula, dict) and '*And' in source_formula.keys():
                for item in source_formula['*And']:
                    formula['*And'].append(item)
            else:
                formula['*And'].append(source_formula)

            if isinstance(cond_formula, dict) and '*And' in cond_formula.keys():
                for item in cond_formula['*And']:
                    formula['*And'].append(item)
            else:
                formula['*And'].append(cond_formula)
        else:
            # SwitchLinkage with none input (this should not exist)
            formula = None

        return formula

    #-------------------------------------------------------------------------------------------------
    def HW_ODF_get_controlling_switches(self, HW_switch_dic, main_branch_switches_list, current_branch_switches_list = [], main_branch_bool=True):
        # recursive fonction which returns in nested dictioranies the logical formula (with Or, And or Not as keys and a list of switches or nested dict as values)
        # indicating the UID of the HW switches controlling the given HW Switch (himself included) and the logical relatioship between them
        # the value current_branch_switches_list contains the list of the HW switches which are controlling the given switch in the same controlling branch
        # examples of returned formulas :
        #     {'Or': ['Switch011028', 'Switch012028', 'Switch013028']}
        #     {'And': [{'Or': ['Switch011001', 'Switch012001', 'Switch013001']}, {'Or': ['Switch011029', 'Switch012029', 'Switch013029']}, {'Not': ['Switch012999']}]}

        # used HW objects :
        #   Switch C> SwitchLinkage C> Switch
        #   SwitchLinkage attributes :
        #     ConditionSwitchID            : if defined and condition switch is at OFF state, the destination switch is forced at OFF state
        #                                                                          ON  state, the source switch state is forwarded to the destination switch
        #     SourceSwitchLinkIfEngaged    : default 'Y', if ='N' the inverted source switch state is applied to the destination switch
        #     ConditionSwitchLinkIfEngaged : default 'Y', if ='N' the inverted conditional switch state is used for the source to destination state forwarding

        if HW_switch_dic == None:
            return None

        if HW_switch_dic in current_branch_switches_list:
            # the given HW switch is already in the given switches branch : the branch is looping on itself (case of switches of different panels having the same functional effect)
            formula = None
            # add in a sub-list of the list HW_looping_switches_lists two switches if not already present :
            # the current one and the previous one in the branch, which are linked together in a loop
            switch1_dic = HW_switch_dic
            switch2_dic = current_branch_switches_list[-1]  # last switch of the current switches branch list
            list_found_bool = False
            for looping_switches_list in self.HW_looping_switches_lists:
                # scan the existing switches lists in the main looping switches list
                if switch1_dic in looping_switches_list:
                    list_found_bool = True
                    if switch2_dic not in looping_switches_list:
                        looping_switches_list.append(switch2_dic)
                elif switch2_dic in looping_switches_list:
                    list_found_bool = True
                    if switch1_dic not in looping_switches_list:
                        looping_switches_list.append(switch1_dic)
            if not list_found_bool:
                # switches not already present in the main list, add them in a sub-list of the main list
                self.HW_looping_switches_lists.append([switch1_dic, switch2_dic])

        else:
            # the given HW switch can be processed
            # add it in the current switches branch list
            extended_current_branch_list = list(current_branch_switches_list)
            extended_current_branch_list.append(HW_switch_dic)

            # add the given HW switch to the main branch list if it is in the main branch
            if main_branch_bool:
                main_branch_switches_list.append(HW_switch_dic)

            # get properties of the given HW switch
            # clickable = self.HW_ODF_get_attribute_value(HW_switch_dic, 'Clickable')
            default_to_engage = self.HW_ODF_get_attribute_value(HW_switch_dic, 'DefaultToEngaged')
            img_set_inst_dic = self.HW_ODF_get_object_by_ref_id('ImageSetInstance', HW_switch_dic, 'Disp_ImageSetInstanceID')

            # build a list containing the formulas of the switches controlling the given HW switch
            formulas_list = []
            if img_set_inst_dic != None:
                # it is a visible controlling switch, add it to the list
                formulas_list.append(HW_switch_dic)
            for HW_switchlinkage_dic in self.HW_ODF_get_linked_objects_by_type(HW_switch_dic, 'SwitchLinkage', TO_PARENT):
                # scan the parent SwitchLinkage objects of the given HW switch
                form = self.HW_ODF_get_linked_controlling_switches(HW_switchlinkage_dic, main_branch_switches_list, extended_current_branch_list, main_branch_bool)
                if form != None:
                    # a formula comes from the current SwitchLinkage, take it into account
                    formulas_list.append(form)

            if len(formulas_list) == 0:
                # no parent controlling switches, the given HW switch is at the top of a branch
                if default_to_engage == 'Y':
                    # the given HW switch is engaged by default, take it into account
                    formula = HW_switch_dic
                else:
                    formula = None
            elif len(formulas_list) == 1:
                # only one controlling switch, take it as it is
                formula = formulas_list[0]
            else:
                # in case of several controlling switches, link them together by an OR logical formula
                # since formulas will be inserted in a Or condition, if they are themself a Or condition as well, remove the condition
                formula = {'*Or':[]}
                for form in formulas_list:
                    if isinstance(form, dict) and '*Or' in form.keys():
                        for item in form['*Or']:
                            formula['*Or'].append(item)
                    else:
                        formula['*Or'].append(form)

        if len(current_branch_switches_list) == 0 and list(formula.keys())[0][0] != '*':  # the first digit of the first key doesn't start by * (so not *And, *Not, *Or)
            # first level call of this recursive function and formula without logical condition : it is a single switch dictionary
            # place this switch in a list under a OR formula, because the returned formula must be a dictionary with logical condition
            formula = {'*Or':[formula]}

        return formula

    #-------------------------------------------------------------------------------------------------
    def HW_ODF_get_controlled_switches(self, HW_switch_dic, switches_dic_list):
        # recursive fonction which fills the list switches_dic_list with the HW switches which are controlled by the given HW Switch (himself included)
        # through standard switch linkage (EngageLinkActionCode = 1 and DisengageLinkActionCode = 2) and not as a condition switch
        # return an empty list if a conditional linkage is found on the controlling branch

        ret = 'standard'
        if HW_switch_dic not in switches_dic_list:
            # the given HW switch has not been already checked (to avoid loops between switches)
            switches_dic_list.append(HW_switch_dic)

            # check the HW Switch objects controlled by the given HW Switch
            for HW_switch_linkage_dic in self.HW_ODF_get_linked_objects_by_type(HW_switch_dic, 'SwitchLinkage', TO_CHILD):
                # scan the children HW SwitchLinkage objects of the given HW Switch
                HW_engage_action_code = myint(self.HW_ODF_get_attribute_value(HW_switch_linkage_dic, 'EngageLinkActionCode'), 1)
                HW_disengage_action_code = myint(self.HW_ODF_get_attribute_value(HW_switch_linkage_dic, 'DisengageLinkActionCode'), 2)
                HW_source_switch_dic = self.HW_ODF_get_object_by_ref_id('Switch', HW_switch_linkage_dic, 'SourceSwitchID')
                if HW_switch_dic == HW_source_switch_dic and HW_engage_action_code == 1 and HW_disengage_action_code == 2:
                    # the HW Switch is the source of the current linkage which has standard linking action codes
                    # check the destination switch of the current linkage
                    HW_dest_switch_dic = self.HW_ODF_get_object_by_ref_id('Switch', HW_switch_linkage_dic, 'DestSwitchID')
                    ret = self.HW_ODF_get_controlled_switches(HW_dest_switch_dic, switches_dic_list)

                elif HW_switch_dic != HW_source_switch_dic:
                    # the HW Switch is not the source of the current linkage : it is the conditional switch
                    ret = 'conditional'

                else:
                    # the switch linkage is not standard
                    ret = 'other_action_codes'

        return ret

    #-------------------------------------------------------------------------------------------------
    def HW_ODF_get_controlling_continuous_control(self,HW_cont_ctrl_dic):
        # returns the HW ContinuousControl object which has a graphical interface to control the given HW ContinuousControl (it can be the one given)
        # returns None if there is no such object

        HW_img_set_inst_dic = self.HW_ODF_get_object_by_ref_id('ImageSetInstance', HW_cont_ctrl_dic, 'ImageSetInstanceID')
        while HW_img_set_inst_dic == None and HW_cont_ctrl_dic != None:
            # the given HW ContinuousControl has no graphical interface
            # search in its parents one having a graphical interface
            HW_cont_ctrl_link_dic = self.HW_ODF_get_linked_objects_by_type(HW_cont_ctrl_dic, 'ContinuousControlLinkage', TO_PARENT, FIRST_ONE)
            HW_cont_ctrl_dic = self.HW_ODF_get_linked_objects_by_type(HW_cont_ctrl_link_dic, 'ContinuousControl', TO_PARENT, FIRST_ONE)
            HW_img_set_inst_dic = self.HW_ODF_get_object_by_ref_id('ImageSetInstance', HW_cont_ctrl_dic, 'ImageSetInstanceID')

        if HW_img_set_inst_dic == None and HW_cont_ctrl_dic == None:
            return None
        else:
            return HW_cont_ctrl_dic

    #-------------------------------------------------------------------------------------------------
    def HW_ODF_save2textfile(self, file_name):
        # save the Hauptwerk ODF objects dictionary into the given text file path/name in a GrandOrgue like format (for development/debug purpose)

        with open(file_name, 'w', encoding=ENCODING_UTF8_BOM) as f:
            f.write(';Hauptwerk ODF XML formatted in a GrandOrgue ODF manner\n')
            f.write('\n')
            for object_type_dic in self.HW_odf_dic.values():
                for HW_object_dic in object_type_dic.values():
                    f.write(f'[{HW_object_dic["_HW_uid"]}]\n')
                    for obj_attr_name, obj_attr_value in HW_object_dic.items():
                        if obj_attr_name in ('_parents', '_children'):
                            # this attribute contains a list of objects dictionaries
                            relations = ''
                            for HW_object_dic2 in obj_attr_value:
                                relations += (HW_object_dic2['_HW_uid'] + '  ')
                            obj_attr_value = relations
                        f.write(f'{obj_attr_name}={obj_attr_value}\n')
                    f.write('\n')

    #-------------------------------------------------------------------------------------------------
    def GO_ODF_save2organfile(self, file_name, file_encoding):
        # save the GrandOrgue ODF objects dictionary into the given .organ ODF file and in the given file encoding (ISO_8859_1 or UTF-8)
        # return True or False whether the saving has succeeded or not

        # check the extension of the given file name
        filename_str, file_extension_str = os.path.splitext(file_name)
        if file_extension_str != '.organ':
            logs.add(f'The file "{file_name}" does not have the expected extension .organ')
            return False

        with open(file_name, 'w', encoding=file_encoding) as f:
            # set the list of objects UID to save : Organ in first, then the others by alphabetical order
            uid_list = sorted(self.GO_odf_dic.keys())
            uid_list.remove('Organ')
            uid_list.insert(0, 'Organ')
            # write a comment in the header
            f.write('; ' + ODF_COMMENT + '\n')
            f.write('\n')
            # write the objects
            for object_uid in uid_list:
                f.write(f'[{object_uid}]\n')
                for obj_attr_name, obj_attr_value in self.GO_odf_dic[object_uid].items():
                    if obj_attr_name[0] != '_': # it is not a temporary attribute created for HW to GO conversion
                        line = obj_attr_name + '=' + str(obj_attr_value) + '\n'
                        if file_encoding == ENCODING_ISO_8859_1:
                            # convert the line from UTF-8 to ISO_8859_1 format
                            line = line.encode('utf-8', errors='ignore').decode('ISO-8859-1', errors='ignore')
                        f.write(line)
                f.write('\n')  # insert an empty line between each object section

        return True

    #-------------------------------------------------------------------------------------------------
    def GO_ODF_build_from_HW_ODF(self, HW_odf_file_name, GO_odf_file_name, progress_status_update_fct, build_unused_ranks_bool, build_alt_ranks_bool, GO_odf_encoding):
        # build and save a GrandOrgue ODF from the given Hauptwerk ODF and its associated sample set (which is not touched)
        # use the given function callback to display a progression status in the GUI
        # return False if an issue has occured, else return True

        self.reset_all_data()

        self.progress_status_show_function = progress_status_update_fct
        self.convert_alt_ranks_bool = build_alt_ranks_bool

        # load the HW ODF in the HW ODF dictionary
        progress_status_update_fct('Loading the Hauptwerk ODF...')
        if self.HW_ODF_load_from_file(HW_odf_file_name):
            # the loading has been done with success

            # store the list of the HW display pages and divisions sorted by ascending ID order
            HW_sorted_display_pages_id_list = sorted(self.HW_odf_dic['DisplayPage'].keys())
            HW_sorted_divisions_id_list = sorted(self.HW_odf_dic['Division'].keys())

            # link the HW objects together
            progress_status_update_fct('Building the Hauptwerk ODF objects tree...')
            self.HW_ODF_do_links_between_objects()

            # build the various GO objects in the GO ODF dictionary from the HW ODF
            # the order of calling the below functions is important, there are dependencies between some of them

            progress_status_update_fct('Building the GrandOrgue Organ object...')
            if self.GO_ODF_build_Organ_object() == None:
                logs.add('ERROR : issue occured while building the GO Organ object')
                return False

            # build the GO Panel objects by sorted HW DisplayPage ID order
            progress_status_update_fct('Building the GrandOrgue Panels...')
            for HW_disp_page_id in HW_sorted_display_pages_id_list:
                HW_disp_page_dic = self.HW_ODF_get_object_dic('DisplayPage', HW_disp_page_id)
                if ('CRESC' not in HW_disp_page_dic['Name'].upper() and
                    'MATRIX' not in HW_disp_page_dic['Name'].upper()):
                    # crescendo and matrix named pages are skipped
                    self.GO_ODF_build_Panel_object(HW_disp_page_dic)
                else:
                    logs.add(f'Panel "{HW_disp_page_dic["Name"]}" has been ignored')

            # build the GO Manual objects by sorted HW Division ID order
            progress_status_update_fct('Building the GrandOrgue Manuals...')
            for HW_division_id in HW_sorted_divisions_id_list:
                HW_division_dic = self.HW_odf_dic['Division'][HW_division_id]
                self.GO_ODF_build_Manual_object(HW_division_dic)

            # build the GO Coupler objects by sorted HW Division ID -> Keyboard -> KeyAction
            for HW_division_id in HW_sorted_divisions_id_list:
                HW_division_dic = self.HW_odf_dic['Division'][HW_division_id]
                for HW_keyboard_dic in self.HW_ODF_get_linked_objects_by_type(HW_division_dic, 'Keyboard', TO_CHILD, sorted_id_list=True):
                    # scan the HW Keyboard objects belonging to the current HW Division
                    for HW_key_action_dic in self.HW_ODF_get_linked_objects_by_type(HW_keyboard_dic, 'KeyAction', TO_CHILD, sorted_id_list=True):
                        # scan the HW KeyAction objects belonging to the current HW Keyboard
                        progress_status_update_fct(f'Building the GrandOrgue Coupler "{HW_key_action_dic["Name"]}"...')
                        self.GO_ODF_build_Drawstop_objects(HW_key_action_dic, HW_division_dic)

            # build the GO Stop pipes objects by sorted HW Division ID
            for HW_division_id in HW_sorted_divisions_id_list:
                HW_division_dic = self.HW_odf_dic['Division'][HW_division_id]
                for HW_stop_dic in self.HW_ODF_get_linked_objects_by_type(HW_division_dic, 'Stop', TO_CHILD, sorted_id_list=True):
                    # scan the HW Stop objects belonging to the current HW Division
                    progress_status_update_fct(f'Building the GrandOrgue Stop "{HW_stop_dic["Name"]}"...')
                    self.GO_ODF_build_Drawstop_objects(HW_stop_dic, HW_division_dic)

            # by default the other drawstops or tremulants are assigned to the last division
            HW_default_division_dic = self.HW_odf_dic['Division'][HW_sorted_divisions_id_list[-1]]

            # build the GO Tremulant objects if any are defined
            if 'Tremulant' in self.HW_odf_dic.keys():
                for HW_tremulant_dic in self.HW_odf_dic['Tremulant'].values():
                    progress_status_update_fct(f'Building the GrandOrgue Tremulant "{HW_tremulant_dic["Name"]}"...')
                    self.GO_ODF_build_Drawstop_objects(HW_tremulant_dic, HW_default_division_dic)

            # build GO Stop objects not built before, parsing the HW switches of the display pages which have not be converted yet to GO object
            progress_status_update_fct('Building other GrandOrgue stops...')
            for HW_disp_page_id in HW_sorted_display_pages_id_list:
                HW_disp_page_dic = self.HW_ODF_get_object_dic('DisplayPage', HW_disp_page_id)
                if HW_disp_page_dic['_GO_uid'] != '':
                    # the current HW display page has been converted in a GO panel
                    for HW_switch_dic in self.HW_ODF_get_linked_objects_by_type(HW_disp_page_dic, 'Switch', TO_CHILD):
                        # scan the HW Switch objects displayed in the current HW DisplayPage
                        if self.HW_ODF_get_linked_objects_by_type(HW_switch_dic, 'KeyboardKey', TO_CHILD, FIRST_ONE) == None and HW_switch_dic['_GO_uid'] == '':
                            # it is not the switch of a keyboard key and it has not been converted in a GO switch
                            self.GO_ODF_build_Drawstop_objects(HW_switch_dic, HW_default_division_dic)

            # build the labels
            progress_status_update_fct('Building the GrandOrgue Labels...')
            for HW_disp_page_id in HW_sorted_display_pages_id_list:
                HW_disp_page_dic = self.HW_ODF_get_object_dic('DisplayPage', HW_disp_page_id)
                if HW_disp_page_dic['_GO_uid'] != '':
                    # the current HW display page has been converted in a GO panel
                    # recover the corresponding GO panel
                    GO_panel_uid = HW_disp_page_dic['_GO_uid']
                    for HW_text_inst_dic in self.HW_ODF_get_linked_objects_by_type(HW_disp_page_dic, 'TextInstance', TO_CHILD):
                        # scan the HW TextInstance objects of the current display page
                        self.GO_ODF_build_Label_object(HW_text_inst_dic, GO_panel_uid)

            if build_unused_ranks_bool:
                # build the GO Ranks objects corresponding to HW Ranks of pipes not converted in GO Ranks previously
                for HW_rank_dic in self.HW_odf_dic['Rank'].values():
                    if HW_rank_dic['_GO_uid'] == '':
                        # HW Rank not converted in a GO Rank
                        progress_status_update_fct(f'Building unused GrandOrgue Rank "{HW_rank_dic["Name"]}"...')
                        self.GO_ODF_build_Rank_object(HW_rank_dic, 0, True)

            progress_status_update_fct('Completing the building operation...')

            if self.silent_loop_file_used:
                # the file SilentLoop.wav is referenced in the GO ODF for a GO Sdrawstop noise
                # copy it in the root folder of the HW sample set
                if not(os.path.exists(self.HW_sample_set_path + os.sep + 'SilentLoop.wav')):
                    # the file is not already present in the HW sample set root folder, copy it
                    shutil.copy(os.path.dirname(__file__) + os.sep + 'resources' + os.sep + 'SilentLoop.wav', self.HW_sample_set_path)
            else:
                # the file SilentLoop.wav is not referenced in the GO ODF
                # remove it in the root folder of the HW sample set if it present
                if os.path.exists(self.HW_sample_set_path + os.sep + 'SilentLoop.wav'):
                    # the file is present in the HW sample set root folder, delete it
                    os.remove(self.HW_sample_set_path + os.sep + 'SilentLoop.wav')

            # save the HW ODF data in a GO ODF text format (for development/debug purpose, more easy to read than a xml file)
            if DEV_MODE:
                pass
##                self.HW_ODF_save2textfile(HW_odf_file_name + '.txt')

            # save the built GO ODF data in a .organ file
            if self.GO_ODF_save2organfile(GO_odf_file_name, GO_odf_encoding):
                logs.add(f'GrandOrgue ODF built and saved in "{GO_odf_file_name}"')

        # clear the last progression message
        progress_status_update_fct('')

        return True

    #-------------------------------------------------------------------------------------------------
    def GO_ODF_build_Organ_object(self):
        # build the GO Organ object from the HW ODF
        # return None if an issue has occured, else return the UID of the created GO Organ

        # used HW objects :
        #   _General, RequiredInstallationPackage

        # get the dictionary of the HW _General object
        self.HW_general_dic = self.HW_ODF_get_object_dic('_General')
        if self.HW_general_dic == None:
            logs.add('ERROR : missing _General object in the Hauptwerk ODF dictionary')
            return None

        # check if the folders of the required installation packages are present in the folder OrganInstallationPackages
        self.available_HW_packages_id_list = []
        for HW_install_pack_dic in self.HW_odf_dic['RequiredInstallationPackage'].values():
            # scan and check the defined HW RequiredInstallationPackage objects
            HW_package_id = myint(self.HW_ODF_get_attribute_value(HW_install_pack_dic, 'InstallationPackageID', MANDATORY))
            if HW_package_id == None:
                logs.add('ERROR : no installation package ID defined in the HW ODF')
                return None

            HW_package_name = self.HW_ODF_get_attribute_value(HW_install_pack_dic, 'Name', MANDATORY)
            HW_package_supplier = self.HW_ODF_get_attribute_value(HW_install_pack_dic, 'SupplierName', MANDATORY)
            if HW_package_name == None or HW_package_supplier == None:
                logs.add('ERROR : no installation package name or supplier defined in the HW ODF')
                return None

            folder_name = os.path.join(self.HW_sample_set_path, 'OrganInstallationPackages', str(HW_package_id).zfill(6))
            if not os.path.isdir(folder_name):
                # the folder doesn't exist in the sample set package
                logs.add(f'WARNING : The package ID {HW_package_id} named "{HW_package_name}" provided by "{HW_package_supplier}"')
                logs.add(f'WARNING : is not present in the folder {path2ospath(folder_name)}')
                logs.add( 'WARNING : Some graphical or sound elements of this organ may be not rendered in GrandOrgue')
            else:
                self.available_HW_packages_id_list.append(HW_package_id)

        # recover the main installation package ID
        HW_install_package_id = myint(self.HW_ODF_get_attribute_value(self.HW_general_dic, 'OrganInfo_InstallationPackageID', MANDATORY))
        if HW_install_package_id == None:
            logs.add('ERROR : no main installation package ID defined in the HW ODF')
            return None

        # add an entry in the GO ODF dictionary for the Organ object
        GO_organ_uid = 'Organ'
        GO_organ_dic = self.GO_odf_dic[GO_organ_uid] = {}

        GO_organ_dic['ChurchName'] = mystr(self.HW_ODF_get_attribute_value(self.HW_general_dic, 'Identification_Name'))
        GO_organ_dic['ChurchAddress'] = mystr(self.HW_ODF_get_attribute_value(self.HW_general_dic, 'OrganInfo_Location'))
        GO_organ_dic['OrganBuilder'] = mystr(self.HW_ODF_get_attribute_value(self.HW_general_dic, 'OrganInfo_Builder'))
        GO_organ_dic['OrganBuildDate'] = mystr(self.HW_ODF_get_attribute_value(self.HW_general_dic, 'OrganInfo_BuildDate'))
        GO_organ_dic['OrganComments'] = ODF_COMMENT
        GO_organ_dic['RecordingDetails'] = mystr(self.HW_ODF_get_attribute_value(self.HW_general_dic, 'Control_OrganDefinitionSupplierName', MANDATORY))

        GO_organ_dic['HasPedals'] = 'N'  # will be set later in GO_ODF_build_Manual_objects
        GO_organ_dic['NumberOfManuals'] = 0
        GO_organ_dic['NumberOfPanels'] = 0
        GO_organ_dic['NumberOfWindchestGroups'] = 0
        GO_organ_dic['NumberOfRanks'] = 0
        GO_organ_dic['NumberOfSwitches'] = 0
        GO_organ_dic['NumberOfEnclosures'] = 0
        GO_organ_dic['NumberOfTremulants'] = 0
        GO_organ_dic['NumberOfGenerals'] = 0
        GO_organ_dic['NumberOfDivisionalCouplers'] = 0
        GO_organ_dic['NumberOfReversiblePistons'] = 0

        GO_organ_dic['GeneralsStoreDivisionalCouplers'] = 'Y'
        GO_organ_dic['DivisionalsStoreTremulants'] = 'Y'
        GO_organ_dic['DivisionalsStoreIntermanualCouplers'] = 'Y'
        GO_organ_dic['DivisionalsStoreIntramanualCouplers'] = 'Y'
        GO_organ_dic['CombinationsStoreNonDisplayedDrawstops'] = 'N'

        gain = myfloat(self.HW_ODF_get_attribute_value(self.HW_general_dic, 'AudioOut_AmplitudeLevelAdjustDecibels'))
        if gain not in (None, 0):
            GO_organ_dic['Gain'] = gain

        # recover the ID of the HW default display page (will be used in other GO_ODF_build_xxx functions)
        self.HW_default_display_page_dic = self.HW_ODF_get_object_by_ref_id('DisplayPage', self.HW_general_dic, 'SpecialObjects_DefaultDisplayPageID')
        if self.HW_default_display_page_dic == None:
            # cannot continue the convertion if there is no default display page defined
            logs.add('ERROR : no default display page defined in the HW ODF')
            return None

        # recover the base pitch of the organ if defined
        self.HW_organ_pitch = myfloat(self.HW_ODF_get_attribute_value(self.HW_general_dic, 'AudioEngine_BasePitchHz'))
        if self.HW_organ_pitch == 0: self.HW_organ_pitch = None

        # add in the HW _General object the ID of the corresponding GO object
        self.HW_general_dic['_GO_uid'] = 'Organ'

        return GO_organ_uid

    #-------------------------------------------------------------------------------------------------
    def GO_ODF_build_Panel_object(self, HW_disp_page_dic):
        # build a GO Panel999 corresponding to the given HW DisplayPage
        # build also the image and label objects which are defined in this panel
        # return the UID of the created GO Panel object or None in case of error

        # used HW objects :
        #   _General
        #   DisplayPage
        #   DisplayPage C> Keyboard
        #   DisplayPage C> ImageSetInstance C> ImageSet C> ImageSetElement (in function GO_ODF_build_Image_object)
        #   DisplayPage C> TextInstance C> TextStyle                       (in function GO_ODF_build_Label_object)
        #   DisplayPage C> TextInstance C> ImageSetInstance C> ImageSet C> ImageSetElement  (idem as above line)

        if self.HW_ODF_get_linked_objects_by_type(HW_disp_page_dic, 'Keyboard', TO_CHILD, FIRST_ONE) != None:
            # the current HW DisplayPage object contains at least one Keyboard object in his children, so it is the HW console page
            self.HW_console_display_page_dic = HW_disp_page_dic

        if HW_disp_page_dic == self.HW_default_display_page_dic:
            # this is the HW default display page, so assigned to the GO Panel000
            GO_panel_uid = 'Panel000'
        else:
            self.GO_odf_dic['Organ']['NumberOfPanels'] += 1  # Panel000 is not counted
            GO_panel_uid = 'Panel' + str(self.GO_odf_dic['Organ']['NumberOfPanels']).zfill(3)
        # add an GO Panel object in the GO ODF dictionary
        GO_panel_dic = self.GO_odf_dic[GO_panel_uid] = {}

        GO_panel_dic['_GO_uid'] = GO_panel_uid
        GO_panel_dic['Name'] = self.HW_ODF_get_attribute_value(HW_disp_page_dic, 'Name')
        GO_panel_dic['HasPedals'] = 'N'  # will be set later in GO_ODF_build_Manual_objects
        GO_panel_dic['NumberOfGUIElements'] = 0
        GO_panel_dic['NumberOfImages'] = 0

        if HW_disp_page_dic == self.HW_console_display_page_dic:
            # the current HW DisplayPage object is the HW console page, get the dimensions of the console page defined in the HW _General object
            GO_panel_dic['DispScreenSizeHoriz'] = myint(self.HW_ODF_get_attribute_value(self.HW_general_dic, 'Display_ConsoleScreenWidthPixels'), 0)
            GO_panel_dic['DispScreenSizeVert'] = myint(self.HW_ODF_get_attribute_value(self.HW_general_dic, 'Display_ConsoleScreenHeightPixels'), 0)
        else:
            GO_panel_dic['DispScreenSizeHoriz'] = 0  # will be set later when GO_ODF_build_Panel_size_update will be called
            GO_panel_dic['DispScreenSizeVert'] = 0

        # set the other mandatory attributes of a GO panel at a default value, no import from Hauptwerk ODF for the GO built-in console drawing
        GO_panel_dic['DispDrawstopBackgroundImageNum'] = '1'
        GO_panel_dic['DispDrawstopInsetBackgroundImageNum'] = '1'
        GO_panel_dic['DispConsoleBackgroundImageNum'] = '1'
        GO_panel_dic['DispKeyHorizBackgroundImageNum'] = '1'
        GO_panel_dic['DispKeyVertBackgroundImageNum'] = '1'
        GO_panel_dic['DispControlLabelFont'] = 'Arial'
        GO_panel_dic['DispShortcutKeyLabelFont'] = 'Arial'
        GO_panel_dic['DispShortcutKeyLabelColour'] = 'Black'
        GO_panel_dic['DispGroupLabelFont'] = 'Arial'
        GO_panel_dic['DispDrawstopCols'] = '2'
        GO_panel_dic['DispDrawstopRows'] = '1'
        GO_panel_dic['DispDrawstopColsOffset'] = 'N'
        GO_panel_dic['DispPairDrawstopCols'] = 'N'
        GO_panel_dic['DispExtraDrawstopRows'] = '0'
        GO_panel_dic['DispExtraDrawstopCols'] = '0'
        GO_panel_dic['DispButtonCols'] = '1'
        GO_panel_dic['DispExtraButtonRows'] = '0'
        GO_panel_dic['DispExtraPedalButtonRow'] = 'N'
        GO_panel_dic['DispButtonsAboveManuals'] = 'N'
        GO_panel_dic['DispExtraDrawstopRowsAboveExtraButtonRows'] = 'N'
        GO_panel_dic['DispTrimAboveManuals'] = 'N'
        GO_panel_dic['DispTrimBelowManuals'] = 'N'
        GO_panel_dic['DispTrimAboveExtraRows'] = 'N'

        # add in the HW DisplayPage object the ID of the corresponding GO object
        HW_disp_page_dic['_GO_uid'] = GO_panel_uid

        # build the GO static images of the panel by order of layer number (to be sure they will be visible in GO as designed in the HW ODF)
        HW_images_list_per_layer_dict = {}
        for HW_img_set_inst_dic in self.HW_ODF_get_linked_objects_by_type(HW_disp_page_dic, 'ImageSetInstance', TO_CHILD):
            # scan the HW ImageSetInstance objects of the given HW DisplayPage
            # to store in a local dictionary the static images of the given HW DisplayPage grouped by layer number
            if len(HW_img_set_inst_dic['_parents']) == 1:
                # the current HW ImageSetInstance object has a single parent (a DisplayPage) : it is a static image
                HW_layer_nb_int = myint(self.HW_ODF_get_attribute_value(HW_img_set_inst_dic, 'ScreenLayerNumber'), 1)  # default to 1
                if HW_layer_nb_int not in HW_images_list_per_layer_dict.keys():
                    # there is not yet an entry in the dictionary for the layer number of the current HW ImageSetInstance
                    # add one entry initialized with an empty list
                    HW_images_list_per_layer_dict[HW_layer_nb_int] = []
                # add the current HW ImageSetInstance to the list of the layer numbers
                HW_images_list_per_layer_dict[HW_layer_nb_int].append(HW_img_set_inst_dic)
        for HW_layer_nb_int in sorted(HW_images_list_per_layer_dict.keys()):
            # scan the HW display layers of the page by ascending order in order to build the images in this same order in the GO panel
            for HW_img_set_inst_dic in HW_images_list_per_layer_dict[HW_layer_nb_int]:
                # scan the HW ImageSetInstance objects of the current display layer
                self.GO_ODF_build_Image_object(HW_img_set_inst_dic, GO_panel_dic)

        return GO_panel_uid

    #-------------------------------------------------------------------------------------------------
    def GO_ODF_build_Panel_size_update(self, GO_panel_dic, x, y):
        # increase the width or height of the given GO panel so that the given coordinates are visible in this panel

        if x != None and x > GO_panel_dic['DispScreenSizeHoriz']: GO_panel_dic['DispScreenSizeHoriz'] = x
        if y != None and y > GO_panel_dic['DispScreenSizeVert']: GO_panel_dic['DispScreenSizeVert'] = y

    #-------------------------------------------------------------------------------------------------
    def GO_ODF_build_Image_object(self, HW_img_set_inst_dic, GO_panel_dic):
        # build a GO Panel999Image999 object corresponding to the given HW ImageSetInstance and in the given GO Panel
        # sub-function of GO_ODF_build_Panel_object
        # return the UID of the created GO PanelImage object or None if no panel image created

        # used HW objects :
        #   ImageSetInstance C> ImageSet C> ImageSetElement

        image_attr_dic = {}
        if self.HW_ODF_get_image_attributes(HW_img_set_inst_dic, image_attr_dic) and image_attr_dic['BitmapFilename'] != None:
            # the data about the current HW ImageSetInstance object have been recovered successfully and an image file name is defined

            if image_attr_dic['ImageWidthPixels'] == None or image_attr_dic['ImageHeightPixels'] == None:
                # if one dimension of the image is not defined, get the dimensions of the image in the bitmap file
                image_filename = os.path.dirname(self.HW_odf_file_name) + os.sep + path2ospath(image_attr_dic['BitmapFilename'])
                if os.path.isfile(image_filename):
                    im = Image.open(image_filename)
                    image_attr_dic['ImageWidthPixels'] = im.size[0]
                    image_attr_dic['ImageHeightPixels'] = im.size[1]
                else:
                    image_attr_dic['ImageWidthPixels'] = None
                    image_attr_dic['ImageHeightPixels'] = None

            # define an additional GO Panel999Image999 object for the given GO Panel
            GO_panel_uid = GO_panel_dic['_GO_uid']
            self.GO_odf_dic[GO_panel_uid]['NumberOfImages'] += 1
            GO_panel_image_uid = GO_panel_uid + 'Image' + str(self.GO_odf_dic[GO_panel_uid]['NumberOfImages']).zfill(3)
            GO_panel_image_dic = self.GO_odf_dic[GO_panel_image_uid] = {}

            # set the position and sizes of the image
            image_max_x = image_max_y = 0
            GO_panel_image_dic['PositionX'] = image_attr_dic['LeftXPosPixels']
            GO_panel_image_dic['PositionY'] = image_attr_dic['TopYPosPixels']
            if image_attr_dic['ImageWidthPixels'] != None:
                GO_panel_image_dic['Width'] = image_attr_dic['ImageWidthPixels']
                image_max_x = image_attr_dic['LeftXPosPixels'] + image_attr_dic['ImageWidthPixels']
            if image_attr_dic['ImageHeightPixels'] != None:
                GO_panel_image_dic['Height'] = image_attr_dic['ImageHeightPixels']
                image_max_y = image_attr_dic['TopYPosPixels'] + image_attr_dic['ImageHeightPixels']

            # set the image and its mask if any
            GO_panel_image_dic['Image'] = image_attr_dic['BitmapFilename']
            if image_attr_dic['TransparencyMaskBitmapFilename'] != None:
                GO_panel_image_dic['Mask'] = image_attr_dic['TransparencyMaskBitmapFilename']

            # increase if necessary the GO panel dimensions to display entirely the image
            self.GO_ODF_build_Panel_size_update(GO_panel_dic, image_max_x, image_max_y)

            # add in the HW ImageSetInstance object the ID of the corresponding GO object
            HW_img_set_inst_dic['_GO_uid'] = GO_panel_image_uid

            return GO_panel_image_uid
        else:
            return None

    #-------------------------------------------------------------------------------------------------
    def GO_ODF_build_Label_object(self, HW_text_inst_dic, GO_panel_uid):
        # build a GO Panel999Element999 object with type=Label corresponding to the given HW TextInstance and in the given GO Panel
        # sub-function of GO_ODF_build_Panel_object
        # return the UID of the created GO Panel Element object, or None if no panel element created

        # used HW objects :
            #   TextInstance C> TextStyle
            #   TextInstance C> ImageSetInstance C> ImageSet C> ImageSetElement

        text_attr_dic = {}
        if self.HW_ODF_get_text_attributes(HW_text_inst_dic, text_attr_dic):
            # the data about the current HW TextInstance object (and his linked HW ImageSetInstance object if any) have been recovered successfully

            # define an additional GO Panel999Element999 object with label type in the given GO panel
            self.GO_odf_dic[GO_panel_uid]['NumberOfGUIElements'] += 1
            GO_panel_element_uid = GO_panel_uid + 'Element' + str(self.GO_odf_dic[GO_panel_uid]['NumberOfGUIElements']).zfill(3)
            GO_panel_element_dic = self.GO_odf_dic[GO_panel_element_uid] = {}

            GO_panel_element_dic['Type'] = 'Label'
            GO_panel_element_dic['Name'] = text_attr_dic['Text'].replace('\n', ' ')  # replace eventual carriage return by black space

            # recover the display dimensions of the label text according to the font name/size/weight
            text_font = tkf.Font(family=text_attr_dic['Face_WindowsName'], size=1 * text_attr_dic['Font_SizePixels'],
                                 weight='bold' if text_attr_dic['Font_WeightCode'] == 3 else 'normal')
            text_width = text_font.measure(text_attr_dic['Text'])
            text_height = text_font.metrics('ascent') + text_font.metrics('descent')

            if text_attr_dic['Font_SizePixels'] != None:
                GO_panel_element_dic['DispLabelFontSize'] = text_attr_dic['Font_SizePixels']

            if text_attr_dic['Face_WindowsName'] != None:
                GO_panel_element_dic['DispLabelFontName'] = text_attr_dic['Face_WindowsName']

            if text_attr_dic['Colour_Red'] != None and text_attr_dic['Colour_Green'] != None and text_attr_dic['Colour_Blue'] != None:
                GO_panel_element_dic['DispLabelColour'] = '#%02x%02x%02x' % (text_attr_dic['Colour_Red'],
                                                                             text_attr_dic['Colour_Green'],
                                                                             text_attr_dic['Colour_Blue'])

            # compute the coordinates of the top left corner of the text according to the text alignment defined in the HW ODF
            if text_attr_dic['HorizontalAlignmentCode'] in (0, 3): # centered or not defined
                xpos = text_attr_dic['XPosPixels'] - int(text_width / 2)
            elif text_attr_dic['HorizontalAlignmentCode'] == 2: # right aligned
                xpos = text_attr_dic['XPosPixels'] - text_width
            else:  # left aligned
                xpos = text_attr_dic['XPosPixels']
            if xpos < 0: xpos = 0

            if text_attr_dic['VerticalAlignmentCode'] == 0: # centered
                ypos = text_attr_dic['YPosPixels'] - int(text_height / 2)
            elif text_attr_dic['VerticalAlignmentCode'] == 2: # bottom aligned
                ypos = text_attr_dic['YPosPixels'] - text_height
            else:  # top aligned or not defined
                ypos = text_attr_dic['YPosPixels']
            if ypos < 0: ypos = 0

            if (not 'BitmapFilename' in text_attr_dic.keys()) or text_attr_dic['BitmapFilename'] == None:
                # text without bitmap or with bitmap undefined, display a label without background image

                # set no image
                GO_panel_element_dic['DispImageNum'] = 0

                # set the text position
                if text_attr_dic['PosRelativeToTopLeftOfImage'] == 'Y' and 'LeftXPosPixels' in text_attr_dic.keys() and text_attr_dic['LeftXPosPixels'] != None:
                    # the text x position is relative to image position which is defined
                    GO_panel_element_dic['PositionX'] = text_attr_dic['LeftXPosPixels'] + xpos
                else:
                    GO_panel_element_dic['PositionX'] = xpos

                if text_attr_dic['PosRelativeToTopLeftOfImage'] == 'Y' and 'TopYPosPixels' in text_attr_dic.keys() and text_attr_dic['TopYPosPixels'] != None:
                    # the text y position is relative to image position which is defined
                    GO_panel_element_dic['PositionY'] = text_attr_dic['TopYPosPixels'] + ypos
                    if GO_panel_element_dic['DispLabelColour'] == '#000000':
                        # set the text in red color since it has no background image and it has a black color, to see it
                        GO_panel_element_dic['DispLabelColour'] = '#F9EE70'
                else:
                    GO_panel_element_dic['PositionY'] = ypos

                GO_panel_element_dic['Width'] = text_width
                GO_panel_element_dic['Height'] = text_height

            else:
                # the text has a background image

                # set the position of the image
                GO_panel_element_dic['PositionX'] = text_attr_dic['LeftXPosPixels']
                GO_panel_element_dic['PositionY'] = text_attr_dic['TopYPosPixels']

                if text_attr_dic['BitmapFilename'] != None:

                    # get the image dimensions if they are not defined in the HW ODF
                    img_w = img_h = None
                    if text_attr_dic['ImageWidthPixels'] == None or text_attr_dic['ImageHeightPixels'] == None:
                        image_path = self.HW_sample_set_odf_path + os.sep + path2ospath(text_attr_dic['BitmapFilename'])
                        if os.path.isfile(image_path):
                            im = Image.open(image_path)
                            img_w = im.size[0]
                            img_h = im.size[1]

                    # set the image width
                    if text_attr_dic['ImageWidthPixels'] != None:
                        GO_panel_element_dic['Width'] = text_attr_dic['ImageWidthPixels']
                    elif img_w != None:
                        GO_panel_element_dic['Width'] = img_w

                    # set the image height
                    if text_attr_dic['ImageHeightPixels'] != None:
                        GO_panel_element_dic['Height'] = text_attr_dic['ImageHeightPixels']
                    elif img_h != None:
                        GO_panel_element_dic['Height'] = img_h

                    # set the image file name
                    GO_panel_element_dic['Image'] = text_attr_dic['BitmapFilename']

                # set the image mask file name
                if text_attr_dic['TransparencyMaskBitmapFilename'] != None:
                    GO_panel_element_dic['Mask'] = text_attr_dic['TransparencyMaskBitmapFilename']

                # get the text rectangle boundary if defined
                if text_attr_dic['WordWrapWithinABoundingBox'] == 'Y':
                    if text_attr_dic['BoundingBoxWidthPixelsIfWordWrap'] not in (None, 0):
                        text_width = int(text_attr_dic['BoundingBoxWidthPixelsIfWordWrap'])
                    if text_attr_dic['BoundingBoxHeightPixelsIfWordWrap'] not in (None, 0):
                        text_height = int(text_attr_dic['BoundingBoxHeightPixelsIfWordWrap'])

                # set the position of the text inside its background image
                if xpos + text_width > GO_panel_element_dic['Width']:
                    # the text width is larger that the image witdh : center the text in the image horizontally and vertically
                    xpos = 0
                    text_width = GO_panel_element_dic['Width']
                    ypos = 0
                    text_height = GO_panel_element_dic['Height']
                if ypos + text_height > GO_panel_element_dic['Height']:
                    # the text height is larger that the image height : center the text in the image vertically
                    ypos = 0
                    text_height = GO_panel_element_dic['Height']
                GO_panel_element_dic['TextRectLeft'] = xpos
                GO_panel_element_dic['TextRectWidth'] = text_width
                GO_panel_element_dic['TextRectTop'] = ypos
                GO_panel_element_dic['TextRectHeight'] = text_height

            # check if the label is overlapping a GO panel element (switch) of the given panel
            # if yes set the text of the panel element with the label text and delete the GO label element just build above
            for object_uid in self.GO_odf_dic.keys():
                # scan the objects of the GO ODF
                if len(object_uid) == 18 and object_uid[:8] == GO_panel_uid:
                    # Panel999Element999 object of the given panel
                    GO_panelem_dic = self.GO_odf_dic[object_uid]
                    if GO_panelem_dic['Type'] not in ('Manual', 'Label'):
                        if (GO_panel_element_dic['PositionX'] >= GO_panelem_dic['PositionX'] and
                            GO_panel_element_dic['PositionX'] < GO_panelem_dic['PositionX'] + GO_panelem_dic['Width'] and
                            GO_panel_element_dic['PositionY'] >= GO_panelem_dic['PositionY'] and
                            GO_panel_element_dic['PositionY'] < GO_panelem_dic['PositionY'] + GO_panelem_dic['Height']):
                            # the top left corner of the text is inside the switch image area
                            GO_panelem_dic['DispLabelText'] += GO_panel_element_dic['Name'] + ' '
                            GO_panelem_dic['DispLabelFontSize'] = 11
                            GO_panelem_dic['DispLabelColour'] = 'Black'
                            self.GO_odf_dic.pop(GO_panel_element_uid)
                            self.GO_odf_dic[GO_panel_uid]['NumberOfGUIElements'] -= 1
                            return None

            # add in the HW TextInstance and ImageSetInstance objects the ID of the corresponding GO object
            HW_text_inst_dic['_GO_uid'] = GO_panel_element_uid
            if text_attr_dic['ImageSetInstanceDic'] != None:
                text_attr_dic['ImageSetInstanceDic']['_GO_uid'] = GO_panel_element_uid

            return GO_panel_element_uid
        else:
            return None

    #-------------------------------------------------------------------------------------------------
    def GO_ODF_build_Manual_object(self, HW_division_dic):
        # build a GO Manual999 object based on the given HW Division
        # return the UID of the GO Manuel object build or already existing

        # used HW objects :
        #   Division C> Keyboard C> KeyboardKey P> Switch C> ImageSetInstance C> ImageSet C> ImageSetElement  ==> keyboard_display_mode = 1
        #   Division C> Keyboard C> KeyImageSet C> ImageSet C> ImageSetElement                                ==> keyboard_display_mode = 2

        if HW_division_dic['_GO_uid'] != '':
            # a GO manual has been already assigned to the HW division, we can exit
            return HW_division_dic['_GO_uid']

        # get the first visible HW Keyboard associated to the given HW Division
        HW_keyboard_dic = None
        for HW_keyb_dic in self.HW_ODF_get_linked_objects_by_type(HW_division_dic, 'Keyboard', TO_CHILD):
            # scan the HW Keyboard objects belonging to the given HW Division, to search the first one which has a KeyImageSet or KeyboardKey child
            if (self.HW_ODF_get_linked_objects_by_type(HW_keyb_dic, 'KeyImageSet', TO_CHILD, FIRST_ONE) != None or
                self.HW_ODF_get_linked_objects_by_type(HW_keyb_dic, 'KeyboardKey', TO_CHILD, FIRST_ONE) != None):
                HW_keyboard_dic = HW_keyb_dic
                break

        # get how the HW keyboard is graphically defined
        keyboard_display_mode = 0  # by default the keyboard is not visible
        if HW_keyboard_dic != None:
            if self.HW_ODF_get_linked_objects_by_type(HW_keyboard_dic, 'KeyboardKey', TO_CHILD, FIRST_ONE) != None:
                keyboard_display_mode = 1  # the keyboard is graphically defined by KeyboardKey objects (which should be linked to a Switch + ImageSetInstance)
            elif self.HW_ODF_get_attribute_value(HW_keyboard_dic, 'KeyGen_KeyImageSetID') != None:
                keyboard_display_mode = 2  # the keyboard is graphically defined by a KeyImageSet object

        # define the GO Manual999 object to associate to this HW Division
        HW_division_id = int(HW_division_dic['_HW_uid'][-6:])
        if HW_division_id == 1:
            # Pedal division
            GO_manual_uid = 'Manual000'
        else:
            self.GO_odf_dic['Organ']['NumberOfManuals'] += 1
            GO_manual_uid = 'Manual' + str(self.GO_odf_dic['Organ']['NumberOfManuals']).zfill(3)
        GO_manual_dic = self.GO_odf_dic[GO_manual_uid] = {}
        GO_manual_dic['_GO_uid'] = GO_manual_uid

        # add in the HW Division and Keyboard objects the UID of the corresponding GO object
        HW_division_dic['_GO_uid'] = GO_manual_uid
        if HW_keyboard_dic != None:
            HW_keyboard_dic['_GO_uid'] = GO_manual_uid

        # update in the GO Organ and Panel objects the HasPedal attribute value
        if GO_manual_uid == 'Manual000':
            self.GO_odf_dic['Organ']['HasPedals'] = 'Y'
            if self.HW_console_display_page_dic != None:
                self.GO_odf_dic[self.HW_console_display_page_dic['_GO_uid']]['HasPedals'] = 'Y'

        # recover the number of keys of the keyboard and its first and last MIDI note numbers
        if keyboard_display_mode == 1:
            # recover this from the HW KeyboardKey objects belonging to the HW Keyboard and being linked to an ImageSetInstance
            first_midi_note_nb_int = 999
            last_midi_note_nb_int = 0
            nb_keys_int = 0
            keys_switch_dic = {}  # dictionary with as key the MIDI note number and as value the corresponding HW Switch object
            for HW_keyboard_key_dic in self.HW_ODF_get_linked_objects_by_type(HW_keyboard_dic, 'KeyboardKey', TO_CHILD):
                # scan the HW KeyboardKey objects which are children of the HW Keyboard
                # recover the HW ImageSetInstance associated to the HW Switch associated to the current HW KeyboardKey
                HW_switch_dic = self.HW_ODF_get_object_by_ref_id('Switch', HW_keyboard_key_dic, 'SwitchID')
                HW_img_set_instance_id = myint(self.HW_ODF_get_attribute_value(HW_switch_dic, 'Disp_ImageSetInstanceID'))
                if HW_img_set_instance_id != None:
                    # the current HW KeyboardKey has an associated HW ImageSetInstance (in Grabowski Enerlo the highest keys have no image)
                    nb_keys_int += 1
                    # get the MIDI note number of the current HW KeyboardKey object
                    midi_note_nb_int = myint(self.HW_ODF_get_attribute_value(HW_keyboard_key_dic, 'NormalMIDINoteNumber'))
                    if midi_note_nb_int == None: midi_note_nb_int = 60 # observed with Sound Paradisi sample sets, the MIDI note 60 is not defined
                    # update the first and last MIDI note numbers
                    if midi_note_nb_int < first_midi_note_nb_int: first_midi_note_nb_int = midi_note_nb_int
                    if midi_note_nb_int > last_midi_note_nb_int:  last_midi_note_nb_int = midi_note_nb_int
                    # add an entry in the keys switch dictionary with the HW Switch associated to the current HW KeyboardKey
                    keys_switch_dic[midi_note_nb_int] = self.HW_ODF_get_object_by_ref_id('Switch', HW_keyboard_key_dic, 'SwitchID')
                    # add in the HW KeyboardKey object the UID of the corresponding GO object
                    HW_keyboard_key_dic['_GO_uid'] = GO_manual_uid
        elif keyboard_display_mode == 2:
            # recover this from the KeyGen attributes of the HW Keyboard
            nb_keys_int = myint(self.HW_ODF_get_attribute_value(HW_keyboard_dic, 'KeyGen_NumberOfKeys'))
            first_midi_note_nb_int = myint(self.HW_ODF_get_attribute_value(HW_keyboard_dic, 'KeyGen_MIDINoteNumberOfFirstKey'))
            last_midi_note_nb_int = first_midi_note_nb_int + nb_keys_int - 1
        else: # keyboard_display_mode == 0 (not visible keyboards)
            # recover this from the InpGen attributes of the HW Division or the KeyGen attributes of the HW Keyboard
            nb_keys_int = myint(self.HW_ODF_get_attribute_value(HW_division_dic, 'InpGen_NumberOfInputs'))
            if nb_keys_int == None:
                nb_keys_int = myint(self.HW_ODF_get_attribute_value(HW_keyboard_dic, 'KeyGen_NumberOfKeys'))

            first_midi_note_nb_int = myint(self.HW_ODF_get_attribute_value(HW_division_dic, 'InpGen_MIDINoteNumberOfFirstInput'))
            if first_midi_note_nb_int == None:
                first_midi_note_nb_int = myint(self.HW_ODF_get_attribute_value(HW_keyboard_dic, 'KeyGen_MIDINoteNumberOfFirstKey'))

            # if still not know, try to recover from the number of HW DivisionInput objects
            if nb_keys_int == None:
                HW_div_inputs_list = self.HW_ODF_get_linked_objects_by_type(HW_division_dic, 'DivisionInput', TO_CHILD)
                if len(HW_div_inputs_list) > 0:
                    nb_keys_int = len(HW_div_inputs_list)
                    first_midi_note_nb_int = 999
                    for HW_div_input_dic in HW_div_inputs_list:
                        midi_not_nb = myint(self.HW_ODF_get_attribute_value(HW_div_input_dic, 'NormalMIDINoteNumber'))
                        if midi_not_nb != None and midi_not_nb < first_midi_note_nb_int:
                            first_midi_note_nb_int = midi_not_nb

            if nb_keys_int != None and first_midi_note_nb_int != None:
                last_midi_note_nb_int = first_midi_note_nb_int + nb_keys_int - 1
            else:
                nb_keys_int = first_midi_note_nb_int = last_midi_note_nb_int = 0

        # get the HW DisplayPage in which is displayed the keyboard
        if keyboard_display_mode == 1:
            # recover this from the HW ImageSetInstance of the first key of the keyboard
            HW_img_set_instance_id = myint(self.HW_ODF_get_attribute_value(keys_switch_dic[first_midi_note_nb_int], 'Disp_ImageSetInstanceID', MANDATORY))
            HW_img_set_instance_dic = self.HW_ODF_get_object_dic('ImageSetInstance', HW_img_set_instance_id)
            keyboard_disp_page_id = myint(self.HW_ODF_get_attribute_value(HW_img_set_instance_dic, 'DisplayPageID'))
        elif keyboard_display_mode == 2:
            keyboard_disp_page_id = myint(self.HW_ODF_get_attribute_value(HW_keyboard_dic, 'KeyGen_DisplayPageID'))

        GO_manual_dic['Name'] = self.HW_ODF_get_attribute_value(HW_division_dic, 'Name')
        GO_manual_dic['NumberOfLogicalKeys'] = nb_keys_int
        GO_manual_dic['NumberOfAccessibleKeys'] = nb_keys_int
        GO_manual_dic['FirstAccessibleKeyLogicalKeyNumber'] = 1
        GO_manual_dic['FirstAccessibleKeyMIDINoteNumber'] = first_midi_note_nb_int
        GO_manual_dic['NumberOfStops'] = 0
        GO_manual_dic['NumberOfSwitches'] = 0
        GO_manual_dic['NumberOfCouplers'] = 0
        GO_manual_dic['NumberOfDivisionals'] = 0
        GO_manual_dic['NumberOfTremulants'] = 0

        if keyboard_display_mode == 0:
            # the keyboard is not visible, we can stop here the definition of the GO Manual
            return GO_manual_uid

        # define the manual graphical attributes in a Panel999Element999 object with Type = Manual

        # get the GO Panel UID in which to display the keyboard
        HW_disp_page_dic = self.HW_ODF_get_object_dic('DisplayPage', keyboard_disp_page_id)
        GO_panel_uid = HW_disp_page_dic['_GO_uid']

        # create the GO Panel999Element999 object to display the keyboard
        self.GO_odf_dic[GO_panel_uid]['NumberOfGUIElements'] += 1
        GO_panel_element_uid = GO_panel_uid + 'Element' + str(self.GO_odf_dic[GO_panel_uid]['NumberOfGUIElements']).zfill(3)
        GO_panel_element_dic = self.GO_odf_dic[GO_panel_element_uid] = {}

        GO_panel_element_dic['Type'] = 'Manual'
        GO_panel_element_dic['Manual'] = str(int(GO_manual_uid[-3:])).zfill(3)

        GO_panel_element_dic['_GO_uid'] = GO_manual_uid

        # define the graphical properties of the GO Manual
        if keyboard_display_mode == 1:
            # keys graphical aspect is defined for each key
            for midi_note_nb_int in range(first_midi_note_nb_int, last_midi_note_nb_int + 1):
                # scan the switches of the HW Keyboard by increasing MIDI note number
                GO_key_nb = midi_note_nb_int - first_midi_note_nb_int + 1

                if midi_note_nb_int < last_midi_note_nb_int:
                    # it is not the latest key of the keyboard
                    self.GO_ODF_build_Manual_keyimage_by_switch(keys_switch_dic[midi_note_nb_int], keys_switch_dic[midi_note_nb_int + 1], GO_panel_element_dic, GO_key_nb)
                else:
                    self.GO_ODF_build_Manual_keyimage_by_switch(keys_switch_dic[midi_note_nb_int], None, GO_panel_element_dic, GO_key_nb)

        else:
            # keys graphical aspect is defined for one octave + the first and last keys

            # get the HW KeyImageSet associated to the HW Keyboard
            HW_key_img_set_dic = self.HW_ODF_get_object_by_ref_id('KeyImageSet', HW_keyboard_dic, 'KeyGen_KeyImageSetID')

            # set the GO Manual position
            GO_panel_element_dic['PositionX'] = myint(self.HW_ODF_get_attribute_value(HW_keyboard_dic, 'KeyGen_DispKeyboardLeftXPos'))
            GO_panel_element_dic['PositionY'] = myint(self.HW_ODF_get_attribute_value(HW_keyboard_dic, 'KeyGen_DispKeyboardTopYPos'))

            # set the GO Manual keys width
            GO_panel_element_dic['Width_A']   = self.HW_ODF_get_attribute_value(HW_key_img_set_dic, 'HorizSpacingPixels_LeftOfDASharpFromLeftOfDA')
            GO_panel_element_dic['Width_Ais'] = self.HW_ODF_get_attribute_value(HW_key_img_set_dic, 'HorizSpacingPixels_LeftOfEBFromLeftOfDASharp')
            GO_panel_element_dic['Width_B']   = self.HW_ODF_get_attribute_value(HW_key_img_set_dic, 'HorizSpacingPixels_LeftOfNaturalFromLeftOfNatural')
            GO_panel_element_dic['Width_C']   = self.HW_ODF_get_attribute_value(HW_key_img_set_dic, 'HorizSpacingPixels_LeftOfCFSharpFromLeftOfCF')
            GO_panel_element_dic['Width_Cis'] = self.HW_ODF_get_attribute_value(HW_key_img_set_dic, 'HorizSpacingPixels_LeftOfDGFromLeftOfCFSharp')
            GO_panel_element_dic['Width_D']   = self.HW_ODF_get_attribute_value(HW_key_img_set_dic, 'HorizSpacingPixels_LeftOfDASharpFromLeftOfDA')
            GO_panel_element_dic['Width_Dis'] = self.HW_ODF_get_attribute_value(HW_key_img_set_dic, 'HorizSpacingPixels_LeftOfEBFromLeftOfDASharp')
            GO_panel_element_dic['Width_E']   = self.HW_ODF_get_attribute_value(HW_key_img_set_dic, 'HorizSpacingPixels_LeftOfNaturalFromLeftOfNatural')
            GO_panel_element_dic['Width_F']   = self.HW_ODF_get_attribute_value(HW_key_img_set_dic, 'HorizSpacingPixels_LeftOfCFSharpFromLeftOfCF')
            GO_panel_element_dic['Width_Fis'] = self.HW_ODF_get_attribute_value(HW_key_img_set_dic, 'HorizSpacingPixels_LeftOfDGFromLeftOfCFSharp')
            GO_panel_element_dic['Width_G']   = self.HW_ODF_get_attribute_value(HW_key_img_set_dic, 'HorizSpacingPixels_LeftOfGSharpFromLeftOfG')
            GO_panel_element_dic['Width_Gis'] = self.HW_ODF_get_attribute_value(HW_key_img_set_dic, 'HorizSpacingPixels_LeftOfAFromLeftOfGSharp')

            # set the GO Manual keys offset
            GO_panel_element_dic['Offset_A']   = '0'
            GO_panel_element_dic['Offset_Ais'] = '0'
            GO_panel_element_dic['Offset_B']   = '0'
            GO_panel_element_dic['Offset_C']   = '0'
            GO_panel_element_dic['Offset_Cis'] = '0'
            GO_panel_element_dic['Offset_D']   = '0'
            GO_panel_element_dic['Offset_Dis'] = '0'
            GO_panel_element_dic['Offset_E']   = '0'
            GO_panel_element_dic['Offset_F']   = '0'
            GO_panel_element_dic['Offset_Fis'] = '0'
            GO_panel_element_dic['Offset_G']   = '0'
            GO_panel_element_dic['Offset_Gis'] = '0'

            # get the key up (not pressed) and key down (pressed) images index within image set if defined, else set default index
            key_up_img_index = myint(self.HW_ODF_get_attribute_value(HW_key_img_set_dic, 'ImageIndexWithinImageSets_Disengaged'))
            if key_up_img_index == None: key_up_img_index = 1
            HW_key_img_set_dic['_key_up_img_index'] = key_up_img_index

            key_down_img_index = myint(self.HW_ODF_get_attribute_value(HW_key_img_set_dic, 'ImageIndexWithinImageSets_Engaged'))
            if key_down_img_index == None: key_down_img_index = 2
            HW_key_img_set_dic['_key_down_img_index'] = key_down_img_index

            # set the GO Manual keys images
            self.GO_ODF_build_Manual_keyimage_by_keytype(HW_key_img_set_dic, 'CF', GO_panel_element_dic, 'C')
            self.GO_ODF_build_Manual_keyimage_by_keytype(HW_key_img_set_dic, 'CF', GO_panel_element_dic, 'F')
            self.GO_ODF_build_Manual_keyimage_by_keytype(HW_key_img_set_dic, 'D', GO_panel_element_dic, 'D')
            self.GO_ODF_build_Manual_keyimage_by_keytype(HW_key_img_set_dic, 'EB', GO_panel_element_dic, 'E')
            self.GO_ODF_build_Manual_keyimage_by_keytype(HW_key_img_set_dic, 'EB', GO_panel_element_dic, 'B')
            self.GO_ODF_build_Manual_keyimage_by_keytype(HW_key_img_set_dic, 'G', GO_panel_element_dic, 'G')
            self.GO_ODF_build_Manual_keyimage_by_keytype(HW_key_img_set_dic, 'A', GO_panel_element_dic, 'A')
            self.GO_ODF_build_Manual_keyimage_by_keytype(HW_key_img_set_dic, 'Sharp', GO_panel_element_dic, 'Ais')
            self.GO_ODF_build_Manual_keyimage_by_keytype(HW_key_img_set_dic, 'Sharp', GO_panel_element_dic, 'Cis')
            self.GO_ODF_build_Manual_keyimage_by_keytype(HW_key_img_set_dic, 'Sharp', GO_panel_element_dic, 'Dis')
            self.GO_ODF_build_Manual_keyimage_by_keytype(HW_key_img_set_dic, 'Sharp', GO_panel_element_dic, 'Fis')
            self.GO_ODF_build_Manual_keyimage_by_keytype(HW_key_img_set_dic, 'Sharp', GO_panel_element_dic, 'Gis')

            # set the GO Manual first key image and width
            first_note_name, octave = midi_number_to_note(int(first_midi_note_nb_int))
            if first_note_name == 'D':
                self.GO_ODF_build_Manual_keyimage_by_keytype(HW_key_img_set_dic, 'FirstKeyDA', GO_panel_element_dic, 'FirstD')
                GO_panel_element_dic['Width_FirstD'] = self.HW_ODF_get_attribute_value(HW_key_img_set_dic, 'HorizSpacingPixels_LeftOfDASharpFromLeftOfDA')
            elif first_note_name == 'A':
                self.GO_ODF_build_Manual_keyimage_by_keytype(HW_key_img_set_dic, 'FirstKeyDA', GO_panel_element_dic, 'FirstA')
                GO_panel_element_dic['Width_FirstA'] = self.HW_ODF_get_attribute_value(HW_key_img_set_dic, 'HorizSpacingPixels_LeftOfDASharpFromLeftOfDA')
            elif first_note_name == 'G':
                self.GO_ODF_build_Manual_keyimage_by_keytype(HW_key_img_set_dic, 'FirstKeyG', GO_panel_element_dic, 'FirstG')
                GO_panel_element_dic['Width_FirstG'] = self.HW_ODF_get_attribute_value(HW_key_img_set_dic, 'HorizSpacingPixels_LeftOfGSharpFromLeftOfG')
            elif first_note_name == 'C':
                self.GO_ODF_build_Manual_keyimage_by_keytype(HW_key_img_set_dic, 'CF', GO_panel_element_dic, 'FirstC')
                GO_panel_element_dic['Width_FirstC'] = self.HW_ODF_get_attribute_value(HW_key_img_set_dic, 'HorizSpacingPixels_LeftOfCFSharpFromLeftOfCF')

            # set the GO Manual last key image and width
            last_note_name, octave = midi_number_to_note(int(last_midi_note_nb_int))
            if last_note_name == 'D':
                self.GO_ODF_build_Manual_keyimage_by_keytype(HW_key_img_set_dic, 'LastKeyDG', GO_panel_element_dic, 'LastD')
                GO_panel_element_dic['Width_LastD'] = self.HW_ODF_get_attribute_value(HW_key_img_set_dic, 'HorizSpacingPixels_LeftOfNaturalFromLeftOfNatural')
            elif last_note_name == 'G':
                self.GO_ODF_build_Manual_keyimage_by_keytype(HW_key_img_set_dic, 'LastKeyDG', GO_panel_element_dic, 'LastG')
                GO_panel_element_dic['Width_LastG'] = self.HW_ODF_get_attribute_value(HW_key_img_set_dic, 'HorizSpacingPixels_LeftOfNaturalFromLeftOfNatural')
            elif last_note_name == 'A':
                self.GO_ODF_build_Manual_keyimage_by_keytype(HW_key_img_set_dic, 'LastKeyA', GO_panel_element_dic, 'LastA')
                GO_panel_element_dic['Width_LastA'] = self.HW_ODF_get_attribute_value(HW_key_img_set_dic, 'HorizSpacingPixels_LeftOfNaturalFromLeftOfNatural')
            elif last_note_name == 'C':
                self.GO_ODF_build_Manual_keyimage_by_keytype(HW_key_img_set_dic, 'WholeNatural', GO_panel_element_dic, 'LastC')
                GO_panel_element_dic['Width_LastC'] = self.HW_ODF_get_attribute_value(HW_key_img_set_dic, 'HorizSpacingPixels_LeftOfNaturalFromLeftOfNatural')
            elif last_note_name == 'F':
                self.GO_ODF_build_Manual_keyimage_by_keytype(HW_key_img_set_dic, 'WholeNatural', GO_panel_element_dic, 'LastF')
                GO_panel_element_dic['Width_LastF'] = self.HW_ODF_get_attribute_value(HW_key_img_set_dic, 'HorizSpacingPixels_LeftOfNaturalFromLeftOfNatural')

        return GO_manual_uid

    #-------------------------------------------------------------------------------------------------
    def GO_ODF_build_Manual_keyimage_by_keytype(self, HW_key_img_set_dic, HW_key_type, GO_panel_element_dic, GO_key_type):
        # add in the given GO panel element the key images attributes of the given HW key type
        # sub-function of GO_ODF_build_Manual_object

        HW_image_set_id = myint(self.HW_ODF_get_attribute_value(HW_key_img_set_dic, 'KeyShapeImageSetID_' + HW_key_type))
        if HW_image_set_id != None:
            HW_image_set_dic = self.HW_ODF_get_object_dic('ImageSet', HW_image_set_id)

            # image for key up (not pressed)
            image_attr_dic = {}
            self.HW_ODF_get_image_attributes(HW_image_set_dic, image_attr_dic, HW_key_img_set_dic['_key_up_img_index'])
            if image_attr_dic['BitmapFilename'] != None:
                GO_panel_element_dic['ImageOff_' + GO_key_type] = image_attr_dic['BitmapFilename']
            if image_attr_dic['TransparencyMaskBitmapFilename'] != None:
                GO_panel_element_dic['MaskOff_' + GO_key_type] = image_attr_dic['TransparencyMaskBitmapFilename']

            # image for key down (pressed)
            image_attr_dic = {}
            self.HW_ODF_get_image_attributes(HW_image_set_dic, image_attr_dic, HW_key_img_set_dic['_key_down_img_index'])
            if image_attr_dic['BitmapFilename'] != None:
                GO_panel_element_dic['ImageOn_' + GO_key_type] = image_attr_dic['BitmapFilename']
            if image_attr_dic['TransparencyMaskBitmapFilename'] != None:
                GO_panel_element_dic['MaskOn_' + GO_key_type] = image_attr_dic['TransparencyMaskBitmapFilename']

    #-------------------------------------------------------------------------------------------------
    def GO_ODF_build_Manual_keyimage_by_switch(self, HW_switch_dic, HW_next_switch_dic, GO_panel_element_dic, GO_key_nb):
        # add in the given GO panel element the key images attributes of the given HW Switch
        # sub-function of GO_ODF_build_Manual_object

        if HW_switch_dic == None: return

        HW_img_set_instance_id = myint(self.HW_ODF_get_attribute_value(HW_switch_dic, 'Disp_ImageSetInstanceID', MANDATORY))
        HW_img_set_instance_dic = self.HW_ODF_get_object_dic('ImageSetInstance', HW_img_set_instance_id)

        # get the key engaged and disengaged images indexes
        key_up_img_index = myint(self.HW_ODF_get_attribute_value(HW_switch_dic, 'Disp_ImageSetIndexDisengaged', MANDATORY))
        key_down_img_index = myint(self.HW_ODF_get_attribute_value(HW_switch_dic, 'Disp_ImageSetIndexEngaged', MANDATORY))

        # add in the HW Switch and ImageSetInstance objects the UID of the corresponding GO object
        HW_switch_dic['_GO_uid'] = GO_panel_element_dic['_GO_uid']
        HW_img_set_instance_dic['_GO_uid'] = GO_panel_element_dic['_GO_uid']

        key_nb_3digit_str = str(GO_key_nb).zfill(3)

        if GO_key_nb == 1:
            # set the GO keyboard position which is the position of the first key
            image_attr_dic = {}
            self.HW_ODF_get_image_attributes(HW_img_set_instance_dic, image_attr_dic, key_up_img_index)
            GO_panel_element_dic['PositionX'] = image_attr_dic['LeftXPosPixels']
            GO_panel_element_dic['PositionY'] = image_attr_dic['TopYPosPixels']

        # image for key up (not pressed)
        image_attr_dic = {}
        self.HW_ODF_get_image_attributes(HW_img_set_instance_dic, image_attr_dic, key_up_img_index)
        if image_attr_dic['BitmapFilename'] != None:
            GO_panel_element_dic['Key' + key_nb_3digit_str + 'ImageOff'] = image_attr_dic['BitmapFilename']
        if image_attr_dic['TransparencyMaskBitmapFilename'] != None:
            GO_panel_element_dic['Key' + key_nb_3digit_str + 'MaskOff'] = image_attr_dic['TransparencyMaskBitmapFilename']

        # image for key down (pressed)
        image_attr_dic = {}
        self.HW_ODF_get_image_attributes(HW_img_set_instance_dic, image_attr_dic, key_down_img_index)
        if image_attr_dic['BitmapFilename'] != None:
            GO_panel_element_dic['Key' + key_nb_3digit_str + 'ImageOn'] = image_attr_dic['BitmapFilename']
        if image_attr_dic['TransparencyMaskBitmapFilename'] != None:
            GO_panel_element_dic['Key' + key_nb_3digit_str + 'MaskOn'] = image_attr_dic['TransparencyMaskBitmapFilename']

        # width/offset of the key, width calculated by the diff of XPos of the key and its next one
        if HW_next_switch_dic != None:
            HW_next_img_set_instance_id = myint(self.HW_ODF_get_attribute_value(HW_next_switch_dic, 'Disp_ImageSetInstanceID', MANDATORY))
            HW_next_img_set_instance_dic = self.HW_ODF_get_object_dic('ImageSetInstance', HW_next_img_set_instance_id)

            next_image_dic = {}
            self.HW_ODF_get_image_attributes(HW_next_img_set_instance_dic, next_image_dic, key_up_img_index)
            key_width = int(next_image_dic['LeftXPosPixels']) - int(image_attr_dic['LeftXPosPixels'])
            GO_panel_element_dic['Key' + key_nb_3digit_str + 'Width'] = str(key_width)
            GO_panel_element_dic['Key' + key_nb_3digit_str + 'Offset'] = '0'

            if GO_panel_element_dic['PositionY'] != image_attr_dic['TopYPosPixels']:
                GO_panel_element_dic['Key' + key_nb_3digit_str + 'YOffset'] = image_attr_dic['TopYPosPixels'] - GO_panel_element_dic['PositionY']

    #-------------------------------------------------------------------------------------------------
    def GO_ODF_build_Drawstop_objects(self, HW_object_dic, HW_division_dic):
        # build the GO drawstop objects (Stop, Coupler, Tremulant, Setter) from the given HW object (Stop, KeyAction, Tremulant, Switch) and build their engage/disengage noise stops
        # return the UID of the built main Stop / Coupler / Tremulant / Setter

        # possible created GO drawstops :
        #   Switch + Coupler + Stop (attack noise) + Stop (release noise)
        #   Switch + Stop (pipes ranks) + alternate Stop (pipes rank) + Stop (attack noise) + Stop (release noise)
        #   Switch + Stop (attack noise : blower, nachtigall...)
        #   the Switch is created with its controlling switches

        # used HW objects :
        #   coupler :
        #     Switch C> KeyAction
        #   tremulant :
        #     Switch C> Tremulant
        #   pipes ranks stop :
        #     Switch C> Stop C> StopRank(s) (ActionTypeCode = 1, ActionEffectCode = 1) C> Rank C> Pipe_SoundEngine01 ... (main or alternate rank)
        #     Switch C> Stop (Hint_PrimaryAssociatedRankID) C> Rank C> Pipe_SoundEngine01 ... (for some demo sample sets where there is no StopRank object defined)
        #   engage noise stop :
        #     Switch C> Stop C> StopRank (ActionTypeCode = 21, ActionEffectCode = 2) C> Rank C> Pipe_SoundEngine01 ...
        #     Switch C> SwitchLinkage (EngageLinkActionCode=4, DisengageLinkActionCode=7) C> Switch C> Pipe_SoundEngine01 ...
        #   engage noise stop or general noise stop (i.e. blower) :
        #     Switch C> Pipe_SoundEngine01 C> Pipe_SoundEngine01Layer C> Pipe_SoundEngine01_AttackSample (no ReleaseSample) ...
        #   disengage noise stop :
        #     Switch C> Stop C> StopRank (ActionTypeCode = 21, ActionEffectCode = 3) C> Rank C> Pipe_SoundEngine01 ...
        #     Switch C> SwitchLinkage (EngageLinkActionCode=7, DisengageLinkActionCode=4) C> Switch C> Pipe_SoundEngine01 ...
        #     Switch C> SwitchLinkage (EngageLinkActionCode=1, DisengageLinkActionCode=2, SourceSwitchLinkIfEngaged=N) C> Switch C> Pipe_SoundEngine01 ...
        #     Switch C> Pipe_SoundEngine01 C> Pipe_SoundEngine01Layer C> Pipe_SoundEngine01_ReleaseSample (AttackSample ignored) ...
        #   general noise stop (i.e. blower) :
        #     Switch C> Stop C> StopRank (ActionTypeCode = 21, ActionEffectCode = 1) C> Rank C> Pipe_SoundEngine01 ...
        #   alternate rank control switch :
        #     Switch C> StopRank(s)
        #   not supported :
        #     Switch C> DivisionInput
        #     Switch C> ContinuousControlLinkage

        if HW_object_dic == None:
            return None

        HW_object_type = HW_object_dic['_HW_uid'][:-6]
        HW_object_name = HW_object_dic['Name']

        if LOG_HW2GO_drawstop: print(f"{HW_object_dic['_HW_uid']} '{HW_object_name}'")

        if HW_object_dic['_GO_uid'] != '':
            # the given HW object has been already converted to a GO object, return its UID
            if LOG_HW2GO_drawstop: print(f"      already converted to GO {HW_object_dic['_GO_uid']}")
            return HW_object_dic['_GO_uid']

        # recover the GO manual corresponding to the given HW division
        if HW_division_dic != None:
            GO_manual_dic = self.GO_odf_dic[HW_division_dic['_GO_uid']]
            GO_manual_id = int(HW_division_dic['_GO_uid'][-3:])
        else:
            GO_manual_dic = None
            GO_manual_id = ''


        #----------------------------------
        # find the HW switches associated to the given HW KeyAction / Stop / Tremulant / Switch

        # recover the HW switch controlling the given HW object, or itself if it is a switch
        if HW_object_type in ('Stop', 'Tremulant'):
            HW_cntrl_switch_dic = self.HW_ODF_get_object_by_ref_id('Switch', HW_object_dic, 'ControllingSwitchID')
        elif HW_object_type == 'KeyAction':
            HW_cntrl_switch_dic = self.HW_ODF_get_object_by_ref_id('Switch', HW_object_dic, 'ConditionSwitchID')
        elif HW_object_type == 'Switch':
            HW_cntrl_switch_dic = HW_object_dic
        else:
            if LOG_HW2GO_drawstop: print(f"ERROR : wrong HW object type given to GO_ODF_build_Drawstop_objects")
            return None

        HW_switches_ctrl_formula_dic = {}  # logical formula describing how are acting together all the various switches controlling the given HW object
        HW_switches_main_branch_list = []  # list of HW switches in the main branch (i.e. without condition) linked to the given HW object

        switch_has_cond_effect = False

        # recover the logical formula describing how are acting together the various HW switches controlling the given HW object
        # recover as well the list of the HW switches controlled without condition (main branch) by the given HW object or its controlling switch
        if HW_cntrl_switch_dic != None:
            HW_switches_ctrl_formula_dic = self.HW_ODF_get_controlling_switches(HW_cntrl_switch_dic, HW_switches_main_branch_list)
            if LOG_HW2GO_drawstop: print(f"     controlled by {self.HW_DIC2UID(HW_switches_ctrl_formula_dic)}")
            if LOG_HW2GO_drawstop: print(f"     main controlling branch is {self.HW_DIC2UID(HW_switches_main_branch_list)}")

            # get the list of HW switches controlled by the controlling HW Switch
            HW_controlled_switches_list = []
            ret = self.HW_ODF_get_controlled_switches(HW_cntrl_switch_dic, HW_controlled_switches_list)
            if LOG_HW2GO_drawstop: print(f"     controlled switches are {self.HW_DIC2UID(HW_controlled_switches_list)}")
            if ret == 'conditional' and HW_object_type == 'Switch':
                switch_has_cond_effect = True
            elif ret == 'other_action_codes' and HW_object_type == 'Switch':
                if LOG_HW2GO_drawstop: print(f"     is a switch with not standard actions codes controlling linkage ====> SKIPPED")
                return None
            else:
                # add the controlled switches to the main switches branch list
                for HW_switch_dic in HW_controlled_switches_list:
                    if HW_switch_dic not in HW_switches_main_branch_list:
                        HW_switches_main_branch_list.append(HW_switch_dic)
        else:
            # the given HW object has no controlling switch
            if HW_object_type == 'KeyAction':
                # a KeyAction between different division/keyboard and without controlling switch
                # can be converted to a coupler engaged by default
                GO_coupler_attr_dic = self.GO_ODF_build_Coupler_attributes(HW_object_dic)
                if GO_coupler_attr_dic != None:
                    # create the GO coupler object in the ODF and in the manual, engaged by default, without switch and graphic interface
                    GO_manual_dic['NumberOfCouplers'] += 1
                    GO_object_uid = 'Coupler' + str(GO_manual_id).zfill(1) + str(GO_manual_dic['NumberOfCouplers']).zfill(2)
                    GO_object_dic = self.GO_odf_dic[GO_object_uid] = {}
                    GO_manual_dic['Coupler' + str(GO_manual_dic['NumberOfCouplers']).zfill(3)] = GO_object_uid[-3:]
                    # copy in it the GO coupler attributes
                    for key, value in GO_coupler_attr_dic.items():
                        if key[0] != '_':
                            GO_object_dic[key] = value
                    GO_object_dic['DefaultToEngaged'] = 'Y'
                    if LOG_HW2GO_drawstop: print(f"     GO Coupler {GO_object_uid} built, engaged by default")
                    return GO_object_uid
                else:
                    if LOG_HW2GO_drawstop: print(f"     GO Coupler attributes NOT built from {HW_object_dic['_HW_uid']} and none controlling switch found")
                    return None
            else:
                if LOG_HW2GO_drawstop: print(f"     None controlling switch found")
                return None

        #----------------------------------
        # try to build GO coupler / stops (pipes, noises) / tremulant / switch from each HW switch of the main controlling branch depending on what each one is controlling
        # and only if it will have a functional effect in GrandOrgue

        GO_objects_attr_list = []     # list containing dictionaries with the attributes of the GO functional objects linked to the given HW object
        nb_couplers = 0
        nb_pipes_stops = 0
        nb_noise_stops = 0
        nb_tremulants = 0
        has_cc_linkage = False        # set at True if one switch is controlling a ContinuousControlLinkage object
        has_wc_linkage = False        # set at True if one switch is controlling a WindCompartmentLinkage object
        is_alt_rank_switch = False    # set at True ifthe given switch is controlling the activation of an alternate rank
        one_visible_switch = False    # set at True if one switch of the branch is visible
        one_default_engaged_switch = False  # set at True if one switch of the branch is engaged by default
        alt_HW_switch_dic = None      # HW switch permitting to switch to the alternate rank for the given HW Stop if any
        HW_switch_asgn_code = None    # default assignment code of one switch of the branch if defined
        HW_noise_pipes_list = []      # list of the HW noise pipes already checked

        for HW_switch_dic in HW_switches_main_branch_list:
            # scan the HW switches of the main controlling branch

            if HW_object_type == 'Switch':
                if self.HW_ODF_get_linked_objects_by_type(HW_switch_dic, 'ContinuousControlLinkage', TO_CHILD, FIRST_ONE) != None:
                    # the current HW switch is controlling a ContinuousControlLinkage object
                    has_cc_linkage = True

                if self.HW_ODF_get_linked_objects_by_type(HW_switch_dic, 'WindCompartmentLinkage', TO_CHILD, FIRST_ONE) != None:
                    # the current HW switch is controlling a WindCompartmentLinkage
                    has_wc_linkage = True

            # check the Switch C> KeyAction use cases
            if HW_object_type == 'KeyAction' and nb_couplers == 0:
                for HW_key_action_dic in self.HW_ODF_get_linked_objects_by_type(HW_switch_dic, 'KeyAction', TO_CHILD):
                    # scan the HW KeyAction objects which are children of the current HW Switch object if any
                    GO_coupler_attr_dic = self.GO_ODF_build_Coupler_attributes(HW_key_action_dic)
                    if GO_coupler_attr_dic != None:
                        GO_coupler_attr_dic['_object_types_list'] = ['Coupler']
                        nb_couplers += 1
                        GO_objects_attr_list.append(GO_coupler_attr_dic)
                        if LOG_HW2GO_drawstop: print(f"     GO Coupler attributes built from {HW_key_action_dic['_HW_uid']}")
                    else:
                        if LOG_HW2GO_drawstop: print(f"     GO Coupler attributes NOT built from {HW_key_action_dic['_HW_uid']}")

            # check the Switch C> Tremulant use cases
            if HW_object_type == 'Tremulant':
                for HW_tremulant_dic in self.HW_ODF_get_linked_objects_by_type(HW_switch_dic, 'Tremulant', TO_CHILD):
                    # scan the HW Tremulant objects which are children of the current HW Switch object if any
                    GO_tremulant_attr_dic = self.GO_ODF_build_Tremulant_attributes(HW_tremulant_dic)
                    if GO_tremulant_attr_dic != None:
                        GO_tremulant_attr_dic['_object_types_list'] = ['Tremulant']
                        nb_tremulants += 1
                        GO_objects_attr_list.append(GO_tremulant_attr_dic)
                        if LOG_HW2GO_drawstop: print(f"     GO Tremulant attributes built from {HW_tremulant_dic['_HW_uid']}")
                    else:
                        if LOG_HW2GO_drawstop: print(f"     GO Tremulant attributes NOT built from {HW_tremulant_dic['_HW_uid']}")


            # check the following use cases
            #   Switch C> Stop C> StopRank(s) (ActionTypeCode = 1, ActionEffectCode = 1) C> Rank C> Pipe_SoundEngine01 ...
            #   Switch C> Stop (Hint_PrimaryAssociatedRankID) C> Rank C> Pipe_SoundEngine01 ...
            #   Switch C> Stop C> StopRank (ActionTypeCode = 21, ActionEffectCode = 1) C> Rank C> Pipe_SoundEngine01 ...
            #   Switch C> Stop C> StopRank (ActionTypeCode = 21, ActionEffectCode = 2) C> Rank C> Pipe_SoundEngine01 ...
            #   Switch C> Stop C> StopRank (ActionTypeCode = 21, ActionEffectCode = 3) C> Rank C> Pipe_SoundEngine01 ...
            #   Switch C> StopRank(s) (ActionTypeCode = 1, ActionEffectCode = 1)
            for HW_stop_dic in self.HW_ODF_get_linked_objects_by_type(HW_switch_dic, 'Stop', TO_CHILD):
                # scan the HW Stop objects which are children of the current HW Switch object if any
                if HW_object_type == 'Switch':
                    if LOG_HW2GO_drawstop: print(f"     {HW_object_dic['_HW_uid']} controls a Stop ====> SKIPPED")
                    return None

                if HW_stop_dic['_GO_uid'] == '':
                    for HW_stop_rank_dic in self.HW_ODF_get_linked_objects_by_type(HW_stop_dic, 'StopRank', TO_CHILD):
                        # scan the HW StopRank objects which are children of the current HW Stop object to find a pipes rank
                        HW_rank_dic = self.HW_ODF_get_object_by_ref_id('Rank', HW_stop_rank_dic, 'RankID')
                        HW_rank_nb_pipes = len(self.HW_ODF_get_linked_objects_by_type(HW_rank_dic, 'Pipe_SoundEngine01', TO_CHILD))
                        if HW_rank_nb_pipes > 0:
                            HW_action_type_code = myint(self.HW_ODF_get_attribute_value(HW_stop_rank_dic, 'ActionTypeCode'), 1)
                            HW_action_effect_code = myint(self.HW_ODF_get_attribute_value(HW_stop_rank_dic, 'ActionEffectCode'), 1)

                            if HW_action_type_code == 1 and HW_action_effect_code == 1 and nb_pipes_stops == 0:
                                # matching attributes for building a pipes stop object
                                GO_stop_attr_dic = self.GO_ODF_build_Stop_pipes_attributes(HW_stop_dic, GO_manual_dic)
                                if GO_stop_attr_dic != None:
                                    GO_stop_attr_dic['_object_types_list'] = ['Stop', 'pipes']
                                    nb_pipes_stops += 1
                                    GO_objects_attr_list.append(GO_stop_attr_dic)
                                    if LOG_HW2GO_drawstop: print(f"     GO Stop pipes attributes built from {HW_stop_dic['_HW_uid']}")
                                    # manage the alternate rank if any (generally used for tremulant based on different wave samples)
                                    HW_alternate_rank_id = myint(self.HW_ODF_get_attribute_value(HW_stop_rank_dic, 'AlternateRankID'))
                                    if HW_alternate_rank_id != None and HW_alternate_rank_id > 0 and self.convert_alt_ranks_bool:
                                        GO_stop_attr_dic = self.GO_ODF_build_Stop_pipes_attributes(HW_stop_dic, GO_manual_dic, True)
                                        if GO_stop_attr_dic != None:
                                            GO_stop_attr_dic['_object_types_list'] = ['Stop', 'pipes', 'alternate']
                                            nb_pipes_stops += 1
                                            GO_objects_attr_list.append(GO_stop_attr_dic)
                                            # get the HW switch permitting to switch to the alternate rank
                                            alt_HW_switch_dic = self.HW_ODF_get_object_by_ref_id('Switch', HW_stop_rank_dic, 'SwitchIDToSwitchToAlternateRank')
                                            if LOG_HW2GO_drawstop: print(f"     GO Stop pipes attributes built from {HW_stop_dic['_HW_uid']} as alternate rank, selected by {alt_HW_switch_dic['_HW_uid']}")
                                        else:
                                            if LOG_HW2GO_drawstop: print(f"     GO Stop pipes attributes NOT built from {HW_stop_dic['_HW_uid']} as alternate rank, selected by {alt_HW_switch_dic['_HW_uid']}")
                                else:
                                    if LOG_HW2GO_drawstop: print(f"     {HW_stop_dic['_HW_uid']} CANNOT be converted to a GO pipes Stop")

                            elif HW_action_type_code == 21 and HW_action_effect_code in (1, 2, 3):
                                # matching use case for a noise sample control (general, attack, release)
                                HW_pipe_dic = None
                                # take into account a MIDI note increment if defined to use the proper Pipe_SoundEngine01 object
                                HW_div_midi_note_increment_to_rank = myint(self.HW_ODF_get_attribute_value(HW_stop_rank_dic, 'MIDINoteNumIncrementFromDivisionToRank'))
                                if HW_div_midi_note_increment_to_rank != None and HW_div_midi_note_increment_to_rank != 0:
                                    # search for the Pipe_SoundEngine01 object having the given MIDI note number
                                    for HW_pipe_check_dic in self.HW_ODF_get_linked_objects_by_type(HW_rank_dic, 'Pipe_SoundEngine01', TO_CHILD):
                                        midi_note_nb = myint(self.HW_ODF_get_attribute_value(HW_pipe_check_dic, 'NormalMIDINoteNumber'))
                                        if midi_note_nb == None: midi_note_nb = 60
                                        if midi_note_nb == HW_div_midi_note_increment_to_rank:
                                            HW_pipe_dic = HW_pipe_check_dic
                                            break
                                if HW_pipe_dic == None:
                                    # Pipe_SoundEngine01 object not found, take the first Pipe_SoundEngine01 child of the Rank
                                    HW_pipe_dic = self.HW_ODF_get_linked_objects_by_type(HW_rank_dic, 'Pipe_SoundEngine01', TO_CHILD, FIRST_ONE)
                                if HW_pipe_dic != None:
                                    # a Pipe_SoundEngine01 is defined
                                    if HW_pipe_dic not in HW_noise_pipes_list:
                                        if HW_action_effect_code in (1, 2): # drawstop engage noise or general noise
                                            attack_bool = True
                                        else: # HW_action_effect_code == 3: # drawstop disengage noise
                                            attack_bool = False
                                        GO_stop_attr_dic = self.GO_ODF_build_Stop_noise_attributes(HW_pipe_dic, HW_object_name, attack_bool)
                                        if GO_stop_attr_dic != None:
                                            GO_stop_attr_dic['_object_types_list'] = ['Stop', 'noise']
                                            nb_noise_stops += 1
                                            GO_objects_attr_list.append(GO_stop_attr_dic)
                                            HW_noise_pipes_list.append(HW_pipe_dic)
                                            if LOG_HW2GO_drawstop: print(f"     GO Stop noise attributes built from {HW_stop_dic['_HW_uid']} and {HW_pipe_dic['_HW_uid']} with attack={attack_bool}")
                                        else:
                                            if LOG_HW2GO_drawstop: print(f"     GO Stop noise attributes NOT built from {HW_stop_dic['_HW_uid']} and {HW_pipe_dic['_HW_uid']} with attack={attack_bool}")
                                    else:
                                        if LOG_HW2GO_drawstop: print(f"     {HW_pipe_dic['_HW_uid']} already used")

                    if nb_pipes_stops == 0:
                        if myint(self.HW_ODF_get_attribute_value(HW_stop_dic, 'Hint_PrimaryAssociatedRankID')) != None:
                            GO_stop_attr_dic = self.GO_ODF_build_Stop_pipes_attributes(HW_stop_dic, GO_manual_dic)
                            if GO_stop_attr_dic != None:
                                GO_stop_attr_dic['_object_types_list'] = ['Stop', 'noise']
                                nb_pipes_stops += 1
                                GO_objects_attr_list.append(GO_stop_attr_dic)
                                if LOG_HW2GO_drawstop: print(f"     GO Stop pipes attributes built from {HW_stop_dic['_HW_uid']} as primary rank hint")
                            else:
                                if LOG_HW2GO_drawstop: print(f"     GO Stop pipes attributes NOT built from {HW_stop_dic['_HW_uid']} as primary rank hint")

                    if LOG_HW2GO_drawstop and nb_pipes_stops == 0 and nb_noise_stops == 0:
                        print(f"     {HW_stop_dic['_HW_uid']} CANNOT be converted to neither pipes nor noise GO stop")
                else:
                    if LOG_HW2GO_drawstop: print(f"     {HW_stop_dic['_HW_uid']} already checked")

            # check the Switch C> SwitchLinkage use cases
            for HW_switch_linkage_dic in self.HW_ODF_get_linked_objects_by_type(HW_switch_dic, 'SwitchLinkage', TO_CHILD):
                # scan the HW SwitchLinkage objects which are children of the given HW Switch object if any
                EngageLinkActionCode = myint(self.HW_ODF_get_attribute_value(HW_switch_linkage_dic, 'EngageLinkActionCode'))
                DisengageLinkActionCode = myint(self.HW_ODF_get_attribute_value(HW_switch_linkage_dic, 'DisengageLinkActionCode'))
                SourceSwitchLinkIfEngaged = self.HW_ODF_get_attribute_value(HW_switch_linkage_dic, 'SourceSwitchLinkIfEngaged')
                HW_dest_switch_dic = self.HW_ODF_get_object_by_ref_id('Switch', HW_switch_linkage_dic, 'DestSwitchID')
                if HW_dest_switch_dic != None:
                    HW_pipe_dic = self.HW_ODF_get_linked_objects_by_type(HW_dest_switch_dic, 'Pipe_SoundEngine01', TO_CHILD, FIRST_ONE)
                    if HW_pipe_dic != None:
                        if HW_pipe_dic not in HW_noise_pipes_list:
                            if EngageLinkActionCode == 4 and DisengageLinkActionCode == 7:
                                # matching use case for building a drawstop engage noise
                                attack_bool = True
                            elif ((EngageLinkActionCode == 7 and DisengageLinkActionCode == 4) or
                                  (EngageLinkActionCode == 1 and DisengageLinkActionCode == 2 and SourceSwitchLinkIfEngaged == 'N')):
                                # matching use case for building a drawstop disengage noise
                                attack_bool = False
                            else:
                                attack_bool = None
                            if attack_bool != None:
                                GO_stop_attr_dic = self.GO_ODF_build_Stop_noise_attributes(HW_pipe_dic, HW_object_name, attack_bool)
                                if GO_stop_attr_dic != None:
                                    GO_stop_attr_dic['_object_types_list'] = ['Stop', 'noise']
                                    nb_noise_stops += 1
                                    GO_objects_attr_list.append(GO_stop_attr_dic)
                                    HW_noise_pipes_list.append(HW_pipe_dic)
                                    if LOG_HW2GO_drawstop: print(f"     GO Stop noise attributes built from {HW_dest_switch_dic['_HW_uid']} and {HW_pipe_dic['_HW_uid']} with attack={attack_bool}")
                                else:
                                    if LOG_HW2GO_drawstop: print(f"     GO Stop noise attributes NOT built from {HW_dest_switch_dic['_HW_uid']} and {HW_pipe_dic['_HW_uid']} with attack={attack_bool}")
                        else:
                            if LOG_HW2GO_drawstop: print(f"     {HW_pipe_dic['_HW_uid']} already used")

            # check the Switch C> Pipe_SoundEngine01 use cases
            for HW_pipe_dic in self.HW_ODF_get_linked_objects_by_type(HW_switch_dic, 'Pipe_SoundEngine01', TO_CHILD):
                # scan the HW Pipe_SoundEngine01 objects which are children of the given HW Switch object if any
                if HW_pipe_dic not in HW_noise_pipes_list:
                    attack_bool = True
                    GO_stop_attr_dic = self.GO_ODF_build_Stop_noise_attributes(HW_pipe_dic, HW_object_name, attack_bool)
                    if GO_stop_attr_dic != None:
                        GO_stop_attr_dic['_object_types_list'] = ['Stop', 'noise']
                        nb_noise_stops += 1
                        GO_objects_attr_list.append(GO_stop_attr_dic)
                        HW_noise_pipes_list.append(HW_pipe_dic)
                        if LOG_HW2GO_drawstop: print(f"     GO Stop noise attributes built from {HW_switch_dic['_HW_uid']} and {HW_pipe_dic['_HW_uid']} with attack={attack_bool}")
                    else:
                        if LOG_HW2GO_drawstop: print(f"     GO Stop noise attributes NOT built from {HW_switch_dic['_HW_uid']} and {HW_pipe_dic['_HW_uid']} with attack={attack_bool}")
                else:
                    if LOG_HW2GO_drawstop: print(f"     {HW_pipe_dic['_HW_uid']} already used")

            # check the Switch C> StopRank use case (to switch to an alternate rank)
            if self.HW_ODF_get_linked_objects_by_type(HW_switch_dic, 'StopRank', TO_CHILD, FIRST_ONE):
                is_alt_rank_switch += 1
                if LOG_HW2GO_drawstop: print(f"     {HW_switch_dic['_HW_uid']} is an alternate rank selection switch")

            # get some status about the current HW switch
            log_message = f"     {HW_switch_dic['_HW_uid']} checked"
            if self.HW_ODF_get_attribute_value(HW_switch_dic, 'Disp_ImageSetInstanceID') != None:
                one_visible_switch = True
                log_message += ', is visible'
            if self.HW_ODF_get_attribute_value(HW_switch_dic, 'DefaultToEngaged') == 'Y':
                one_default_engaged_switch = True
                log_message += ', is default engaged'
            asgn_code = myint(self.HW_ODF_get_attribute_value(HW_switch_dic, 'DefaultInputOutputSwitchAsgnCode'))
            if asgn_code != None:
                HW_switch_asgn_code = asgn_code
                log_message += f', asgn code {asgn_code}'
            if LOG_HW2GO_drawstop: print(log_message)

        # check if the given HW Switch has supported setter actions
        GO_setter_name = None
        if HW_object_type == 'Switch':
            if int(HW_cntrl_switch_dic['_HW_uid'][-6:]) == myint(self.HW_ODF_get_attribute_value(self.HW_general_dic, 'SpecialObjects_MasterCaptureSwitchID')):
                # general capture switch defined in the _General object
                HW_switch_asgn_code = 12

            if HW_switch_asgn_code != None:
                if HW_switch_asgn_code == 12:
                    GO_setter_name = 'Set'
                    GO_setter_text = 'Set'
                elif HW_switch_asgn_code == 100:
                    GO_setter_name = 'GC'
                    GO_setter_text = 'C'
                elif HW_switch_asgn_code in range(101, 200):
                    GO_setter_name = 'General' + str(HW_switch_asgn_code - 100).zfill(2)
                    GO_setter_text = str(HW_switch_asgn_code - 100)
                elif HW_switch_asgn_code in range(200, 900):
                    # divisional combination
                    one_visible_switch = False # not managed, consider it not visible in ordre to skip it
                elif HW_switch_asgn_code == 900369:
                    GO_setter_name = 'Prev'
                    GO_setter_text = 'Prev'
                elif HW_switch_asgn_code == 900366:
                    GO_setter_name = 'Next'
                    GO_setter_text = 'Next'

        if LOG_HW2GO_drawstop:
            message = '     SYNTHESIS:'
            if nb_couplers > 0: message += f' {nb_couplers} couplers,'
            if nb_tremulants > 0: message += f' {nb_tremulants} tremulants,'
            if nb_pipes_stops > 0: message += f' {nb_pipes_stops} stops,'
            if nb_noise_stops > 0: message += f' {nb_noise_stops} noises,'
            if alt_HW_switch_dic != None: message += ' has alternate rank,'
            if is_alt_rank_switch : message += ' is alternate rank cntrl switche,'
            if HW_switch_asgn_code != None: message += f' assignment code {HW_switch_asgn_code},'
            if GO_setter_name != None: message += f' GO setter name {GO_setter_name},'
            if one_visible_switch : message += ' one visible switch,'
            if one_default_engaged_switch : message += ' default engaged,'
            if switch_has_cond_effect == True: message += ' switch with conditional effect,'
            if has_cc_linkage: message += ' controlling a ContinuousControlLinkage object,'
            if has_wc_linkage: message += ' controlling a WindCompartmentLinkage object,'
            print(message)

        #----------------------------------
        # based on all the data retrieved previously, decide if coupler/stops/switches have to be built (if one of the conditions below is not fulfilled)
        # in order to avoid clickable object but without controlled feature (in case of feature not supported or demo sample sets with absent ranks)
        if not((HW_object_type == 'KeyAction' and nb_couplers > 0) or
               (HW_object_type == 'Tremulant' and nb_tremulants > 0) or
               (HW_object_type == 'Stop' and (nb_pipes_stops > 0 or int(nb_noise_stops % 2) != 0)) or
               (HW_object_type == 'Switch' and HW_switch_asgn_code != None and GO_setter_name != None) or
               (HW_object_type == 'Switch' and
                (one_default_engaged_switch or one_visible_switch) and
                (is_alt_rank_switch or nb_noise_stops == 0 or int(nb_noise_stops % 2) != 0) and
                has_cc_linkage == False and
                (has_wc_linkage == False or nb_noise_stops > 0) and
                (switch_has_cond_effect == False or int(nb_noise_stops % 2) != 0))):
            if LOG_HW2GO_drawstop: print('     ====> SKIPPED : will have no functional role in the GO ODF')
            return None

        #----------------------------------
        # management of the setter if any
        if GO_setter_name != None:
            for HW_switch_dic in HW_switches_main_branch_list:
                self.GO_ODF_build_Setter_object(HW_switch_dic, GO_setter_name, GO_setter_text)
            if LOG_HW2GO_drawstop: print(f'       SETTER built for function {GO_setter_name}')
            return

        #----------------------------------
        # build the GO controlling switches
        if len(HW_switches_ctrl_formula_dic) > 0:
            # build the GO controlling switches based on the formula
            if nb_couplers > 0 or nb_pipes_stops > 0 or nb_tremulants > 0:
                gc_state = 0
            else:
                gc_state = -1
            if HW_object_type == 'Switch':
                GO_switch_uid = self.GO_ODF_build_Switch_objects(HW_switches_ctrl_formula_dic, None, gc_state)
            else:
                GO_switch_uid = self.GO_ODF_build_Switch_objects(HW_switches_ctrl_formula_dic, HW_object_name, gc_state)

        if GO_switch_uid == None:
            if LOG_HW2GO_drawstop: print(f"       ERROR : Unable to build control switch(es) for {HW_object_dic['_HW_uid']}")
            return None

        if HW_object_type == 'Switch':
            HW_object_dic['_GO_uid'] = GO_switch_uid

        # build the GO switch permitting to switch to the alternate rank if any and if not already built
        alt_GO_switch_uid = None
        alt_not_GO_switch_uid = None
        if alt_HW_switch_dic != None:
            if alt_HW_switch_dic['_GO_uid'] == '':
                if LOG_HW2GO_drawstop: print(f"    +++++ Alternate switch building START")
                alt_GO_switch_uid = self.GO_ODF_build_Drawstop_objects(alt_HW_switch_dic, HW_division_dic)
                if LOG_HW2GO_drawstop: print(f"    +++++ Alternate switch building END")

                if alt_GO_switch_uid != None:
                    # create a NOT switch to activate the normal rank when the alternate switch is off
                    self.GO_odf_dic['Organ']['NumberOfSwitches'] += 1
                    alt_not_GO_switch_uid = 'Switch' + str(self.GO_odf_dic['Organ']['NumberOfSwitches']).zfill(3)
                    alt_not_GO_switch_dic = self.GO_odf_dic[alt_not_GO_switch_uid] = {}
                    alt_not_GO_switch_dic['Name'] = 'NOT gate'
                    alt_not_GO_switch_dic['Function'] = 'Not'
                    alt_not_GO_switch_dic['Switch001'] = alt_GO_switch_uid[-3:]
                    # write in the HW object the UID of the corresponding GO object
                    alt_HW_switch_dic['_GO_uid_not'] = alt_not_GO_switch_uid
            else:
                alt_GO_switch_uid = alt_HW_switch_dic['_GO_uid']
                if '_GO_uid_not' in alt_HW_switch_dic.keys():
                    alt_not_GO_switch_uid = alt_HW_switch_dic['_GO_uid_not']

            if LOG_HW2GO_drawstop: print(f"       Alternate rank selection GO switch is {alt_GO_switch_uid}, NOT switch is {alt_not_GO_switch_uid}")

        #----------------------------------
        # build the GO Coupler / Stop(s) / Tremulant objects
        main_GO_object_uid = None
        for GO_obj_data_dic in GO_objects_attr_list:
            GO_object_type = GO_obj_data_dic['_object_types_list'][0]

            if GO_object_type != 'Tremulant':
                # create a new GO object (coupler or stop) in the GO ODF dictionary using the manual ID for the first digit
                GO_manual_dic['NumberOf' + GO_object_type + 's'] += 1
                GO_object_uid = GO_object_type + str(GO_manual_id).zfill(1) + str(GO_manual_dic['NumberOf' + GO_object_type + 's']).zfill(2)
            else:
                self.GO_odf_dic['Organ']['NumberOfTremulants'] += 1
                GO_object_uid = GO_object_type + str(self.GO_odf_dic['Organ']['NumberOfTremulants']).zfill(3)
            GO_object_dic = self.GO_odf_dic[GO_object_uid] = {}

            # copy in it the GO object data prepared before
            for key, value in GO_obj_data_dic.items():
                if key[0] != '_':
                    GO_object_dic[key] = value

            if GO_object_type != 'Tremulant':
                # add the GO object to the GO Manual to which it belongs
                GO_manual_dic[GO_object_type + str(GO_manual_dic['NumberOf' + GO_object_type + 's']).zfill(3)] = GO_object_uid[-3:]
            else:
                # add the GO Tremulant to the GO WindchestGroups to which it has an effect
                for GO_windchest_uid in GO_obj_data_dic['_go_windchests_uid_list']:
                    self.GO_odf_dic[GO_windchest_uid]['NumberOfTremulants'] += 1
                    self.GO_odf_dic[GO_windchest_uid]['Tremulant' + str(self.GO_odf_dic[GO_windchest_uid]['NumberOfTremulants']).zfill(3)] = GO_object_uid[-3:]
                # add the GO Tremulant to the GO Manuals to which it belongs
                for GO_manual_uid in GO_obj_data_dic['_go_manuals_uid_list']:
                    self.GO_odf_dic[GO_manual_uid]['NumberOfTremulants'] += 1
                    self.GO_odf_dic[GO_manual_uid]['Tremulant' + str(self.GO_odf_dic[GO_manual_uid]['NumberOfTremulants']).zfill(3)] = GO_object_uid[-3:]

            # write in the HW object the UID of the corresponding GO object
            if ((HW_object_type == 'Stop' and 'pipes' in GO_obj_data_dic['_object_types_list']) or
                (HW_object_type == 'KeyAction' and 'Coupler' in GO_obj_data_dic['_object_types_list']) or
                (HW_object_type == 'Tremulant' and 'Tremulant' in GO_obj_data_dic['_object_types_list'])):
                HW_object_dic['_GO_uid'] = main_GO_object_uid = GO_object_uid

            # add the controlling GO switch in the GO object
            if GO_switch_uid != None:
                GO_object_dic['Function'] = 'And'
                GO_object_dic['SwitchCount'] = 1
                GO_object_dic['Switch001'] = GO_switch_uid[-3:]

                if alt_GO_switch_uid != None and alt_not_GO_switch_uid != None and 'pipes' in GO_obj_data_dic['_object_types_list']:
                    GO_object_dic['SwitchCount'] = 2
                    if 'alternate' in GO_obj_data_dic['_object_types_list']:
                        GO_object_dic['Switch002'] = alt_GO_switch_uid[-3:]
                    else:
                        GO_object_dic['Switch002'] = alt_not_GO_switch_uid[-3:]

            elif one_default_engaged_switch:
                GO_object_dic['DefaultToEngaged'] = 'Y'
            else:
                GO_object_dic['DefaultToEngaged'] = 'N'

            if LOG_HW2GO_drawstop: print(f"     GO {GO_object_uid} '{GO_object_dic['Name']}' built, {GO_obj_data_dic['_object_types_list']}, controlled by {GO_switch_uid}")

        if HW_object_type in ('Stop', 'KeyAction', 'Tremulant') and main_GO_object_uid != None:
            if LOG_HW2GO_drawstop: print(f"     returned GO object is {main_GO_object_uid}")
            return main_GO_object_uid
        else:
            if LOG_HW2GO_drawstop: print(f"     returned GO object is {GO_switch_uid}")
            return GO_switch_uid

    #-------------------------------------------------------------------------------------------------
    def GO_ODF_build_Coupler_attributes(self, HW_key_action_dic):
        # build the GO Coupler attributes corresponding to the given HW KeyAction object
        # if the KeyAction is between two different divisions/keyboards or the same but with keys shift
        # return the dictionary of the GO Coupler attributes, or None in case of building issue

        # used HW objects :
        #   KeyAction P> Keyboard P> Division  (source division)
        #   KeyAction C> Keyboard C> Division  (destination division)
        #   KeyAction C> Division              (destination division)

        # get the HW source division of the HW KeyAction
        HW_source_keyboard_dic = self.HW_ODF_get_object_by_ref_id('Keyboard', HW_key_action_dic, 'SourceKeyboardID')
        HW_source_division_dic = self.HW_ODF_get_linked_objects_by_type(HW_source_keyboard_dic, 'Division', TO_PARENT, FIRST_ONE)
        if HW_source_division_dic == None:
            # no existing HW source division/keyboard of the KeyAction, the Coupler cannot be built
            if LOG_HW2GO_coupler: print(f'Unable to find the HW source division of the HW keyboard {HW_source_keyboard_dic["_HW_uid"]}')
            return None

        # get the HW destination division of the HW KeyAction
        HW_dest_division_dic = self.HW_ODF_get_object_by_ref_id('Division', HW_key_action_dic, 'DestDivisionID')
        if HW_dest_division_dic == None:
            HW_dest_keyboard_dic = self.HW_ODF_get_object_by_ref_id('Keyboard', HW_key_action_dic, 'DestKeyboardID')
            if HW_dest_keyboard_dic != None:
                HW_dest_division_dic = self.HW_ODF_get_linked_objects_by_type(HW_dest_keyboard_dic, 'Division', TO_PARENT, FIRST_ONE)
        if HW_dest_division_dic == None:
            # no existing HW destination division/keyboard of the KeyAction, the Coupler cannot be built
            if LOG_HW2GO_coupler: print(f'Unable to find the HW destination division for the KeyAction {HW_key_action_dic["_HW_uid"]}')
            return None

        # get the corresponding GO source and destination Manual UID
        GO_source_manual_uid = HW_source_division_dic['_GO_uid']
        if GO_source_manual_uid == '':
            if LOG_HW2GO_coupler: print(f"Unable to find the GO source manual for the HW source division {HW_source_division_dic['_GO_uid']}")
            return None

        GO_dest_manual_uid = HW_dest_division_dic['_GO_uid']
        if GO_dest_manual_uid == '':
            if LOG_HW2GO_coupler: print(f"Unable to find the GO destination manual for the HW destination division {HW_source_division_dic['_GO_uid']}")
            return None

        keys_shift = myint(self.HW_ODF_get_attribute_value(HW_key_action_dic, 'MIDINoteNumberIncrement'), 0)
        if GO_source_manual_uid == GO_dest_manual_uid and keys_shift == 0:
            if LOG_HW2GO_coupler: print(f"{HW_key_action_dic['_HW_uid']} is linking the same division {HW_source_division_dic['_HW_uid']} / {GO_source_manual_uid} without keys shift, no need to build a GO Coupler")
            return None

        # create a dictionary to store in it the GO Coupler attributes
        GO_coupler_dic = {}

        GO_coupler_dic['Name'] = self.HW_ODF_get_attribute_value(HW_key_action_dic, 'Name')
        GO_coupler_dic['UnisonOff'] = 'N'
        GO_coupler_dic['DestinationManual'] = GO_dest_manual_uid[-3:]

        first_key = myint(self.HW_ODF_get_attribute_value(HW_key_action_dic, 'MIDINoteNumOfFirstSourceKey'))
        if first_key != None:
            GO_coupler_dic['FirstMIDINoteNumber'] = first_key

        GO_coupler_dic['DestinationKeyshift'] = keys_shift

        GO_coupler_dic['NumberOfKeys'] = myint(self.HW_ODF_get_attribute_value(HW_key_action_dic, 'NumberOfKeys'))
        GO_coupler_dic['CoupleToSubsequentUnisonIntermanualCouplers'] = 'N'
        GO_coupler_dic['CoupleToSubsequentUpwardIntermanualCouplers'] = 'N'
        GO_coupler_dic['CoupleToSubsequentDownwardIntermanualCouplers'] = 'N'
        GO_coupler_dic['CoupleToSubsequentUpwardIntramanualCouplers'] = 'N'
        GO_coupler_dic['CoupleToSubsequentDownwardIntramanualCouplers'] = 'N'

        return GO_coupler_dic

    #-------------------------------------------------------------------------------------------------
    def GO_ODF_build_Stop_pipes_attributes(self, HW_stop_dic, GO_manual_dic, alternate_rank_bool=False):
        # build the GO Stop attributes (controlling pipes ranks, normal or alternate) corresponding to the given HW KeyAction object and linked to the given GO manual
        # return the dictionary of the Stop attributes, or None in case of building issue or stop without controlled pipes (case of demo sample sets)

        # used HW objects :
        #   Stop
        #   Stop C> StopRank(s) (ActionTypeCode = 1, ActionEffectCode = 1) C> Rank C> Pipe_SoundEngine01 ... (in function GO_ODF_build_Rank_data_out_stop)

        # create a dictionary to store in it the GO Stop attributes
        GO_stop_dic = {}

        GO_stop_dic['Name'] = self.HW_ODF_get_attribute_value(HW_stop_dic, 'Name')

        if alternate_rank_bool:
            GO_stop_dic['Name'] += ' (alt.)'

        # fill the rank attributes of the stop
        self.GO_ODF_build_Rank_data_out_stop(HW_stop_dic, GO_stop_dic, GO_manual_dic, alternate_rank_bool)

        if GO_stop_dic['NumberOfAccessiblePipes'] == 0:
            # no pipe accessible for the built stop
            return None
        else:
            return GO_stop_dic

    #-------------------------------------------------------------------------------------------------
    def GO_ODF_build_Stop_noise_attributes(self, HW_pipe_dic, object_name, attack_bool):
        # build the GO Stop attributes (controlling noise samples, attack or release) corresponding to the given HW KeyAction object
        # give to the GO Stop the given object name
        # return the dictionary of the Stop attributes, or None in case of building issue

        # used HW objects :
        #   Pipe_SoundEngine01 C> Pipe_SoundEngine01_Layer C> Pipe_SoundEngine01_AttackSample C> Sample   (in function GO_ODF_build_Rank_data_in_stop)
        #   Pipe_SoundEngine01 C> Pipe_SoundEngine01_Layer C> Pipe_SoundEngine01_ReleaseSample C> Sample  (in function GO_ODF_build_Rank_data_in_stop)

        if HW_pipe_dic == None:
            return None

        # create a dictionary to store in it the GO Stop attributes
        GO_stop_dic = {}

        GO_stop_dic['Name'] = ''  # defined below, created here to have this attribute in first position

        # fill the GO stop dictionary with the data of the provided HW Pipe_SoundEngine01 object (and update attack_bool if necessary)
        attack_bool = self.GO_ODF_build_Rank_data_in_stop(HW_pipe_dic, GO_stop_dic, attack_bool)

        if attack_bool:
            GO_stop_dic['Name'] = object_name + ' (atk. noise)'
        else:
            GO_stop_dic['Name'] = object_name + ' (rel. noise)'

        return GO_stop_dic

    #-------------------------------------------------------------------------------------------------
    def GO_ODF_build_Stop_keys_noise_object_TBD(self, HW_object_dic, GO_manual_dic, attack_bool):
        # try to build GO Stop data with rank data inside for keyboard keys action noise rendering from the given HW object (Stop or Keyboard)

        # used HW objects :
        #   attack noise (key press) :
        #      Stop C> StopRank(s) (ActionTypeCode = 1, ActionEffectCode = 2) C> Rank C> Pipe_SoundEngine01 ...
        #      Keyboard C> KeyboardKey P> Switch C> SwitchLinkage (EngageLinkActionCode=4, DisengageLinkActionCode=7) C> Switch C> Pipe_SoundEngine01 ...
        #      Keyboard C> KeyboardKey P> Switch C> Pipe_SoundEngine01 C> Pipe_SoundEngine01Layer C> Pipe_SoundEngine01_AttackSample ...
        #   release noise (key release) :
        #      Stop C> StopRank(s) (ActionTypeCode = 1, ActionEffectCode = 3) C> Rank C> Pipe_SoundEngine01 ...
        #      Keyboard C> KeyboardKey P> Switch C> SwitchLinkage (EngageLinkActionCode=7, DisengageLinkActionCode=4) C> Switch C> Pipe_SoundEngine01 ...
        #      Keyboard C> KeyboardKey P> Switch C> Pipe_SoundEngine01 C> Pipe_SoundEngine01Layer C> Pipe_SoundEngine01_AttackSample + Pipe_SoundEngine01_ReleaseSample ...

        pass # TO BE DONE, low priority

    #-------------------------------------------------------------------------------------------------
    def GO_ODF_build_Tremulant_attributes(self, HW_tremulant_dic):
        # build the GO Tremulant attributes corresponding to the given HW Tremulant object (synthetized tremulant)
        # return the dictionary of the GO Tremulant attributes, or None in case of building issue

        # used HW objects :
        #   Tremulant C> TremulantWaveform C> TremulantWaveformPipe C> Pipe_SoundEngine01 P> Rank
        #                                                                                 P> WindCompartment

        # create a dictionary to store in it the GO Tremulant attributes
        GO_tremulant_dic = {}

        GO_tremulant_dic['Name'] = self.HW_ODF_get_attribute_value(HW_tremulant_dic, 'Name')

        freq_hz = myfloat(self.HW_ODF_get_attribute_value(HW_tremulant_dic, 'FrequencyWhenEngagedHz'), 5.0)
        if freq_hz == 0: freq_hz = 5.0
        GO_tremulant_dic['Period'] = int(1000.0 / freq_hz)  # in milliseconds

        GO_tremulant_dic['TremulantType'] = 'Synth'
        GO_tremulant_dic['StartRate'] = myint(myfloat(self.HW_ODF_get_attribute_value(HW_tremulant_dic, 'StartRatePercent'), 1))
        GO_tremulant_dic['StopRate'] = myint(myfloat(self.HW_ODF_get_attribute_value(HW_tremulant_dic, 'StopRatePercent'), 100))

        GO_tremulant_dic['AmpModDepth'] = 15
        # from kerkovits in GitHub GrandOrgue discussion : AmpModDepth is stored in wav files for each pipe.
        # One could multiple the minimum value found in the sample and multiply it by -100 to get AmpModDepth
        # but it is very tedious (an average of all pipes should be calculated),
        # so a default reasonable value (e.g. 15) could be set, which is still better than nothing

        # scan the HW pipes linked to the given HW Tremulant to identify the impacted ranks / wind compartments / manuals
        if LOG_HW2GO_tremulant: print(f"{HW_tremulant_dic['_HW_uid']} {GO_tremulant_dic['Name']} --------------------------------------------------------------------------------")
        GO_tremulant_dic['_go_windchests_uid_list'] = []
        GO_tremulant_dic['_go_manuals_uid_list'] = []
        for HW_trem_wave_form_dic in self.HW_ODF_get_linked_objects_by_type(HW_tremulant_dic, 'TremulantWaveform', TO_CHILD):
            # scan the HW TremulantWaveForm objects which are children of the given HW Tremulant object
            if LOG_HW2GO_tremulant: print(f"   {HW_trem_wave_form_dic['_HW_uid']}")
            for HW_trem_wave_form_pipe_dic in self.HW_ODF_get_linked_objects_by_type(HW_trem_wave_form_dic, 'TremulantWaveformPipe', TO_CHILD):
                # scan the HW TremulantWaveFormPipe objects which are children of the HW TremulantWaveform object
                if LOG_HW2GO_tremulant: print(f"      {HW_trem_wave_form_pipe_dic['_HW_uid']}")
                HW_pipe_dic = self.HW_ODF_get_object_by_ref_id('Pipe_SoundEngine01', HW_trem_wave_form_pipe_dic, 'PipeID')
                if HW_pipe_dic != None:
                    # get the HW Rank to which belongs to the current HW Pipe
                    HW_rank_dic = self.HW_ODF_get_linked_objects_by_type(HW_pipe_dic, 'Rank', TO_PARENT, FIRST_ONE)
                    if HW_rank_dic != None and HW_rank_dic['_GO_uid'] != '' and '_GO_manual_uid' in self.GO_odf_dic[HW_rank_dic['_GO_uid']]:
                        # get the GO manual UID to which belongs the HW/GO Rank
                        GO_manual_uid = self.GO_odf_dic[HW_rank_dic['_GO_uid']]['_GO_manual_uid']
                    else:
                        GO_manual_uid = None

                    # get the HW WindCompartment which is source of the current HW Pipe
                    HW_wind_comp_dic = self.HW_ODF_get_object_by_ref_id('WindCompartment', HW_pipe_dic, 'WindSupply_SourceWindCompartmentID')
                    if LOG_HW2GO_tremulant: print(f"         {HW_rank_dic['_HW_uid']} {HW_rank_dic['_GO_uid']}, {HW_wind_comp_dic['_HW_uid']} {HW_wind_comp_dic['_GO_uid']}")
                    # add the GO WindchestGroup UIDs to the list of windchests affected by the tremulant
                    if HW_wind_comp_dic != None and '_GO_uid_list' in HW_wind_comp_dic.keys() :
                        for GO_windchest_uid in HW_wind_comp_dic['_GO_uid_list']:
                            if GO_windchest_uid not in GO_tremulant_dic['_go_windchests_uid_list']:
                                GO_tremulant_dic['_go_windchests_uid_list'].append(GO_windchest_uid)
                    # add the GO Manual UID to the list of manuals affected by the tremulant
                    if GO_manual_uid != None and GO_manual_uid not in GO_tremulant_dic['_go_manuals_uid_list']:
                        GO_tremulant_dic['_go_manuals_uid_list'].append(GO_manual_uid)

        if LOG_HW2GO_tremulant: print(f"======> {GO_tremulant_dic['Name']} to link to {GO_tremulant_dic['_go_windchests_uid_list']} and {GO_tremulant_dic['_go_manuals_uid_list']}")
        return GO_tremulant_dic

    #-------------------------------------------------------------------------------------------------
    def GO_ODF_build_Switch_objects(self, HW_formula, stop_name=None, gc_state=-1):
        # recursive function to build the GO controlling switches corresponding to the given formula (a dictionary returned by HW_ODF_get_controlling_switches)
        # return the GO Switch UID which is controlled by this formula

        if not isinstance(HW_formula, dict):
            logs.add(f'INTERNAL ERROR "{HW_formula}" is not a dictionary given to GO_ODF_build_Switch_objects')
            return None

        # get the function of the formula (it must be AND, OR or NOT), will be the function attribute of the controlled GO Switch to return
        switch_function = list(HW_formula.keys())[0]  # get the first key of the HW formula dictionary
        if not switch_function in ('*And', '*Not', '*Or'):
            logs.add(f'INTERNAL ERROR unknown function "{switch_function}" given to GO_ODF_build_Switch_objects')
            return None

        # get the arguments of the function (a list of dictionaries)
        HW_arguments_list = HW_formula[switch_function]

        # build control switches for each argument
        HW_switch_dic_list = []  # list of HW Switch dictionaries which are present in the arguments of the formula
        GO_switch_uid_list = []  # list of GO Switch UID which have been build from dictionaries arguments
        for HW_argument in HW_arguments_list:
            if list(HW_argument.keys())[0][0] == '*':  # the first character of the first key is *, it is a logical condition name
                # the current argument is a dictionary with a logical condition as first key, create a GO Switch to implement this condition
                GO_switch_uid = self.GO_ODF_build_Switch_objects(HW_argument, stop_name, gc_state)
                if GO_switch_uid != None:
                    # a GO Switch has been build, add it in the GO list
                    GO_switch_uid_list.append(GO_switch_uid)
            else:
                # the current argument is HW Switch dictionary, add it in the HW list
                HW_switch_dic_list.append(HW_argument)

        if len(HW_switch_dic_list) > 0:
            # there are HW switch(es) to convert into GO switch(es)
            if switch_function == '*Or':
                # the switches are linked by a OR function
                for HW_switch_dic in HW_switch_dic_list:
                    # scan the HW switches to convert into GO switches
                    # search if the current HW switch is in the looping switches list
                    found_looping_switches_list = []
                    for looping_switches_list in self.HW_looping_switches_lists:
                        if HW_switch_dic in looping_switches_list:
                            found_looping_switches_list = looping_switches_list
                            break

                    if len(found_looping_switches_list) > 0 and isinstance(found_looping_switches_list[0], str):
                        # the first item of the list is a string and not a dictionary : a GO switch is already associated to the found looping switches ensemble
                        common_GO_switch_uid = found_looping_switches_list[0]
                    else:
                        common_GO_switch_uid = None

                    GO_switch_uid = self.GO_ODF_build_Switch_object(HW_switch_dic, common_GO_switch_uid, stop_name, gc_state)
                    if GO_switch_uid != None:
                        if GO_switch_uid not in GO_switch_uid_list:
                            GO_switch_uid_list.append(GO_switch_uid)
                        if common_GO_switch_uid == None:
                            found_looping_switches_list.insert(0, GO_switch_uid)

            elif switch_function == '*And':
                # the switches are linked by a AND function
                # build a GO switch and a GO PanelElement for each HW Switch
                # the HW switches has to be linked to one GO switch and one GO PanelElement for each
                for HW_switch_dic in HW_switch_dic_list:
                    GO_switch_uid = self.GO_ODF_build_Switch_object(HW_switch_dic, None, stop_name, gc_state)
                    GO_switch_uid_list.append(GO_switch_uid)

            else: # NOT
                # the switche has to be negated
                if len(HW_switch_dic_list) > 1:
                    logs.add(f'INTERNAL ERROR more than one switch in an OR function in formula "{HW_formula}" given to GO_ODF_build_Switch_objects')
                    return None
                else:
                    HW_switch_dic = HW_switch_dic_list[0]
                    GO_switch_uid = self.GO_ODF_build_Switch_object(HW_switch_dic, None, stop_name, gc_state)
                    GO_switch_uid_list.append(GO_switch_uid)

        if len(GO_switch_uid_list) == 1 and switch_function != '*Not':
            # if only one input switch with AND or OR function applied to it, no need to build a switch to execute this function, return the switch directly
            return GO_switch_uid_list[0]

        elif len(GO_switch_uid_list) > 0:
            # create a GO switch to apply the logical function to the GO switches of the list
            self.GO_odf_dic['Organ']['NumberOfSwitches'] += 1
            GO_switch_uid = 'Switch' + str(self.GO_odf_dic['Organ']['NumberOfSwitches']).zfill(3)
            GO_switch_dic = self.GO_odf_dic[GO_switch_uid] = {}

            GO_switch_dic['Name'] = switch_function.upper()[1:] + ' gate'
            GO_switch_dic['Function'] = switch_function[1:]
            if switch_function != '*Not':
                GO_switch_dic['SwitchCount'] = len(GO_switch_uid_list)
            for i in range(len(GO_switch_uid_list)):
                GO_switch_dic['Switch' + str(i+1).zfill(3)] = GO_switch_uid_list[i][-3:]

            return GO_switch_uid

    #-------------------------------------------------------------------------------------------------
    def GO_ODF_build_Switch_object(self, HW_switch_dic, linked_GO_switch_uid = None, switch_name = None, gc_state=-1):
        # build a GO Switch with the properties of the given HW Switch if no linked GO switch provided, only if it is not a keyboard key switch
        # build a GO Panel999Element999 object with type=Switch corresponding to the given HW Switch and in the proper GO Panel
        # link the Panel999Element999 to the build Switch or to the linked GO switch if provided
        # give to the GO Switch the given switch name if provided
        # return the UID of the added GO Switch or the linked GO Switch if provided

        # used HW objects :
        #   Switch C> ImageSetInstance

        if self.HW_ODF_get_linked_objects_by_type(HW_switch_dic, 'KeyboardKey', TO_CHILD, FIRST_ONE) != None:
            # this HW Switch object is controlling a HW KeyboardKey object : it is ignored
            GO_switch_uid = linked_GO_switch_uid
            return GO_switch_uid

        # if the given HW Switch is already associated to a GO Switch, consider this GO Switch as a linked switch
        if HW_switch_dic['_GO_uid'] != '':
            linked_GO_switch_uid = HW_switch_dic['_GO_uid']

##        if switch_name == None:
        switch_name = self.HW_ODF_get_attribute_value(HW_switch_dic, 'Name')
        if '(' in switch_name:
            # the HW switch has an opening parenthesis : get the text at the left of this parenthesis
            switch_name = switch_name.split('(')[0].rstrip()

        if linked_GO_switch_uid == None:
            # new GO Switch999 to create
            self.GO_odf_dic['Organ']['NumberOfSwitches'] += 1
            GO_switch_uid = 'Switch' + str(self.GO_odf_dic['Organ']['NumberOfSwitches']).zfill(3)
            GO_switch_dic = self.GO_odf_dic[GO_switch_uid] = {}

            GO_switch_dic['Name'] = switch_name

            if self.HW_ODF_get_attribute_value(HW_switch_dic, 'DefaultToEngaged') == 'Y':
                GO_switch_dic['DefaultToEngaged'] = 'Y'
            else:
                GO_switch_dic['DefaultToEngaged'] = 'N'

            GO_switch_dic['GCState'] = gc_state
            if gc_state != -1:
                GO_switch_dic['StoreInDivisional'] = 'Y'
                GO_switch_dic['StoreInGeneral'] = 'Y'

            if LOG_HW2GO_drawstop: print(f"          {GO_switch_uid} built from {HW_switch_dic['_HW_uid']}")
        else:
            # no new GO Switch999 to create, we reuse the UID of the linked switch
            GO_switch_uid = linked_GO_switch_uid
            if LOG_HW2GO_drawstop: print(f"          {GO_switch_uid} reused for {HW_switch_dic['_HW_uid']}")

        # add in the HW Switch object the ID of the corresponding GO object
        HW_switch_dic['_GO_uid'] = GO_switch_uid

        # manage the graphical part of the switch

        # get the HW ImageSetInstance object associated to the given HW Switch object if any
        HW_img_set_inst_dic = self.HW_ODF_get_object_by_ref_id('ImageSetInstance', HW_switch_dic, 'Disp_ImageSetInstanceID')
        # get the ID of the HW display page in which the switch is displayed if any
        HW_switch_disp_page_id = myint(self.HW_ODF_get_attribute_value(HW_img_set_inst_dic, 'DisplayPageID', MANDATORY))

        if HW_switch_disp_page_id != None and HW_img_set_inst_dic != None:
            if '_GO_panelem_uid' not in HW_switch_dic.keys():
                # build a new GO Panel999Element999 object with Type=Switch to display the switch if it has graphical properties and has not already a GO PanelElement built

                # recover the GO panel UID corresponding to the HW display page ID of the switch
                HW_disp_page_dic = self.HW_ODF_get_object_dic('DisplayPage', HW_switch_disp_page_id)
                GO_panel_uid = HW_disp_page_dic['_GO_uid']

                # create the GO Panel999Element999 switch object to display the switch in it
                self.GO_odf_dic[GO_panel_uid]['NumberOfGUIElements'] += 1
                GO_panel_element_uid = GO_panel_uid + 'Element' + str(self.GO_odf_dic[GO_panel_uid]['NumberOfGUIElements']).zfill(3)
                GO_panel_element_dic = self.GO_odf_dic[GO_panel_element_uid] = {}

                GO_panel_element_dic['Type'] = 'Switch'
                GO_panel_element_dic['Switch'] = str(int(GO_switch_uid[-3:])).zfill(3)
                GO_panel_element_dic['DispLabelText'] = ''

                # get the index of the switch image for OFF and ON positions
                switch_off_img_index = myint(self.HW_ODF_get_attribute_value(HW_switch_dic, 'Disp_ImageSetIndexDisengaged'))
                switch_on_img_index = myint(self.HW_ODF_get_attribute_value(HW_switch_dic, 'Disp_ImageSetIndexEngaged'))
                if switch_off_img_index == None: switch_off_img_index = '1'
                if switch_on_img_index == None: switch_on_img_index = '1'

                # get the attributes of the ImageSetInstance objects and its children
                image_attr_dic = {}
                self.HW_ODF_get_image_attributes(HW_img_set_inst_dic, image_attr_dic, switch_off_img_index)

                # set the position of the switch image
                GO_panel_element_dic['PositionX'] = image_attr_dic['LeftXPosPixels']
                GO_panel_element_dic['PositionY'] = image_attr_dic['TopYPosPixels']

                # get the image dimensions if they are not defined in the HW ODF
                img_w = img_h = None
                if (image_attr_dic['ImageWidthPixels'] == None or image_attr_dic['ImageHeightPixels'] == None) and image_attr_dic['BitmapFilename'] != None:
                    image_path = self.HW_sample_set_odf_path + os.sep + path2ospath(image_attr_dic['BitmapFilename'])
                    if os.path.isfile(image_path):
                        im = Image.open(image_path)
                        img_w = im.size[0]
                        img_h = im.size[1]

                if image_attr_dic['ImageWidthPixels'] != None:
                    GO_panel_element_dic['Width'] = int(image_attr_dic['ImageWidthPixels'])
                elif img_w != None:
                    GO_panel_element_dic['Width'] = img_w

                if image_attr_dic['ImageHeightPixels'] != None:
                    GO_panel_element_dic['Height'] = int(image_attr_dic['ImageHeightPixels'])
                elif img_h != None:
                    GO_panel_element_dic['Height'] = img_h

                # update the host panel size if needed to see the switch images
                self.GO_ODF_build_Panel_size_update(self.GO_odf_dic[GO_panel_uid], GO_panel_element_dic['PositionX'] + GO_panel_element_dic['Width'],
                                                                                   GO_panel_element_dic['PositionY'] + GO_panel_element_dic['Height'])

               # set the mouse clickable rectangle width
                if image_attr_dic['ClickableAreaLeftRelativeXPosPixels'] not in (None, 0):
                    GO_panel_element_dic['MouseRectLeft'] = int(image_attr_dic['ClickableAreaLeftRelativeXPosPixels'])

                if image_attr_dic['ClickableAreaRightRelativeXPosPixels'] not in (None, 0):
                    if image_attr_dic['ClickableAreaLeftRelativeXPosPixels'] != None:
                        GO_panel_element_dic['MouseRectWidth'] = image_attr_dic['ClickableAreaRightRelativeXPosPixels'] - image_attr_dic['ClickableAreaLeftRelativeXPosPixels']
                    else:
                        GO_panel_element_dic['MouseRectWidth'] = image_attr_dic['ClickableAreaRightRelativeXPosPixels']
                    # check if the mouse rectangle width is exceeding the image size
                    if 'MouseRectLeft' in GO_panel_element_dic.keys():
                        if GO_panel_element_dic['MouseRectLeft'] + GO_panel_element_dic['MouseRectWidth'] > GO_panel_element_dic['Width']:
                            GO_panel_element_dic['MouseRectWidth'] = GO_panel_element_dic['Width'] - GO_panel_element_dic['MouseRectLeft']
                    else:
                        if GO_panel_element_dic['MouseRectWidth'] > GO_panel_element_dic['Width']:
                            GO_panel_element_dic['MouseRectWidth'] = GO_panel_element_dic['Width']

                # set the mouse clickable rectangle height
                if image_attr_dic['ClickableAreaTopRelativeYPosPixels'] not in (None, 0):
                    GO_panel_element_dic['MouseRectTop'] = int(image_attr_dic['ClickableAreaTopRelativeYPosPixels'])

                if image_attr_dic['ClickableAreaBottomRelativeYPosPixels'] not in (None, 0):
                    if image_attr_dic['ClickableAreaTopRelativeYPosPixels'] != None:
                        GO_panel_element_dic['MouseRectHeight'] = image_attr_dic['ClickableAreaBottomRelativeYPosPixels'] - image_attr_dic['ClickableAreaTopRelativeYPosPixels']
                    else:
                        GO_panel_element_dic['MouseRectHeight'] = image_attr_dic['ClickableAreaBottomRelativeYPosPixels']
                    # check if the mouse rectangle height is exceeding the image size
                    if 'MouseRectTop' in GO_panel_element_dic.keys():
                        if GO_panel_element_dic['MouseRectTop'] + GO_panel_element_dic['MouseRectHeight'] > GO_panel_element_dic['Height']:
                            GO_panel_element_dic['MouseRectHeight'] = GO_panel_element_dic['Height'] - GO_panel_element_dic['MouseRectTop']
                    else:
                       if GO_panel_element_dic['MouseRectHeight'] > GO_panel_element_dic['Height']:
                            GO_panel_element_dic['MouseRectHeight'] = GO_panel_element_dic['Height']

                    GO_panel_element_dic['MouseRadius'] = 0

                # set the attributes of the switch OFF image
                if image_attr_dic['BitmapFilename'] != None:
                    GO_panel_element_dic['ImageOff'] = image_attr_dic['BitmapFilename']
                if image_attr_dic['TransparencyMaskBitmapFilename'] != None:
                    GO_panel_element_dic['MaskOff'] = image_attr_dic['TransparencyMaskBitmapFilename']

                # set the attributes of the switch ON image
                image_attr_dic = {}
                self.HW_ODF_get_image_attributes(HW_img_set_inst_dic, image_attr_dic, switch_on_img_index)
                if image_attr_dic['BitmapFilename'] != None:
                    GO_panel_element_dic['ImageOn'] = image_attr_dic['BitmapFilename']
                if image_attr_dic['TransparencyMaskBitmapFilename'] != None:
                    GO_panel_element_dic['MaskOn'] = image_attr_dic['TransparencyMaskBitmapFilename']

                # add in the HW Switch object the ID of the corresponding GO object
                HW_img_set_inst_dic['_GO_uid'] = GO_panel_element_uid
                HW_switch_dic['_GO_panelem_uid'] = GO_panel_element_uid

                if LOG_HW2GO_drawstop: print(f"             {GO_panel_element_uid} built, linked to {GO_switch_uid}")
            else:
                if LOG_HW2GO_drawstop: print(f"             {HW_switch_dic['_GO_panelem_uid']} already built for {HW_switch_dic['_HW_uid']}")

        return GO_switch_uid

    #-------------------------------------------------------------------------------------------------
    def GO_ODF_build_Setter_object(self, HW_switch_dic, GO_setter_name, GO_setter_text):

        if HW_switch_dic['_GO_uid'] != '':
            return HW_switch_dic['_GO_uid']

        if GO_setter_name == None:
            return None

        # get the HW ImageSetInstance object associated to the given HW Switch object if any
        HW_img_set_inst_dic = self.HW_ODF_get_object_by_ref_id('ImageSetInstance', HW_switch_dic, 'Disp_ImageSetInstanceID')
        # get the ID of the HW display page in which the switch is displayed if any
        HW_switch_disp_page_id = myint(self.HW_ODF_get_attribute_value(HW_img_set_inst_dic, 'DisplayPageID', MANDATORY))

        if HW_switch_disp_page_id != None and HW_img_set_inst_dic != None:
            # build a new GO Panel999Element999 object with Type=<setter name> to display the setter if it has graphical properties

            # recover the GO panel UID corresponding to the HW display page ID of the switch
            HW_disp_page_dic = self.HW_ODF_get_object_dic('DisplayPage', HW_switch_disp_page_id)
            GO_panel_uid = HW_disp_page_dic['_GO_uid']

            # create the GO Panel999Element999 switch object to display the switch in it
            self.GO_odf_dic[GO_panel_uid]['NumberOfGUIElements'] += 1
            GO_panel_element_uid = GO_panel_uid + 'Element' + str(self.GO_odf_dic[GO_panel_uid]['NumberOfGUIElements']).zfill(3)
            GO_panel_element_dic = self.GO_odf_dic[GO_panel_element_uid] = {}

            GO_panel_element_dic['Type'] = GO_setter_name
            GO_panel_element_dic['DispLabelText'] = ''
            GO_panel_element_dic['DisplayAsPiston'] = 'Y'

            # get the index of the switch image for OFF and ON positions
            switch_off_img_index = myint(self.HW_ODF_get_attribute_value(HW_switch_dic, 'Disp_ImageSetIndexDisengaged'))
            switch_on_img_index = myint(self.HW_ODF_get_attribute_value(HW_switch_dic, 'Disp_ImageSetIndexEngaged'))
            if switch_off_img_index == None: switch_off_img_index = '1'
            if switch_on_img_index == None: switch_on_img_index = '1'

            # get the attributes of the ImageSetInstance objects and its children
            image_attr_dic = {}
            self.HW_ODF_get_image_attributes(HW_img_set_inst_dic, image_attr_dic, switch_off_img_index)

            # set the position of the switch image
            GO_panel_element_dic['PositionX'] = image_attr_dic['LeftXPosPixels']
            GO_panel_element_dic['PositionY'] = image_attr_dic['TopYPosPixels']

            # get the image dimensions if they are not defined in the HW ODF
            img_w = img_h = None
            if (image_attr_dic['ImageWidthPixels'] == None or image_attr_dic['ImageHeightPixels'] == None) and image_attr_dic['BitmapFilename'] != None:
                image_path = self.HW_sample_set_odf_path + os.sep + path2ospath(image_attr_dic['BitmapFilename'])
                if os.path.isfile(image_path):
                    im = Image.open(image_path)
                    img_w = im.size[0]
                    img_h = im.size[1]

            if image_attr_dic['ImageWidthPixels'] != None:
                GO_panel_element_dic['Width'] = int(image_attr_dic['ImageWidthPixels'])
            elif img_w != None:
                GO_panel_element_dic['Width'] = img_w
            else:
                GO_panel_element_dic['Width'] = 32  # size of the default setter image of GO

            if image_attr_dic['ImageHeightPixels'] != None:
                GO_panel_element_dic['Height'] = int(image_attr_dic['ImageHeightPixels'])
            elif img_h != None:
                GO_panel_element_dic['Height'] = img_h
            else:
                GO_panel_element_dic['Height'] = 32  # size of the default setter image of GO

           # set the mouse clickable rectangle width
            if image_attr_dic['ClickableAreaLeftRelativeXPosPixels'] not in (None, 0):
                GO_panel_element_dic['MouseRectLeft'] = int(image_attr_dic['ClickableAreaLeftRelativeXPosPixels'])

            if image_attr_dic['ClickableAreaRightRelativeXPosPixels'] not in (None, 0):
                if image_attr_dic['ClickableAreaLeftRelativeXPosPixels'] != None:
                    GO_panel_element_dic['MouseRectWidth'] = image_attr_dic['ClickableAreaRightRelativeXPosPixels'] - image_attr_dic['ClickableAreaLeftRelativeXPosPixels']
                else:
                    GO_panel_element_dic['MouseRectWidth'] = image_attr_dic['ClickableAreaRightRelativeXPosPixels']

            # set the mouse clickable rectangle height
            if image_attr_dic['ClickableAreaTopRelativeYPosPixels'] not in (None, 0):
                GO_panel_element_dic['MouseRectTop'] = int(image_attr_dic['ClickableAreaTopRelativeYPosPixels'])

            if image_attr_dic['ClickableAreaBottomRelativeYPosPixels'] not in (None, 0):
                if image_attr_dic['ClickableAreaTopRelativeYPosPixels'] != None:
                    GO_panel_element_dic['MouseRectHeight'] = image_attr_dic['ClickableAreaBottomRelativeYPosPixels'] - image_attr_dic['ClickableAreaTopRelativeYPosPixels']
                else:
                    GO_panel_element_dic['MouseRectHeight'] = image_attr_dic['ClickableAreaBottomRelativeYPosPixels']

                GO_panel_element_dic['MouseRadius'] = 0

            # set the attributes of the switch OFF image
            if image_attr_dic['BitmapFilename'] != None:
                GO_panel_element_dic['ImageOff'] = image_attr_dic['BitmapFilename']
            if image_attr_dic['TransparencyMaskBitmapFilename'] != None:
                GO_panel_element_dic['MaskOff'] = image_attr_dic['TransparencyMaskBitmapFilename']

            # set the attributes of the switch ON image
            image_attr_dic = {}
            self.HW_ODF_get_image_attributes(HW_img_set_inst_dic, image_attr_dic, switch_on_img_index)
            if image_attr_dic['BitmapFilename'] != None:
                GO_panel_element_dic['ImageOn'] = image_attr_dic['BitmapFilename']
            if image_attr_dic['TransparencyMaskBitmapFilename'] != None:
                GO_panel_element_dic['MaskOn'] = image_attr_dic['TransparencyMaskBitmapFilename']

            # add in the HW Switch object the ID of the corresponding GO object
            HW_img_set_inst_dic['_GO_uid'] = GO_panel_element_uid
            HW_switch_dic['_GO_uid'] = GO_panel_element_uid

            if LOG_HW2GO_drawstop: print(f"             {GO_panel_element_uid} built for setter {GO_setter_name}")

            return GO_panel_element_uid
        else:
            if LOG_HW2GO_drawstop: print(f"             GO PanelElement NOT built for setter {GO_setter_name}")
            return None

    #-------------------------------------------------------------------------------------------------
    def GO_ODF_build_Rank_data_in_stop(self, HW_pipe_dic, GO_stop_dic, attack_bool):
        # build one pipe data (for noise effect) in the given GO Stop from the given HW Pipe_SoundEngine01, depending on the provided noise attack status
        # return the value of attack_bool which may have been updated in the function

        # the given HW pipe musts have always an attack sample
        # if the given HW pipe has a  release sample                       ==> build       attack pipe and    release pipe, attack_bool set to False
        # if the given HW pipe has no release sample and attack_bool=True  ==> build       attack pipe and no release pipe
        #            "             "            "    and attack_bool=False ==> build blank attack pipe and    release pipe from attack sample

        # used HW objects :
        #   Pipe_SoundEngine01 C> Pipe_SoundEngine01_Layer C> Pipe_SoundEngine01_AttackSample C> Sample
        #   Pipe_SoundEngine01 C> Pipe_SoundEngine01_Layer C> Pipe_SoundEngine01_ReleaseSample C> Sample

        # get the source HW WindCompartment of the given HW Pipe
        HW_wind_comp_dic = self.HW_ODF_get_object_by_ref_id('WindCompartment', HW_pipe_dic, 'WindSupply_SourceWindCompartmentID')
        # get the HW ScalingContinuousControlID of the current layer of the first pipe to use it as GO Enclosure of the whole GO Rank if any
        HW_pipe_layer_dic = self.HW_ODF_get_linked_objects_by_type(HW_pipe_dic, 'Pipe_SoundEngine01_Layer', TO_CHILD, FIRST_ONE)
        HW_cont_ctrl_dic = self.HW_ODF_get_object_by_ref_id('ContinuousControl', HW_pipe_layer_dic, 'AmpLvl_ScalingContinuousControlID')

        GO_windchest_uid = self.GO_ODF_build_WindchestGroup_object(HW_wind_comp_dic, HW_cont_ctrl_dic, None)
        GO_stop_dic['WindchestGroup'] = int(GO_windchest_uid[-3:])

        GO_stop_dic['FirstAccessiblePipeLogicalKeyNumber'] = 1
        GO_stop_dic['FirstAccessiblePipeLogicalPipeNumber'] = 1
        GO_stop_dic['NumberOfAccessiblePipes'] = 1
        GO_stop_dic['NumberOfLogicalPipes'] = 1
        GO_stop_dic['Percussive'] = 'N'
        GO_stop_dic['AcceptsRetuning'] = 'N'

        # get the first HW Pipe_SoundEngine01_Layer linked to the given HW Pipe_SoundEngine01 (the others if any are ignored)
        HW_pipe_layer_dic = self.HW_ODF_get_linked_objects_by_type(HW_pipe_dic, 'Pipe_SoundEngine01_Layer', TO_CHILD, FIRST_ONE)

        # get the pipe gain if any
        pipe_gain = myfloat(self.HW_ODF_get_attribute_value(HW_pipe_layer_dic, 'AmpLvl_LevelAdjustDecibels'))
        if pipe_gain != None and pipe_gain != 0:
            GO_stop_dic['Pipe001Gain'] = pipe_gain

        # get the pipe harmonic number if any
        pipe_harmonic_nb = myint(self.HW_ODF_get_attribute_value(HW_pipe_dic, 'Pitch_Tempered_RankBasePitch64ftHarmonicNum'))
        if pipe_harmonic_nb != None and pipe_harmonic_nb != 0:
            GO_stop_dic['Pipe001HarmonicNumber'] = pipe_harmonic_nb

        HW_pipe_attack_samples_list = self.HW_ODF_get_linked_objects_by_type(HW_pipe_layer_dic, 'Pipe_SoundEngine01_AttackSample', TO_CHILD)
        HW_pipe_release_samples_list = self.HW_ODF_get_linked_objects_by_type(HW_pipe_layer_dic, 'Pipe_SoundEngine01_ReleaseSample', TO_CHILD)

        # decide if attack and/or release pipes have to be built
        if len(HW_pipe_release_samples_list) > 0:
            # there are both attack and release samples : it is a release sound (the attack sample is silent normally)
            attack_bool = False
        elif attack_bool:
            # there is no release sample and it is an attack noise : clear the release samples list if not already empty
            HW_pipe_release_samples_list.clear()
        else:
            # there is no release sample and it is an release noise : use the attack sample as release sample, use a silent attack
            HW_pipe_release_samples_list = list(HW_pipe_attack_samples_list)
            HW_pipe_attack_samples_list.clear()
            # use a silent loop sample as attack pipe
            GO_stop_dic['Pipe001'] = '..' + os.sep + 'SilentLoop.wav'
            self.silent_loop_file_used = True

        # define the attack pipes
        attacks_number = 0
        for HW_pipe_attack_sample_dic in HW_pipe_attack_samples_list:
            # scan the HW Pipe_SoundEngine01_AttackSample child objects of the Pipe_SoundEngine01_Layer object
            HW_sample_dic = self.HW_ODF_get_linked_objects_by_type(HW_pipe_attack_sample_dic, 'Sample', TO_CHILD, FIRST_ONE)
            if HW_sample_dic != None:
                attacks_number += 1
                HW_install_package_id = myint(self.HW_ODF_get_attribute_value(HW_sample_dic, 'InstallationPackageID', MANDATORY))
                sample_file_name = self.convert_HW2GO_file_name(self.HW_ODF_get_attribute_value(HW_sample_dic, 'SampleFilename', MANDATORY), HW_install_package_id)
                if sample_file_name != None:
                    if attacks_number == 1:
                        GO_stop_dic['Pipe001'] = sample_file_name
                    else:
                        GO_stop_dic['Pipe001AttackCount'] = attacks_number - 1
                        GO_stop_dic['Pipe001Attack' + str(attacks_number - 1).zfill(3)] = sample_file_name

        # define the release pipes
        if len(HW_pipe_release_samples_list) > 0:
            GO_stop_dic['Pipe001LoadRelease'] = 'N'
            GO_stop_dic['Pipe001ReleaseCount'] = 0
            for HW_pipe_release_sample_dic in HW_pipe_release_samples_list:
                HW_sample_dic = self.HW_ODF_get_linked_objects_by_type(HW_pipe_release_sample_dic, 'Sample', TO_CHILD, FIRST_ONE)
                if HW_sample_dic != None:
                    HW_install_package_id = myint(self.HW_ODF_get_attribute_value(HW_sample_dic, 'InstallationPackageID', MANDATORY))
                    sample_file_name = self.convert_HW2GO_file_name(self.HW_ODF_get_attribute_value(HW_sample_dic, 'SampleFilename', MANDATORY), HW_install_package_id)
                    if sample_file_name != None:
                        GO_stop_dic['Pipe001ReleaseCount'] += 1
                        GO_stop_dic['Pipe001Release' + str(GO_stop_dic['Pipe001ReleaseCount']).zfill(3)] = sample_file_name
        else:
            GO_stop_dic['Pipe001LoadRelease'] = 'Y'

        return attack_bool

    #-------------------------------------------------------------------------------------------------
    def GO_ODF_build_Rank_data_out_stop(self, HW_stop_dic, GO_stop_dic, GO_manual_dic, alternate_rank_bool=False):
        # build in the given GO Stop dictionary the data and links to GO Rank(s) for pipes sound generation from the given HW Stop object

        # used HW objects :
        #   Stop C> StopRank(s) (ActionTypeCode = 1, ActionEffectCode = 1) C> Rank C> Pipe_SoundEngine01 C> Pipe_SoundEngine01_Layer C> Pipe_SoundEngine01_AttackSample C> Sample
        #   Stop C> StopRank(s) (ActionTypeCode = 1, ActionEffectCode = 1) C> Rank C> Pipe_SoundEngine01 C> Pipe_SoundEngine01_Layer C> Pipe_SoundEngine01_ReleaseSample C> Sample

        # get some data about the GO manual to which is attached the GO Stop
        manual_first_midi_note = GO_manual_dic['FirstAccessibleKeyMIDINoteNumber']
        manual_nb_keys = GO_manual_dic['NumberOfLogicalKeys']

        GO_stop_dic['FirstAccessiblePipeLogicalKeyNumber'] = 0
        GO_stop_dic['NumberOfAccessiblePipes'] = 0
        GO_stop_dic['NumberOfRanks'] = 0
        GO_stop_nb_ranks = 0

        # add inside the given GO Stop references to GO Ranks
        for HW_stop_rank_dic in self.HW_ODF_get_linked_objects_by_type(HW_stop_dic, 'StopRank', TO_CHILD):
            # scan the HW StopRank objects which are children of the given HW Stop object

            # get some data of the current StopRank
            HW_div_nb_mapped_inputs = myint(self.HW_ODF_get_attribute_value(HW_stop_rank_dic, 'NumberOfMappedDivisionInputNodes'))
            if HW_div_nb_mapped_inputs == None: HW_div_nb_mapped_inputs = 61  # observed with HW Augustine Lorris sample set, this data is not defined for the Larigot stop
            HW_div_midi_note_first_mapped_input = myint(self.HW_ODF_get_attribute_value(HW_stop_rank_dic, 'MIDINoteNumOfFirstMappedDivisionInputNode'))
            HW_div_midi_note_increment_to_rank = myint(self.HW_ODF_get_attribute_value(HW_stop_rank_dic, 'MIDINoteNumIncrementFromDivisionToRank'))

            if HW_div_midi_note_first_mapped_input != None and HW_div_midi_note_first_mapped_input < manual_first_midi_note:
                # the first note of the current StopRank starts before the first note of the manual
                # set it at the first note of the manual and compute accordingly the number of notes of the StopRank
                HW_div_midi_note_first_mapped_input = manual_first_midi_note
                HW_div_nb_mapped_inputs -= manual_first_midi_note - HW_div_midi_note_first_mapped_input

            # get the HW Rank linked to the current HW StopRank
            if not alternate_rank_bool:
                HW_rank_dic = self.HW_ODF_get_object_by_ref_id('Rank', HW_stop_rank_dic, 'RankID')
            else:
                HW_rank_dic = self.HW_ODF_get_object_by_ref_id('Rank', HW_stop_rank_dic, 'AlternateRankID')

            # get the list of the HW Pipe_SoundEngine01 objects which are children of the current HW Rank object
            HW_pipes_dic_list = self.HW_ODF_get_linked_objects_by_type(HW_rank_dic, 'Pipe_SoundEngine01', TO_CHILD)
            if (HW_pipes_dic_list != None and len(HW_pipes_dic_list) > 0 and
                myint(self.HW_ODF_get_attribute_value(HW_stop_rank_dic, 'ActionTypeCode'), 1) == 1 and
                myint(self.HW_ODF_get_attribute_value(HW_stop_rank_dic, 'ActionEffectCode'), 1) == 1):
                # the current StopRank has normal action codes and is linked to a Rank having at least one pipe inside

                # get the number of pipes layers defined inside the first pipe of the current HW rank
                # we consider that all the pipes of the HW rank have the same number of layers as the first pipe has
                HW_pipe1_layers_dic_list = self.HW_ODF_get_linked_objects_by_type(HW_pipes_dic_list[0], 'Pipe_SoundEngine01_Layer', TO_CHILD)
                nb_pipe1_layers = len(HW_pipe1_layers_dic_list)

                for pipes_layer_nb in range(0, 1):  #nb_pipe1_layers):  # load only the first layer
                    # scan the pipes layers of the current HW rank, to build one GO rank for each HW rank layer

                    # get in the HW Pipe_SoundEngine01_Layer of the current layer of the first pipe the UID of the GO Rank associated to it
                    GO_rank_uid = HW_pipe1_layers_dic_list[pipes_layer_nb]['_GO_uid']
                    if GO_rank_uid == '':
                        # there is not yet a GO Rank built for the current HW rank layer
                        GO_rank_uid = self.GO_ODF_build_Rank_object(HW_rank_dic, pipes_layer_nb)
                        self.GO_odf_dic[GO_rank_uid]['_GO_manual_uid'] = GO_manual_dic['_GO_uid']
                    GO_rank_dic = self.GO_odf_dic[GO_rank_uid]

                    # add the GO Rank to the GO Stop
                    GO_stop_nb_ranks += 1
                    GO_stop_dic['Rank' + str(GO_stop_nb_ranks).zfill(3)] = GO_rank_uid[-3:]

                    # convert the current HW StopRank data into GO Stop data
                    if HW_div_midi_note_increment_to_rank != None:
                        # there is a note increment between the manual key number and the rank pipe number
                        if HW_div_midi_note_first_mapped_input != None:
                            GO_rank_first_access_key_nb = HW_div_midi_note_first_mapped_input - manual_first_midi_note + 1
                            GO_stop_rank_first_pipe_nb = HW_div_midi_note_first_mapped_input + HW_div_midi_note_increment_to_rank - GO_rank_dic['FirstMidiNoteNumber'] + 1
                        else:
                            if HW_div_midi_note_increment_to_rank < 0:
                                GO_rank_first_access_key_nb = 1 - HW_div_midi_note_increment_to_rank
                            else:
                                GO_rank_first_access_key_nb = 1
                            GO_stop_rank_first_pipe_nb = GO_rank_first_access_key_nb + HW_div_midi_note_increment_to_rank
                    elif HW_div_midi_note_first_mapped_input != None:
                        # there is no note increment defined but there is a mapping defined for the first input of the division which can act on the rank
                        GO_rank_first_access_key_nb = HW_div_midi_note_first_mapped_input - manual_first_midi_note + 1
                        GO_stop_rank_first_pipe_nb = HW_div_midi_note_first_mapped_input - GO_rank_dic['FirstMidiNoteNumber'] + 1
                    else:
                        # no increment and no mapping defined, by default the first key of the keyboard acts on the first pipe of the rank for this stop
                        GO_rank_first_access_key_nb = 1
                        GO_stop_rank_first_pipe_nb = 1

                    GO_stop_rank_pipe_count = HW_div_nb_mapped_inputs
##                    if GO_stop_rank_first_pipe_nb > GO_rank_dic['NumberOfLogicalPipes']:
##                        # the stop is using more pipes than what is defined in the rank
##                        GO_stop_rank_pipe_count = GO_rank_dic['NumberOfLogicalPipes']
##                    if GO_rank_first_access_key_nb + GO_stop_rank_pipe_count - 1 > manual_nb_keys:
##                        # the rank range is going beyond the highest key of the manual (observed with a sample set) : reduce its number of accessible pipes
##                        GO_stop_rank_pipe_count = manual_nb_keys - GO_rank_first_access_key_nb + 1

                    GO_stop_dic[f'Rank{str(GO_stop_nb_ranks).zfill(3)}FirstAccessibleKeyNumber'] = GO_rank_first_access_key_nb
                    if GO_stop_rank_first_pipe_nb > 1:
                        GO_stop_dic[f'Rank{str(GO_stop_nb_ranks).zfill(3)}FirstPipeNumber'] = GO_stop_rank_first_pipe_nb
                    GO_stop_dic[f'Rank{str(GO_stop_nb_ranks).zfill(3)}PipeCount'] = GO_stop_rank_pipe_count - GO_stop_rank_first_pipe_nb + 1

                    # add in the HW StopRank object the UID of the corresponding GO object
                    HW_stop_rank_dic['_GO_uid'] = GO_rank_uid

        if GO_stop_nb_ranks > 0:
            # based on the Rank999xxx attributes created just before in the GO Stop for each HW StopRank, compute remaining attributes of the GO Stop
            # identify the first and last keys of the manual which can access to the ranks associated to the stop
            GO_stop_first_access_key_nb = 999
            GO_stop_last_access_key_nb = 0
            for r in range(1, GO_stop_nb_ranks + 1):
                rank_first_key = GO_stop_dic[f'Rank{str(r).zfill(3)}FirstAccessibleKeyNumber']
                rank_last_key = rank_first_key + GO_stop_dic[f'Rank{str(r).zfill(3)}PipeCount'] - 1
                if GO_stop_first_access_key_nb > rank_first_key:
                    GO_stop_first_access_key_nb = rank_first_key
                if GO_stop_last_access_key_nb < rank_last_key:
                    GO_stop_last_access_key_nb = rank_last_key

            GO_stop_dic['FirstAccessiblePipeLogicalKeyNumber'] = GO_stop_first_access_key_nb
            GO_stop_dic['NumberOfAccessiblePipes'] = GO_stop_last_access_key_nb - GO_stop_first_access_key_nb + 1
            GO_stop_dic['NumberOfRanks'] = GO_stop_nb_ranks

            # adjust the Rank999FirstAccessibleKeyNumber attributes so that it is an offset value compated to FirstAccessiblePipeLogicalKeyNumber and no more an absolute value
            for r in range(1, GO_stop_nb_ranks + 1):
                GO_stop_dic[f'Rank{str(r).zfill(3)}FirstAccessibleKeyNumber'] -= (GO_stop_dic['FirstAccessiblePipeLogicalKeyNumber'] - 1)
                # remove the attribute if it has the default value
                if GO_stop_dic[f'Rank{str(r).zfill(3)}FirstAccessibleKeyNumber'] == 1:
                    GO_stop_dic.pop(f'Rank{str(r).zfill(3)}FirstAccessibleKeyNumber')
                if GO_stop_dic[f'Rank{str(r).zfill(3)}PipeCount'] == GO_stop_dic['FirstAccessiblePipeLogicalKeyNumber'] + GO_stop_dic['NumberOfAccessiblePipes'] - 1:
                    GO_stop_dic.pop(f'Rank{str(r).zfill(3)}PipeCount')

        else:
            # none rank build thanks to StopRank objects : try using the attribute Hint_PrimaryAssociatedRankID if defined
            HW_rank_id = myint(self.HW_ODF_get_attribute_value(HW_stop_dic, 'Hint_PrimaryAssociatedRankID'))
            HW_rank_dic = self.HW_ODF_get_object_dic('Rank', HW_rank_id)
            if HW_rank_dic != None:
                # the given HW Stop is linked to one Rank through the Hint attribute

                # get the list of the HW Pipe_SoundEngine01 objects which are children of the HW Rank
                HW_pipes_dic_list = self.HW_ODF_get_linked_objects_by_type(HW_rank_dic, 'Pipe_SoundEngine01', TO_CHILD)
                if len(HW_pipes_dic_list) > 0:
                    # the Rank has at least one pipe inside

                    # get the number of pipes layers defined inside the first pipe of the HW rank
                    # we consider that all the pipes of the HW rank have the same number of layers as the first pipe has
                    HW_pipe1_layers_dic_list = self.HW_ODF_get_linked_objects_by_type(HW_pipes_dic_list[0], 'Pipe_SoundEngine01_Layer', TO_CHILD)
                    nb_pipe1_layers = len(HW_pipe1_layers_dic_list)

                    for pipes_layer_nb in range(0, 1):  #nb_pipe1_layers):  # load only the first layer
                        # scan the pipes layers of the current HW rank, to build one GO rank for each HW rank layer

                        # get in the HW Pipe_SoundEngine01_Layer of the current layer of the first pipe the UID of the GO Rank associated to it
                        GO_rank_uid = HW_pipe1_layers_dic_list[pipes_layer_nb]['_GO_uid']
                        if GO_rank_uid == '':
                            # there is not yet a GO Rank built for the current HW rank layer
                            GO_rank_uid = self.GO_ODF_build_Rank_object(HW_rank_dic, pipes_layer_nb)
                            self.GO_odf_dic[GO_rank_uid]['_GO_manual_uid'] = GO_manual_dic['_GO_uid']
                        GO_rank_dic = self.GO_odf_dic[GO_rank_uid]

                        # add the GO Rank to the GO Stop
                        GO_stop_nb_ranks += 1
                        GO_stop_dic['Rank' + str(GO_stop_nb_ranks).zfill(3)] = GO_rank_uid[-3:]
                        GO_stop_dic[f'Rank{str(GO_stop_nb_ranks).zfill(3)}FirstAccessibleKeyNumber'] = 1
                        GO_stop_dic[f'Rank{str(GO_stop_nb_ranks).zfill(3)}FirstPipeNumber'] = 1
                        GO_stop_dic[f'Rank{str(GO_stop_nb_ranks).zfill(3)}PipeCount'] = len(HW_pipes_dic_list)

                        GO_stop_dic['FirstAccessiblePipeLogicalKeyNumber'] = 1
                        GO_stop_dic['NumberOfAccessiblePipes'] = len(HW_pipes_dic_list)
                        GO_stop_dic['NumberOfRanks'] = GO_stop_nb_ranks

    #-------------------------------------------------------------------------------------------------
    def GO_ODF_build_Rank_object(self, HW_rank_dic, pipes_layer_nb, unused_rank_bool=False):
        # build the GO Rank object from the given HW Rank object and its given layer number
        # if unused_rank_bool is set at True, manage the HW Rank as an unused rank (only pipes ranks are build in this case)
        # return the UID of the built GO Rank or None if not created

        # used HW objects :
        #   WindCompartment C> Pipe_SoundEngine01
        #   Rank C> Pipe_SoundEngine01 C> Pipe_SoundEngine01_Layer C> Pipe_SoundEngine01_AttackSample C> Sample
        #   Rank C> Pipe_SoundEngine01 C> Pipe_SoundEngine01_Layer C> Pipe_SoundEngine01_ReleaseSample C> Sample

        GO_rank_uid = ''

        # get the list of the HW Pipe_SoundEngine01 objects which are children of the given HW Rank
        HW_pipes_dic_list = self.HW_ODF_get_linked_objects_by_type(HW_rank_dic, 'Pipe_SoundEngine01', TO_CHILD)
        if len(HW_pipes_dic_list) > 0:
            # the current HW rank has pipes defined inside

#            if unused_rank_bool:
#                base_tuning_scheme_code = myint(self.HW_ODF_get_attribute_value(HW_pipes_dic_list[0], 'Pitch_Tempered_BaseTuningSchemeCode'))
#                base_pitch_harmonic_num = myint(self.HW_ODF_get_attribute_value(HW_pipes_dic_list[0], 'Pitch_Tempered_RankBasePitch64ftHarmonicNum'))
#                if base_tuning_scheme_code == 4 or base_pitch_harmonic_num == None or 'NOISE' in HW_rank_dic['Name'].upper():
#                    # it is a noise rank, this rank is to ignore if unused in GO ODF
#                    return ''

            # get the number of pipes layers defined inside the first pipe of the given HW rank
            # we consider that all the pipes of the HW rank have the same number of layers as the first pipe
            HW_pipe1_layers_dic_list = self.HW_ODF_get_linked_objects_by_type(HW_pipes_dic_list[0], 'Pipe_SoundEngine01_Layer', TO_CHILD)
            nb_pipe1_layers = len(HW_pipe1_layers_dic_list)

            # get the first and last MIDI note numbers defined in the HW Pipe_SoundEngine01 of the given HW Rank
            first_midi_note_nb = 999
            last_midi_note_nb = 0
            pipes_dic = {}  # dictionary with as key a MIDI note number and as value the dictionary of the associated Pipe_SoundEngine01 object
            for HW_pipe_dic in HW_pipes_dic_list:
                # scan the Pipe_SoundEngine01 objects of the current HW Rank

                # get the MIDI note number of the current HW Pipe_SoundEngine01
                midi_note_nb = myint(self.HW_ODF_get_attribute_value(HW_pipe_dic, 'NormalMIDINoteNumber'))
                if midi_note_nb == None: midi_note_nb = 60 # observed with Sound Paradisi sample sets, the MIDI note 60 is not defined
                if midi_note_nb >= 36:
                    # notes under MIDI 36 are ignored
                    # update the first/last MIDI note number data
                    if midi_note_nb < first_midi_note_nb:
                        first_midi_note_nb = midi_note_nb
                    if midi_note_nb > last_midi_note_nb:
                        last_midi_note_nb = midi_note_nb

                    # associate the dictionary of the current pipe to its MIDI note number
                    pipes_dic[midi_note_nb] = HW_pipe_dic

            # create a GO Rank999 object
            self.GO_odf_dic['Organ']['NumberOfRanks'] += 1
            GO_rank_uid = 'Rank' + str(self.GO_odf_dic['Organ']['NumberOfRanks']).zfill(3)
            GO_rank_dic = self.GO_odf_dic[GO_rank_uid] = {}

            if nb_pipe1_layers < 2:
                GO_rank_dic['Name'] = self.HW_ODF_get_attribute_value(HW_rank_dic, 'Name')
            else:
                GO_rank_dic['Name'] = self.HW_ODF_get_attribute_value(HW_rank_dic, 'Name') # + ' Layer' + str(pipes_layer_nb + 1)

            if unused_rank_bool:
                GO_rank_dic['Name'] += ' UNUSED'

            GO_rank_dic['FirstMidiNoteNumber'] = first_midi_note_nb
            GO_rank_dic['NumberOfLogicalPipes'] = len(pipes_dic)
            GO_rank_dic['Percussive'] = 'N'

            # get the source HW WindCompartment of the first pipe to use it as GO WindchestGroup of the whole GO Rank
            HW_wind_comp_dic = self.HW_ODF_get_object_by_ref_id('WindCompartment', HW_pipes_dic_list[0], 'WindSupply_SourceWindCompartmentID')
            # get the HW scaling ContinuousControl of the first pipe of the current layer to use it as GO Enclosure of the whole GO Rank if any
            HW_pipe_layers_dic_list = self.HW_ODF_get_linked_objects_by_type(HW_pipes_dic_list[0], 'Pipe_SoundEngine01_Layer', TO_CHILD)
            HW_pipe_layer_dic = HW_pipe_layers_dic_list[pipes_layer_nb]
            HW_cont_ctrl_dic = self.HW_ODF_get_object_by_ref_id('ContinuousControl', HW_pipe_layer_dic, 'AmpLvl_ScalingContinuousControlID')
            # get the HW Enclosure of the first pipe to use it as GO Enclosure of the whole GO Rank if any
            HW_enclosure_pipe_dic = self.HW_ODF_get_linked_objects_by_type(HW_pipes_dic_list[0], 'EnclosurePipe', TO_PARENT, FIRST_ONE)
            HW_enclosure_dic = self.HW_ODF_get_object_by_ref_id('Enclosure', HW_enclosure_pipe_dic, 'EnclosureID')
            # create the GO WindchestGroup corresponding to the current HW WindCompartment + ContinuousControl + Enclosure
            #   if not already existing, else recover the UID of the existing associated GO WindchestGroup
            GO_windchest_uid = self.GO_ODF_build_WindchestGroup_object(HW_wind_comp_dic, HW_cont_ctrl_dic, HW_enclosure_dic)
            GO_rank_dic['WindchestGroup'] = int(GO_windchest_uid[-3:])

            nb_pipes = 0
            for midi_note_nb in range(first_midi_note_nb, last_midi_note_nb + 1):
                # scan the HW Pipe_SoundEngine01_Layer objects by increasing MIDI note number

                if midi_note_nb in pipes_dic.keys():
                    HW_pipe_dic = pipes_dic[midi_note_nb]

                    # recover the pitch in Hertz of the current pipe if defined
                    HW_pipe_pitch_hz = myfloat(self.HW_ODF_get_attribute_value(HW_pipe_dic, 'Pitch_OriginalOrgan_PitchHz'))
                    if HW_pipe_pitch_hz == 0: HW_pipe_pitch_hz = None

                    # get the dictionary of the HW Pipe_SoundEngine01_Layer child of the current HW Pipe_SoundEngine01_Layer
                    # and corresponding to the given pipes layer number
                    HW_pipe_layers_dic_list = self.HW_ODF_get_linked_objects_by_type(HW_pipe_dic, 'Pipe_SoundEngine01_Layer', TO_CHILD)
                    HW_pipe_layer_dic = HW_pipe_layers_dic_list[pipes_layer_nb]

                    # add in the HW Pipe_SoundEngine01_Layer the ID of the corresponding GO object
                    HW_pipe_layer_dic['_GO_uid'] = GO_rank_uid

                    # set the GO pipe ID
                    nb_pipes += 1
                    GO_pipe_uid = 'Pipe' + str(nb_pipes).zfill(3)

                    # get the pipe gain if any
                    pipe_gain = myfloat(self.HW_ODF_get_attribute_value(HW_pipe_layer_dic, 'AmpLvl_LevelAdjustDecibels'))
                    if pipe_gain != None and pipe_gain != 0:
                        GO_rank_dic[GO_pipe_uid + 'Gain'] = pipe_gain

                    # set the MIDI note number of the current pipe
                    #GO_rank_dic[GO_pipe_uid + 'MIDIKeyNumber'] = midi_note_nb  #--> removed, see : https://github.com/GrandOrgue/ODFEdit/discussions/11#discussioncomment-5629225

                    # get the pipe harmonic number if any
                    pipe_harmonic_nb = myint(self.HW_ODF_get_attribute_value(HW_pipe_dic, 'Pitch_Tempered_RankBasePitch64ftHarmonicNum'))
                    if pipe_harmonic_nb != None and pipe_harmonic_nb != 0 and pipe_harmonic_nb != 8:  # 8 is the default value
                        GO_rank_dic[GO_pipe_uid + 'HarmonicNumber'] = pipe_harmonic_nb

                    # get the list of the Pipe_SoundEngine01_AttackSample child objects of the current Pipe_SoundEngine01_Layer object
                    HW_pipe_attack_samples_list = self.HW_ODF_get_linked_objects_by_type(HW_pipe_layer_dic, 'Pipe_SoundEngine01_AttackSample', TO_CHILD)
                    attacks_count = len(HW_pipe_attack_samples_list)

                    # apply if necessary a pitch tuning correction to the current pipe sample
                    if attacks_count > 0 and HW_pipe_pitch_hz != None:
                        # there is a pitch value defined for the current pipe and for the organ
                        # get the pitch defined for the first attack sample if any
                        HW_pipe_attack_sample_dic = HW_pipe_attack_samples_list[0]
                        HW_sample_dic = self.HW_ODF_get_linked_objects_by_type(HW_pipe_attack_sample_dic, 'Sample', TO_CHILD, FIRST_ONE)
                        HW_sample_pitch_hz = myfloat(self.HW_ODF_get_attribute_value(HW_sample_dic, 'Pitch_ExactSamplePitch'))
                        if HW_sample_pitch_hz != None and HW_sample_pitch_hz != HW_pipe_pitch_hz:
                            # the sample has a pitch defined and it has not the same frequency as the pipe one, need to apply a pitch tuning value to the pipe
                            GO_rank_dic[GO_pipe_uid + 'PitchTuning'] = delta_freq_to_cent(HW_pipe_pitch_hz, HW_sample_pitch_hz, self.HW_organ_pitch)

                    # manage the attack samples
                    attack_nb = 0
                    for HW_pipe_attack_sample_dic in HW_pipe_attack_samples_list:
                        # scan the HW Pipe_SoundEngine01_AttackSample child objects of the Pipe_SoundEngine01_Layer object
                        HW_sample_dic = self.HW_ODF_get_linked_objects_by_type(HW_pipe_attack_sample_dic, 'Sample', TO_CHILD, FIRST_ONE)
                        if HW_sample_dic != None:
                            attack_nb += 1
                            HW_install_package_id = myint(self.HW_ODF_get_attribute_value(HW_sample_dic, 'InstallationPackageID', MANDATORY))
                            sample_file_name = self.convert_HW2GO_file_name(self.HW_ODF_get_attribute_value(HW_sample_dic, 'SampleFilename', MANDATORY), HW_install_package_id)
                            if sample_file_name != None:
                                if attack_nb == 1:
                                    GO_rank_dic[GO_pipe_uid] = sample_file_name
                                    GO_rank_dic[GO_pipe_uid + 'LoadRelease'] = 'N'
                                else:
                                    if attack_nb == 2: GO_rank_dic[GO_pipe_uid + 'AttackCount'] = attacks_count - 1
                                    GO_rank_dic[GO_pipe_uid + 'Attack' + str(attack_nb - 1).zfill(3)] = sample_file_name
                                    GO_rank_dic[GO_pipe_uid + 'Attack' + str(attack_nb - 1).zfill(3) + 'LoadRelease'] = 'N'


                    # manage the release samples
                    # get the list of the Pipe_SoundEngine01_ReleaseSample child objects of the current Pipe_SoundEngine01_Layer object
                    HW_pipe_release_samples_list = self.HW_ODF_get_linked_objects_by_type(HW_pipe_layer_dic, 'Pipe_SoundEngine01_ReleaseSample', TO_CHILD)
                    if len(HW_pipe_release_samples_list) > 0:
                        # there are release samples
                        GO_rank_dic[GO_pipe_uid + 'ReleaseCount'] = len(HW_pipe_release_samples_list)
                        release_nb = 0
                        for HW_pipe_release_sample_dic in HW_pipe_release_samples_list:

                            # get the max key release time for the current release sample
                            HW_max_key_release_time_int = myint(self.HW_ODF_get_attribute_value(HW_pipe_release_sample_dic, 'ReleaseSelCriteria_LatestKeyReleaseTimeMs'))

                            # get the dictionary of the first Sample child object of the current Pipe_SoundEngine01_ReleaseSample object
                            HW_sample_dic = self.HW_ODF_get_linked_objects_by_type(HW_pipe_release_sample_dic, 'Sample', TO_CHILD, FIRST_ONE)
                            release_nb += 1

                            HW_install_package_id = myint(self.HW_ODF_get_attribute_value(HW_sample_dic, 'InstallationPackageID', MANDATORY))
                            sample_file_name = self.convert_HW2GO_file_name(self.HW_ODF_get_attribute_value(HW_sample_dic, 'SampleFilename', MANDATORY), HW_install_package_id)
                            if sample_file_name != None:
                                GO_rank_dic[GO_pipe_uid + 'Release' + str(release_nb).zfill(3)] = sample_file_name

                            if HW_max_key_release_time_int == None or HW_max_key_release_time_int == 99999 or HW_max_key_release_time_int == -1:
                                #GO_rank_dic[GO_pipe_uid + 'Release' + str(release_nb).zfill(3) + 'MaxKeyPressTime'] = '-1'
                                pass  # -1 is the default value, no need to add the attribute
                            else:
                                GO_rank_dic[GO_pipe_uid + 'Release' + str(release_nb).zfill(3) + 'MaxKeyPressTime'] = HW_max_key_release_time_int

            # add in the HW Rank object the ID of the corresponding GO object
            HW_rank_dic['_GO_uid'] = GO_rank_uid

        return GO_rank_uid

    #-------------------------------------------------------------------------------------------------
    def GO_ODF_build_WindchestGroup_object(self, HW_wind_comp_dic, HW_cont_ctrl_dic, HW_enclosure_dic):
        # build the GO WindchestGroup object corresponding to the given HW WindCompartment + ContinuousControl + Enclosure (two last parameters can be at None)
        # a GO WindchestGroup corresponds to a HW WindCompartment + HW ContinuousControl (if not None) + HW Enclosure (if not None)
        # return the UID of the GO WindchestGroup built or already existing

        # used HW objects :
        #   WindCompartment

        # recover the HW ContinuousControl controlling the given HW Enclosure (linked to pipe object) and being visible if any
        HW_enc_cont_ctrl_dic = self.HW_ODF_get_linked_objects_by_type(HW_enclosure_dic, 'ContinuousControl', TO_PARENT, FIRST_ONE)
        HW_enc_cont_ctrl_dic = self.HW_ODF_get_controlling_continuous_control(HW_enc_cont_ctrl_dic)

        # recover the HW ContinuousControl controlling the given HW ContinousControl (linked to pipe layer object) and being visible if any
        HW_cont_ctrl_dic = self.HW_ODF_get_controlling_continuous_control(HW_cont_ctrl_dic)

        # search if there is already a GO WindchestGroup matching with the given HW WindCompartment + Continuouscontrol + Enclosure continuous control at the same time
        for GO_object_uid, GO_object_dic in self.GO_odf_dic.items():
            # scan the defined GO objects
            if GO_object_uid[0] == 'W':
                # it is a WindchestGroup object
                HW_wind_comp_uid = GO_object_dic['_HW_wc_uid']
                HW_cont_ctrl_uid = GO_object_dic['_HW_cc_uid']
                HW_enc_cont_ctrl_uid = GO_object_dic['_HW_enc_cc_uid']
                if (HW_wind_comp_dic == self.HW_ODF_get_object_dic(HW_wind_comp_uid) and
                    ((HW_cont_ctrl_dic == None and HW_cont_ctrl_uid == '') or
                     (HW_cont_ctrl_dic != None and HW_cont_ctrl_dic == self.HW_ODF_get_object_dic(HW_cont_ctrl_uid))) and
                    ((HW_enc_cont_ctrl_dic == None and HW_enc_cont_ctrl_uid == '') or
                     (HW_enc_cont_ctrl_dic != None and HW_enc_cont_ctrl_dic == self.HW_ODF_get_object_dic(HW_enc_cont_ctrl_uid)))):
                    # the current GO WindchesGroup matches with the given parameters : no need to create a new GO WindchestGroup
                    return GO_object_dic['_GO_uid']

        # create a new GO WindchestGroup
        self.GO_odf_dic['Organ']['NumberOfWindchestGroups'] += 1
        GO_windchest_uid = 'WindchestGroup' + str(self.GO_odf_dic['Organ']['NumberOfWindchestGroups']).zfill(3)
        GO_windchest_dic = self.GO_odf_dic[GO_windchest_uid] = {}
        GO_windchest_dic['_GO_uid'] = GO_windchest_uid

        GO_windchest_dic['Name'] = self.HW_ODF_get_attribute_value(HW_wind_comp_dic, 'Name')
        GO_windchest_dic['NumberOfEnclosures'] = 0

        # add in the HW WindCompartment the UID of the corresponding GO object (several GO WindchestGroup can be linked to the same HW WindCompartment)
        if '_GO_uid_list' not in HW_wind_comp_dic.keys(): HW_wind_comp_dic['_GO_uid_list'] = []
        HW_wind_comp_dic['_GO_uid_list'].append(GO_windchest_uid)
        # add in the GO WindchestGroup the UID of the corresponding HW WindCompartment
        GO_windchest_dic['_HW_wc_uid'] =  HW_wind_comp_dic['_HW_uid']

        # build a GO Enclosure if needed based on the given HW ContinuousControl
        GO_windchest_dic['_HW_cc_uid'] =  ''
        if HW_cont_ctrl_dic != None:
            GO_enclosure_uid = self.GO_ODF_build_Enclosure_object(HW_cont_ctrl_dic)
            if GO_enclosure_uid != '':
                GO_windchest_dic['_HW_cc_uid'] =  HW_cont_ctrl_dic['_HW_uid']
                GO_windchest_dic['NumberOfEnclosures'] = 1
                GO_windchest_dic['Enclosure001'] = GO_enclosure_uid[-3:]
                GO_windchest_dic['Name'] += '+' + self.GO_odf_dic[GO_enclosure_uid]['Name']
                HW_cont_ctrl_dic['_GO_uid'] = GO_enclosure_uid

        # build a GO Enclosure if needed based on the given HW Enclosure
        GO_windchest_dic['_HW_enc_cc_uid'] =  ''
        if HW_enc_cont_ctrl_dic != None:
            GO_enclosure_uid = self.GO_ODF_build_Enclosure_object(HW_enclosure_dic)
            if GO_enclosure_uid != '':
                GO_windchest_dic['_HW_enc_cc_uid'] =  HW_enc_cont_ctrl_dic['_HW_uid']
                GO_windchest_dic['NumberOfEnclosures'] += 1
                GO_windchest_dic['Enclosure' + str(GO_windchest_dic['NumberOfEnclosures']).zfill(3)] = GO_enclosure_uid[-3:]
                GO_windchest_dic['Name'] += '+' + self.GO_odf_dic[GO_enclosure_uid]['Name']
                HW_enc_cont_ctrl_dic['_GO_uid'] = GO_enclosure_uid

        GO_windchest_dic['NumberOfTremulants'] = 0

        return GO_windchest_uid

    #-------------------------------------------------------------------------------------------------
    def GO_ODF_build_Enclosure_object(self, HW_object_dic):
        # build a GO Enclosure object corresponding to the given HW object (ContinuousControl or Enclosure)
        # build a GO Panel999Element999 object with type=Enclosure corresponding to the given HW object and in the proper GO Panel
        # return the UID of the built GO enclosure

        # used HW objects :
        #   ContinuousControl C> ImageSetInstance C> ImageSet C> ImageSetElement
        #                                                     C> ContinuousControlImageSetStage

        HW_object_type = HW_object_dic['_HW_uid'][:-6]
        if HW_object_type == 'ContinuousControl':
            HW_cont_ctrl_dic = HW_object_dic
        elif HW_object_type == 'Enclosure':
            HW_cont_ctrl_dic = self.HW_ODF_get_linked_objects_by_type(HW_object_dic, 'ContinuousControl', TO_PARENT, FIRST_ONE)
        else:
            return ''

        if HW_cont_ctrl_dic['_GO_uid'] != '':
            # there is already a GO Enclosure linked to the given HW Continuouscontrol
            return HW_cont_ctrl_dic['_GO_uid']

        # recover the HW ContinuousControl which has a graphical interface and is controlling the given HW ContinuousControl
        HW_cont_ctrl_dic = self.HW_ODF_get_controlling_continuous_control(HW_cont_ctrl_dic)
        if HW_cont_ctrl_dic == None:
            # there is no graphical control
            return ''

        self.GO_odf_dic['Organ']['NumberOfEnclosures'] += 1
        GO_enclosure_uid = 'Enclosure' + str(self.GO_odf_dic['Organ']['NumberOfEnclosures']).zfill(3)
        GO_enclosure_dic = self.GO_odf_dic[GO_enclosure_uid] = {}

        GO_enclosure_dic['Name'] = self.HW_ODF_get_attribute_value(HW_object_dic, 'Name')
        GO_enclosure_dic['AmpMinimumLevel'] = 1  # if set at 0, when the enclosure is set at its minimum, there is no sound when the enclosure position is increased

        # add the graphical attributes of the enclosure

        # get the HW ImageSetInstance object associated to the given HW ContinuousControl
        HW_img_set_inst_dic = self.HW_ODF_get_object_by_ref_id('ImageSetInstance', HW_cont_ctrl_dic, 'ImageSetInstanceID')
        HW_display_page_id = myint(self.HW_ODF_get_attribute_value(HW_img_set_inst_dic, 'DisplayPageID', MANDATORY))
        HW_display_page_dic = self.HW_ODF_get_object_dic('DisplayPage', HW_display_page_id)

        # create a GO Panel999Element999 enclosure object to display the enclosure
        GO_panel_uid = HW_display_page_dic['_GO_uid']
        self.GO_odf_dic[GO_panel_uid]['NumberOfGUIElements'] += 1
        GO_panel_element_uid = GO_panel_uid + 'Element' + str(self.GO_odf_dic[GO_panel_uid]['NumberOfGUIElements']).zfill(3)
        GO_panel_element_dic = self.GO_odf_dic[GO_panel_element_uid] = {}

        GO_panel_element_dic['Type'] = 'Enclosure'
        GO_panel_element_dic['Enclosure'] = str(int(GO_enclosure_uid[-3:])).zfill(3)
        GO_panel_element_dic['DispLabelText'] = ''

        # get the image attributes of the first image index to set the attributes of the GO enclosure
        image_attr_dic = {}
        self.HW_ODF_get_image_attributes(HW_img_set_inst_dic, image_attr_dic, 1)

        GO_panel_element_dic['PositionX'] = image_attr_dic['LeftXPosPixels']
        GO_panel_element_dic['PositionY'] = image_attr_dic['TopYPosPixels']

        if image_attr_dic['ImageWidthPixels'] != None:
            GO_panel_element_dic['Width'] = image_attr_dic['ImageWidthPixels']
        else:
            GO_panel_element_dic['Width'] = 0

        if image_attr_dic['ImageHeightPixels'] != None:
            GO_panel_element_dic['Height'] = image_attr_dic['ImageHeightPixels']
        else:
            GO_panel_element_dic['Height'] = 0

        # set the mouse clickable area
        if image_attr_dic['ClickableAreaLeftRelativeXPosPixels'] != None:
            GO_panel_element_dic['MouseRectLeft'] = image_attr_dic['ClickableAreaLeftRelativeXPosPixels']
        if image_attr_dic['ClickableAreaTopRelativeYPosPixels'] != None:
            GO_panel_element_dic['MouseRectTop'] = image_attr_dic['ClickableAreaTopRelativeYPosPixels']
        else:
            GO_panel_element_dic['MouseRectTop'] = 0  # to avoid GO to set it at 13 by default
        if image_attr_dic['ClickableAreaRightRelativeXPosPixels'] != None:
            if image_attr_dic['ClickableAreaLeftRelativeXPosPixels'] != None:
                GO_panel_element_dic['MouseRectWidth'] = image_attr_dic['ClickableAreaRightRelativeXPosPixels'] - image_attr_dic['ClickableAreaLeftRelativeXPosPixels']
            else:
                GO_panel_element_dic['MouseRectWidth'] = image_attr_dic['ClickableAreaRightRelativeXPosPixels']
        if image_attr_dic['ClickableAreaBottomRelativeYPosPixels'] != None:
            if image_attr_dic['ClickableAreaTopRelativeYPosPixels'] != None:
                GO_panel_element_dic['MouseRectHeight'] = image_attr_dic['ClickableAreaBottomRelativeYPosPixels'] - image_attr_dic['ClickableAreaTopRelativeYPosPixels']
            else:
                GO_panel_element_dic['MouseRectHeight'] = image_attr_dic['ClickableAreaBottomRelativeYPosPixels']

        # get the number of bitmaps of the HW ContinuousControl
        HW_img_set_dic = self.HW_ODF_get_object_by_ref_id('ImageSet', HW_img_set_inst_dic, 'ImageSetID')
        HW_img_elems_list = self.HW_ODF_get_linked_objects_by_type(HW_img_set_dic, 'ImageSetElement', TO_CHILD)
        bitmap_count = len(HW_img_elems_list)
        if bitmap_count > 128: bitmap_count = 128  # GO supports up to 128 bitmaps
        GO_panel_element_dic['BitmapCount'] = bitmap_count

        # add the enclosure bitmaps
        for i in range(1, bitmap_count + 1):
            # scan the set of images of the enclosure
            image_attr_dic = {}
            self.HW_ODF_get_image_attributes(HW_img_set_inst_dic, image_attr_dic, i)
            if image_attr_dic['BitmapFilename'] != None:
                GO_panel_element_dic['Bitmap' + str(i).zfill(3)] = image_attr_dic['BitmapFilename']

                if GO_panel_element_dic['Width'] == 0 or GO_panel_element_dic['Height'] == 0:
                    # get the dimentions of the current image
                    img_w = img_h = 0
                    if (image_attr_dic['ImageWidthPixels'] == None or image_attr_dic['ImageHeightPixels'] == None) and image_attr_dic['BitmapFilename'] != None:
                        image_path = self.HW_sample_set_odf_path + os.sep + path2ospath(image_attr_dic['BitmapFilename'])
                        if os.path.isfile(image_path):
                            im = Image.open(image_path)
                            img_w = im.size[0]
                            img_h = im.size[1]
                    GO_panel_element_dic['Width'] = img_w
                    GO_panel_element_dic['Height'] = img_h

            if image_attr_dic['TransparencyMaskBitmapFilename'] != None:
                GO_panel_element_dic['Mask' + str(i).zfill(3)] = image_attr_dic['TransparencyMaskBitmapFilename']

        # add in the HW ContinuousControl object the ID of the corresponding GO object
        HW_cont_ctrl_dic['_GO_uid'] = GO_enclosure_uid

        return GO_enclosure_uid

    #-------------------------------------------------------------------------------------------------
    def convert_HW2GO_file_name(self, HW_file_name, HW_install_package_id):
        # return the given file path/name (for images or sounds or info files) converted from HW to GO format with path relative to ODF folder
        # in HW format the files path starts from the root package folder (named with 6 digits) and the folders separator is either / or \
        # in GO format the files path starts from the ODF location (in the HW folder OrganDefinitions) and the folders separator is \ (it can be / as well)

        os_file_name_str = path2ospath(HW_file_name)

        if os_file_name_str[0] == os.sep:
            # the HW file name must not start by a path separator (seen on some sample sets)
            os_file_name_str = os_file_name_str[1:]

        os_file_name_str = os.path.join(self.HW_sample_set_path, 'OrganInstallationPackages', str(HW_install_package_id).zfill(6), os_file_name_str)
        actual_file_name_str = get_actual_file_name(os_file_name_str)

        # return the GO file path/name relative to the folder where is located the ODF and with the \ folders separator
        if actual_file_name_str != None:
            return '..' + actual_file_name_str[len(self.HW_sample_set_path):].replace(os.sep,'\\')
        else:
            # file not found in the sample set files
            if DEV_MODE:
                # return the given file name which comes from the HW ODF
                # permits to test HW ODF conversion without having all the files of the sample set on the computer
                return '..' + os_file_name_str[len(self.HW_sample_set_path):].replace(os.sep,'\\')
            else:
                if HW_install_package_id in self.available_HW_packages_id_list:
                    # don't show warning for file missing in the packages which are not of the sample set (i.e. standard packages of Hauptwerk)
                    logs.add(f'WARNING : file not found in the sample set : {os_file_name_str}')
                return None

    #-------------------------------------------------------------------------------------------------
    def HW_DIC2UID(self, HW_DIC):
        # for logging purpose, return the same type as the given data with all the present HW object dictionary converted sto HW object UID string

        if isinstance(HW_DIC, dict):
            if '_HW_uid' in HW_DIC.keys():
                # it is the dictionary of a HW object
                return HW_DIC['_HW_uid']
            else:
                # it is another kind of dictionary content, scan the values of each key
                uid_dic = {}
                for key, value in HW_DIC.items():
                    uid_dic[key] = self.HW_DIC2UID(value)
                return uid_dic

        elif isinstance(HW_DIC, list):
            uid_list = []
            for hw_dic in HW_DIC:
                uid_list.append(self.HW_DIC2UID(hw_dic))
            return uid_list

        elif isinstance(HW_DIC, str):
            return HW_DIC

#-------------------------------------------------------------------------------------------------
class C_GUI():
    # class to manage the graphical user interface of the application

    odf_data = None             # one instance of the C_ODF_DATA class
    odf_hw2go = None            # one instance of the C_ODF_HW2GO class

    odf_file_save_encoding = '' # StringVar with encoding type (ENCODING_ISO_8859_1 or ENCODING_UTF8_BOM) to use when saving data in an ODF
    odf_file_dir = ''           # directory of the last opened or saved ODF

    selected_object_app = 'GO'  # application associated to the object currently selected : 'GO' or 'HW', GO by default
    selected_object_uid = None  # UID of the object currently selected in the objects lists (GO or HW) or objects tree widgets (GO)
    selected_linked_uid = None  # UID of the linked object currently selected in the linked objects list if any (GO)
    edited_object_uid = None    # UID of the edited object

    focused_objects_widget = None  # objects widget which has the focus : self.lst_objects_list / self.trv_objects_tree / self.lst_links_list / self.lst_hw_browser / None
    focused_sel_item_id = None     # identifier of the selected item of the focused widget

    key_control_pressed_bool = False # flag indicating if a Control key is currently pressed on the keyboard of the computer in OdfEdit

    ignore_b1_release = False      # flag permitting to ignore the processing of the mouse button 1 release event

    opened_objects_iid_list = []   # list of the objects tree nodes iid which are opened

    odf_data_changed = False       # flag indicating that data have been changed in the odf_data and not saved in an ODF
    edited_object_changed = False  # flag indicating that data have been changed in the object currently edited (and not yet applied in odf_data)

    is_loaded_hw_odf = False       # flag set at True if a Hauptwerk ODF is currently loaded

    gui_events_blocked = False     # flag indicating that the GUI events are currently blocked

    text_to_search = None       # text which has to be searched in the help
    search_index = None         # last search result position in the help

    hw2go_warning_displayed = False         # flag indicating that the HW to GO conversion warning has been displayed one time in the current life cycle of the application
    hw2go_convert_unused_ranks_bool = False # flag BooleanVar set by the menu to ask the HW 2 GO conversion of the HW ranks not used by the conversion
    hw2go_convert_alt_ranks_bool = False    # flag BooleanVar set by the menu to ask the HW 2 GO convertion of the alternate ranks (for wave based tremulants)

    objects_tree_auto_expand_bool = True # flag BooleanVar set by the menu to define if the objects tree has to be expanded automatically on object selection
                                         # in order to make visible all the occurrences of this object in the tree

    #-------------------------------------------------------------------------------------------------
    def reset_all_data(self):
        # reset all the data of the class

        self.selected_object_app = 'GO'
        self.selected_object_uid = None
        self.selected_linked_uid = None
        self.edited_object_uid = None

        self.focused_objects_widget = None
        self.focused_sel_item_id = None

        self.odf_data_changed = False
        self.edited_object_changed = False

        self.is_loaded_hw_odf = False

        self.odf_data.reset_all_data()
        self.odf_hw2go.reset_all_data()

        self.lst_odf_sresults.delete(0, END)

    #-----------------------------------------------------------------------------------------------
    def wnd_main_build(self):
        # build the main window of the application with all its GUI widgets

        # create the main window
        self.wnd_main = Tk(className='OdfEdit')
        self.wnd_main.title(MAIN_WINDOW_TITLE)
        self.wnd_main.geometry('1600x800+50+50')
        self.wnd_main.protocol("WM_DELETE_WINDOW", self.wnd_main_quit) # to ask the user to save his changed before to close the main window
        # assign an image to the main window icon
        icon = PhotoImage(file = os.path.dirname(__file__) + os.sep + 'resources' + os.sep + 'OdfEdit.png')
        self.wnd_main.iconphoto(False, icon)

        # define the styles of some widgets
        self.wnd_main.style = ttk.Style()
        self.wnd_main.style.theme_use('default')
        self.wnd_main.style.configure("Treeview", highlightthickness=3, font=('Calibri', 11), foreground="black")
        self.wnd_main.style.map('Treeview', background=[('selected', COLOR_SELECTED_ITEM)])
        self.wnd_main.style.configure("TNotebook.Tab", font=('Calibri', 11), foreground="black")
        self.wnd_main.option_add("*TCombobox*Listbox*Background", 'white')
        self.wnd_main.option_add("*TCombobox*Listbox*Foreground", 'black')
        self.wnd_main.option_add('*Dialog.msg.font', 'Calibri 11')
        self.wnd_main.option_add("*Button.Font", 'Calibri 11')

        # bind a fonction to react to ctrl + s or ctrl + S keyboard keys to save changed data
        self.wnd_main.bind('<Control-s>', self.wnd_main_key_ctrl_s)
        self.wnd_main.bind('<Control-S>', self.wnd_main_key_ctrl_s)

        self.wnd_main.bind('<KeyPress>', self.wnd_main_key_press)
        self.wnd_main.bind('<KeyRelease>', self.wnd_main_key_release)

        #--- create the various widgets inside the main window

        #-- top buttons bar

        # top frame to encapsulate widgets bar
        self.frm_top = Frame(self.wnd_main)
        self.frm_top.pack(side='top', fill='x')

        # button "New"
        self.btn_odf_new = Button(self.frm_top, text="New", fg="black", width=7, command=self.file_new)
        self.btn_odf_new.pack(side='left', padx=5, pady=5)

        # button "Open"
        self.btn_odf_file_open = Button(self.frm_top, text="Open", fg="black", width=7, command=self.file_open)
        self.btn_odf_file_open.pack(side='left', padx=5, pady=5)
        CreateToolTip(self.btn_odf_file_open, "Load a GrandOrgue ODF (extension .organ) or a Hauptwerk ODF (extension .Organ_Hauptwerk_xml or .xml).")

        # button "Save"
        self.btn_odf_file_save = Button(self.frm_top, text="Save", fg="black", width=7, state=DISABLED, command=self.file_save)
        self.btn_odf_file_save.pack(side='left', padx=5, pady=5)
        CreateToolTip(self.btn_odf_file_save, "Save the changes done in the last loaded GrandOrgue ODF.")

        # button "Save as..."
        self.btn_odf_file_saveas = Button(self.frm_top, text="Save as...", fg="black", width=10, state=DISABLED, command=self.file_saveas)
        self.btn_odf_file_saveas.pack(side='left', padx=5, pady=5)
        CreateToolTip(self.btn_odf_file_saveas, "Save the changes done in a new GrandOrgue ODF.")

        # button "Check ODF data"
        self.btn_data_check = Button(self.frm_top, text="Check ODF data", fg="black", width=15, state=DISABLED, command=self.odf_data_check)
        self.btn_data_check.pack(side='left', padx=5, pady=5)
        CreateToolTip(self.btn_data_check, "Execute checks in the loaded ODF data (syntax, compliance with the specification).")

        # button "Menu" and general menu
        self.btn_gen_menu = Button(self.frm_top, text="≡", fg="black", width=2, command=self.gen_menu_open)
        self.btn_gen_menu.pack(side='left', padx=5, pady=5)
        self.odf_file_save_encoding = StringVar(self.wnd_main)
        self.odf_file_save_encoding.set(ENCODING_ISO_8859_1)
        self.hw2go_convert_unused_ranks_bool = BooleanVar(self.wnd_main)
        self.hw2go_convert_alt_ranks_bool = BooleanVar(self.wnd_main)
        self.objects_tree_auto_expand_bool = BooleanVar(self.wnd_main)
        self.general_menu = Menu(self.btn_gen_menu, tearoff=0)
        self.general_menu['bg'] = 'snow2'
        self.general_menu.add_checkbutton(label="Save ODF with ISO-8859-1 encoding (else UTF-8-BOM)", onvalue=ENCODING_ISO_8859_1, offvalue=ENCODING_UTF8_BOM, variable=self.odf_file_save_encoding)
        self.general_menu.add_checkbutton(label="Auto expand objects tree on object selection", onvalue=True, offvalue=False, variable=self.objects_tree_auto_expand_bool)
#        self.general_menu.add_command(label="Extend the compass of a manual... TBD")  #, command=self.gen_menu_about)
        self.general_menu.add_separator()
        self.general_menu.add_checkbutton(label="HW to GO : convert wave based tremulants", onvalue=True, offvalue=False, variable=self.hw2go_convert_alt_ranks_bool)
        self.general_menu.add_checkbutton(label="HW to GO : convert unused ranks", onvalue=True, offvalue=False, variable=self.hw2go_convert_unused_ranks_bool)
        self.general_menu.add_separator()
        self.general_menu.add_command(label="Clear logs", command=self.logs_clear)
        self.general_menu.add_command(label="About...", command=self.gen_menu_about)
        self.general_menu.bind('<FocusOut>', self.gen_menu_close)

        # button "Quit"
        self.btn_quit_appli = Button(self.frm_top, text="Quit", fg="black", width=7, relief='groove', command=self.wnd_main_quit)
        self.btn_quit_appli.pack(side='left', padx=10, pady=5)

        # label with loaded ODF file name or to display progression status
        self.lab_odf_file_name = Label(self.frm_top, text="", fg="black", borderwidth=1, relief="solid", anchor='w', height=1)
        self.lab_odf_file_name.pack(side='left', padx=5, pady=5, ipady=3, expand=1, fill='x')

        #-- bottom area with horizontal paned window on the full window width

        # horizontal paned window at the bottom of the main window
        self.paned_wnd = PanedWindow(self.wnd_main, orient ='horizontal', relief = 'sunken', sashrelief = 'raised', sashwidth = 10)
        self.paned_wnd.pack(side='bottom', padx=5, pady=5, expand=1, fill='both')

        #-- paned window element #1 (objects list)

        # frame to occupy the full area of the element #1
        self.frm_hpaned_wnd_1 = Frame(self.wnd_main)
        self.paned_wnd.add(self.frm_hpaned_wnd_1, minsize=200, width=250)

        # label with the number of objects in the objects list, placed at the top of the parent frame
        self.lab_objects_nb = Label(self.frm_hpaned_wnd_1, text="", fg="black", borderwidth=0, relief="solid", anchor=CENTER)
        self.lab_objects_nb.pack(side = 'top', pady=10, fill='x')

        # frame to occupy the bottom area of the parent frame and to encapsulate the list box and its scroll bars
        self.frm_objects_list = Frame(self.frm_hpaned_wnd_1)
        self.frm_objects_list.pack(side = 'bottom', fill='both', expand=1)

        # list box with objects UIDs and names, with horizontal and vertical scroll bars, inside the parent frame
        self.scrollbarv_obj_list = ttk.Scrollbar(self.frm_objects_list, orient='vertical')
        self.scrollbarv_obj_list.pack(side=RIGHT, fill=Y)
        scrollbarh = ttk.Scrollbar(self.frm_objects_list, orient='horizontal')
        scrollbarh.pack(side=BOTTOM, fill=X)
        self.lst_objects_list = Listbox(self.frm_objects_list, bg='white', font='Calibri 11', fg="black", selectbackground=COLOR_SELECTED_ITEM, exportselection=0, selectmode='single', activestyle='none')
        self.lst_objects_list.pack(side=LEFT, fill=BOTH, expand=1)
        self.lst_objects_list.bind('<<ListboxSelect>>', self.objects_list_selected)
        self.lst_objects_list.bind("<B1-Motion>", self.object_b1_motion)
        self.lst_objects_list.bind('<ButtonRelease-1>', self.object_b1_release)
        self.lst_objects_list.bind("<B1-Leave>", lambda event: "break")  # to avoid the auto scrolling in the list on drag
        self.lst_objects_list.config(yscrollcommand=self.scrollbarv_obj_list.set)
        self.lst_objects_list.config(xscrollcommand=scrollbarh.set)
        self.scrollbarv_obj_list.config(command=self.lst_objects_list.yview)
        scrollbarh.config(command=self.lst_objects_list.xview)

        #-- paned window element #2 (objects tree)

        # frame to occupy the full area of the element #2
        self.frm_paned_wnd_2 = Frame(self.wnd_main)
        self.paned_wnd.add(self.frm_paned_wnd_2, minsize=200, width=250)

        # frame to occupy the top area of the parent frame and to encamsulate collapse/expand buttons
        self.frm_top_paned_wnd_2 = Frame(self.frm_paned_wnd_2)
        self.frm_top_paned_wnd_2.pack(side='top', fill='x')

        # button "Collapse" for the objects tree
        self.btn_collapse_all = Button(self.frm_top_paned_wnd_2, text="Collapse", fg="black", state=DISABLED, command=self.objects_tree_collapse_all)
        self.btn_collapse_all.pack(side='left', padx=1, pady=5, fill='x', expand=1)

        # button "Expand" for the objects tree
        self.btn_expand_all = Button(self.frm_top_paned_wnd_2, text="Expand", fg="black", state=DISABLED, command=self.objects_tree_expand_all)
        self.btn_expand_all.pack(side='left', padx=1, pady=5, fill='x', expand=1)

        # button "Unselect"
        self.btn_unselect = Button(self.frm_top_paned_wnd_2, text="Unselect", fg="black", state=DISABLED, command=self.object_unselect)
        self.btn_unselect.pack(side='left', padx=1, pady=5, fill='x', expand=1)

        # frame to occupy the bottom area of the parent frame and to encapsulate the tree view and its scroll bars
        self.frm_object_tree = Frame(self.frm_paned_wnd_2)
        self.frm_object_tree.pack(side = 'bottom', fill='both', expand=1)

        # treeview to display the objects hierarchy, with horizontal and vertical scroll bars
        scrollbarv = ttk.Scrollbar(self.frm_object_tree, orient='vertical')
        scrollbarv.pack(side=RIGHT, fill=Y)
        scrollbarh = ttk.Scrollbar(self.frm_object_tree, orient='horizontal')
        scrollbarh.pack(side=BOTTOM, fill=X)
        self.trv_objects_tree = ttk.Treeview(self.frm_object_tree, show="tree", selectmode='extended')   #'browse')
        self.trv_objects_tree.pack(side=LEFT, fill=BOTH, expand=1)
        self.trv_objects_tree.column('#0', width=500)
        self.trv_objects_tree.bind('<<TreeviewSelect>>', self.objects_tree_selected)
        self.trv_objects_tree.bind("<B1-Motion>", self.object_b1_motion)
        self.trv_objects_tree.bind('<ButtonRelease-1>', self.object_b1_release)

        self.trv_objects_tree.config(yscrollcommand=scrollbarv.set)
        self.trv_objects_tree.config(xscrollcommand=scrollbarh.set)
        scrollbarv.config(command=self.trv_objects_tree.yview)
        scrollbarh.config(command=self.trv_objects_tree.xview)
        self.trv_objects_tree.tag_configure(TAG_SAME_UID, foreground='black', background=COLOR_OBJ_UID_ITEM)

        #-- paned window element #3 (object editor)

        # frame to occupy the full area of the element #3
        self.frm_paned_wnd_3 = Frame(self.wnd_main)
        self.paned_wnd.add(self.frm_paned_wnd_3, minsize=400, width=500)

        # vertical paned window placed inside the frame of the element #3
        self.obj_paned_wnd = PanedWindow(self.frm_paned_wnd_3, orient ='vertical', relief = 'sunken', sashrelief = 'raised', sashwidth = 10)
        self.obj_paned_wnd.pack(side='top', expand=1, fill='both')

        # frame to occupy the full area of the element #1 of the vertical paned window
        self.frm_obj_paned_wnd_1 = Frame(self.wnd_main)
        self.obj_paned_wnd.add(self.frm_obj_paned_wnd_1, minsize=120, height=200)

        # frame to occupy the top area of the parent frame and to encapsulate buttons
        self.frm_top_obj_paned_wnd_1 = Frame(self.frm_obj_paned_wnd_1)
        self.frm_top_obj_paned_wnd_1.pack(side='top', fill='x')

        # button "Apply"
        self.btn_object_apply_chg = Button(self.frm_top_obj_paned_wnd_1, text="Apply", fg="black", state=DISABLED, command=self.object_text_changes_apply)
        self.btn_object_apply_chg.pack(side='left', padx=1, pady=5, fill='x', expand=1)
        CreateToolTip(self.btn_object_apply_chg, "Apply the changes done in the text box below.")

        # button "Add"
        self.btn_object_add = Button(self.frm_top_obj_paned_wnd_1, text="Add", fg="black", state=NORMAL, command=self.object_add)
        self.btn_object_add.pack(side='left', padx=1, pady=5, fill='x', expand=1)
        CreateToolTip(self.btn_object_add, "Add a child object to the selected object or at the root.")

        # button "Parents"
        self.btn_object_parents = Button(self.frm_top_obj_paned_wnd_1, text="Parents", fg="black", state=DISABLED, command=lambda type=TO_PARENT: self.object_link(type))
        self.btn_object_parents.pack(side='left', padx=1, pady=5, fill='x', expand=1)
        CreateToolTip(self.btn_object_parents, "Set links between the selected object and parent objects.")

        # button "Children"
        self.btn_object_children = Button(self.frm_top_obj_paned_wnd_1, text="Children", fg="black", state=DISABLED, command=lambda type=TO_CHILD: self.object_link(type))
        self.btn_object_children.pack(side='left', padx=1, pady=5, fill='x', expand=1)
        CreateToolTip(self.btn_object_children, "Set links between the selected object and child objects.")

        # button "Rename"
        self.btn_object_rename = Button(self.frm_top_obj_paned_wnd_1, text="Rename", fg="black", state=DISABLED, command=self.object_rename)
        self.btn_object_rename.pack(side='left', padx=1, pady=5, fill='x', expand=1)
        CreateToolTip(self.btn_object_rename, "Rename the last three digits of the selected object.")

        # button "Delete"
        self.btn_object_delete = Button(self.frm_top_obj_paned_wnd_1, text="Delete", fg="black", state=DISABLED, command=self.object_delete)
        self.btn_object_delete.pack(side='left', padx=1, pady=5, fill='x', expand=1)
        CreateToolTip(self.btn_object_delete, "Delete the selected object.")

        # button "Help"
        self.btn_show_help = Button(self.frm_top_obj_paned_wnd_1, text="Help", fg="black", state=DISABLED, command=self.help_search_object)
        self.btn_show_help.pack(side='left', padx=1, pady=5, fill='x', expand=1)
        CreateToolTip(self.btn_show_help, "Show in the help the part describing the selected object type.")

        # frame to occupy the bottom area of the parent frame and to encapsulate the parent/children list and its vertical scroll bar
        self.frm_bottom_obj_paned_wnd_1 = Frame(self.frm_obj_paned_wnd_1)
        self.frm_bottom_obj_paned_wnd_1.pack(side='top', fill='both', expand=1)

        # list of the selected object UID and its linked parent/children UID
        scrollbarv = ttk.Scrollbar(self.frm_bottom_obj_paned_wnd_1, orient='vertical')
        scrollbarv.pack(side='right', fill='y')
        self.lst_links_list = Listbox(self.frm_bottom_obj_paned_wnd_1, bg='white', font='Calibri 11', fg="black", selectforeground="white", selectbackground=COLOR_SELECTED_ITEM, exportselection=0, selectmode='single', activestyle='none')
        self.lst_links_list.pack(side='top', fill='both', expand=1)
        self.lst_links_list.bind('<<ListboxSelect>>', self.object_links_list_selected)
        self.lst_links_list.bind('<Double-1>', self.object_links_list_selected_dbl)
        self.lst_links_list.bind("<B1-Motion>", self.object_b1_motion)
        self.lst_links_list.bind('<ButtonRelease-1>', self.object_b1_release)
        self.lst_links_list.bind("<B1-Leave>", lambda event: "break")  # to avoid the auto scrolling in the list on drag
        self.lst_links_list.config(yscrollcommand=scrollbarv.set)
        scrollbarv.config(command=self.lst_links_list.yview)

        # frame to occupy the full area of the element #2 of the vertical paned window
        self.frm_obj_paned_wnd_2 = Frame(self.wnd_main)
        self.obj_paned_wnd.add(self.frm_obj_paned_wnd_2, minsize=200, height=200)

        # text box with the object text and with horizontal and vertical scroll bars
        scrollbarv = ttk.Scrollbar(self.frm_obj_paned_wnd_2, orient='vertical')
        scrollbarv.pack(side='right', fill=Y)
        scrollbarh = ttk.Scrollbar(self.frm_obj_paned_wnd_2, orient='horizontal')
        scrollbarh.pack(side='bottom', fill=X)
        self.txt_object_text = Text(self.frm_obj_paned_wnd_2, fg="black", bg='gray95', bd=3, wrap="none", font="Calibri 11", selectbackground="snow3", undo=True)
        self.txt_object_text.pack(side=LEFT, fill=BOTH, expand=1)
        self.txt_object_text.bind('<<Modified>>', self.object_text_changed)
        self.txt_object_text.bind('<<Paste>>', self.object_text_paste)
        self.txt_object_text.bind('<KeyRelease>', self.object_text_key_pressed)
        self.txt_object_text.bind('<Control-Key-a>', self.object_text_select_all)
        self.txt_object_text.bind('<Control-Key-A>', self.object_text_select_all)
        self.txt_object_text.config(xscrollcommand=scrollbarh.set, yscrollcommand=scrollbarv.set)
        scrollbarv.config(command=self.txt_object_text.yview)
        scrollbarh.config(command=self.txt_object_text.xview)
        # define the tags for the syntax highlighting in the text box
        self.txt_object_text.tag_config(TAG_FIELD, foreground='red3')
        self.txt_object_text.tag_config(TAG_COMMENT, foreground='chartreuse4')
        self.txt_object_text.tag_config(TAG_OBJ_UID, foreground='blue2', font='Calibri 11 bold')

        #-- paned window element #4 (notebook with several tabs)

        # frame to occupy the full area of the element #4
        self.frm_paned_wnd_4 = Frame(self.wnd_main)
        self.paned_wnd.add(self.frm_paned_wnd_4, minsize=400, width=400)

        # notebook to display the events logs or the help
        self.notebook = ttk.Notebook(self.frm_paned_wnd_4)
        self.notebook.pack(side='top', fill='both', expand=1)

        # text box to display the application logs in the notebook, with horizontal/vertical scroll bars
        # a frame is used to encapsulate the text box and scroll bars
        self.frm_logs = Frame(self.notebook)
        self.frm_logs.pack(fill='both', expand=1)
        scrollbarv = ttk.Scrollbar(self.frm_logs, orient='vertical')
        scrollbarh = ttk.Scrollbar(self.frm_logs, orient='horizontal')
        scrollbarv.pack(side='right', fill=Y)
        scrollbarh.pack(side='bottom', fill=X)
        self.txt_events_log = Text(self.frm_logs, fg="black", bg='ivory2', bd=3, wrap="none", font='Calibri 11', selectbackground="grey")
        self.txt_events_log.pack(side=LEFT, fill='both', expand=1)
        self.txt_events_log.bind('<Control-Key-a>', self.logs_select_all)
        self.txt_events_log.bind('<Control-Key-A>', self.logs_select_all)
        self.txt_events_log.config(xscrollcommand=scrollbarh.set, yscrollcommand=scrollbarv.set)
        scrollbarv.config(command=self.txt_events_log.yview)
        scrollbarh.config(command=self.txt_events_log.xview)

        # text box to display the help in the notebook, with vertical scroll bar and search widgets
        # a main frame is used to encapsulate two other frames, one for the search widgets, one for the text box and his scroll bar
        self.frm_help = Frame(self.notebook)
        self.frm_help.pack(fill='both', expand=1)
        # widgets to search a text
        self.frm_help_top = Frame(self.frm_help)
        self.frm_help_top.pack(side='top', fill='x')
        self.lab_search = Label(self.frm_help_top, text="Search :", fg="black", borderwidth=0, relief="solid", anchor=E)
        self.lab_search.pack(side='left', padx=5, pady=5, fill='x')
        self.cmb_search_text = ttk.Combobox(self.frm_help_top, height=24, width=20, values=['[Organ]', '[Button]', '[Coupler999]', '[Divisional999]', '[DivisionalCoupler999]', '[DrawStop]', '[Enclosure999]', '[General999]', '[Image999]', '[Label999]', '[Manual999]', '[Panel999]', '[Panel999Element999]', '[Panel999Image999]', '[Panel999xxxxx999]', '[Piston]', '[PushButton]', '[Rank999]', '[ReversiblePiston999]', '[SetterElement999]', '[Stop999]', '[Switch999]', '[Tremulant999]', '[WindchestGroup999]'])
        self.cmb_search_text.pack(side='left', padx=5, pady=5, fill='x')
        self.cmb_search_text.bind('<KeyRelease>', self.help_search_text_key_pressed)
        self.cmb_search_text.bind('<<ComboboxSelected>>', self.help_search_text_key_pressed)
        self.btn_search_prev = Button(self.frm_help_top, text="<", fg="black", width=5, state=NORMAL, command=self.help_search_previous)
        self.btn_search_prev.pack(side='left', padx=5, pady=5, fill='x')
        self.btn_search_next = Button(self.frm_help_top, text=">", fg="black", width=5, state=NORMAL, command=self.help_search_next)
        self.btn_search_next.pack(side='left', padx=5, pady=5, fill='x')
        self.btn_search_clear = Button(self.frm_help_top, text="Clear", fg="black", width=10, state=NORMAL, command=self.help_search_clear)
        self.btn_search_clear.pack(side='left', padx=5, pady=5, fill='x')
        self.lab_search_occur_nb = Label(self.frm_help_top, text="", fg="black", borderwidth=0, relief="solid", anchor=W)
        self.lab_search_occur_nb.pack(side='left', padx=5, pady=5, fill='x')
        # help text box
        self.frm_help_bottom = Frame(self.frm_help)
        self.frm_help_bottom.pack(side = 'bottom', fill='both', expand=1)
        scrollbarv = ttk.Scrollbar(self.frm_help_bottom, orient='vertical')
        scrollbarv.pack(side='right', fill=Y)
        self.txt_help = Text(self.frm_help_bottom, fg="black", bg='azure', bd=3, wrap="word", font='Calibri 11', selectbackground="grey")
        self.txt_help.pack(side='bottom', fill='both', expand=1)
        self.txt_help.config(yscrollcommand=scrollbarv.set)
        scrollbarv.config(command=self.txt_help.yview)
        # define the tags for the syntax highlighting
        self.txt_help.tag_config(TAG_FIELD, foreground='red3')
        self.txt_help.tag_config(TAG_COMMENT, foreground='chartreuse4')
        self.txt_help.tag_config(TAG_OBJ_UID, foreground='blue2', font='Calibri 11 bold')
        self.txt_help.tag_config(TAG_TITLE, foreground='red3', font='Calibri 11 bold')

        # list to search in the GrandOrgue ODF and display the search results, with vertical scroll bar
        # a main frame is used to encapsulate two other frames, one for the search widgets, one for the list box and his vertical scroll bar
        self.frm_search = Frame(self.notebook)
        self.frm_search.pack(fill='both', expand=1)
        # widgets to search a text
        self.frm_search_top = Frame(self.frm_search)
        self.frm_search_top.pack(side='top', fill='x')
        self.ent_odf_search_text = Entry(self.frm_search_top, width=35)
        self.ent_odf_search_text.pack(side='left', padx=5, pady=5, fill='x')
        self.ent_odf_search_text.bind('<Return>', self.odf_search_text)
        self.btn_odf_search = Button(self.frm_search_top, text="Search", fg="black", state=NORMAL, command=self.odf_search_text)
        self.btn_odf_search.pack(side='left', padx=5, pady=5, fill='x')
        self.btn_odf_search_hw = Button(self.frm_search_top, text="HW search", fg="black", state=NORMAL, command=self.odf_search_text_hw)
        self.btn_odf_search_hw.pack(side='left', padx=5, pady=5, fill='x')
        # search results list box
        self.frm_search_bottom = Frame(self.frm_search)
        self.frm_search_bottom.pack(side = 'bottom', fill='both', expand=1)
        scrollbarv = ttk.Scrollbar(self.frm_search_bottom, orient='vertical')
        scrollbarv.pack(side=RIGHT, fill=Y)
        self.lst_odf_sresults = Listbox(self.frm_search_bottom, bg='light yellow', font='Calibri 11', fg="black", exportselection=0, selectmode='single', activestyle='none')
        self.lst_odf_sresults.pack(side=LEFT, fill='both', expand=True)
        self.lst_odf_sresults.bind('<ButtonRelease-1>', self.odf_search_text_result_selected)
        self.lst_odf_sresults.config(yscrollcommand=scrollbarv.set)
        scrollbarv.config(command=self.lst_odf_sresults.yview)

        # list to navigate inside the Hauptwerk objects in the ODF, with vertical scroll bar
        # a main frame is used to encapsulate two other frames, one for the search widgets, one for the list box and his vertical scroll bar
        self.frm_hw_browser = Frame(self.notebook)
        self.frm_hw_browser.pack(fill='both', expand=True)
        # widgets to search an object UID
        self.frm_hw_browser_top = Frame(self.frm_hw_browser)
        self.frm_hw_browser_top.pack(side='top', fill='x')
        self.ent_hw_uid_search_text = Entry(self.frm_hw_browser_top, width=40)
        self.ent_hw_uid_search_text.pack(side='left', padx=5, pady=5, fill='x')
        self.btn_hw_uid_search = Button(self.frm_hw_browser_top, text="UID search", fg="black", state=NORMAL, command=self.odf_search_uid_hw)
        self.btn_hw_uid_search.pack(side='left', padx=5, pady=5, fill='x')
        # browser list box
        self.frm_hw_browser_bottom = Frame(self.frm_hw_browser)
        self.frm_hw_browser_bottom.pack(side = 'bottom', fill='both', expand=1)
        scrollbarv = ttk.Scrollbar(self.frm_hw_browser_bottom, orient='vertical')
        scrollbarv.pack(side=RIGHT, fill=Y)
        self.lst_hw_browser = Listbox(self.frm_hw_browser_bottom, bg='alice blue', font='Calibri 11', fg="black", selectbackground=COLOR_SELECTED_ITEM, exportselection=0, selectmode='single', activestyle='none')
        self.lst_hw_browser.pack(side=LEFT, fill='both', expand=True)
        self.lst_hw_browser.bind('<ButtonRelease>', self.objects_list_selected_hw)
        self.lst_hw_browser.bind('<Double-1>', self.objects_list_selected_dbl_hw)
        self.lst_hw_browser.config(yscrollcommand=scrollbarv.set)
        scrollbarv.config(command=self.lst_hw_browser.yview)

        # create the notebook tabs, and attach the frames to them
        self.notebook.add(self.frm_logs, text="    Logs    ")
        self.notebook.add(self.frm_help, text="    Help    ")
        self.notebook.add(self.frm_search, text="    Search in ODF    ")
        self.notebook.add(self.frm_hw_browser, text="    Hauptwerk objects    ")
        self.notebook.hide(self.frm_hw_browser)  # will be visible only if a Hauptwerk ODF is opened

        # create an instance of the C_ODF_DATA class
        self.odf_data = C_ODF_DATA()

        # create an instance of the C_ODF_HW2GO class
        self.odf_hw2go = C_ODF_HW2GO()

        self.reset_all_data()

        # load the application data
        self.app_data_load()

        # update the status of GUI widgets
        self.gui_status_update_buttons()
        self.gui_status_update_objects_lists()
        self.gui_status_update_search()

        # display the logs resulting from the init of the application if any
        self.logs_display()

        # launch a timer to complete some initialization operations 200ms after the application start
        # to permit an application bring up as fast as possible
        self.wnd_main.after(20, self.init_complete)

        return self.wnd_main

    #-------------------------------------------------------------------------------------------------
    def wnd_main_quit(self):
        # (GUI event callback) the user has clicked on the button "Quit" or window top-right "X"

        if self.can_i_make_change(file_change_bool=True):
            # the user has saved his modifications if he wanted and has not canceled the operation
            # save application data
            self.app_data_save()
            # destroy the main window
            self.wnd_main.destroy()

    #-------------------------------------------------------------------------------------------------
    def wnd_main_key_ctrl_s(self, event):
        # (GUI event callback) the user has pressed on the ctrl + s or ctrl + S keyboard keys

        if self.object_text_changes_apply() and self.odf_data_changed:
            # changes have been made in the ODF data : save them
            self.file_save()

    #-------------------------------------------------------------------------------------------------
    def wnd_main_key_press(self, event):
        # (GUI event callback) the user has pressed a keyboard key

        if event.keysym in ('Control_L', 'Control_R'):
            # control left or right key pressed
            self.key_control_pressed_bool = True
            # update the mouse cursor aspect if it is not the default arrow (i.e. there is a drag&drop in progress)
            if self.wnd_main['cursor'] != '':
                self.wnd_main['cursor'] = 'plus'

    #-------------------------------------------------------------------------------------------------
    def wnd_main_key_release(self, event):
        # (GUI event callback) the user has released a keyboard key

        if event.keysym in ('Control_L', 'Control_R'):
            # control left or right key released
            self.key_control_pressed_bool = False
            # update the mouse cursor aspect if it is not the default arrow (i.e. there is a drag&drop in progress)
            if self.wnd_main['cursor'] != '':
                self.wnd_main['cursor'] = 'sb_up_arrow'

    #-------------------------------------------------------------------------------------------------
    def init_complete(self):
        # function to complete the initialization of the application

        # load the help text
        self.help_file_load()

        # load the GO objects templates
        self.odf_data.objects_templates_load()

        self.logs_display()

    #-------------------------------------------------------------------------------------------------
    def app_data_load(self):
        # load application configuration data from a .cfg file located in the folder of the OdfEdit file (.py or .exe)

        # initialize the saved application data with default values
        self.odf_file_dir = ''
        self.odf_file_save_encoding.set(ENCODING_UTF8_BOM)
        self.objects_tree_auto_expand_bool.set(False)
        self.hw2go_convert_unused_ranks_bool.set(False)
        self.hw2go_convert_alt_ranks_bool.set(False)

        try:
            # load the dictionary stored in the config file
            data_dic = {}
            with open('OdfEdit.cfg', 'r') as f:
                data_dic = eval(f.read())

            # recover each data from the dictionary if they are valid
            if 'last_odf_dir' in data_dic.keys() and os.path.isdir(data_dic['last_odf_dir']):
                self.odf_file_dir = data_dic['last_odf_dir']
            if 'file_save_encoding' in data_dic.keys() and data_dic['file_save_encoding'] in (ENCODING_ISO_8859_1, ENCODING_UTF8_BOM):
                self.odf_file_save_encoding.set(data_dic['file_save_encoding'])
            if 'auto_expand_tree' in data_dic.keys() and data_dic['auto_expand_tree'] in (True, False):
                self.objects_tree_auto_expand_bool.set(data_dic['auto_expand_tree'])
            if 'convert_unused_ranks' in data_dic.keys() and data_dic['convert_unused_ranks'] in (True, False):
                self.hw2go_convert_unused_ranks_bool.set(data_dic['convert_unused_ranks'])
            if 'convert_alt_ranks' in data_dic.keys() and data_dic['convert_alt_ranks'] in (True, False):
                self.hw2go_convert_alt_ranks_bool.set(data_dic['convert_alt_ranks'])

        except:
            # issue occured to read the config file : we keep the default values set before
            pass

    #-------------------------------------------------------------------------------------------------
    def app_data_save(self):
        # save application configuration data in a .cfg file located in the folder of the OdfEdit file (.py or .exe)

        # build a dictionary with the application data to save
        data_dic = {}
        data_dic['last_odf_dir'] = self.odf_file_dir
        data_dic['file_save_encoding'] = self.odf_file_save_encoding.get()
        data_dic['auto_expand_tree'] = self.objects_tree_auto_expand_bool.get()
        data_dic['convert_unused_ranks'] = self.hw2go_convert_unused_ranks_bool.get()
        data_dic['convert_alt_ranks'] = self.hw2go_convert_alt_ranks_bool.get()

        # save the dictionnary in the config file
        with open('OdfEdit.cfg', 'w') as f:
            f.write(str(data_dic))

    #-------------------------------------------------------------------------------------------------
    def file_new(self):
        # (GUI event callback) the user has clicked on the button "New"
        # do a reset of the objects list/tree, edit box and ODF data

        if self.can_i_make_change(file_change_bool=True):
            # the user has saved his modifications if he wanted and has not canceled the operation

            # reset the various data
            self.reset_all_data()

            # update the various GUI widgets
            self.objects_list_update()
            self.objects_list_update_hw()
            self.objects_tree_update()
            self.object_text_update()
            self.object_links_list_update()
            self.gui_status_update_buttons()
            self.gui_status_update_search()
            self.notebook.hide(self.frm_hw_browser)

    #-------------------------------------------------------------------------------------------------
    def file_open(self):
        # (GUI event callback) the user has clicked on the button "Open"

        if self.can_i_make_change(file_change_bool=True):
            # the user has saved his modifications if he wanted and has not canceled the operation

            # let the user select the ODF file to open
            file_name = fd.askopenfilename(title='Open an Organ Definition File (ODF)', initialdir = self.odf_file_dir , filetypes=[('All supported ODF', '*.organ *.xml *.Organ_Hauptwerk_xml'), ('GrandOrgue ODF', '*.organ'), ('Hauptwerk ODF', '*.xml *.Organ_Hauptwerk_xml')])
            if len(file_name) > 0:
                # a file has been selected by the user

                # reset the various data
                self.reset_all_data()
                self.gui_status_update_buttons()
                self.gui_status_update_search()

                # store the file extension of the selected file
                file_extension = os.path.splitext(file_name)[1]

                # store the directory of the selected file
                self.odf_file_dir = os.path.dirname(file_name)

                # reset the data and HMI
                self.file_new()

                # select the logs tab of the notebook to show the file opening logs
                self.notebook.select(self.frm_logs)
                self.notebook.hide(self.frm_hw_browser)

                if file_extension in ('.xml', '.Organ_Hauptwerk_xml'):
                    # Hauptwerk ODF selected : build a GrandOrgue ODF which uses the Hauptwerk sample set

                    HW_odf_file_name = path2ospath(file_name)
                    # define the name of the built GO ODF according to the name of the HW ODF : same path and file name, only the extension is changed
                    if file_extension == '.xml':
                        if '.Organ.Hauptwerk.xml' in HW_odf_file_name:
                            GO_odf_file_name = HW_odf_file_name.replace('.Organ.Hauptwerk.xml', '.organ')
                        else:
                            GO_odf_file_name = HW_odf_file_name.replace('.xml', '.organ')
                    else:
                        GO_odf_file_name = HW_odf_file_name.replace('.Organ_Hauptwerk_xml', '.organ')

                    # legal message displayed to the user before to start the ODF building
                    if not self.hw2go_warning_displayed and not DEV_MODE:
                        confirm = messagebox.askokcancel(title="Hauptwerk ODF conversion to GrandOrgue format", message=HW_CONV_MSG)
                    else:
                        confirm = True
                    if confirm:
                        self.hw2go_warning_displayed = True
                        if self.odf_hw2go.GO_ODF_build_from_HW_ODF(HW_odf_file_name, GO_odf_file_name, self.progress_status_update,
                                                                   self.hw2go_convert_unused_ranks_bool.get(), self.hw2go_convert_alt_ranks_bool.get(),
                                                                   self.odf_file_save_encoding.get()):
                            # the GO ODF building has succeeded
                            self.is_loaded_hw_odf = True
                            # display the HW objects notebook tab and list inside this tab
                            self.notebook.add(self.frm_hw_browser)
                            # the built GO ODF will be then loaded
                            file_name = GO_odf_file_name
                        else:
                            logs.add('ERROR : something went wrong while converting the Hauptwerk ODF in a GrandOrgue ODF')
                            file_name = ''
                        self.logs_display()
                    else:
                        file_name = ''

                if file_name != '':
                    # GrandOrgue ODF selected or built from a Hauptwerk ODF
                    self.progress_status_update('Loading ODF...')
                    if self.odf_data.load_from_file(file_name):
                        # the file has been loaded properly
                        # update the objects list / tree / text
                        self.initial_dir = file_name

                self.objects_list_update()
                self.objects_list_update_hw()
                self.objects_tree_update()
                self.object_text_update()
                self.object_links_list_update()
                self.gui_status_update_buttons()
                self.gui_status_update_search()

                self.logs_display()

    #-------------------------------------------------------------------------------------------------
    def file_save(self):
        # (GUI event callback) the user has clicked on the button "Save"
        # return True or False whether the saving has been done or not in the current loaded ODF

        return self.file_saveas(self.odf_data.odf_file_name)

    #-------------------------------------------------------------------------------------------------
    def file_saveas(self, file_name = ''):
        # (GUI event callback) the user has clicked on the button "Save as"
        # return True or False whether the saving has been done or not

        if file_name == '':
            # let the user select the ODF file in which to make the saving
            file_name = fd.asksaveasfilename(title='Save in ODF...', filetypes=[('ODF', '*.organ')])

        if file_name != '' and self.odf_data.save_to_file(file_name, self.odf_file_save_encoding.get()):
            # a file has been selected by the user
            # and the ODF data have been correctly saved

            # store the directory of the saved file
            self.odf_file_dir = os.path.dirname(file_name)

            self.odf_data_changed = False
            self.gui_status_update_buttons()
            data_saved = True
        else:
            data_saved = False

        self.logs_display()
        return data_saved

    #-------------------------------------------------------------------------------------------------
    def can_i_make_change(self, file_change_bool=False, object_change_bool=False):
        # before a file change or window closing (file_change_bool=True) or a selected object change (object_change_bool=True)
        # ask to the user if he wants to save his modifications if any, if the answer is yes then do it
        # return True if the change to do can be done

        change_ok_bool = True

        if file_change_bool:
            # the coming change will be at file level
            if self.edited_object_changed:
                # the selected object have been edited
                # ask to the user if he wants to apply changes made in the selected object and to save the changed ODF data
                if self.edited_object_uid != None:
                    confirm = messagebox.askyesnocancel(title="Apply and save changes ?", message=f"Do you want to apply and save changes made in {self.edited_object_uid} ?")
                else:
                    confirm = messagebox.askyesnocancel(title="Apply and save changes ?", message=f"Do you want to apply and save changes ?")
                if confirm:  # answer is yes
                    if not self.object_text_changes_apply():
                        change_ok_bool = False
                    elif not self.file_save():
                        change_ok_bool = False
                elif confirm is None:  # answer is cancel
                    change_ok_bool = False
                else:  # answer is no
                    pass

            elif self.odf_data_changed:
                # data have changed in the ODF data
                # ask to the user if he wants to save the changes done
                confirm = messagebox.askyesnocancel(title="Save changes ?", message=f"Do you want to save changes ?")
                if confirm:  # answer is yes
                    if not self.file_save():
                        change_ok_bool = False
                elif confirm is None:  # answer is cancel
                    change_ok_bool = False
                else:  # answer is no
                    pass

        elif self.edited_object_changed:
            # the coming change will be at selected object level, and the selected object have been edited
            # ask to the user if he wants to apply changes made in the selected object
            if self.edited_object_uid != None:
                confirm = messagebox.askyesnocancel(title="Apply changes ?", message=f"Do you want to apply changes made in {self.edited_object_uid} ?")
            else:
                confirm = messagebox.askyesnocancel(title="Apply changes ?", message=f"Do you want to apply changes ?")
            if confirm:  # answer is yes
                if not self.object_text_changes_apply():
                    change_ok_bool = False
            elif confirm is None:  # answer is cancel
                change_ok_bool = False
            else:  # answer is no
                pass

        return change_ok_bool

    #-------------------------------------------------------------------------------------------------
    def gui_events_block(self):
        # set the flag which blocks the GUI events processing and launch a blocking timer of 100ms

        if self.gui_events_blocked == False:
            # the events are not yet blocked
            self.gui_events_blocked = True
            # launch a timer which will unblock the events 100ms later, the time for the modified widgets to have completed their update
            self.wnd_main.after(100, self.gui_events_unblock)

    #-------------------------------------------------------------------------------------------------
    def gui_events_unblock(self):
        # (GUI event callback) end of a timer started by the function gui_events_block
        # reset the flag which blocks the GUI events processing

        self.gui_events_blocked = False

    #-------------------------------------------------------------------------------------------------
    def gui_status_update_buttons(self):
        # update the status of some GUI widgets in a single time, according to some status of the application

        # recover the number of defined objects in the ODF data
        objects_nb = self.odf_data.objects_number_get()

        # recover the list of possible parents and children objects of the selected object
        (possible_parents_list, possible_children_list) = self.odf_data.object_poss_kinship_list_get(self.edited_object_uid)
        possible_children_type_list = self.odf_data.object_poss_children_type_list_get(self.edited_object_uid)

        if 'Header' not in self.odf_data.objects_list_get() or 'Organ' not in self.odf_data.objects_list_get():
            # the root object Header or Organ is not present in the ODF
            root_object_not_def = True
        else:
            root_object_not_def = False

        # button "New"
        self.btn_odf_new['state'] = NORMAL if objects_nb > 0 else DISABLED

        # button "Save"
        self.btn_odf_file_save['state'] = NORMAL if (self.odf_data.odf_file_name != '' and self.odf_data_changed) else DISABLED
        self.btn_odf_file_save['foreground'] = 'red' if (self.odf_data.odf_file_name != '' and self.odf_data_changed) else 'grey'

        # button "Save as"
        self.btn_odf_file_saveas['state'] = NORMAL if objects_nb > 0 else DISABLED
        self.btn_odf_file_saveas['foreground'] = 'red' if (self.odf_data.odf_file_name == '' and self.odf_data_changed) else 'black'

        # button "Do check"
        self.btn_data_check['state'] = NORMAL if objects_nb > 0 else DISABLED

        # button "Apply changes"
        self.btn_object_apply_chg['state'] = NORMAL if self.edited_object_changed else DISABLED
        self.btn_object_apply_chg['foreground'] = 'red' if self.edited_object_changed else 'grey'

        # button "Add"
        self.btn_object_add['state'] = NORMAL if (len(possible_children_type_list) > 0 or root_object_not_def) else DISABLED

        # button "Parents"
        self.btn_object_parents['state'] = NORMAL if len(possible_parents_list) > 0 else DISABLED

        # button "Children"
        self.btn_object_children['state'] = NORMAL if len(possible_children_list) > 0 else DISABLED

        # button "Rename"
        self.btn_object_rename['state'] = NORMAL if (self.edited_object_uid != None and self.selected_object_app == 'GO' and self.edited_object_uid[-3:].isdigit()) else DISABLED

        # button "Delete"
        self.btn_object_delete['state'] = NORMAL if (self.edited_object_uid != None and self.selected_object_app == 'GO') else DISABLED

        # button "Unselect"
        self.btn_unselect['state'] = NORMAL if (self.edited_object_uid != None and self.selected_object_app == 'GO') else DISABLED

        # button "Show help"
        self.btn_show_help['state'] = NORMAL if (self.edited_object_uid not in (None, 'Header') and self.selected_object_app == 'GO') else DISABLED

        # buttons "Collapse all" and "Expand all"
        self.btn_collapse_all['state'] = NORMAL if objects_nb > 0 else DISABLED
        self.btn_expand_all['state'] = NORMAL if objects_nb > 0 else DISABLED

        # label with the loaded ODF name
        if self.odf_data.odf_file_name == '':
            if objects_nb == 0:
                self.lab_odf_file_name.config(text='Click on the button "Open" to load a GrandOrgue or Hauptwerk ODF, or "Add" to create new objects')
            else:
                self.lab_odf_file_name.config(text='Click on the button "Save as" to define a file name')
        else:
            self.lab_odf_file_name.config(text=self.odf_data.odf_file_name)
        self.lab_odf_file_name['foreground'] = 'black'

        # label with the number of objects
        if objects_nb == 0:
            self.lab_objects_nb.config(text="None object")
        elif objects_nb == 1:
            self.lab_objects_nb.config(text="1 object")
        else:
            self.lab_objects_nb.config(text=f"{objects_nb} objects")

    #-------------------------------------------------------------------------------------------------
    def gui_status_update_objects_lists(self):
        # update the selections in the GUI lists/tree

        # to block the GUI events triggered by the GUI updates done in this function
        self.gui_events_block()

        # GO objects list
        # highlight and make visible the item corresponding to the selected object UID
        self.lst_objects_list.selection_clear(0, 'end')
        for i in range(0, self.lst_objects_list.size()):
            object_uid = self.lst_objects_list.get(i).split(' ')[0]
            if object_uid == self.selected_object_uid and self.selected_object_app == 'GO':
                # the current item corresponds to the selected GO object UID : highlight it
                self.lst_objects_list.itemconfig(i, foreground='black', background=COLOR_OBJ_UID_ITEM)
            else:
                self.lst_objects_list.itemconfig(i, foreground='black', background='white')

            if self.focused_objects_widget == self.lst_objects_list and self.focused_sel_item_id == object_uid:
                # the current item has the focus : select it and make it visible
                self.lst_objects_list.selection_set(i)
                self.lst_objects_list.see(i)

        # GO linked objects list
        self.lst_links_list.selection_clear(0, 'end')
        for i in range(0, self.lst_links_list.size()):
            object_uid = self.lst_links_list.get(i).strip().split(' ')[0]
            if object_uid == self.selected_object_uid and self.selected_object_app == 'GO':
                # the current item corresponds to the selected GO object UID : highlight it
                self.lst_links_list.itemconfig(i, foreground='black', background=COLOR_OBJ_UID_ITEM)
            else:
                self.lst_links_list.itemconfig(i, foreground='black', background='white')

            if self.focused_objects_widget == self.lst_links_list and self.focused_sel_item_id == object_uid:
                # the current item has the focus : select it
                self.lst_links_list.selection_set(i)
                self.lst_links_list.see(i)

        # HW objects list
        if self.selected_object_app != 'HW':
            # clear the selected items if it is not a HW object which is selected
            self.lst_hw_browser.selection_clear(0, 'end')

        # GO objects tree
        if self.selected_object_app == 'GO':
            object_uid = self.selected_object_uid
        else:
            object_uid = None
        # select the items corresponding to the selected object UID
        for iid in self.trv_objects_tree.get_children():
            self.objects_tree_nodes_select(iid, object_uid)

    #-------------------------------------------------------------------------------------------------
    def gui_status_update_search(self):
        # update the status of GUI widgets of the search function in the notebook

        # buttons to search previous or next or clear the search in the help
        is_search_text = (self.cmb_search_text.get() != '')
        self.btn_search_prev['state']  = NORMAL if is_search_text else DISABLED
        self.btn_search_next['state']  = NORMAL if is_search_text else DISABLED
        self.btn_search_clear['state'] = NORMAL # if is_search_text else DISABLED

        if self.is_loaded_hw_odf:
            self.btn_odf_search_hw.pack(side='left', padx=5, pady=5, fill='x')
        else:
            self.btn_odf_search_hw.pack_forget()

    #-------------------------------------------------------------------------------------------------
    def objects_list_update(self):
        # do an update of the objects list widget content

        # clear the objects list widget content
        self.lst_objects_list.delete(0, 'end')

        # update the widget with the current list of sorted objects UID and name
        # puting the 'Header' and 'Organ' objects in first position of the list and excluding the Header object
        organ_text = None
        header_text = None
        for object_uid in sorted(self.odf_data.objects_list_get()):
            item_text = self.odf_data.object_names_get(object_uid)
            if object_uid == 'Organ':
                organ_text = item_text
            elif object_uid =='Header':
                header_text = item_text
            else:
                self.lst_objects_list.insert(END, item_text)

        if organ_text != None:
            self.lst_objects_list.insert(0, organ_text)
        if header_text != None:
            self.lst_objects_list.insert(0, header_text)

    #-------------------------------------------------------------------------------------------------
    def objects_list_update_hw(self, event=0):
        # do an update the Hauptwerk objects list widget

        tab = '      '

        # clear the HW objects list widget content
        self.lst_hw_browser.delete(0, END)

        # update the HW objects list widgets
        if len(self.odf_hw2go.HW_odf_dic):
            # there are HW ODF data in the dictionary
            if self.selected_object_uid == None or self.selected_object_app != 'HW':
                center_object_UID = "_General"
            else:
                center_object_UID = self.selected_object_uid

            selected_object_dic = self.odf_hw2go.HW_ODF_get_object_dic(center_object_UID)
            if selected_object_dic != None:
                # set the first element
                if center_object_UID != "_General":
                    self.lst_hw_browser.insert(END, '_General')
                self.lst_hw_browser.insert(END, '*** OBJECTS RELATIONSHIP (parents/current in red/children) ***')

                # display the parents of the selected object
                objects_uid_list = []
                for object_dic in selected_object_dic['_parents']:
                    objects_uid_list.append(object_dic['_HW_uid'])
                for object_uid in sorted(objects_uid_list):
                    object_dic = self.odf_hw2go.HW_ODF_get_object_dic(object_uid)
                    obj_name = self.odf_hw2go.HW_ODF_get_attribute_value(object_dic, 'Text')
                    if obj_name == None: obj_name = self.odf_hw2go.HW_ODF_get_attribute_value(object_dic, 'Name')
                    if obj_name != None:
                        self.lst_hw_browser.insert(END, object_uid + ' (' + obj_name + ')')
                    else:
                        self.lst_hw_browser.insert(END, object_uid)

                # display the selected object
                item_str = tab + center_object_UID
                obj_name = self.odf_hw2go.HW_ODF_get_attribute_value(selected_object_dic, 'Text')
                if obj_name == None:
                    obj_name = self.odf_hw2go.HW_ODF_get_attribute_value(selected_object_dic, 'Name')
                if obj_name != None:
                    item_str += ' (' + obj_name + ')'
                children_nb = len(self.odf_hw2go.HW_ODF_get_attribute_value(selected_object_dic, '_children'))
                if children_nb == 1:
                    item_str += '  >> 1 child'
                elif children_nb >= 1:
                    item_str += '  >> ' + str(children_nb) + ' children'
                self.lst_hw_browser.insert(END, item_str)
                self.lst_hw_browser.itemconfig(END, foreground='red')

                # display the children of the selected object
                objects_uid_list = []
                for object_dic in selected_object_dic['_children']:
                    objects_uid_list.append(object_dic['_HW_uid'])
                for object_uid in sorted(objects_uid_list):
                    item_str = tab + tab + object_uid
                    object_dic = self.odf_hw2go.HW_ODF_get_object_dic(object_uid)
                    obj_name = self.odf_hw2go.HW_ODF_get_attribute_value(object_dic, 'Text')
                    if obj_name == None:
                        obj_name = self.odf_hw2go.HW_ODF_get_attribute_value(object_dic, 'Name')
                    if obj_name != None:
                        item_str += ' (' + obj_name + ')'
                    children_nb = len(self.odf_hw2go.HW_ODF_get_attribute_value(object_dic, '_children'))
                    if children_nb == 1:
                        item_str += '  >> 1 child'
                    elif children_nb >= 1:
                        item_str += '  >> ' + str(children_nb) + ' children'
                    self.lst_hw_browser.insert(END, item_str)

            self.lst_hw_browser.insert(END, '*** OBJECTS WITH NO PARENT ***')

            # add at the end all the objects which have no parent except some types
            objects_uid_list = []
            for HW_object_type, HW_object_type_dic in self.odf_hw2go.HW_odf_dic.items():
                # scan the HW object types
                if not HW_object_type.startswith(('Pi', 'Sa', 'TremulantWaveformP', 'SwitchL', '_General')):
                    # excluded objects types are : Pipe_xxx, Sample, TremulantWaveformPipe, SwitchLinkage, _General
                    # the current HW object type can be added in the list
                    for object_dic in HW_object_type_dic.values():
                        # scan the HW objects of the current HW objects type
                        if len(object_dic['_parents']) == 0:
                            # the current object has no parent
                            objects_uid_list.append(object_dic['_HW_uid'])

            for object_uid in sorted(objects_uid_list):
                item_str = object_uid
                object_dic = self.odf_hw2go.HW_ODF_get_object_dic(object_uid)
                obj_name = self.odf_hw2go.HW_ODF_get_attribute_value(object_dic, 'Text')
                if obj_name == None:
                    obj_name = self.odf_hw2go.HW_ODF_get_attribute_value(object_dic, 'Name')
                if obj_name != None:
                    item_str += ' (' + obj_name + ')'
                children_nb = len(self.odf_hw2go.HW_ODF_get_attribute_value(object_dic, '_children'))
                if children_nb == 1:
                    item_str += '  >> 1 child'
                elif children_nb >= 1:
                    item_str += '  >> ' + str(children_nb) + ' children'
                self.lst_hw_browser.insert(END, item_str)

    #-------------------------------------------------------------------------------------------------
    def objects_list_selected(self, event):
        # (GUI event callback) the user has selected an item in the objects list widget

        if self.gui_events_blocked: return

        # get the line number of the selected item in the list
        cursel_tuple = self.lst_objects_list.curselection()
        if len(cursel_tuple) > 0:
            selected_line_indice = cursel_tuple[0]
        else:
            selected_line_indice = None

        if selected_line_indice != None:
            # an item has been selected in the list

            # ignore the mouse button 1 release if the edited object has been changed : to let the user say if he wants to save the change or not or cancel
            self.ignore_b1_release = self.edited_object_changed

            if self.can_i_make_change(object_change_bool=True):
                # the user has saved his modifications if he wanted and has not canceled the selection

                # recover in the objects list widget the UID of the selected object (before the first space in the selected item text)
                object_uid = self.lst_objects_list.get(selected_line_indice).split(' ')[0]
                self.selected_object_app = 'GO'
                self.selected_object_uid = object_uid
                self.selected_linked_uid = None
                self.edited_object_uid = self.selected_object_uid

                self.focused_objects_widget = self.lst_objects_list
                self.focused_sel_item_id = object_uid

                if self.ignore_b1_release:
                    # do now the processing of the mouse button 1 release
                    self.ignore_b1_release = False
                    self.object_b1_release(event)
                # else the widgets will be updated on mouse button release

            else:
                # the user had canceled the selection
                self.ignore_b1_release = False
                self.gui_status_update_objects_lists()

    #-------------------------------------------------------------------------------------------------
    def objects_list_selected_hw(self, event):
        # (GUI event callback) the user has selected an item in the Hauptwerk objects list widget

        if self.gui_events_blocked: return

        # get the line numbers of the selected item in the list
        cursel_tuple = self.lst_hw_browser.curselection()
        if len(cursel_tuple) > 0:
            selected_line_indice = cursel_tuple[0]
        else:
            selected_line_indice = None

        if selected_line_indice != None and self.can_i_make_change(object_change_bool=True):
            # an item of the HW objects list widget is selected
            # recover in the objects list widget the UID of the selected object (before the first space in the selected item text)
            self.selected_object_app = 'HW'
            self.selected_object_uid = self.lst_hw_browser.get(selected_line_indice).strip().split(' ')[0]
            if self.selected_object_uid[0] == '*': # item without object UID
                self.selected_object_uid = None
            self.selected_linked_uid = None
            self.edited_object_uid = self.selected_object_uid

            self.focused_objects_widget = self.lst_hw_browser
            self.focused_sel_item_id = self.selected_object_uid

            # update the object text box and links list
            self.object_links_list_update()
            self.object_text_update()

        # update the status of GUI widgets
        self.gui_status_update_buttons()
        self.gui_status_update_objects_lists()

    #-------------------------------------------------------------------------------------------------
    def objects_list_selected_dbl_hw(self, event):
        # (GUI event callback) the user has double-clicked an item in the Hauptwerk objects list widget

        if self.selected_object_uid != None:
            self.objects_list_update_hw()

    #-------------------------------------------------------------------------------------------------
    def objects_tree_update(self):
        # do an update of the objects tree widget

        # memorize the nodes of the tree which are currently opened to restore them in the updated list
        self.opened_objects_iid_list.clear()
        for iid in self.trv_objects_tree.get_children(''):
            self.objects_tree_node_and_children_opened_nodes_get(iid)

        # delete all the nodes of the tree
        for node_iid in self.trv_objects_tree.get_children():
            self.trv_objects_tree.delete(node_iid)

        odf_objects_list = self.odf_data.objects_list_get()
        if len(odf_objects_list) > 0:
            # there are existing objects

            # treeview insert syntax : insert(parent_iid or '', position (0 or 'end'), node_iid, keyword arguments...)

            if 'Header' in odf_objects_list:
                # place the Header object in first position of the tree
                iid = self.trv_objects_tree.insert('', 'end', 'Header', text='Header')

            if 'Organ' in odf_objects_list:
                # place the Organ object after the Header or in first position if no header
                organ_node_iid = self.trv_objects_tree.insert('', 'end', 'Organ', text=self.odf_data.object_names_get('Organ'), open=True)
            else:
                organ_node_iid = ''

            depth = 0
            for object_uid in sorted(odf_objects_list):
                if object_uid not in ('Header', 'Organ'):
                    # scan the objects UID of the objects list which are not Header or Organ
                    object_type = self.odf_data.object_type_get(object_uid)
                    if object_type in ('General', 'Manual', 'Panel', 'WindchestGroup', 'Image', 'Label', 'ReversiblePiston', 'SetterElement'):
                        # put the current object under the 'Organ' node
                        self.objects_tree_child_add(organ_node_iid, object_uid, depth)
                    elif len(self.odf_data.object_kinship_list_get(object_uid, TO_PARENT)) == 0:
                        # the object has no parent, put it at the root of the tree
                        self.objects_tree_child_add('', object_uid, depth)

    #-------------------------------------------------------------------------------------------------
    def objects_tree_child_add(self, parent_node_iid, child_object_uid, depth):
        # recursive function to insert in the objects tree widget the given child object UID under the given parent node ID

        # insert the given child object in the tree under the given parent node iid
        child_node_iid = self.trv_objects_tree.insert(parent_node_iid, 'end', parent_node_iid + child_object_uid, text=self.odf_data.object_names_get(child_object_uid))

        if child_node_iid in self.opened_objects_iid_list:
            # the given child node iid has to be opened
            self.trv_objects_tree.item(child_node_iid, open=True)
            self.opened_objects_iid_list.remove(child_node_iid)

        # the given child becomes the parent for the next recursive call
        new_parent_node_iid = child_node_iid
        new_parent_uid = child_object_uid
        new_parent_type = self.odf_data.object_type_get(new_parent_uid)

        # scan the children of new parent to add the corresponding children nodes
        if self.odf_data.object_dic_get(new_parent_uid) != None:
            # the new parent object UID exists in the ODF dictionary
            if not(new_parent_type == 'Manual' and depth > 0):
                # it is not a Manual object at depth higher than 1 (to avoid Manual childs in the tree when Manual is not child of Organ)
                for child_uid in sorted(self.odf_data.object_kinship_list_get(new_parent_uid, TO_CHILD)):
                    self.objects_tree_child_add(new_parent_node_iid, child_uid, depth + 1)

    #-------------------------------------------------------------------------------------------------
    def objects_tree_expand_all(self):
        # (GUI event callback) the user has pressed the button "Expand all"
        # expend all the nodes of the objects tree widget

        for iid in self.trv_objects_tree.get_children(''):
            self.objects_tree_node_and_children_open(iid, True)

    #-------------------------------------------------------------------------------------------------
    def objects_tree_collapse_all(self):
        # (GUI event callback) the user has pressed the button "Collapse all"
        # collapse all the nodes of the objects tree widget except the root and the 'Organ' nodes

        for iid in self.trv_objects_tree.get_children(''):
            self.objects_tree_node_and_children_open(iid, False)

    #-------------------------------------------------------------------------------------------------
    def objects_tree_node_and_parents_open(self, node_iid):
        # recursive function to open the given node and his parents in the objects tree

        if node_iid != '':
            # the node exists
            self.trv_objects_tree.item(node_iid, open=True)

            # apply the open status to the parent node of node_iid
            self.objects_tree_node_and_parents_open(self.trv_objects_tree.parent(node_iid))

    #-------------------------------------------------------------------------------------------------
    def objects_tree_node_and_children_open(self, node_iid, open_status):
        # recursive function to open (if True, else close) the given node and his children in the objects tree

        if self.trv_objects_tree.item(node_iid, option='text').startswith('Organ'):
            # the Organ node must stay always opened
            self.trv_objects_tree.item(node_iid, open=True)
        else:
            self.trv_objects_tree.item(node_iid, open=open_status)

        # apply the open status to the child nodes
        for iid in self.trv_objects_tree.get_children(node_iid):
            self.objects_tree_node_and_children_open(iid, open_status)

    #-------------------------------------------------------------------------------------------------
    def objects_tree_nodes_select(self, node_iid, object_uid):
        # recursive function to select and make visible the nodes of the objects tree which contain the given object UID text

        if object_uid != None and self.trv_objects_tree.item(node_iid)['text'].split(' ')[0] == object_uid:
            # the node node_iid corresponds to the object UID : tag it and open it parents nodes
            self.trv_objects_tree.item(node_iid, tags=TAG_SAME_UID)
            # open the parents of the node so that the object is visible if it is requested by the user in the menu
            if self.objects_tree_auto_expand_bool.get():
                self.objects_tree_node_and_parents_open(self.trv_objects_tree.parent(node_iid))
        else:
            # remove the tag on the node_iid if any
            self.trv_objects_tree.item(node_iid, tags=())

        if self.focused_objects_widget == self.trv_objects_tree and self.focused_sel_item_id != None and node_iid.endswith(self.focused_sel_item_id):
            # the current node has the focus (use of endswith in case the focused_sel_item_id doesn't fit the full path of the node iid)
            self.trv_objects_tree.selection_add(node_iid)
            self.trv_objects_tree.see(node_iid)
        else:
            self.trv_objects_tree.selection_remove(node_iid)

        # search to select the object_uid in the children of node_iid
        for iid in self.trv_objects_tree.get_children(node_iid):
            self.objects_tree_nodes_select(iid, object_uid)

    #-------------------------------------------------------------------------------------------------
    def objects_tree_node_show(self, object_uid, parent_uid, node_iid=''):
        # recursive function to show in the objects tree the node which has the given object UID under the given parent object UID

        if node_iid != '' and node_iid.endswith(parent_uid + object_uid):
            # the given node is matching the given UIDs (use of endswith in case the given parent + object UID doesn't fit the full path of the node iid)
            self.trv_objects_tree.see(node_iid)
            return True
        else:
            for iid in self.trv_objects_tree.get_children(node_iid):
                if self.objects_tree_node_show(object_uid, parent_uid, iid):
                    return True
            return False

    #-------------------------------------------------------------------------------------------------
    def objects_tree_node_and_children_opened_nodes_get(self, node_iid):
        # recursive function to build the list of the opened nodes from the given node iid and its children

        if self.trv_objects_tree.item(node_iid, 'open'):
            self.opened_objects_iid_list.append(node_iid)

        # check the children of the given node_iid
        for iid in self.trv_objects_tree.get_children(node_iid):
            self.objects_tree_node_and_children_opened_nodes_get(iid)

    #-------------------------------------------------------------------------------------------------
    def objects_tree_selected(self, event):
        # (GUI event callback) the user has selected an item in the objects tree widget

        if self.gui_events_blocked: return

        # get the iid of the selected node in the tree
        cursel_tuple = self.trv_objects_tree.selection()
        if len(cursel_tuple) > 0:
            selected_node_iid = cursel_tuple[0]
        else:
            selected_node_iid = None

        if selected_node_iid != None:
            # an item has been selected in the objects tree

            # ignore the mouse button 1 release if the edited object has been changed : to let the user say if he wants to save the change or not or cancel
            self.ignore_b1_release = self.edited_object_changed

            if self.can_i_make_change(object_change_bool=True):
                # the user has saved his modifications if he wanted and has not canceled the operation

                # recover the object UID
                object_uid = self.trv_objects_tree.item(selected_node_iid, option='text').split(' ')[0]
                self.selected_object_app = 'GO'
                self.selected_object_uid = object_uid
                self.selected_linked_uid = None
                self.edited_object_uid = self.selected_object_uid

                self.focused_objects_widget = self.trv_objects_tree
                self.focused_sel_item_id = selected_node_iid

                if self.ignore_b1_release:
                    # do now the processing of the mouse button 1 release
                    self.ignore_b1_release = False
                    self.object_b1_release(event)
                # else the widgets will be updated on mouse button release

            else:
                # the user had canceled the selection
                self.ignore_b1_release = False
                self.gui_status_update_objects_lists()

    #-------------------------------------------------------------------------------------------------
    def object_links_list_update(self):
        # update the selected object links list

        tab = '    '

        # clear the objects list widget content
        self.lst_links_list.delete(0, END)

        if self.selected_object_app == 'GO' and self.selected_object_uid not in (None, 'Header', 'Organ'):

            # display the selected object
            self.lst_links_list.insert('end', self.odf_data.object_names_get(self.selected_object_uid))

            # display the parents
            parents_list = sorted(self.odf_data.object_kinship_list_get(self.selected_object_uid, TO_PARENT))
            if len(parents_list) > 0:
                self.lst_links_list.insert('end', f'Parents : #{len(parents_list)}')
                for parent_uid in parents_list:
                    self.lst_links_list.insert('end', tab + self.odf_data.object_names_get(parent_uid))

            # display the children
            children_list = sorted(self.odf_data.object_kinship_list_get(self.selected_object_uid, TO_CHILD))
            if len(children_list) > 0:
                self.lst_links_list.insert('end', f'Children : #{len(children_list)}')
                for child_uid in children_list:
                    self.lst_links_list.insert('end', tab + self.odf_data.object_names_get(child_uid))

    #-------------------------------------------------------------------------------------------------
    def object_links_list_selected(self, event):
        # (GUI event callback) the user has selected an item in the object links list widget

        if self.gui_events_blocked: return

        # get the line number of the selected item in the list
        cursel_tuple = self.lst_links_list.curselection()
        if len(cursel_tuple) > 0:
            selected_line_indice = cursel_tuple[0]
        else:
            selected_line_indice = None

        if selected_line_indice != None:
            # an item has been selected in the object links list

            # ignore the mouse button 1 release if the edited object has been changed : to let the user say if he wants to save the change or not or cancel
            self.ignore_b1_release = self.edited_object_changed

            if self.can_i_make_change(object_change_bool=True):
                # the user has saved his modifications if he wanted and has not canceled the operation

                # recover in the list widget the UID of the selected object (before the first space in the selected item text)
                object_uid = self.lst_links_list.get(selected_line_indice).strip().split(' ')[0]
                if object_uid not in ('Parents', 'Children', self.selected_object_uid):
                    self.selected_linked_uid = object_uid
                    self.edited_object_uid = self.selected_linked_uid
                    self.focused_sel_item_id = self.selected_linked_uid
                else:
                    self.selected_linked_uid = None
                    self.edited_object_uid = self.selected_object_uid
                    self.focused_sel_item_id = self.selected_object_uid

                self.focused_objects_widget = self.lst_links_list

                if self.ignore_b1_release:
                    # do now the processing of the mouse button 1 release
                    self.ignore_b1_release = False
                    self.object_b1_release(event)
                # else the widgets will be updated on mouse button release

            else:
                # the user had canceled the selection
                self.ignore_b1_release = False
                self.gui_status_update_objects_lists()

    #-------------------------------------------------------------------------------------------------
    def object_links_list_selected_dbl(self, event):
        # (GUI event callback) the user has double-clicked an item in the object links list widget

        if self.selected_linked_uid != None:
            # make the selected linked UID the selected object UID
            self.selected_object_uid = self.selected_linked_uid
            self.selected_linked_uid = None
            self.ignore_b1_release = True

            # update the status of GUI widgets
            self.object_links_list_update()
            self.gui_status_update_buttons()
            self.gui_status_update_objects_lists()

    #-------------------------------------------------------------------------------------------------
    def object_b1_motion(self, event):
        # (GUI event callback) the user has moved inside the objects lists or tree his mouse with the button 1 pressed

        # change the mouse cursor aspect
        if self.wnd_main['cursor'] == '':
            if self.key_control_pressed_bool:
                self.wnd_main['cursor'] = 'plus'
            else:
                self.wnd_main['cursor'] = 'sb_up_arrow'

    #-------------------------------------------------------------------------------------------------
    def object_b1_release(self, event):
        # (GUI event callback) the user has released inside the GO objects lists or tree the mouse button 1

        # restore the default mouse cursor
        self.wnd_main['cursor'] = ''

        if self.ignore_b1_release:
            # the mouse button 1 release event has to be ignored (asked by a list/tree select function if the edited object has been changed)
            return

        if self.edited_object_uid != None and self.odf_data.object_dic_get(self.edited_object_uid) != None:
            # manage the drag & drop of the edited object if the user has moved it with the mouse

            dragged_object_uid = self.edited_object_uid

            # recover the widget and the object UID on which the mouse button has been released (the target object UID)
            target_widget = event.widget.winfo_containing(event.x_root, event.y_root)
            if target_widget == self.lst_objects_list:
                index = self.lst_objects_list.nearest(event.y)
                target_object_uid = self.lst_objects_list.get(index).split(' ')[0]
            elif target_widget == self.trv_objects_tree:
                index = self.trv_objects_tree.identify_row(event.y)
                target_object_uid = self.trv_objects_tree.item(index, option='text').split(' ')[0]
            elif target_widget == self.lst_links_list:
                index = self.lst_links_list.nearest(event.y)
                target_object_uid = self.lst_links_list.get(index).strip().split(' ')[0]
                if target_object_uid in ('Parents', 'Children'):
                    target_object_uid = None
            else:
                target_object_uid = None

            dragged_object_type = self.odf_data.object_type_get(dragged_object_uid)
            target_object_type = self.odf_data.object_type_get(target_object_uid)

            if target_object_uid not in (None, '') and target_object_uid != dragged_object_uid:
                # the object UID is not the same between mouse button press and release : a drag action has been done

                # recover the list of the object types which can be children of the target object
                possible_children_type_list = self.odf_data.object_poss_children_type_list_get(target_object_uid)
                if dragged_object_type not in possible_children_type_list:
                    # the type of the dragged object cannot be child of the target object
                    if target_object_type == 'Stop' and dragged_object_type == 'Rank':
                        messagebox.showerror('OdfEdit', f'{dragged_object_type} cannot be child of {target_object_type} which refers to a WindchestGroup.')
                    else:
                        messagebox.showerror('OdfEdit', f'{dragged_object_type} cannot be child of {target_object_type}.')
                else:
                    if not self.key_control_pressed_bool:
                        # it is an object move operation (key Control is not pressed on mouse button release)
                        allowed_dragged_object_types_list = ('Coupler', 'Enclosure', 'PanelElement', 'PanelImage', 'Rank', 'Stop', 'Tremulant')
                        if dragged_object_type in allowed_dragged_object_types_list:
                            # the dragged object can be moved to become child of another object
                            parents_uid_list = list(self.odf_data.object_kinship_list_get(dragged_object_uid, TO_PARENT))
                            if target_object_uid in parents_uid_list:
                                # the target object is already parent of the dragged object
                                messagebox.showerror('OdfEdit', f'{target_object_uid} is already parent of {dragged_object_uid}.')
                            else:
                                # the dragged object can be moved as child of the target object
                                # if the dragged object has already a parent of the type of the target object, remove it in the parents list of the dragged object
                                for parent_uid in list(parents_uid_list):
                                    if self.odf_data.object_type_get(parent_uid) == target_object_type:
                                        parents_uid_list.remove(parent_uid)
                                # add the target object UID in the parents list of the dragged object
                                parents_uid_list.append(target_object_uid)
                                # update the parent links of the dragged object
                                object_uid = self.odf_data.object_link(dragged_object_uid, parents_uid_list, TO_PARENT)
                                if object_uid != None:
                                    # the links update has been done properly
                                    self.odf_data_changed = True
                                    self.selected_object_uid = object_uid
                                    self.selected_linked_uid = None
                                    self.edited_object_uid = self.selected_object_uid
                                    self.focused_objects_widget = self.trv_objects_tree
                                    self.focused_sel_item_id = target_object_uid + object_uid
                                    # update the content of GUI widgets
                                    self.objects_list_update()
                                    self.objects_tree_update()
                        else:
                            message = 'Only the following object types\ncan be moved toward a new parent object : '
                            for object_type in allowed_dragged_object_types_list:
                                message += '\n      ' + object_type
                            messagebox.showinfo('OdfEdit', message)
                    else:
                        # it is an object copy operation (key Control is pressed on mouse button release)
                        new_object_uid = self.odf_data.object_copy(dragged_object_uid, target_object_uid)
                        if new_object_uid != None:
                            # the object copy has been done properly
                            self.odf_data_changed = True
                            self.selected_object_uid = new_object_uid
                            self.selected_linked_uid = None
                            self.edited_object_uid = self.selected_object_uid
                            self.focused_objects_widget = self.trv_objects_tree
                            self.focused_sel_item_id = target_object_uid + new_object_uid
                            # update the content of GUI widgets
                            self.objects_list_update()
                            self.objects_tree_update()

                # update the events log text
                self.logs_display()

        # update the status of GUI widgets
        self.object_text_update()
        self.object_links_list_update()
        self.gui_status_update_buttons()
        self.gui_status_update_objects_lists()

        # reset by security the control pressed flag
        self.key_control_pressed_bool = False

    #-------------------------------------------------------------------------------------------------
    def object_add(self):
        # (GUI event callback) the user has clicked on the button "Add" to create a new object

        if not self.can_i_make_change(object_change_bool=True):
            # the user has answered Cancel if the edited object has been modified
            return

        # recover the list of the object types which can be child of the edited object
        object_types_list = self.odf_data.object_poss_children_type_list_get(self.edited_object_uid)

        # add to the objects types list Organ and Header if not already defined in the ODF
        if 'Organ' not in self.odf_data.objects_list_get():
            object_types_list.insert(0, 'Organ')
        if 'Header' not in self.odf_data.objects_list_get():
            object_types_list.insert(0, 'Header')

        # let the user choose the object type to add with the proper invitation message
        if 'Header' in object_types_list or 'Organ' in object_types_list:
            if self.edited_object_uid in (None, 'Header'):
                msg = 'Choose a type of object to add at the root'
            else:
                msg = f'Choose a type of object to add as child of\n{self.edited_object_uid} or at the root'
        else:
            if self.edited_object_uid == None:
                return
            else:
                msg = f'Choose a type of object to add as child of\n{self.odf_data.object_names_get(self.edited_object_uid)}'
        chosen_type_list = ask_choose_list_items(self.wnd_main, 'Add object', msg, object_types_list, multiselect_bool=False)

        if chosen_type_list == None or len(chosen_type_list) == 0:
            # no chosen object type
            return

        # recover the chosen object type and its parent UID
        chosen_object_type = chosen_type_list[0]
        if self.edited_object_uid in ('Header', 'Organ'):
            parent_object_uid = None
        else:
            parent_object_uid = self.edited_object_uid

        # create the object in the ODF
        new_object_uid = self.odf_data.object_add(chosen_object_type, parent_object_uid)
        if new_object_uid != None:
            # the object has been created successfully
            self.odf_data_changed = True
            # set the new object as the current selected and focused object
            self.selected_object_uid = new_object_uid
            self.selected_linked_uid = None
            self.edited_object_uid = new_object_uid
            if self.focused_objects_widget == self.trv_objects_tree:
                # in the objects tree the new object is child of the curent selected node
                self.focused_sel_item_id += new_object_uid
            else:
                self.focused_sel_item_id = new_object_uid

            # update the content of GUI widgets
            self.objects_list_update()
            self.objects_tree_update()
            self.object_links_list_update()
            self.object_text_update()
            self.gui_status_update_buttons()
            self.gui_status_update_objects_lists()

        # update the events log text
        self.logs_display()

    #-------------------------------------------------------------------------------------------------
    def object_link(self, relationship):
        # (GUI event callback ) the user has clicked on the button "Parents" or "Children" to link the current selected object UID to another object
        # relationship must be TO_PARENT or TO_CHILD

        if not self.can_i_make_change(object_change_bool=True):
            # the user has answered Cancel if the edited object has been modified
            return

        # recover the list of the parents/children objects of the edited object
        current_kinship_list = list(self.odf_data.object_kinship_list_get(self.edited_object_uid, relationship))

        # add in the current kinship list the name of each object to have same object names as in the possible kinship list
        for i, object_uid in enumerate(current_kinship_list):
            current_kinship_list[i] = self.odf_data.object_names_get(object_uid)

        # recover the list of the objects UID which can be possibly parents or children of the edited object
        (possible_parents_list, possible_children_list)  = self.odf_data.object_poss_kinship_list_get(self.edited_object_uid)

        # take the list corresponding to the kinship type, this will be the possible kinship objects list
        if relationship == TO_PARENT:
            if len(possible_parents_list) == 0:
                # no possible parent object
                return
            else:
                possible_kinship_list = possible_parents_list
        elif relationship == TO_CHILD:
            if len(possible_children_list) == 0:
                # no possible child object
                return
            else:
                possible_kinship_list = possible_children_list
        else:
            # wrong relationship value given
            return

        # add in the possible kinship objects list the name of each object to facilitate the objects selection
        for i, object_uid in enumerate(possible_kinship_list):
            possible_kinship_list[i] = self.odf_data.object_names_get(object_uid)

        # let the user choose the parent/children object(s) to which link the selected object
        if relationship == TO_PARENT:
            selected_kinship_list = ask_choose_list_items(self.wnd_main, 'Link to parents',
                                                          f'Select/unselect parent(s) of\n{self.odf_data.object_names_get(self.edited_object_uid)}',
                                                          sorted(possible_kinship_list), current_kinship_list, True)
        else:
            selected_kinship_list = ask_choose_list_items(self.wnd_main, 'Link to children',
                                                          f'Select/unselect child(ren) of\n{self.odf_data.object_names_get(self.edited_object_uid)}',
                                                          sorted(possible_kinship_list), current_kinship_list, True)

        if selected_kinship_list == None:
            # operation cancelled
            return

        # remove the object name in the selected kinship objects list before to give it to the function odf_data.object_link
        for i in range(len(selected_kinship_list)):
            selected_kinship_list[i] = selected_kinship_list[i].split(' ')[0]

        # link the selected object to the one of the selected kinship objects list
        object_uid = self.odf_data.object_link(self.edited_object_uid, selected_kinship_list, relationship)
        if object_uid != None:
            # the link change has been done successfully
            self.odf_data_changed = True

            if self.focused_objects_widget != self.trv_objects_tree:
                self.focused_sel_item_id = object_uid
            # else if the focus is in the objects tree let unchanged the selected node iid
            # in case the object has not been renamed or has still the current parent node

            # update the object selection
            self.selected_object_uid = object_uid
            self.selected_linked_uid = None
            self.edited_object_uid = object_uid

            # update the content of GUI widgets
            self.objects_list_update()
            self.objects_tree_update()
            self.object_links_list_update()
            self.object_text_update()
            self.gui_status_update_buttons()
            self.gui_status_update_objects_lists()

        # update the events log text
        self.logs_display()

    #-------------------------------------------------------------------------------------------------
    def object_rename(self):
        # (GUI event callback) the user has clicked on the button "Rename" to rename the current selected object UID

        if (not self.can_i_make_change(object_change_bool=True) and not self.edited_object_uid[-3:].isdigit()):
            # the user has answered Cancel if the edited object has been modified
            # of the edited object UID has not 3 digits at the end
            return

        # ask to the user the new object ID to set
        answer = sd.askstring("Object identifier rename", f"Define a new value for\nthe 3 ending digits of {self.edited_object_uid} :",
                              initialvalue=int(self.edited_object_uid[-3:]), parent=self.wnd_main)
        if answer == None:
            return

        # check the given number
        if not answer.isdigit():
            messagebox.showerror(title='Naming error', message='Only digits are expected')
        elif int(answer) not in range(0,1000):
            messagebox.showerror(title='Naming error', message='A value between 0 and 999 is expected')
        else:
            # the given number is correct
            # define the new UID of the object
            new_uid = self.edited_object_uid[:-3] + str(int(answer)).zfill(3)
            # check if the new UID can be applied
            object_type = self.odf_data.object_type_get(self.edited_object_uid)
            if new_uid == self.edited_object_uid:
                messagebox.showerror(title='Naming error', message=f'{new_uid} is not a new name !')
            elif new_uid in self.odf_data.objects_list_get():
                messagebox.showerror(title='Naming error', message=f'An object named {new_uid} already exists')
            elif int(answer) == 0 and object_type not in ('Panel', 'Manual'):
                messagebox.showerror(title='Naming error', message='Only Manual and Panel can end with 000')
            elif self.odf_data.object_rename(self.edited_object_uid, new_uid) != None:
                # the object has been renamed successfully
                self.odf_data_changed = True
                # update the UID of the selected object
                if self.selected_linked_uid != None:
                    self.selected_linked_uid = new_uid
                else:
                    self.selected_object_uid = new_uid
                self.focused_sel_item_id = self.focused_sel_item_id.replace(self.edited_object_uid, new_uid)
                self.edited_object_uid = new_uid

                # update the content of GUI widgets
                self.objects_list_update()
                self.objects_tree_update()
                self.object_links_list_update()
                self.object_text_update()
                self.gui_status_update_buttons()
                self.gui_status_update_objects_lists()

            # update the events log text
            self.logs_display()

    #-------------------------------------------------------------------------------------------------
    def object_delete(self):
        # (GUI event callback) the user has clicked on the button "Delete" to delete the current selected object UID

        if self.edited_object_uid == None or self.selected_object_app != 'GO':
            return

        # if the selected object has children, it cannot be deleted, inform the user about this
        if len(self.odf_data.object_kinship_list_get(self.edited_object_uid, TO_CHILD)) > 0:
            messagebox.showwarning('OdfEdit', f'{self.edited_object_uid} cannot be deleted while it has child(ren).')
            return

        if messagebox.askokcancel("OdfEdit", f"Do you confirm you want to delete the object {self.edited_object_uid} ?"):
            # the user confirmed the deletion

            # choose the object UID which will be selected after the removal of the current selected object
            if self.focused_objects_widget == self.lst_links_list and self.selected_linked_uid != None:
                # a parent/child object is selected in the linked objects list : the parent will be the selected object
                next_selected_object_uid = self.selected_object_uid
            else:
                next_selected_object_uid = None

            # identify the line in the objects list widget where is present the object to delete (to make visible this line after the deletion)
            for line_nb in range(self.lst_objects_list.size()):
                if self.lst_objects_list.get(line_nb).split(' ')[0] == self.edited_object_uid:
                    break

            # remove the object in the ODF data
            if self.odf_data.object_delete(self.edited_object_uid):
                # the object has been removed without issue
                self.odf_data_changed = True
                self.edited_object_changed = False
                # update the current object UID
                self.selected_object_uid = next_selected_object_uid
                self.selected_linked_uid = None
                self.edited_object_uid = None
                self.focused_objects_widget = None

                # update the content of GUI widgets
                self.objects_list_update()
                self.lst_objects_list.see(line_nb)
                self.objects_tree_update()
                self.object_links_list_update()
                self.object_text_update()
                self.gui_status_update_buttons()
                self.gui_status_update_objects_lists()

            # update the events log text
            self.logs_display()

    #-------------------------------------------------------------------------------------------------
    def object_unselect(self):
        # (GUI event callback) the user has selected 'Clear all' in the context menu of the object text box

        if self.can_i_make_change(object_change_bool=True):
            # clear the current object selection
            self.selected_object_app = 'GO'
            self.selected_object_uid = None
            self.selected_linked_uid = None
            self.edited_object_uid = None

            self.focused_objects_widget = None
            self.focused_sel_item_id = None

            # update the object text and links list
            self.object_text_update()
            self.object_links_list_update()

            # reset the edit modified flag
            self.txt_object_text.edit_modified(False)
            self.edited_object_changed = False

            self.gui_status_update_buttons()
            self.gui_status_update_objects_lists()

    #-------------------------------------------------------------------------------------------------
    def object_text_update(self):
        # update the content of the object editor text box widget

        # to block the GUI events triggered by the text box content change
        self.gui_events_block()

        # erase the content of the text box
        self.txt_object_text.delete(1.0, "end")

        # choose which object lines to display in the text box
        object_lines_list = []
        if self.selected_object_app == 'GO':
            # get the data lines list of the selected GrandOrgue object UID
            object_lines_list = self.odf_data.object_lines_read(self.edited_object_uid)
        elif self.selected_object_app == 'HW':
            # get the data lines list of the selected Hauptwerk object UID
            object_lines_list = self.odf_hw2go.HW_ODF_get_object_data_list(self.selected_object_uid)

        # write the object data lines in the object text box
        if object_lines_list != None and len(object_lines_list) > 0:
            self.txt_object_text.insert(1.0, '\n'.join(object_lines_list))

        # place the insertion cursor at the beginning of the text
        self.txt_object_text.mark_set("insert", "1.0")

        # apply the syntax highlighting
        self.odf_syntax_highlight(self.txt_object_text)

        # reset the text modified flag
        self.txt_object_text.edit_modified(False)
        self.edited_object_changed = False

    #-------------------------------------------------------------------------------------------------
    def object_text_changed(self, event):
        # (GUI event callback) the user has made a change in the object text box

        if self.gui_events_blocked: return

        if self.txt_object_text.edit_modified() and self.edited_object_changed == False and self.selected_object_app == 'GO':
            # update the status of GUI widgets
            self.edited_object_changed = True
            self.gui_status_update_buttons()

    #-------------------------------------------------------------------------------------------------
    def object_text_key_pressed(self, event):
        # (GUI event callback) the user has pressed a keyboard key in the object text box

        # update the syntax highlighting
        self.odf_syntax_highlight(self.txt_object_text)

    #-------------------------------------------------------------------------------------------------
    def object_text_select_all(self, event):
        # (GUI event callback) the user has pressed the Ctrl+a or Ctrl+A keys combinaison in the object text box to select all the text
        # in Windows it is managed natively by the text box widget, but not in Linux

        self.txt_object_text.tag_add('sel', '1.0', 'end')
        return 'break'  # do not process further the event in the widget

    #-------------------------------------------------------------------------------------------------
    def object_text_paste(self, event):
        # (GUI event callback) the user has requested a past in the object text box
        # in Windows it is managed correctly to past instead of a selected text of the text box widget, but not in Linux

        # delete the current selected if any
        try:
            event.widget.delete('sel.first', 'sel.last')
        except:
            pass

        # paste the text of the clipboard if any
        try:
            event.widget.insert('insert', event.widget.clipboard_get())
        except:
            pass

        return 'break'  # do not process further the event in the widget

    #-------------------------------------------------------------------------------------------------
    def object_text_changes_apply(self):
        # (GUI event callback) the user has clicked on the button "Apply" to apply the changes done in the object text box
        # return False if there is an error in the text to apply, else True

        if not self.edited_object_changed:
            # there is no change to apply
            return True

        # convert the object text lines in a list
        object_lines_list = self.txt_object_text.get(1.0, 'end').splitlines()

        if len(object_lines_list) <= 1 and object_lines_list[0] == '':
            # the text box is empty
            return True

        # apply the object data in the ODF data
        object_uid = self.odf_data.object_lines_write(object_lines_list, self.edited_object_uid)
        if object_uid != None:
            # the modification has been applied with success
            self.odf_data_changed = True
            self.edited_object_changed = False
            # reset the edit modified flag
            self.txt_object_text.edit_modified(False)

            if object_uid != self.edited_object_uid and self.edited_object_uid != None:
                # the object UID has been renamed inside the edited lines list
                if self.selected_linked_uid != None:
                    self.selected_linked_uid = object_uid
                else:
                    self.selected_object_uid = object_uid
                self.focused_sel_item_id = self.focused_sel_item_id.replace(self.edited_object_uid, object_uid)
                self.edited_object_uid = object_uid

            # update the various GUI widgets
            self.objects_list_update()
            self.objects_tree_update()
            self.object_links_list_update()
            self.gui_status_update_buttons()
            self.gui_status_update_objects_lists()
            changes_applied = True
        else:
            changes_applied = False
            # select the Logs tab of the notebook to show error logs
            self.notebook.select(self.frm_logs)

        # update the events log text
        self.logs_display()

        return changes_applied

    #-------------------------------------------------------------------------------------------------
    def gen_menu_open(self):
        # (GUI event callback) the user has clicked on the button Menu to open the general menu

        self.general_menu.tk_popup(self.btn_gen_menu.winfo_rootx() + self.btn_gen_menu.winfo_width(), self.btn_gen_menu.winfo_rooty())

    #-------------------------------------------------------------------------------------------------
    def gen_menu_close(self, event=None):
        # (GUI event callback) the menu has lost its focus

        self.general_menu.grab_release()

    #-------------------------------------------------------------------------------------------------
    def gen_menu_about(self):
        # (GUI event callback) the user has clicked on the item About... of the general Menu

        messagebox.showinfo('OdfEdit', f'OdfEdit {APP_VERSION} - {RELEASE_DATE}\n\ngithub.com/GrandOrgue/ODFEdit')

    #-------------------------------------------------------------------------------------------------
    def odf_search_text(self, event=None):
        # (GUI event callback) the user has clicked on the button "Search" of the "Search in ODF" tab or pressed Enter in the entry box

        # recover the text to search
        search_text = self.ent_odf_search_text.get()

        self.lst_odf_sresults.delete(0, END)

        if search_text != '':
            results_list = []
            for object_uid, object_dic in self.odf_data.odf_data_dic.items():
                # scan the objects of the ODF data
                for line in object_dic['lines']:
                    # scan the lines of the current object
                    if search_text in line:
                        results_list.append(f'{object_uid} : {line}')
            results_list.sort()

            if len(results_list) > 0:
                self.lst_odf_sresults.insert(END, *results_list)
            else:
                messagebox.showinfo(title='Information', message=f'"{search_text}" not found in the ODF (the search is case sensitive)')

    #-------------------------------------------------------------------------------------------------
    def odf_search_text_hw(self, event=None):
        # (GUI event callback) the user has clicked on the button "HW search" of the "Search in ODF" tab

        # recover the text to search
        search_text = self.ent_odf_search_text.get()

        self.lst_odf_sresults.delete(0, END)

        if search_text != '':
            results_list = []
            for object_type_dic in self.odf_hw2go.HW_odf_dic.values():
                for HW_object_dic in object_type_dic.values():
                    for obj_attr_name, obj_attr_value in HW_object_dic.items():
                        if obj_attr_name[0] != '_':
                            if search_text in obj_attr_name or search_text in str(obj_attr_value):
                                results_list.append(f"{HW_object_dic['_HW_uid']} : {obj_attr_name}={obj_attr_value}")
            results_list.sort()

            if len(results_list) > 0:
                self.lst_odf_sresults.insert(END, *results_list)
            else:
                messagebox.showinfo(title='Information', message=f'"{search_text}" not found in the HW ODF (the search is case sensitive)')

    #-------------------------------------------------------------------------------------------------
    def odf_search_uid_hw(self):
        # (GUI event callback) the user has clicked on the button "UID search" of the HW ODF browser

        # recover the text to search (must be a HW object UID only)
        search_text = self.ent_hw_uid_search_text.get()

        if search_text != '':
            object_dic = self.odf_hw2go.HW_ODF_get_object_dic(search_text)
            if object_dic != None:
                # the UID is existing in the HW ODF
                self.selected_object_app = 'HW'
                self.selected_object_uid = search_text
                self.selected_linked_uid = None
                self.edited_object_uid = search_text
                self.focused_objects_widget = self.lst_hw_browser
                self.focused_sel_item_id = search_text

                # update the status of GUI widgets
                self.object_links_list_update()
                self.objects_list_update_hw()
                self.object_text_update()
                self.gui_status_update_buttons()
                self.gui_status_update_objects_lists()
            else:
                messagebox.showerror(title="Error", message=f'"{search_text}" is not a known HW UID')

    #-------------------------------------------------------------------------------------------------
    def odf_search_text_result_selected(self, event):
        # (GUI event callback) the user has clicked on an item of the ODF search results list

        # get the selected indice
        selected_indice = self.lst_odf_sresults.curselection()

        if self.can_i_make_change(object_change_bool=True):
            # the user has saved his modifications if he wanted and has not canceled the operation
            self.selected_object_uid = self.lst_odf_sresults.get(selected_indice[0]).split(' ')[0]
            self.selected_linked_uid = None
            self.edited_object_uid = self.selected_object_uid

            if self.selected_object_uid == '_General' or self.selected_object_uid[-6:].isdigit():
                # the results are concerning HW UID
                self.selected_object_app = 'HW'
                self.objects_list_update_hw()
            else:
                self.selected_object_app = 'GO'

            self.focused_objects_widget = None

            # update the object text box and links list
            self.object_text_update()
            self.object_links_list_update()

            # select in the object edition text box the line which corresponds to the selected result
            selected_search_result = self.lst_odf_sresults.get(selected_indice[0]).split(':')[1].strip()
            idx = self.txt_object_text.search(selected_search_result, '1.0', stopindex=END)
            if idx != '':
                self.txt_object_text.tag_remove('sel', '1.0', 'end')
                self.txt_object_text.tag_add('sel', idx, f'{idx} + {len(selected_search_result)} chars')
                self.txt_object_text.see(idx)
                self.txt_object_text.focus_set()

            # update the status of GUI widgets
            self.gui_status_update_buttons()
            self.gui_status_update_objects_lists()

    #-------------------------------------------------------------------------------------------------
    def logs_display(self):
        # add in the logs text box widget the content of the logs buffer then clear it

        logs_list = logs.get()
        if len(logs_list) > 0:
            self.txt_events_log.insert('end', '\n' + '\n'.join(logs_list) + '\n')
            self.txt_events_log.see('end-1c linestart')  # to see the start of the last line of the text
        self.txt_events_log.update()

        # reset the logs buffer
        logs.clear()

    #-------------------------------------------------------------------------------------------------
    def logs_select_all(self, event):
        # (GUI event callback) the user has pressed the Ctrl+a or Ctrl+A keys combinaison in the logs text box to select all the text
        # in Windows it is managed natively by the text box widget, but not in Linux

        self.txt_events_log.tag_add('sel', '1.0', 'end')
        return 'break'  # do not process further the event in the widget

    #-------------------------------------------------------------------------------------------------
    def logs_clear(self):
        # (GUI event callback) the user has selected 'Clear all' in the context menu of the logs text box

        # clear the content of the logs text box
        self.txt_events_log.delete(1.0, "end")

        # reset the logs buffer
        logs.clear()

    #-------------------------------------------------------------------------------------------------
    def help_file_load(self):
        # load in the help text box widget the help file
        # done one time at the application start

        file_name = os.path.dirname(__file__) + os.sep + 'resources' + os.sep + 'Help.txt'

        try:
            with open(file_name, 'r') as f:   # errors='ignore'
                f.seek(0)
                # copy in the widget the help text
                self.txt_help.insert(1.0, f.read())
        except OSError as err:
            # it has not be possible to open the file
            messagebox.showinfo(title="ERROR", message=f'Cannot open the file "{file_name}"\n{err}')
            return False
        except IOError as e:
            messagebox.showinfo(title="ERROR", message=f'I/O error while opening the file "{file_name}"\n{e.errno}: {e.strerror}')
            return False
        except: #handle other exceptions such as attribute errors
            messagebox.showinfo(title="ERROR", message=f'Unexpected error while opening the file "{file_name}"\n{sys.exc_info()[0]}')
            return False

        # apply the ODF syntax highlighting
        self.odf_syntax_highlight(self.txt_help)
        # disable the text box to not permit its editing
        self.txt_help.configure(state='disabled')
        return True

    #-------------------------------------------------------------------------------------------------
    def help_search_next(self):
        # (GUI event callback) the user has clicked on the button '>'
        # show the next occurence of the text to search

        self.help_search_text(self.cmb_search_text.get(), True)

    #-------------------------------------------------------------------------------------------------
    def help_search_previous(self):
        # (GUI event callback) the user has clicked on the button '<'
        # show the previous occurence of the text to search

        self.help_search_text(self.cmb_search_text.get(), False)

    #-------------------------------------------------------------------------------------------------
    def help_search_clear(self):
        # (GUI event callback) the user has clicked on the button 'Clear'
        # clear the text to search (text box and highlighting)

        self.cmb_search_text.delete(0, END)
        self.help_search_text('', False)
        self.lab_search_occur_nb.config(text='')

        # update the status of some GUI widgets
        self.gui_status_update_search()

    #-------------------------------------------------------------------------------------------------
    def help_search_object(self):
        # (GUI event callback) the user has clicked on the button "Show in help"
        # search and display in the help the part describing the selected object UID

        if self.edited_object_uid not in (None, 'Header'):
            # substitute the digits by the char 9 in the object UID to create a generic object ID
            gen_object_UID = '['
            for c in self.edited_object_uid: gen_object_UID += '9' if c.isdigit() else c
            gen_object_UID += ']'

            # put the generic object UID in the search text widget
            self.cmb_search_text.delete(0, END)
            self.cmb_search_text.insert(0, gen_object_UID)

            # update the status of GUI widgets
            self.gui_status_update_search()

            # search the first occurence of the generic object ID
            self.help_search_next()

            # select the Help tab of the notebook
            self.notebook.select(self.frm_help)

    #-------------------------------------------------------------------------------------------------
    def help_search_text(self, text_to_find, search_next = True):
        # show in the help the next occurence (or previous if search_next=False) of the given text to find
        # highlight in yellow all the occurences of this text

        if text_to_find != '':
            text_len = len(text_to_find)
        else:
            text_to_find = None
            text_len = 0

        if text_to_find != self.text_to_search:
            # a new text has to be searched, highlight all its occurences in the entire help text

            # store the new text to search
            self.text_to_search = text_to_find

            # remove the highlight of the previous searched text occurences
            self.txt_help.tag_remove(TAG_FOUND, '1.0', END)
            self.txt_help.tag_remove(TAG_FOUND2, '1.0', END)
            nb_occurences = 0

            if text_to_find != None:
                # highlight the all occurences of the text to find in the entire help
                # configure the tag for the found text
                self.txt_help.tag_config(TAG_FOUND, foreground='black', background='yellow', font='Calibri 11')
                # get the lines of the text widget
                lines = self.txt_help.get('1.0', END).splitlines()
                # scan all the lines
                for l in range(0, len(lines)):
                    idx = 0
                    while idx != -1:
                        # check the various occurences of the searched text in the current line (if any)
                        idx = lines[l].find(text_to_find, idx)
                        if idx != -1:
                            # highlight the found occurence in the line
                            self.txt_help.tag_add(TAG_FOUND, f'{l+1}.{idx}', f'{l+1}.{idx} + {text_len} chars')
                            # move the search index after the found occurence
                            idx += text_len
                            nb_occurences += 1

                # display the number of occurences of the searched text
                if nb_occurences == 0:
                    self.lab_search_occur_nb.config(text='None occurence')
                elif nb_occurences == 1:
                    self.lab_search_occur_nb.config(text='1 occurence')
                else:
                    self.lab_search_occur_nb.config(text=f'{nb_occurences} occurences')

        if text_to_find != None:
            # search for the next/previous occurence of the text in the help

            # remove the highlight of the previous searched text occurence
            self.txt_help.tag_remove(TAG_FOUND2, '1.0', END)
            # configure the tag for the highlighted found text
            self.txt_help.tag_config(TAG_FOUND2, foreground='black', background='gold2', font='Calibri 11')

            if search_next and self.search_index != None:
                # if search upward, move the current search position after the previous found position
                self.search_index = f'{self.search_index} + {text_len} chars'

            # search for the next/previous occurence
            if self.search_index == None: self.search_index = '1.0'
            self.search_index = self.txt_help.search(text_to_find, self.search_index, backwards = not(search_next))
            if self.search_index == '': self.search_index = None

            if self.search_index != None:
                # show and highlight the found text
                self.txt_help.see(self.search_index)
                self.txt_help.tag_add(TAG_FOUND2, self.search_index, f'{self.search_index} + {text_len} chars')

    #-------------------------------------------------------------------------------------------------
    def help_search_text_key_pressed(self, event):
        # (GUI event callback) the user has pressed a keyboard key in the help text search box

        # update the status of GUI widgets
        self.gui_status_update_search()

        self.search_index = None  # restart the search at the beginning of the help text
        self.help_search_text(self.cmb_search_text.get(), True)

    #-------------------------------------------------------------------------------------------------
    images_ref=[]  # list needed to keep in memory the reference to the images opened by PhotoImage and added in the text box, else they are not displayed (Python bug ?)

    def odf_syntax_highlight(self, txt_widget):
        # apply syntax highlighting to the content of the given object text box widget

        # remove the tags previously set in the text box
        txt_widget.tag_remove(TAG_FIELD, '1.0', END)
        txt_widget.tag_remove(TAG_COMMENT, '1.0', END)
        txt_widget.tag_remove(TAG_OBJ_UID, '1.0', END)
        txt_widget.tag_remove(TAG_TITLE, '1.0', END)

        # put in a list the lines of the text box
        lines = txt_widget.get('1.0', END).splitlines()

        # scan all the characters of the text box lines
        for l in range(0, len(lines)):
            c0 = None
            for c in range(0, len(lines[l])):
                if lines[l][c] == ';':
                    # comment : apply the comment color until the end of the line
                    txt_widget.tag_add(TAG_COMMENT, f'{l+1}.{c}', f'{l+1}.0 lineend')
                    break  # skip the rest of the line
                elif lines[l][c] == '[':
                    # start of an object UID
                    c0 = c
                elif lines[l][c] == ']':
                    # end of an object UID : apply the UID color between the opening and closing brackets
                    if c0 != None:
                        txt_widget.tag_add(TAG_OBJ_UID, f'{l+1}.{c0}', f'{l+1}.{c+1}')
                        c0 = None
                elif txt_widget.get(f'{l + 1}.{c}') == '=':
                    # equal character : apply the field color before the '='
                    txt_widget.tag_add(TAG_FIELD, f'{l+1}.0', f'{l + 1}.{c}')
                elif lines[l][:2] == '§§' :
                    # image file to insert (in the help)
                    # recover the file name after the '§§' tag
                    file_name = lines[l][2:]
                    # remove the file name in the widget
                    txt_widget.delete(f'{l+1}.0', f'{l+1}.0 lineend')
                    try:
                        # open the image file
                        photo = PhotoImage(file = os.path.dirname(__file__) + os.sep + 'resources' + os.sep + file_name)
                        # add the reference of the image in the list to store these references
                        self.images_ref.append(photo)
                        # insert the image in the text box
                        txt_widget.image_create(f'{l+1}.0', image=photo, padx=10, pady=10)
                    except:
                        # insert a message indicating that the image has not been opened
                        txt_widget.insert(f'{l+1}.0', f'!!! cannot open the image resources{os.sep + file_name}')
                    break
                elif lines[l][:2] == '>>' :
                    # title line (in the help) : apply the title color to the whole line
                    txt_widget.delete(f'{l+1}.0', f'{l+1}.3')
                    txt_widget.tag_add(TAG_TITLE, f'{l+1}.0', f'{l+1}.0 lineend')
                    break  # skip the rest of the line

    #-------------------------------------------------------------------------------------------------
    def odf_data_check(self):
        # check the consistency of the ODF data

        # ask to the user to apply his object data change before to launch the check
        if self.can_i_make_change(object_change_bool=True):
            # the user has not cancelled the operation

            # do the check
            self.odf_data.check_odf_data(self.progress_status_update)

            # update the events log text
            self.logs_display()

            # select the Logs tab of the notebook to show the check result
            self.notebook.select(self.frm_logs)

            self.gui_status_update_buttons()

    #-------------------------------------------------------------------------------------------------
    def progress_status_update(self, message):
        # callback function called by the C_ODF_DATA.check_odf_data or C_ODF_HW2GO.GO_ODF_build_from_HW_ODF function
        # to display in the object links label widget a progress status message

        self.lab_odf_file_name.config(text=message)
        self.lab_odf_file_name['foreground'] = 'red3'
        self.lab_odf_file_name.update()

#-------------------------------------------------------------------------------------------------
class CreateToolTip(object):
    # class to create a tooltip for a given widget
    # tk_ToolTip_class101.py
    # gives a Tkinter widget a tooltip as the mouse is above the widget
    # tested with Python27 and Python34  by  vegaseat  09sep2014
    # www.daniweb.com/programming/software-development/code/484591/a-tooltip-class-for-tkinter
    # Modified to include a delay time by Victor Zaccardo, 25mar16
    # example of usage : tooltip = CreateToolTip(parend_widget, "string to display")
    def __init__(self, widget, text='widget info'):
        self.waittime = 500     #miliseconds
        self.wraplength = 180   #pixels
        self.widget = widget
        self.text = text
        self.widget.bind("<Enter>", self.enter)
        self.widget.bind("<Leave>", self.leave)
        self.widget.bind("<ButtonPress>", self.leave)
        self.id = None
        self.tw = None
    def enter(self, event=None):
        self.schedule()
    def leave(self, event=None):
        self.unschedule()
        self.hidetip()
    def schedule(self):
        self.unschedule()
        self.id = self.widget.after(self.waittime, self.showtip)
    def unschedule(self):
        id = self.id
        self.id = None
        if id: self.widget.after_cancel(id)
    def showtip(self, event=None):
        x = y = 0
        x, y, cx, cy = self.widget.bbox("insert")
        x += self.widget.winfo_rootx() + 25
        y += self.widget.winfo_rooty() + 20
        # creates a toplevel window
        self.tw = Toplevel(self.widget)
        # Leaves only the label and removes the app window
        self.tw.wm_overrideredirect(True)
        self.tw.wm_geometry("+%d+%d" % (x, y))
        label = Label(self.tw, text=self.text, justify='left',
        background="#ffffff", relief='solid', borderwidth=1,
        wraplength = self.wraplength)
        label.pack(ipadx=1)
    def hidetip(self):
        tw = self.tw
        self.tw= None
        if tw: tw.destroy()

#-------------------------------------------------------------------------------------------------
NOTES = ['C', 'Cis', 'D', 'Dis', 'E', 'F', 'Fis', 'G', 'Gis', 'A', 'Ais', 'B']
OCTAVES = list(range(11))
NOTES_IN_OCTAVE = len(NOTES)

def midi_number_to_note(number: int) -> tuple:
    # convert the given MIDI note number to note and octave numbers
    octave = number // NOTES_IN_OCTAVE
    assert octave in OCTAVES, f'Wrong octave {octave} number in midi_number_to_note function'
    assert 0 <= number <= 127, f'Wrong MIDI note number {number} in midi_number_to_note function'
    note = NOTES[number % NOTES_IN_OCTAVE]
    return note, octave

def midi_note_to_number(note: str, octave: int) -> int:
    # convert the given note and octave numbers to a MIDI note number
    assert note in NOTES, f'Wrong note name {note} in midi_note_to_number function input'
    assert octave in OCTAVES, f'Wrong octave number {octave} in midi_note_to_number function input'
    note = NOTES.index(note)
    note += (NOTES_IN_OCTAVE * octave)
    assert 0 <= note <= 127, f'Wrong note number {note} in midi_note_to_number function'
    return note

def frequency_to_midi_number(frequency: float, a4_frequency: float) -> int:
    # convert the given frequency in Hz into a MIDI note number
    # using the given reference frequency of the A4 note (which has MIDI note 69), set at 440Hz by default if None is provided
    if a4_frequency == None: a4_frequency = 440.0
    return round(12 * math.log2(frequency / a4_frequency) + 69)

def delta_freq_to_cent(frequency1: float, frequency2: float, a4_frequency: float) -> int:
    # return the number of cent between the two given frequencies (f1 - f2), using if given the reference A4 note frequency
    if a4_frequency == None: a4_frequency = 440.0
    nb_cent_from_a4_1 = 1200.0 * math.log2(frequency1 / a4_frequency)
    nb_cent_from_a4_2 = 1200.0 * math.log2(frequency2 / a4_frequency)
    return int(nb_cent_from_a4_1 - nb_cent_from_a4_2)

#-------------------------------------------------------------------------------------------------
def myint(data, default_val=None):
    # return the given data in integer format, or the provided default value (or None if not defined) if it cannot be converted to integer or is not defined

    if data == None:
        return default_val

    try:
        return int(data)
    except:
        return default_val

#-------------------------------------------------------------------------------------------------
def myfloat(data, default_val=None):
    # return the given data in float format, or the provided default value (or None if not defined) if it cannot be converted to float or is not defined

    if data == None:
        return default_val

    try:
        return float(data)
    except:
        return default_val

#-------------------------------------------------------------------------------------------------
def mystr(data, default_val=''):
    # return the given data in string format, or the provided default value (or '' if not defined) if it cannot be converted to string or is not defined

    if data == None:
        return default_val

    try:
        return str(data)
    except:
        return default_val

#-------------------------------------------------------------------------------------------------
prev_actual_file_name = ''  # variable to keep in memory the previous found actual file name, to speed up the processing of the next one if there are common parts
def get_actual_file_name(file_name):
    # return the given file path/name with the actual characters case as they are defined on the storage
    # return None if the given file name doesn't exist
    # the given file path/name must have the path separator of the OS on which is running the script

    global prev_actual_file_name

    # split the given file name by elements separated by the OS path separator
    file_name_split = file_name.split(os.sep)
    file_name_split_len = len(file_name_split)

    i = 0
    if prev_actual_file_name != '':
        # recover from the previous actual file name the path elements which are equal to the one of the given file name (to spend less time in the next while loop)
        # split the previous actual file name by elements separated by the OS path separator
        prev_actual_file_name_split = prev_actual_file_name.split(os.sep)
        actual_file_name = ''
        while i < file_name_split_len and file_name_split[i].lower() == prev_actual_file_name_split[i].lower():
            actual_file_name += prev_actual_file_name_split[i] + os.sep
            i += 1
        if i == file_name_split_len:
            # the entire previous actual file name has been recovered, remove the last separator
            actual_file_name = actual_file_name[:-1]

    if i == 0:
        # nothing to recover from the previous actual file name or it is empty
        # we consider that the root folder of the given file name has the actual case
        actual_file_name = file_name_split[0] + os.sep
        i = 1

    # recover from the storage the actual name of the remaining elements of the given file path/name
    while i < file_name_split_len:
        found = False
        for actual_element in os.listdir(actual_file_name):
            if actual_element.lower() == file_name_split[i].lower():
                found = True
                break
        if not found:
            return None
        actual_file_name = os.path.join(actual_file_name, actual_element)
        i += 1

    prev_actual_file_name = actual_file_name
    return actual_file_name

#-------------------------------------------------------------------------------------------------
def path2ospath(file_name):
    # replace the / or \ in the given file name by the OS separator

    if os.sep == '/':
        return file_name.replace('\\', os.sep)
    else:
        return file_name.replace('/', os.sep)

#-------------------------------------------------------------------------------------------------
dialog_wnd_w = 300
dialog_wnd_h = 450

def ask_choose_list_items(parent_wnd, title, message, choice_items_list, preselect_items_list = [], multiselect_bool=False, resizable_wnd_bool=True):
    # opens a dialog box to ask the user to select items in the given choice items list
    # if items are provided in preselect_items_list and they are present in choice_items_list, they are pre-selected in the list
    # returns a list containing the items selected in the given choice items list, or None if the user clicked on Cancel or close button

    global dialog_wnd_w
    global dialog_wnd_h

    # disable the parent window so that the dialog box is modal (only possible in Windows OS)
    if os.name == 'nt':
        parent_wnd.wm_attributes("-disabled", True)

    # create the toplevel modal dialog window
    dialog_wnd = Toplevel(parent_wnd, takefocus=True)
    dialog_wnd.title(title)
    if not resizable_wnd_bool:
        dialog_wnd.resizable(False, False)

    # place the dialog window at the center of the parent window
    parent_wnd_x = parent_wnd.winfo_x()
    parent_wnd_y = parent_wnd.winfo_y()
    parent_wnd_w = parent_wnd.winfo_width()
    parent_wnd_h = parent_wnd.winfo_height()
    dialog_wnd_x = parent_wnd_x + int(parent_wnd_w/2) - int(dialog_wnd_w/2)
    dialog_wnd_y = parent_wnd_y + int(parent_wnd_h/2) - int(dialog_wnd_h/2)
    if dialog_wnd_x < 0: dialog_wnd_x = 0
    if dialog_wnd_y < 0: dialog_wnd_y = 0
    dialog_wnd.geometry(f"{dialog_wnd_w}x{dialog_wnd_h}+{dialog_wnd_x}+{dialog_wnd_y}")

    # tell the window manager this is the child window of the parent window, permits to let the child window flash if one clicks onto parent
    dialog_wnd.transient(parent_wnd)
    dialog_wnd.focus_force()

    # string var permitting to know the reason of the dialog box closure
    closure_reason = StringVar()
    closure_reason.set('none')

    # link to the callback WM_DELETE_WINDOW or Escape key to manage the window closure
    dialog_wnd.protocol("WM_DELETE_WINDOW",  lambda reason='cancel': closure_reason.set(reason))
    dialog_wnd.bind('<Escape>', lambda reason='cancel': closure_reason.set(reason))

    # create the top label widget
    listdialog_label = Label(dialog_wnd, text=message, fg="black", anchor='center', wraplength=dialog_wnd_w - 10, height=2)
    listdialog_label.pack(side='top', padx=5, pady=5, fill='x')

    # frame to occupy the bottom area of the dialog window and to encapsulate OK and Cancel buttons
    listdialog_frm1 = Frame(dialog_wnd)
    listdialog_frm1.pack(side='bottom', fill='x')

    # OK button
    toplevel_dialog_yes_button = Button(listdialog_frm1, text='OK', command=lambda reason='ok': closure_reason.set(reason))
    toplevel_dialog_yes_button.pack(side='left', padx=5, pady=5, fill='x', expand=1)

    # Cancel button
    toplevel_dialog_no_button = Button(listdialog_frm1, text='Cancel', command=lambda reason='cancel': closure_reason.set(reason))
    toplevel_dialog_no_button.pack(side='left', padx=5, pady=5, fill='x', expand=1)

    # frame to occupy the middle area of the window and to encapsulate the list and its vertical scroll bar
    listdialog_frm2 = Frame(dialog_wnd)
    listdialog_frm2.pack(side='top', fill='both', padx=5, expand=1)

    # list box widget with its vertical scroll bar
    scrollbarv = ttk.Scrollbar(listdialog_frm2, orient='vertical')
    scrollbarv.pack(side='right', fill='y')
    listdialog_list = Listbox(listdialog_frm2, selectmode=('multiple' if multiselect_bool else 'single'))
    listdialog_list.pack(side='left', fill='both', expand=1)
    listdialog_list.config(yscrollcommand=scrollbarv.set)
    scrollbarv.config(command=listdialog_list.yview)

    # fill the list box
    see_used_bool = False
    for item in choice_items_list:
        # scan the items of the choice list
        # add the current item to the list widget
        listdialog_list.insert('end', item)
        if item in preselect_items_list:
            # the current has to be selected
            listdialog_list.selection_set('end')
            if not see_used_bool:
                # make visible the first selected item
                listdialog_list.see('end')
                see_used_bool = True

    # wait for the change of the StringVar closure_reason
    dialog_wnd.wait_variable(closure_reason)

    if closure_reason.get() == 'ok':
        # the user has clicked on the OK button, recover the list of the selected items
        selected_items_list = []
        for i in listdialog_list.curselection():
            selected_items_list.append(listdialog_list.get(i))
    else:
        selected_items_list = None

    # store the dialog window current dimensions
    dialog_wnd_w = dialog_wnd.winfo_width()
    dialog_wnd_h = dialog_wnd.winfo_height()

    # re-enable the parent window
    if os.name == 'nt':
        parent_wnd.wm_attributes("-disabled", False)
    # destroy this dialog box
    dialog_wnd.destroy()
    # restore the parent window if it was in icon state
    parent_wnd.deiconify()

    return selected_items_list

#-------------------------------------------------------------------------------------------------
def main():
    # main function of the application

    # initiate a C_GUI class instance, display the main window based on this instance, start the main loop of this window
    C_GUI().wnd_main_build().mainloop()

#-------------------------------------------------------------------------------------------------
# first line of code executed at the launch of the script
# if we are in the main execution environment, call the main function of the application
if __name__ == '__main__': main()
