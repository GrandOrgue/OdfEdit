"""
-------------------------------------------------------------------------------
 Name:        OdfEdit
 Purpose:     Application helping to edit an organ definition file (ODF) in plain text
              and permitting to convert a Hauptwerk ODF into GrandOrgue ODF
              The ODF can be used in the GrandOrgue application
              Implemented with Python 3.1x
              Tested in Windows 10 and Ubuntu 21.10
              It is contains 7 classes :
                   C_LOGS to manage the logs generated by the various fonctions of the application
                   C_ODF_DATA_CHECK to check the syntax and the consistency of the edited ODF data
                   C_ODF_DATA to manage the edited ODF data
                   C_ODF_HW2GO to manage the convertion from a Hauptwerk ODF to a GrandOrgue ODF
                   C_GUI_NOTEBOOK to manage the notebook widget and its tabs content in the GUI of the application
                   C_GUI to manage the graphical user interface of the application
                   CreateToolTip to display a tool tip on a GUI widget
 Author:      Eric Turpault (France, ChÃ¢tellerault)
 Copyright:   open source
 Licence:     free to modify, please share the modification with the author

 The considered GrandOrgue ODF syntax is :
    [object_uid]  ; comment
    ; comment line, empty lines are ignored
    ; object_uid can contain only alphanumeric characters
    attribute1=value1  ; comment
    attribute2=value2
    ; attribute can contain only alphanumeric or '_' characters

 The new panel format is detected if the Panel000 object is present and contains the attribute NumberOfGUIElements

 Versions history :
   v1.0 - 15 April 2022 - initial version
   v1.1 - 16 April 2022 - minor changes to be Linux compatible, minor GUI fixes
   v1.2 - 27 April 2022 - some GUI behavior improvements, minor improvements in the help and the objects checks
   v1.3 - 19 May   2022 - data management improvement, change in the way to define the parent-child relations between the objects,
                          completed some attributes values maximum check, added a tab to search a string in the whole ODF
   v2.0 - 23 Dec.  2022 - fix made in the function check_object_Manual around the key_type checks
                          fix made in the function check_attribute_value to not change out of range integer value and better check HTML color code
                          use the PIL library instead of Tk to check the sample set images sizes
                          first implementation of the Hauptwerk to GrandOrgue ODF conversion feature
   v2.1 - 22 Dec.  2023 - HW2GO : fix for files path separator management in various OS
                          HW2GO : get the actual files path/name/extension case from the HW sample set instead of from the HW ODF
                          HW2GO : some design changes without functional impact
                          HW2GO : added general sound stops (blower, bells, ...) and stop action noise support
   v2.2 - 12 Jan. 2023  - HW2GO : improved and more robust way to detect Stop / Coupler / Switch objects to build
                          HW2GO : fix of issues observed with some newly tested HW sample sets
                          HW2GO : added support of HW continuous control and enclosure objects, converted into GO enclosure objects
                          GUI : graphical user interface rework with resizable width for lists and notebook areas
                          GUI : Organ object placed systematically at the top of the objects list
   v2.3 - 08 April 2023 - fix for help text not loaded with Windows OdfEdit.exe (fix in file Help.txt due to characters 0x81 not supported by unicode format)
                          add the support of comments at the end of the lines in the ODF
                          add the support of the separator / in the files path in the ODF
                          improved display and selection of parents/children objects of the selected object
                          improved several behaviors in the GUI management
                          ODF saving in a file places the objects by alphabetical UID order, but Header and Organ which are placed in first position
                          new buttons to add, link to parents/children or rename an object, with automatical update of the object referencing
                             and the total number in other objects, new panel format only is supported
                          HW2GO : visual elements of the main panel are now defined in Panel999Element999 objects
                          HW2GO : Switches have by default StoreInDivisional=Y, StoreInGeneral=Y, GCState=0
                          HW2GO : added a menu item checkbox to ask to convert to GO ranks the HW ranks not used by OdfEdit
   v2.4 - 30 May 2023   - objects having child(ren) cannot be deleted with the button Delete
                          added a menu item checkbox to select the file format to use when saving an ODF (ISO_8859_1 or UTF-8 BOM)
                          added a menu item checkbox to disable the automatic objects tree expand on object selection
                          added a menu item checkbox to enable the wave based tremulants convertion from HW to GO
                          added a menu item checkbox to enable the unused ranks convertion from HW to GO
                          configuration data of the application (last ODF folder, options of the menu) are saved in a file OdfEdit.cfg
                          improvements made in the objects list/tree behavior on object selection or change
                          the parents/children of the selected object can be selected and edited in the central list (above the text editor)
                          a double-click on a parent/child object makes it the selected object in the list/tree
                          ctrl+s keys permits to save changes in the edited object and to save changed data in the ODF
                          escape key permits to close the pop-up windows permitting to select parent/children objects
                          added the possiblity to search a text inside the loaded HW ODF
                          HW2GO : removed the attribute AcceptRetuning=N in ranks of pipes
                          HW2GO : pitch tuning attribute used for pipes which the sample has a different native frequency
                          HW2GO : convert the conditional switches (switches which the state depends on the state of other switches)
                          HW2GO : convert the synthetized and wave based tremulants
                          HW2GO : the stop and coupler objects are numeroted according to the manual number to which they belong to
                          several bugs fixing as at each release
   v2.5 - 26 Aug. 2023  - manage drag&drop of one object (type : Coupler, Enclosure, PanelElement, PanelImage, Rank, Stop, Tremulant)
                            between the objects lists or tree, in order to move it under another parent object
                          drag&drop with Control key pressed adds a copy of the dragged object as child of the object on which the drop has been done
                          Ctrl-a in object edition or logs text boxes permits to selected all the text (needed for Linux)
                          paste in object edition text box replaces the current selected text if any (needed for Linux)
                          mouse double click in object edition text box selects the text until the equal or brackets character
                          added the possibility to search in the ODF in a selected range (ODF, selected object, children of the selected object)
                          added the possibility to search in the ODF with a regular expression
                          added the possibility to replace the text found by the search
                          "object" renamed to "section" in the GUI
                          HW2GO : check that the mouse or text rectangle doesn't exceed the image size of a switch or label
                          HW2GO : unused HW noise ranks are converted to GO ranks if the convertion option is enabled in the menu
                          HW2GO : add in a switch or setter the text of a label which is overlapping it
                          HW2GO : rework of the way to calculate the rank related attributes in the Stop object (pipes stop)
                          HW2GO : update the organ / pipes pitch tuning calculation
                          HW2GO : manage the case where there are more than 99 stops in a manual
                          HW2GO : manage the case where one enclosure is controlled from several panel element objects
                          HW2GO : add the Loop/ReleaseCrossfadeLength attributes conversion in the ranks (clipped to GO max values waiting for GO 3.13.0)
                          HW2GO : use TextBreakWidth=0 instead of DispLabelText= to have no text displayed in a button or enclosure
                          several minor improvements and bugs fixing
   v2.6 - 13 Oct. 2023  - added a Viewer tab to view or play the selected file in the editor
                          HW2GO : Loop/ReleaseCrossfadeLength maximum value set at 3000 (needs GO 3.13.0-1)
   v2.7 - 07 Nov. 2023  - manage in the viewer the pipe borrowing format REF:xx:xx:xx + minor improvements
                          HW2GO : manage the keyboards noises conversion
                          HW2GO : add in manual sections the reference to the associated stop/coupler/tremulant switches
                          HW2GO : place the wav tremmed samples in the same rank as the not tremmed samples if selected in a new menu option
                          HW2GO : noise samples gains lower than -5 are set at -5
                          several minor improvements and bugs fixing

TO DO :
    drag&drop of a stop over another stop of the same manual to sort the stops manually (see https://github.com/GrandOrgue/OdfEdit/issues/28)
    add a manual compass extension feature
-------------------------------------------------------------------------------
"""

APP_VERSION = 'v2.7'
RELEASE_DATE = 'November 7th 2023'

DEV_MODE = False
LOG_HW2GO_drawstop = False
LOG_HW2GO_coupler = False
LOG_HW2GO_tremulant = False
LOG_HW2GO_ctrl_switch = False
LOG_HW2GO_stop_rank = False
LOG_HW2GO_windchest = False
LOG_wav_decode = False

MAIN_WINDOW_TITLE = 'OdfEdit - ' + APP_VERSION + (' - DEV MODE' if DEV_MODE else '')

import os
import re
import shutil
import math
import struct
import inspect

from tkinter import *
from tkinter import filedialog as fd
from tkinter import simpledialog as sd
from tkinter import messagebox, ttk
import tkinter.font as tkf

from audioplayer import AudioPlayer        # install with : pip install audioplayer
from PIL import Image, ImageOps, ImageTk   # install with : pip install pillow (+ sudo apt-get install python3-pil python3-pil.imagetk)
from lxml import etree                     # install with : pip install lxml


# warning message displayed before to start a HW to GO ODF conversion
HW_CONV_MSG = """An ODF will be built in order to use the selected Hauptwerk sample set in the GrandOrgue application. None file of the Hauptwerk sample set will be modified.
ATTENTION :
- Please do this operation only with a free Hauptwerk sample set or a not-free sample set that you have duly paid for, and if the editor of this sample set does not preclude its use outside Hauptwerk application.
- Don't expect to have necessarily with GrandOrgue the sound quality and all control possibilities that this sample set can have with Hauptwerk.
"""

# sentence added in the GO ODF (header and Organ comments) when generated from a HW ODF
ODF_COMMENT = 'GrandOrgue ODF automatically generated from a Hauptwerk ODF by OdfEdit ' + APP_VERSION + ' (see github.com/GrandOrgue/OdfEdit)'

ENCODING_ISO_8859_1 = 'ISO-8859-1'  # ISO-8859-1 encoding for ODF file saving
ENCODING_UTF8_BOM   = 'utf_8_sig'   # UTF-8 encoding for ODF file saving

ALLOWED_CHARS_4_FIELDS = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_'  # characters allowed in a attribute name

# data types used in the attributes of the objects, used in the check object/attribute functions
ATTR_TYPE_INTEGER = 1
ATTR_TYPE_FLOAT = 2
ATTR_TYPE_BOOLEAN = 3
ATTR_TYPE_STRING = 4
ATTR_TYPE_COLOR = 5            # used in Button, Enclosure, Label, Panel
ATTR_TYPE_FONT_SIZE = 6        # used in Button, Enclosure, Label
ATTR_TYPE_PANEL_SIZE = 7       # used in Panel
ATTR_TYPE_COUPLER_TYPE = 8     # used in Coupler
ATTR_TYPE_ELEMENT_TYPE = 9     # used in Panel Element
ATTR_TYPE_TREMULANT_TYPE = 10  # used in Tremulant
ATTR_TYPE_PISTON_TYPE = 11     # used in Piston
ATTR_TYPE_DRAWSTOP_FCT = 12    # used in DrawStop
ATTR_TYPE_FILE_NAME = 13       # used in many objects for bitmap or wav files
ATTR_TYPE_OBJECT_REF = 14      # used in many objects to make a reference to another object ID
ATTR_TYPE_PIPE_WAVE = 15       # used in Rank

# tags for the text syntax highlighting in the object edition textbox and help
TAG_FIELD   = 'tag_field'      # tag to color the fields names of the objects
TAG_COMMENT = 'tag_comment'    # tag to color the comments
TAG_OBJ_UID = 'tag_obj_uid'    # tag to color the object UID
TAG_TITLE   = 'tag_title'      # tag to color the titles in the help
TAG_FOUND   = 'tag_found'      # tag to color the strings found by the search in the help
TAG_FOUND2  = 'tag_found2'     # tag to color the found string currently highlighted

TAG_SAME_UID = 'tag_same_uid'  # tag to color in the objects tree the items having the same UID as the selected one

COLOR_SELECTED_ITEM = 'RoyalBlue1'  # background color for the selected object UID in the lists or tree
COLOR_OBJ_UID_ITEM  = 'LightBlue1'  # background color for the objects of the lists or tree having the selected object UID

# constants to identify the type of link between two objects
TO_PARENT = 1
TO_CHILD = 2

# constants to make the functions parameters more understandable
FIRST_ONE = True
MANDATORY = True

#-------------------------------------------------------------------------------------------------
class C_LOGS:
    # class to manage logs

    logs_list = [] # list of logs strings (errors or messages resulting from file operation or syntax check or ODF conversion)

    #-------------------------------------------------------------------------------------------------
    def add(self, log_string):
        # add the given string to the events log list
        self.logs_list.append(log_string)

    #-------------------------------------------------------------------------------------------------
    def get(self):
        # recover the logs list
        return self.logs_list

    #-------------------------------------------------------------------------------------------------
    def nb_get(self):
        # recover the number of logs present in the list
        return len(self.logs_list)

    #-------------------------------------------------------------------------------------------------
    def clear(self):
        # clear the log list
        self.logs_list.clear()

# create a global instance of the C_LOGS class
logs = C_LOGS()

#-------------------------------------------------------------------------------------------------
class C_ODF_DATA_CHECK:
    # class to check the data contained in the GO ODF data

    check_files_names_bool = None  # flag storing the choice of the user to check or not the files names in the ODF (None if not defined, False, True)
    checked_attr_nb = 0            # number of attributes checked during the checking operation

    #-------------------------------------------------------------------------------------------------
    def check_odf_data(self, progress_status_update_fct):
        # check the consistency of the data which are present in ODF data of the C_ODF_DATA class

        if self.check_files_names_bool == None:
            # ask the user if he wants to check the files names (to make a faster check)
            self.check_files_names_bool = messagebox.askyesno("ODF Editor", "Do you want to check the files names (to have a faster check or to test only the ODF content) ? \nThis choice will be kept until the next ODF opening")

        self.checked_attr_nb = 0

        logs.add("ODF data check report :")

        # check the presence of the Organ object
        if 'Organ' not in self.odf_data_dic.keys():
            logs.add("ERROR the Organ object is not defined")

        for object_uid, object_dic in sorted(self.odf_data_dic.items()):
            # scan the objects of the ODF data

            # recover a copy of the lines of the current object
            object_lines_list = list(object_dic['lines'])

            # update in the GUI the name of the checked object
            progress_status_update_fct(f'Checking {object_uid}...')

            if len(object_lines_list) > 0:
                # lines have been recovered for the current object

                # sort the lines list to make faster the search which is done in check_attribute_value
                object_lines_list.sort()

                # remove the first line while it is empty (after the sorting the empty lines are all in first positions)
                while len(object_lines_list) > 0 and object_lines_list[0] == '':
                    object_lines_list.pop(0)

                # check if the attributes are all uniques in the object
                self.check_attributes_unicity(object_uid, object_lines_list)

                # check the attributes and values of the object by type
                object_type = self.object_type_get(object_uid)
                if object_type == 'Header':
                    pass
                elif object_type == 'Organ':
                    self.check_object_Organ(object_uid, object_lines_list)
                elif object_type == 'Coupler':
                    self.check_object_Coupler(object_uid, object_lines_list)
                elif object_type == 'Divisional':
                    self.check_object_Divisional(object_uid, object_lines_list)
                elif object_type == 'DivisionalCoupler':
                    self.check_object_DivisionalCoupler(object_uid, object_lines_list)
                elif object_type == 'Enclosure':
                    self.check_object_Enclosure(object_uid, object_lines_list)
                elif object_type == 'General':
                    self.check_object_General(object_uid, object_lines_list)
                elif object_type == 'Image':
                    self.check_object_Image(object_uid, object_lines_list)
                elif object_type == 'Label':
                    self.check_object_Label(object_uid, object_lines_list)
                elif object_type == 'Manual':
                    self.check_object_Manual(object_uid, object_lines_list)
                elif object_type == 'Panel':
                    self.check_object_Panel(object_uid, object_lines_list)
                elif object_type == 'PanelElement':
                    self.check_object_PanelElement(object_uid, object_lines_list)
                elif object_type[:5] == 'Panel': # Panel999Coupler999, Panel999Divisional999, Panel999Image999, ...
                    self.check_object_PanelOther(object_uid, object_lines_list)
                elif object_type == 'Rank':
                    self.check_object_Rank(object_uid, object_lines_list)
                elif object_type == 'ReversiblePiston':
                    self.check_object_ReversiblePiston(object_uid, object_lines_list)
                elif object_type == 'SetterElement':
                    self.check_object_SetterElement(object_uid, object_lines_list)
                elif object_type == 'Stop':
                    self.check_object_Stop(object_uid, object_lines_list)
                elif object_type == 'Switch':
                    self.check_object_Switch(object_uid, object_lines_list)
                elif object_type == 'Tremulant':
                    self.check_object_Tremulant(object_uid, object_lines_list)
                elif object_type == 'WindchestGroup':
                    self.check_object_WindchestGroup(object_uid, object_lines_list)
                else:
                    # the object UID has not been recognized
                    logs.add(f"WARNING the object type of {object_uid} is unknown")
                    # empty the lines list of the object which is not recognized, to not display in the log its attributes which have not been checked
                    object_lines_list = []

                # check the lines not checked by the function check_attribute_value() (that is which are still present in the lines list)
                for line in object_lines_list:
                    (error_msg, attr_name, attr_value, comment) = self.object_line_split(line)
                    if error_msg != None:
                        logs.add(f'ERROR in {object_uid} section, line "{line}" : {error_msg}')

                    if attr_name not in (None, 'uid'):
                        # the current line is an attribute line
                        self.checked_attr_nb += 1
                        logs.add(f"WARNING in {object_uid} : the attribute {attr_name} is not expected in this object section or is misspelled")

        # display in the log the number of checked attributes
        logs.add(f"{self.checked_attr_nb:,} attributes checked")

        # update the panel format flag
        self.check_panel_format()

        # display in the log if none error has been detected
        if logs.nb_get() <= 3:  # 3 log lines when no error : check start message + detected panel format + number of checked attributes
            logs.add("None error found")

    #-------------------------------------------------------------------------------------------------
    def check_panel_format(self):
        # check which is the panel format used in the ODF (new or old) and update the flag

        value = self.object_attr_value_get('Panel000', 'NumberOfGUIElements')
        if value != None:
            self.new_panel_format_bool = (value.isdigit() and int(value) >= 0)
        else:
            self.new_panel_format_bool = False

        if self.new_panel_format_bool:
            logs.add(f'New panel format')
        else:
            logs.add(f'Old panel format')

    #-------------------------------------------------------------------------------------------------
    def check_object_uid(self, object_uid):
        # return an error message if an issue has been detected in the given object UID, else None

        error_msg = None

        object_type = self.object_type_get(object_uid)

        if not object_uid.isalnum():
            error_msg = 'an object identifier must contain only alphanumeric characters'
        elif object_type not in self.go_objects_children_dic.keys():
            error_msg = f'{object_type} is an unknown object type'
        elif object_type not in ('Organ', 'Header'):
            if not object_uid[-3:].isdigit():
                error_msg = f'three digits are expected at the end of "{object_uid}"'
            elif int(object_uid[-3:]) == 0 and not object_type in ('Panel', 'Manual'):
                error_msg = f"{object_uid} cannot have the index 000"
            elif object_uid[:5] == 'Panel' and len(object_uid) > 8 and not object_uid[5:8].isdigit():
                # Panel999xxxxx999 object
                error_msg = f'three digits are expected after "Panel" in "{object_uid}"'

        return error_msg

    #-------------------------------------------------------------------------------------------------
    def check_object_line(self, line):
        # check the syntax of the given object line and extract from it the attribute name + attribute value + comment
        # return a tuple containing : (error message, attribute name, attribute value, comment)
        # attribute name = 'uid' if the given line contains an object UID between brackets, the UID is in the attribute value
        # error message = an error description message in case a syntax error has been detected in the given line, or None if no error found

        error_msg = attr_name = attr_value = comment = None

        if line != None and len(line) > 0: # not an empty line
            if line[0] == "[":
                # line with an object UID inside normally
                pos = line.find(']', 1)
                if pos == -1:  # object ID without closing bracket
                    error_msg = 'character "]" is missing to define an object ID'
                    comment = line
                elif pos == 1: # object ID with no string between the brackets
                    error_msg = 'no object identifier defined between the brackets'
                    comment = line
                else:
                    attr_name = 'uid'
                    attr_value = line[1:pos]
                    # check the coherency of the UID
                    error_msg = self.check_object_uid(attr_value)

                    if error_msg == None and len(line) > pos + 1:
                        # there are characters after the ]
                        comment = line[pos+1:]
                        if comment.lstrip()[0] != ';':
                            error_msg = 'only text beginning by ; is allowed after the ] character'

            elif line[0] != ";":  # not a comment line
                pos = line.find('=', 0)
                if pos == -1:  # no equal character in the line
                    error_msg = 'character ";" missing at the beginning of the line to make it a comment line'
                    comment = line
                elif pos == 0:  # the line starts by an equal character
                    error_msg = 'the character "=" cannot start a line'
                    comment = line
                elif line.find('=', pos+1) > pos:  # another equal character is present in the line
                    error_msg = 'more than one character "=" is defined'
                    comment = line
                else:
                    attr_name = line[0:pos]
                    for char in attr_name:
                        if char not in ALLOWED_CHARS_4_FIELDS:
                            # the attribute name has a forbiden character
                            error_msg = f'the attribute "{attr_name}" can contain only alphanumeric or "_" characters'
                            break

                    posc = line.find(';', pos + 1)
                    if posc != -1:
                        # there is a comment after the attribute value
                        while line[posc-1] == ' ': posc -= 1
                        attr_value = line[pos+1:posc]
                        comment = line[posc:]
                    else:
                        attr_value = line[pos+1:]
                    attr_value = attr_value.rstrip()

            else: # comment or empty line
                comment = line

        return (error_msg, attr_name, attr_value, comment)


    #-------------------------------------------------------------------------------------------------
    def check_object_Organ(self, object_uid, lines_list):
        # check the data of an Organ object section which the lines are in the given lines list

        # required attributes
        self.check_attribute_value(object_uid, lines_list, 'ChurchName', ATTR_TYPE_STRING, True)
        self.check_attribute_value(object_uid, lines_list, 'ChurchAddress', ATTR_TYPE_STRING, True)

        value = self.check_attribute_value(object_uid, lines_list, 'HasPedals', ATTR_TYPE_BOOLEAN, True)
        if value != None and value == "Y" and not ('Manual000' in self.odf_data_dic):
            logs.add(f"ERROR in {object_uid} : HasPedals=Y but no Manual000 object is defined")
        elif value == "N" and ('Manual000' in self.odf_data_dic):
            logs.add(f"ERROR in {object_uid} : HasPedals=N whereas a Manual000 object is defined")

        value = self.check_attribute_value(object_uid, lines_list, 'NumberOfDivisionalCouplers', ATTR_TYPE_INTEGER, True, 0, 8)
        if value != None and value.isdigit() and int(value) >= 0:
            count = self.objects_type_number_get('DivisionalCoupler')
            if count != int(value):
                logs.add(f"ERROR in {object_uid} : NumberOfDivisionalCouplers={value} whereas {count} DivisionalCoupler object(s) defined")

        value = self.check_attribute_value(object_uid, lines_list, 'NumberOfEnclosures', ATTR_TYPE_INTEGER, True, 0, 999)
        if value != None and value.isdigit() and int(value) >= 0:
            count = self.objects_type_number_get('Enclosure')
            if count != int(value):
                logs.add(f"ERROR in {object_uid} : NumberOfEnclosures={value} whereas {count} Enclosure object(s) defined")

        value = self.check_attribute_value(object_uid, lines_list, 'NumberOfGenerals', ATTR_TYPE_INTEGER, True, 0, 99)
        if value != None and value.isdigit() and int(value) >= 0:
            count = self.objects_type_number_get('General')
            if count != int(value):
                logs.add(f"ERROR in {object_uid} : NumberOfGenerals={value} whereas {count} General object(s) defined")

        value = self.check_attribute_value(object_uid, lines_list, 'NumberOfManuals', ATTR_TYPE_INTEGER, True, 1, 16)
        if value != None and value.isdigit() and int(value) >= 0:
            count = self.objects_type_number_get('Manual')
            if 'Manual000' in self.odf_data_dic.keys(): count -= 1
            if count != int(value):
                logs.add(f"ERROR in {object_uid} : NumberOfManuals={value} whereas {count} Manual object(s) defined")

        value = self.check_attribute_value(object_uid, lines_list, 'NumberOfPanels', ATTR_TYPE_INTEGER, self.new_panel_format_bool, 0, 100)
        if value != None and value.isdigit() and int(value) >= 0:
            count = self.objects_type_number_get('Panel')
            if 'Panel000' in self.odf_data_dic.keys(): count -= 1
            if count != int(value):
                logs.add(f"ERROR in {object_uid} : NumberOfPanels={value} whereas {count} Panel object(s) defined")

        if self.new_panel_format_bool and not ('Panel000' in self.odf_data_dic):
            logs.add("ERROR new panel format used but no Panel000 object is defined")
        elif not self.new_panel_format_bool and ('Panel000' in self.odf_data_dic):
            logs.add(f"ERROR in {object_uid} : old panel format used whereas a Panel000 is defined")

        value = self.check_attribute_value(object_uid, lines_list, 'NumberOfReversiblePistons', ATTR_TYPE_INTEGER, True, 0, 32)
        if value != None and value.isdigit() and int(value) >= 0:
            count = self.objects_type_number_get('ReversiblePiston')
            if count != int(value):
                logs.add(f"ERROR in {object_uid} : NumberOfReversiblePistons={value} whereas {count} ReversiblePiston object(s) defined")

        value = self.check_attribute_value(object_uid, lines_list, 'NumberOfTremulants', ATTR_TYPE_INTEGER, True, 0, 10)
        if value != None and value.isdigit() and int(value) >= 0:
            count = self.objects_type_number_get('Tremulant')
            if count != int(value):
                logs.add(f"ERROR in {object_uid} : NumberOfTremulants={value} whereas {count} Tremulant object(s) defined")

        value = self.check_attribute_value(object_uid, lines_list, 'NumberOfWindchestGroups', ATTR_TYPE_INTEGER, True, 1, 999)
        if value != None and value.isdigit() and int(value) >= 0:
            count = self.objects_type_number_get('WindchestGroup')
            if count != int(value):
                logs.add(f"ERROR in {object_uid} : NumberOfWindchestGroups={value} whereas {count} WindchestGroup object(s) defined")

        self.check_attribute_value(object_uid, lines_list, 'DivisionalsStoreIntermanualCouplers', ATTR_TYPE_BOOLEAN, True)
        self.check_attribute_value(object_uid, lines_list, 'DivisionalsStoreIntramanualCouplers', ATTR_TYPE_BOOLEAN, True)
        self.check_attribute_value(object_uid, lines_list, 'DivisionalsStoreTremulants', ATTR_TYPE_BOOLEAN, True)
        self.check_attribute_value(object_uid, lines_list, 'GeneralsStoreDivisionalCouplers', ATTR_TYPE_BOOLEAN, True)

        # optional attributes
        self.check_attribute_value(object_uid, lines_list, 'OrganBuilder', ATTR_TYPE_STRING, False)
        self.check_attribute_value(object_uid, lines_list, 'OrganBuildDate', ATTR_TYPE_STRING, False)
        self.check_attribute_value(object_uid, lines_list, 'OrganComments', ATTR_TYPE_STRING, False)
        self.check_attribute_value(object_uid, lines_list, 'RecordingDetails', ATTR_TYPE_STRING, False)
        self.check_attribute_value(object_uid, lines_list, 'InfoFilename', ATTR_TYPE_STRING, False)

        value = self.check_attribute_value(object_uid, lines_list, 'NumberOfImages', ATTR_TYPE_INTEGER, False, 0, 999) # old panel format
        if value != None and value.isdigit() and int(value) >= 0:
            count = self.objects_type_number_get('Image')
            if count != int(value):
                logs.add(f"ERROR in {object_uid} : NumberOfImages={value} whereas {count} Image object(s) defined")

        value = self.check_attribute_value(object_uid, lines_list, 'NumberOfLabels', ATTR_TYPE_INTEGER, False, 0, 999)  # old panel format
        if value != None and value.isdigit() and int(value) >= 0:
            count = self.objects_type_number_get('Label')
            if count != int(value):
                logs.add(f"ERROR in {object_uid} : NumberOfLabels={value} whereas {count} Label object(s) defined")

        value = self.check_attribute_value(object_uid, lines_list, 'NumberOfRanks', ATTR_TYPE_INTEGER, False, 0, 999)
        if value != None and value.isdigit() and int(value) >= 0:
            count = self.objects_type_number_get('Rank')
            if count != int(value):
                logs.add(f"ERROR in {object_uid} : NumberOfRanks={value} whereas {count} Rank object(s) defined")

        value = self.check_attribute_value(object_uid, lines_list, 'NumberOfSetterElements', ATTR_TYPE_INTEGER, False, 0, 999)  # old panel format
        if value != None and value.isdigit() and int(value) >= 0:
            count = self.objects_type_number_get('SetterElement')
            if count != int(value):
                logs.add(f"ERROR in {object_uid} : NumberOfSetterElements={value} whereas {count} SetterElement object(s) defined")

        value = self.check_attribute_value(object_uid, lines_list, 'NumberOfSwitches', ATTR_TYPE_INTEGER, False, 0, 999)
        if value != None and value.isdigit() and int(value) >= 0:
            count = self.objects_type_number_get('Switch')
            if count != int(value):
                logs.add(f"ERROR in {object_uid} : NumberOfSwitches={value} whereas {count} Switch object(s) defined")

        self.check_attribute_value(object_uid, lines_list, 'CombinationsStoreNonDisplayedDrawstops', ATTR_TYPE_BOOLEAN, False)
        self.check_attribute_value(object_uid, lines_list, 'AmplitudeLevel', ATTR_TYPE_FLOAT, False, 0, 1000)
        self.check_attribute_value(object_uid, lines_list, 'Gain', ATTR_TYPE_FLOAT, False, -120, 40)
        self.check_attribute_value(object_uid, lines_list, 'PitchTuning', ATTR_TYPE_FLOAT, False, -1200, 1200)
        self.check_attribute_value(object_uid, lines_list, 'TrackerDelay', ATTR_TYPE_FLOAT, False, 0, 10000)

        if not self.new_panel_format_bool:
            # if old parnel format, the Organ object contains panel attributes
            self.check_object_Panel(object_uid, lines_list)

    #-------------------------------------------------------------------------------------------------
    def check_object_Button(self, object_uid, lines_list):
        # check the data of a Button object section which the lines are in the given lines list

        # optional attributes
        self.check_attribute_value(object_uid, lines_list, 'Name', ATTR_TYPE_STRING, False)
        self.check_attribute_value(object_uid, lines_list, 'ShortcutKey', ATTR_TYPE_INTEGER, False, 0, 255)
        self.check_attribute_value(object_uid, lines_list, 'StopControlMIDIKeyNumber', ATTR_TYPE_INTEGER, False, 0, 127)
        self.check_attribute_value(object_uid, lines_list, 'MIDIProgramChangeNumber', ATTR_TYPE_INTEGER, False, 1, 128)
        self.check_attribute_value(object_uid, lines_list, 'Displayed', ATTR_TYPE_BOOLEAN, False)
        self.check_attribute_value(object_uid, lines_list, 'DisplayInInvertedState', ATTR_TYPE_BOOLEAN, False)

        display_as_piston = self.check_attribute_value(object_uid, lines_list, 'DisplayAsPiston', ATTR_TYPE_BOOLEAN, False)
        if display_as_piston == '':
            # attribute not defined, set its default value
            if (object_uid.startwith(('Divisional', 'General')) or
                (object_uid[8:15] == 'Element' and self.object_attr_value_get(object_uid, 'Type') in ('Divisional', 'General'))):
                # the object is a Divisional or General button or a panel element of Divisional or General type, so it must be displayed as a piston by default
                display_as_piston = 'Y'
            else:
                display_as_piston = 'N'

        self.check_attribute_value(object_uid, lines_list, 'DispLabelColour', ATTR_TYPE_COLOR, False)
        self.check_attribute_value(object_uid, lines_list, 'DispLabelFontSize', ATTR_TYPE_FONT_SIZE, False)
        self.check_attribute_value(object_uid, lines_list, 'DispLabelFontName', ATTR_TYPE_STRING, False)
        self.check_attribute_value(object_uid, lines_list, 'DispLabelText', ATTR_TYPE_STRING, False)
        self.check_attribute_value(object_uid, lines_list, 'DispKeyLabelOnLeft', ATTR_TYPE_BOOLEAN, False)
        self.check_attribute_value(object_uid, lines_list, 'DispImageNum', ATTR_TYPE_INTEGER, False, 1, 5 if display_as_piston == 'Y' else 6)
        self.check_attribute_value(object_uid, lines_list, 'DispButtonRow', ATTR_TYPE_INTEGER, False, 0, 199)
        self.check_attribute_value(object_uid, lines_list, 'DispButtonCol', ATTR_TYPE_INTEGER, False, 1, 32)
        self.check_attribute_value(object_uid, lines_list, 'DispDrawstopRow', ATTR_TYPE_INTEGER, False, 1, 199)
        self.check_attribute_value(object_uid, lines_list, 'DispDrawstopCol', ATTR_TYPE_INTEGER, False, 1, 12)
        image_on = self.check_attribute_value(object_uid, lines_list, 'ImageOn', ATTR_TYPE_FILE_NAME, False)
        self.check_attribute_value(object_uid, lines_list, 'ImageOff', ATTR_TYPE_FILE_NAME, False)
        self.check_attribute_value(object_uid, lines_list, 'MaskOn', ATTR_TYPE_FILE_NAME, False)
        self.check_attribute_value(object_uid, lines_list, 'MaskOff', ATTR_TYPE_FILE_NAME, False)

        # get the dimensions of the parent panel
        panel_uid = self.object_parent_panel_get(object_uid)
        value = self.object_attr_value_get(panel_uid, 'DispScreenSizeHoriz')
        panel_width = int(value) if value != None and value.isdigit() else 3000
        value = self.object_attr_value_get(panel_uid, 'DispScreenSizeVert')
        panel_height = int(value) if value != None and value.isdigit() else 2000

        self.check_attribute_value(object_uid, lines_list, 'PositionX', ATTR_TYPE_INTEGER, False, 0, panel_width)
        self.check_attribute_value(object_uid, lines_list, 'PositionY', ATTR_TYPE_INTEGER, False, 0, panel_height)
        width = self.check_attribute_value(object_uid, lines_list, 'Width', ATTR_TYPE_INTEGER, False, 0, panel_width)
        height = self.check_attribute_value(object_uid, lines_list, 'Height', ATTR_TYPE_INTEGER, False, 0, panel_height)
        max_width = int(width) if width != None and width.isdigit() else panel_width
        max_height = int(height) if height != None and height.isdigit() else panel_height

        # get the dimensions of the button bitmap
        if image_on != None and image_on != '':
            # an image is defined to display the button
            if self.check_files_names_bool:
                # get the sizes of the image in the file which is existing
                im = Image.open(os.path.dirname(self.odf_file_name) + os.sep + path2ospath(image_on))
                bitmap_width = im.size[0]
                bitmap_height = im.size[1]
            else:
                bitmap_width = 500  # arbritrary default value
                bitmap_height = 200 # arbritrary default value
        else:
            # no image file defined, get the dimensions of the internal bitmap (piston or drawstop)
            if display_as_piston == 'Y':
                bitmap_width = bitmap_height = 32
            else:
                bitmap_width = bitmap_height = 62

        self.check_attribute_value(object_uid, lines_list, 'TileOffsetX', ATTR_TYPE_INTEGER, False, 0, bitmap_width)
        self.check_attribute_value(object_uid, lines_list, 'TileOffsetY', ATTR_TYPE_INTEGER, False, 0, bitmap_height)

        self.check_attribute_value(object_uid, lines_list, 'MouseRectLeft', ATTR_TYPE_INTEGER, False, 0, max_width)
        self.check_attribute_value(object_uid, lines_list, 'MouseRectTop', ATTR_TYPE_INTEGER, False, 0, max_height)
        mouse_rect_width = self.check_attribute_value(object_uid, lines_list, 'MouseRectWidth', ATTR_TYPE_INTEGER, False, 0, max_width)
        mouse_rect_height = self.check_attribute_value(object_uid, lines_list, 'MouseRectHeight', ATTR_TYPE_INTEGER, False, 0, max_height)

        if mouse_rect_width != None and mouse_rect_width.isdigit() and mouse_rect_height != None and  mouse_rect_height.isdigit():
            mouse_radius = max(int(mouse_rect_width), int(mouse_rect_height))
        else:
            mouse_radius = max(bitmap_width, bitmap_height)
        self.check_attribute_value(object_uid, lines_list, 'MouseRadius', ATTR_TYPE_INTEGER, False, 0, mouse_radius)

        self.check_attribute_value(object_uid, lines_list, 'TextRectLeft', ATTR_TYPE_INTEGER, False, 0, max_width)
        self.check_attribute_value(object_uid, lines_list, 'TextRectTop', ATTR_TYPE_INTEGER, False, 0, max_height)
        text_rect_width = self.check_attribute_value(object_uid, lines_list, 'TextRectWidth', ATTR_TYPE_INTEGER, False, 0, max_width)
        self.check_attribute_value(object_uid, lines_list, 'TextRectHeight', ATTR_TYPE_INTEGER, False, 0, max_height)

        if text_rect_width != None and text_rect_width.isdigit():
            text_break_width = int(text_rect_width)
        else:
            text_break_width = bitmap_width
        self.check_attribute_value(object_uid, lines_list, 'TextBreakWidth', ATTR_TYPE_INTEGER, False, 0, text_break_width)

    #-------------------------------------------------------------------------------------------------
    def check_object_Coupler(self, object_uid, lines_list):
        # check the data of a Coupler object section which the lines are in the given lines list

        # required attributes
        ret1 = self.check_attribute_value(object_uid, lines_list, 'UnisonOff', ATTR_TYPE_BOOLEAN, True)
        ret2 = self.check_attribute_value(object_uid, lines_list, 'CouplerType', ATTR_TYPE_COUPLER_TYPE, False)  # optional but here to recover its value used after
        self.check_attribute_value(object_uid, lines_list, 'DestinationManual', ATTR_TYPE_INTEGER, True if ret1 == 'N' else False, 0, 16) # conditional required/optional
        self.check_attribute_value(object_uid, lines_list, 'DestinationKeyshift', ATTR_TYPE_INTEGER, True if ret1 == 'N' else False, -24, 24) # conditional required/optional

        is_required = (ret1 != None and ret2 != None and ret1 == 'N' and not(ret2.upper() in ('MELODY', 'BASS')))
        self.check_attribute_value(object_uid, lines_list, 'CoupleToSubsequentUnisonIntermanualCouplers', ATTR_TYPE_BOOLEAN, is_required)
        self.check_attribute_value(object_uid, lines_list, 'CoupleToSubsequentUpwardIntermanualCouplers', ATTR_TYPE_BOOLEAN, is_required)
        self.check_attribute_value(object_uid, lines_list, 'CoupleToSubsequentDownwardIntermanualCouplers', ATTR_TYPE_BOOLEAN, is_required)
        self.check_attribute_value(object_uid, lines_list, 'CoupleToSubsequentUpwardIntramanualCouplers', ATTR_TYPE_BOOLEAN, is_required)
        self.check_attribute_value(object_uid, lines_list, 'CoupleToSubsequentDownwardIntramanualCouplers', ATTR_TYPE_BOOLEAN, is_required)

        # optional attributes
        self.check_attribute_value(object_uid, lines_list, 'FirstMIDINoteNumber', ATTR_TYPE_INTEGER, False, 0, 127)
        self.check_attribute_value(object_uid, lines_list, 'NumberOfKeys', ATTR_TYPE_INTEGER, False, 0, 127)

        # a Coupler has in addition the attributes of a DrawStop
        self.check_object_DrawStop(object_uid, lines_list)

    #-------------------------------------------------------------------------------------------------
    def check_object_Divisional(self, object_uid, lines_list):
        # check the data of a Divisional object section which the lines are in the given lines list

        # recover the ID of manual in which is referenced this Divisional
        parent_manual_uid = self.object_parent_manual_get(object_uid)

        # required attributes
        value = self.object_attr_value_get(parent_manual_uid, 'NumberOfCouplers')
        max = int(value) if value != None and value.isdigit() else 999
        value = self.check_attribute_value(object_uid, lines_list, 'NumberOfCouplers', ATTR_TYPE_INTEGER, True, 0, max)
        if value != None and value.isdigit():
            for idx in range(1, int(value)+1):
                self.check_attribute_value(object_uid, lines_list, f'Coupler{str(idx).zfill(3)}', ATTR_TYPE_OBJECT_REF, True)

        value = self.object_attr_value_get(parent_manual_uid, 'NumberOfStops')
        max = int(value) if value != None and value.isdigit() else 999
        value = self.check_attribute_value(object_uid, lines_list, 'NumberOfStops', ATTR_TYPE_INTEGER, True, 0, max)
        if value != None and value.isdigit():
            for idx in range(1, int(value)+1):
                self.check_attribute_value(object_uid, lines_list, f'Stop{str(idx).zfill(3)}', ATTR_TYPE_OBJECT_REF, True)

        value = self.object_attr_value_get(parent_manual_uid, 'NumberOfTremulants')
        max = int(value) if value != None and value.isdigit() else 10
        value = self.check_attribute_value(object_uid, lines_list, 'NumberOfTremulants', ATTR_TYPE_INTEGER, True, 0, max)
        if value != None and value.isdigit():
            for idx in range(1, int(value)+1):
                self.check_attribute_value(object_uid, lines_list, f'Tremulant{str(idx).zfill(3)}', ATTR_TYPE_OBJECT_REF, True)

        # optional attributes
        self.check_attribute_value(object_uid, lines_list, 'Protected', ATTR_TYPE_BOOLEAN, False)

        value = self.object_attr_value_get(parent_manual_uid, 'NumberOfSwitches')
        max = int(value) if value != None and value.isdigit() else 999
        value = self.check_attribute_value(object_uid, lines_list, 'NumberOfSwitches', ATTR_TYPE_INTEGER, False, 0, max)
        if value != None and value.isdigit():
            for idx in range(1, int(value)+1):
                self.check_attribute_value(object_uid, lines_list, f'Switch{str(idx).zfill(3)}', ATTR_TYPE_OBJECT_REF, True)

        # a Divisional has in addition the attributes of a Push Button
        self.check_object_PushButton(object_uid, lines_list)

    #-------------------------------------------------------------------------------------------------
    def check_object_DivisionalCoupler(self, object_uid, lines_list):
        # check the data of a Divisional Coupler object section which the lines are in the given lines list

        # required attributes
        self.check_attribute_value(object_uid, lines_list, 'BiDirectionalCoupling', ATTR_TYPE_BOOLEAN, True)

        value = self.object_attr_value_get('Organ', 'NumberOfManuals')
        max = int(value) if value != None and value.isdigit() else 16
        value = self.check_attribute_value(object_uid, lines_list, 'NumberOfManuals', ATTR_TYPE_INTEGER, True, 1, max)
        if value != None and value.isdigit():
            for idx in range(1, int(value)+1):
                self.check_attribute_value(object_uid, lines_list, f"Manual{str(idx).zfill(3)}", ATTR_TYPE_OBJECT_REF, True)

        # a Divisional Coupler has in addition the attributes of a DrawStop
        self.check_object_DrawStop(object_uid, lines_list)

    #-------------------------------------------------------------------------------------------------
    def check_object_DrawStop(self, object_uid, lines_list):
        # check the data of a DrawStop object section which the lines are in the given lines list

        # optional attributes
        self.check_attribute_value(object_uid, lines_list, 'Function', ATTR_TYPE_DRAWSTOP_FCT, False)

        max = myint(self.object_attr_value_get('Organ', 'NumberOfSwitches'), 999)
        switch_id = int(object_uid[-3:]) if (object_uid[-3:].isdigit() and object_uid[:-3] == 'Switch') else 999
        switch_nb = myint(self.check_attribute_value(object_uid, lines_list, 'SwitchCount', ATTR_TYPE_INTEGER, False, 1, max), 0)
        function = self.object_attr_value_get(object_uid, 'Function')
        if function == 'Not':
            if switch_nb > 1:
                logs.add(f'ERROR in {object_uid} section, a NOT switch cannot have more than one switch input')
            switch_nb = 1

        for idx in range(1, switch_nb + 1):
            attr_value = self.check_attribute_value(object_uid, lines_list, f"Switch{str(idx).zfill(3)}", ATTR_TYPE_OBJECT_REF, True)
            if switch_id != 999 and int(attr_value) >= switch_id:
                # the given object is a Switch and it refers to another switch which has an higher ID than it
                logs.add(f'ERROR in {object_uid} section, cannot reference switches with an equal or higher number')

        self.check_attribute_value(object_uid, lines_list, 'DefaultToEngaged', ATTR_TYPE_BOOLEAN, False)
        self.check_attribute_value(object_uid, lines_list, 'GCState', ATTR_TYPE_INTEGER, False, -1, 1)
        self.check_attribute_value(object_uid, lines_list, 'StoreInDivisional', ATTR_TYPE_BOOLEAN, False)
        self.check_attribute_value(object_uid, lines_list, 'StoreInGeneral', ATTR_TYPE_BOOLEAN, False)

        # a Drawstop has in addition the attributes of a Button
        self.check_object_Button(object_uid, lines_list)

    #-------------------------------------------------------------------------------------------------
    def check_object_Enclosure(self, object_uid, lines_list):
        # check the data of an Enclosure object section which the lines are in the given lines list

        # required attributes
        # none required attribute

        # optional attributes
        self.check_attribute_value(object_uid, lines_list, 'Name', ATTR_TYPE_STRING, False)
        self.check_attribute_value(object_uid, lines_list, 'AmpMinimumLevel', ATTR_TYPE_INTEGER, False, 0, 100)
        self.check_attribute_value(object_uid, lines_list, 'MIDIInputNumber', ATTR_TYPE_INTEGER, False, 0, 100)
        self.check_attribute_value(object_uid, lines_list, 'Displayed', ATTR_TYPE_BOOLEAN, False)
        self.check_attribute_value(object_uid, lines_list, 'DispLabelColour', ATTR_TYPE_COLOR, False)
        self.check_attribute_value(object_uid, lines_list, 'DispLabelFontSize', ATTR_TYPE_FONT_SIZE, False)
        self.check_attribute_value(object_uid, lines_list, 'DispLabelFontName', ATTR_TYPE_STRING, False)
        self.check_attribute_value(object_uid, lines_list, 'DispLabelText', ATTR_TYPE_STRING, False)
        self.check_attribute_value(object_uid, lines_list, 'EnclosureStyle', ATTR_TYPE_INTEGER, False, 1, 4)

        value = self.check_attribute_value(object_uid, lines_list, 'BitmapCount', ATTR_TYPE_INTEGER, False, 1, 128)
        if value != None and value.isdigit():
            image = None
            for idx in range(1, int(value)+1):
                image = self.check_attribute_value(object_uid, lines_list, f'Bitmap{str(idx).zfill(3)}', ATTR_TYPE_FILE_NAME, True)
                self.check_attribute_value(object_uid, lines_list, f'Mask{str(idx).zfill(3)}', ATTR_TYPE_FILE_NAME, False)
            # get the dimensions of the last enclosure bitmap
            if image != None and image != '' and self.check_files_names_bool:
                # an image is defined to display the enclosure
                # get the sizes of the image in the file which is existing
                im = Image.open(os.path.dirname(self.odf_file_name) + os.sep + path2ospath(image))
                bitmap_width = im.size[0]
                bitmap_height = im.size[1]
            else:
                bitmap_width = 100  # arbitrary default value
                bitmap_height = 200 # arbitrary default value
        else:
            # no image file defined, get the dimensions of the internal bitmap
            bitmap_width = 46
            bitmap_height = 61

        # get the dimensions of the parent panel
        panel_uid = self.object_parent_panel_get(object_uid)
        value = self.object_attr_value_get(panel_uid, 'DispScreenSizeHoriz')
        panel_width = int(value) if value != None and value.isdigit() else 3000
        value = self.object_attr_value_get(panel_uid, 'DispScreenSizeVert')
        panel_height = int(value) if value != None and value.isdigit() else 2000

        self.check_attribute_value(object_uid, lines_list, 'PositionX', ATTR_TYPE_INTEGER, False, 0, panel_width)
        self.check_attribute_value(object_uid, lines_list, 'PositionY', ATTR_TYPE_INTEGER, False, 0, panel_height)
        width = self.check_attribute_value(object_uid, lines_list, 'Width', ATTR_TYPE_INTEGER, False, 0, panel_width)
        height = self.check_attribute_value(object_uid, lines_list, 'Height', ATTR_TYPE_INTEGER, False, 0, panel_height)
        max_width = int(width) if width != None and width.isdigit() else panel_width
        max_height = int(height) if height != None and height.isdigit() else panel_height

        self.check_attribute_value(object_uid, lines_list, 'TileOffsetX', ATTR_TYPE_INTEGER, False, 0, bitmap_width)
        self.check_attribute_value(object_uid, lines_list, 'TileOffsetY', ATTR_TYPE_INTEGER, False, 0, bitmap_height)

        self.check_attribute_value(object_uid, lines_list, 'MouseRectLeft', ATTR_TYPE_INTEGER, False, 0, max_width)
        self.check_attribute_value(object_uid, lines_list, 'MouseRectTop', ATTR_TYPE_INTEGER, False, 0, max_height)
        self.check_attribute_value(object_uid, lines_list, 'MouseRectWidth', ATTR_TYPE_INTEGER, False, 0, max_width)
        mouse_rect_height = self.check_attribute_value(object_uid, lines_list, 'MouseRectHeight', ATTR_TYPE_INTEGER, False, 0, max_height)

        if mouse_rect_height != None and mouse_rect_height.isdigit():
            max_start = int(mouse_rect_height)
        else:
            max_start = 200
        mouse_axis_start = self.check_attribute_value(object_uid, lines_list, 'MouseAxisStart', ATTR_TYPE_INTEGER, False, 0, max_start)

        if mouse_axis_start != None and mouse_axis_start.isdigit():
            min_end = int(mouse_axis_start)
        else:
            min_end = 200
        self.check_attribute_value(object_uid, lines_list, 'MouseAxisEnd', ATTR_TYPE_INTEGER, False, min_end, max_start)

        self.check_attribute_value(object_uid, lines_list, 'TextRectLeft', ATTR_TYPE_INTEGER, False, 0, max_width)
        self.check_attribute_value(object_uid, lines_list, 'TextRectTop', ATTR_TYPE_INTEGER, False, 0, max_height)
        text_rect_width = self.check_attribute_value(object_uid, lines_list, 'TextRectWidth', ATTR_TYPE_INTEGER, False, 0, max_width)
        self.check_attribute_value(object_uid, lines_list, 'TextRectHeight', ATTR_TYPE_INTEGER, False, 0, max_height)

        if text_rect_width != None and text_rect_width.isdigit():
            text_break_width = int(text_rect_width)
        else:
            text_break_width = bitmap_width
        self.check_attribute_value(object_uid, lines_list, 'TextBreakWidth', ATTR_TYPE_INTEGER, False, 0, text_break_width)

    #-------------------------------------------------------------------------------------------------
    def check_object_General(self, object_uid, lines_list):
        # check the data of a General object section which the lines are in the given lines list

        is_general_obj = (self.object_type_get(object_uid) == 'General') # some mandatory attributes are not mandatory for objects which inherit the General attributes

        # required attributes
        max = self.objects_type_number_get('Coupler')
        value = self.check_attribute_value(object_uid, lines_list, 'NumberOfCouplers', ATTR_TYPE_INTEGER, is_general_obj, 0, max)
        if value != None and value.isdigit():
            for idx in range(1, int(value)+1):
                self.check_attribute_value(object_uid, lines_list, f'CouplerNumber{str(idx).zfill(3)}', ATTR_TYPE_OBJECT_REF, True)
                self.check_attribute_value(object_uid, lines_list, f'CouplerManual{str(idx).zfill(3)}', ATTR_TYPE_OBJECT_REF, True)

        max = self.objects_type_number_get('DivisionalCoupler')
        value = self.check_attribute_value(object_uid, lines_list, 'NumberOfDivisionalCouplers', ATTR_TYPE_INTEGER, False, 0, max)
        if value != None and value.isdigit():
            for idx in range(1, int(value)+1):
                self.check_attribute_value(object_uid, lines_list, f'DivisionalCouplerNumber{str(idx).zfill(3)}', ATTR_TYPE_OBJECT_REF, True)

        max = self.objects_type_number_get('Stop')
        value = self.check_attribute_value(object_uid, lines_list, 'NumberOfStops', ATTR_TYPE_INTEGER, is_general_obj, 0, max)
        if value != None and value.isdigit():
            for idx in range(1, int(value)+1):
                self.check_attribute_value(object_uid, lines_list, f'StopNumber{str(idx).zfill(3)}', ATTR_TYPE_OBJECT_REF, True)
                self.check_attribute_value(object_uid, lines_list, f'StopManual{str(idx).zfill(3)}', ATTR_TYPE_OBJECT_REF, True)

        max = self.objects_type_number_get('Tremulant')
        value = self.check_attribute_value(object_uid, lines_list, 'NumberOfTremulants', ATTR_TYPE_INTEGER, is_general_obj, 0, max)
        if value != None and value.isdigit():
            for idx in range(1, int(value)+1):
                self.check_attribute_value(object_uid, lines_list, f'TremulantNumber{str(idx).zfill(3)}', ATTR_TYPE_OBJECT_REF, True)

        # optional attributes
        max = self.objects_type_number_get('Switch')
        value = self.check_attribute_value(object_uid, lines_list, 'NumberOfSwitches', ATTR_TYPE_INTEGER, False, 0, max)
        if value != None and value.isdigit():
            for idx in range(1, int(value)+1):
                self.check_attribute_value(object_uid, lines_list, f'SwitchNumber{str(idx).zfill(3)}', ATTR_TYPE_OBJECT_REF, True)

        self.check_attribute_value(object_uid, lines_list, 'Protected', ATTR_TYPE_BOOLEAN, False)

        # a General has in addition the attributes of a Push Button
        self.check_object_PushButton(object_uid, lines_list)

    #-------------------------------------------------------------------------------------------------
    def check_object_Image(self, object_uid, lines_list):
        # check the data of an Image object section which the lines are in the given lines list

        # required attributes
        image = self.check_attribute_value(object_uid, lines_list, 'Image', ATTR_TYPE_FILE_NAME, True)

        # get the dimensions of the parent panel
        parent_panel_uid = self.object_parent_panel_get(object_uid)
        value = self.object_attr_value_get(parent_panel_uid, 'DispScreenSizeHoriz')
        panel_width = int(value) if value != None and value.isdigit() else 3000
        value = self.object_attr_value_get(parent_panel_uid, 'DispScreenSizeVert')
        panel_height = int(value) if value != None and value.isdigit() else 2000

        # optional attributes
        self.check_attribute_value(object_uid, lines_list, 'Mask', ATTR_TYPE_FILE_NAME, False)
        self.check_attribute_value(object_uid, lines_list, 'PositionX', ATTR_TYPE_INTEGER, False, 0, panel_width)
        self.check_attribute_value(object_uid, lines_list, 'PositionY', ATTR_TYPE_INTEGER, False, 0, panel_height)
        self.check_attribute_value(object_uid, lines_list, 'Width', ATTR_TYPE_INTEGER, False, 0, panel_width)
        self.check_attribute_value(object_uid, lines_list, 'Height', ATTR_TYPE_INTEGER, False, 0, panel_height)

        # get the dimensions of the image bitmap
        if image != None and image != '':
            # an image is defined
            if self.check_files_names_bool:
                # get the sizes of the image in the file which is existing
                im = Image.open(os.path.dirname(self.odf_file_name) + os.sep + path2ospath(image))
                bitmap_width = im.size[0]
                bitmap_height = im.size[1]
            else:
                bitmap_width = panel_width
                bitmap_height = panel_height
        else:
            # no image file defined
            bitmap_width = panel_width
            bitmap_height = panel_height

        self.check_attribute_value(object_uid, lines_list, 'TileOffsetX', ATTR_TYPE_INTEGER, False, 0, bitmap_width)
        self.check_attribute_value(object_uid, lines_list, 'TileOffsetY', ATTR_TYPE_INTEGER, False, 0, bitmap_height)

    #-------------------------------------------------------------------------------------------------
    def check_object_Label(self, object_uid, lines_list):
        # check the data of a Label object section which the lines are in the given lines list

        # optional attributes
        self.check_attribute_value(object_uid, lines_list, 'Name', ATTR_TYPE_STRING, False)
        ret1 = self.check_attribute_value(object_uid, lines_list, 'FreeXPlacement', ATTR_TYPE_BOOLEAN, False)
        ret2 = self.check_attribute_value(object_uid, lines_list, 'FreeYPlacement', ATTR_TYPE_BOOLEAN, False)

        # get the dimensions of the parent panel
        parent_panel_uid = self.object_parent_panel_get(object_uid)
        value = self.object_attr_value_get(parent_panel_uid, 'DispScreenSizeHoriz')
        panel_width = int(value) if value != None and value.isdigit() else 3000
        value = self.object_attr_value_get(parent_panel_uid, 'DispScreenSizeVert')
        panel_height = int(value) if value != None and value.isdigit() else 2000

        self.check_attribute_value(object_uid, lines_list, 'DispXpos', ATTR_TYPE_INTEGER, False, 0, panel_width)
        self.check_attribute_value(object_uid, lines_list, 'DispYpos', ATTR_TYPE_INTEGER, False, 0, panel_height)

        self.check_attribute_value(object_uid, lines_list, 'DispAtTopOfDrawstopCol', ATTR_TYPE_BOOLEAN, ret2 == 'N')

        # get the number of drawstop columns in the parent panel
        value = self.object_attr_value_get(parent_panel_uid, 'DispDrawstopCols')
        columns_nb = int(value) if value != None and value.isdigit() else 12
        self.check_attribute_value(object_uid, lines_list, 'DispDrawstopCol', ATTR_TYPE_INTEGER, ret1 == 'N', 1, columns_nb)

        self.check_attribute_value(object_uid, lines_list, 'DispSpanDrawstopColToRight', ATTR_TYPE_BOOLEAN, True if ret1 == 'N' else False)
        self.check_attribute_value(object_uid, lines_list, 'DispLabelColour', ATTR_TYPE_COLOR, False)
        self.check_attribute_value(object_uid, lines_list, 'DispLabelFontSize', ATTR_TYPE_FONT_SIZE, False)
        self.check_attribute_value(object_uid, lines_list, 'DispLabelFontName', ATTR_TYPE_STRING, False)
        image_num = self.check_attribute_value(object_uid, lines_list, 'DispImageNum', ATTR_TYPE_INTEGER, False, 0, 12)
        image = self.check_attribute_value(object_uid, lines_list, 'Image', ATTR_TYPE_FILE_NAME, False)
        self.check_attribute_value(object_uid, lines_list, 'Mask', ATTR_TYPE_FILE_NAME, False)

        self.check_attribute_value(object_uid, lines_list, 'PositionX', ATTR_TYPE_INTEGER, False, 0, panel_width)
        self.check_attribute_value(object_uid, lines_list, 'PositionY', ATTR_TYPE_INTEGER, False, 0, panel_height)
        width = self.check_attribute_value(object_uid, lines_list, 'Width', ATTR_TYPE_INTEGER, False, 0, panel_width)
        height = self.check_attribute_value(object_uid, lines_list, 'Height', ATTR_TYPE_INTEGER, False, 0, panel_height)
        max_width = int(width) if width != None and width.isdigit() else panel_width
        max_height = int(height) if height != None and height.isdigit() else panel_height

        # get the dimensions of the label bitmap
        if image != None and image != '':
            # an image is defined to display the label
            if self.check_files_names_bool:
                # get the sizes of the image in the file which is existing
                im = Image.open(os.path.dirname(self.odf_file_name) + os.sep + path2ospath(image))
                bitmap_width = im.size[0]
                bitmap_height = im.size[1]
            else:
                bitmap_width = 400  # arbritrary default value
                bitmap_height = 100 # arbritrary default value
        else:
            if   image_num == '1':  bitmap_width = 80; bitmap_height = 25
            elif image_num == '2':  bitmap_width = 80; bitmap_height = 50
            elif image_num == '3':  bitmap_width = 80; bitmap_height = 25
            elif image_num == '4':  bitmap_width = 160; bitmap_height = 25
            elif image_num == '5':  bitmap_width = 200; bitmap_height = 50
            elif image_num == '6':  bitmap_width = 80; bitmap_height = 50
            elif image_num == '7':  bitmap_width = 80; bitmap_height = 25
            elif image_num == '8':  bitmap_width = 160; bitmap_height = 25
            elif image_num == '9':  bitmap_width = 80; bitmap_height = 50
            elif image_num == '10': bitmap_width = 80; bitmap_height = 25
            elif image_num == '11': bitmap_width = 160; bitmap_height = 25
            else:                   bitmap_width = 200; bitmap_height = 50


        self.check_attribute_value(object_uid, lines_list, 'TileOffsetX', ATTR_TYPE_INTEGER, False, 0, bitmap_width)
        self.check_attribute_value(object_uid, lines_list, 'TileOffsetY', ATTR_TYPE_INTEGER, False, 0, bitmap_height)

        self.check_attribute_value(object_uid, lines_list, 'TextRectLeft', ATTR_TYPE_INTEGER, False, 0, max_width)
        self.check_attribute_value(object_uid, lines_list, 'TextRectTop', ATTR_TYPE_INTEGER, False, 0, max_height)
        text_rect_width = self.check_attribute_value(object_uid, lines_list, 'TextRectWidth', ATTR_TYPE_INTEGER, False, 0, max_width)
        self.check_attribute_value(object_uid, lines_list, 'TextRectHeight', ATTR_TYPE_INTEGER, False, 0, max_height)

        if text_rect_width != None and text_rect_width.isdigit():
            text_break_width = int(text_rect_width)
        else:
            text_break_width = bitmap_width
        self.check_attribute_value(object_uid, lines_list, 'TextBreakWidth', ATTR_TYPE_INTEGER, False, 0, text_break_width)

    #-------------------------------------------------------------------------------------------------
    def check_object_Manual(self, object_uid, lines_list):
        # check the data of a Manual object section which the lines are in the given lines list

        is_manual_obj = (self.object_type_get(object_uid) == 'Manual') # some mandatory attributes are not mandatory for objects which inherit the Manual attributes

        if not is_manual_obj:
            # object_uid is a PanelElement object with Type=Manual, get the UID of the linked Manual
            manual_uid = self.object_attr_value_get(object_uid, 'Manual')
            if manual_uid != None:
                manual_uid = 'Manual' + str(int(manual_uid)).zfill(3)
        else:
            manual_uid = None

        # required attributes
        self.check_attribute_value(object_uid, lines_list, 'Name', ATTR_TYPE_STRING, is_manual_obj)
        value = self.check_attribute_value(object_uid, lines_list, 'NumberOfLogicalKeys', ATTR_TYPE_INTEGER, is_manual_obj, 1, 192)
        if value == None and manual_uid != None:
            # recover the number of logical keys in the linked Manual object
            value = self.object_attr_value_get(manual_uid, 'NumberOfLogicalKeys')

        if value != None and value.isdigit() and int(value) > 0:
            for idx in range(1, int(value) + 1):
                # attributes Key999xxx
                image = self.check_attribute_value(object_uid, lines_list, f'Key{str(idx).zfill(3)}ImageOn', ATTR_TYPE_FILE_NAME, False)
                if image != None and image != '':
                    # check the other attributes for this key only if an image on is defined
                    self.check_attribute_value(object_uid, lines_list, f'Key{str(idx).zfill(3)}ImageOff', ATTR_TYPE_FILE_NAME, False)
                    self.check_attribute_value(object_uid, lines_list, f'Key{str(idx).zfill(3)}MaskOn', ATTR_TYPE_FILE_NAME, False)
                    self.check_attribute_value(object_uid, lines_list, f'Key{str(idx).zfill(3)}MaskOff', ATTR_TYPE_FILE_NAME, False)
                    self.check_attribute_value(object_uid, lines_list, f'Key{str(idx).zfill(3)}Width', ATTR_TYPE_INTEGER, False, 0, 500)
                    self.check_attribute_value(object_uid, lines_list, f'Key{str(idx).zfill(3)}Offset', ATTR_TYPE_INTEGER, False, -500, 500)
                    self.check_attribute_value(object_uid, lines_list, f'Key{str(idx).zfill(3)}YOffset', ATTR_TYPE_INTEGER, False, -500, 500)

                    # get the dimensions of the key bitmap
                    # an image is defined to display the key
                    if self.check_files_names_bool:
                        # get the sizes of the image in the file which is existing
                        im = Image.open(os.path.dirname(self.odf_file_name) + os.sep + path2ospath(image))
                        bitmap_width = im.size[0]
                        bitmap_height = im.size[1]
                    else:
                        bitmap_width = 100  # arbritrary default value
                        bitmap_height = 300 # arbritrary default value

                    self.check_attribute_value(object_uid, lines_list, f'Key{str(idx).zfill(3)}MouseRectLeft', ATTR_TYPE_INTEGER, False, 0, bitmap_width)
                    self.check_attribute_value(object_uid, lines_list, f'Key{str(idx).zfill(3)}MouseRectTop', ATTR_TYPE_INTEGER, False, 0, bitmap_height)
                    self.check_attribute_value(object_uid, lines_list, f'Key{str(idx).zfill(3)}MouseRectWidth', ATTR_TYPE_INTEGER, False, 0, bitmap_width)
                    self.check_attribute_value(object_uid, lines_list, f'Key{str(idx).zfill(3)}MouseRectHeight', ATTR_TYPE_INTEGER, False, 0, bitmap_height)

        logical_keys_nb = int(value) if value != None and value.isdigit() else 192
        self.check_attribute_value(object_uid, lines_list, 'FirstAccessibleKeyLogicalKeyNumber', ATTR_TYPE_INTEGER, is_manual_obj, 1, logical_keys_nb)
        self.check_attribute_value(object_uid, lines_list, 'FirstAccessibleKeyMIDINoteNumber', ATTR_TYPE_INTEGER, is_manual_obj, 0, 127)

        value = self.check_attribute_value(object_uid, lines_list, 'NumberOfAccessibleKeys', ATTR_TYPE_INTEGER, is_manual_obj, 0, 85)
        accessible_keys_nb = int(value) if value != None and value.isdigit() else 85

        value = self.check_attribute_value(object_uid, lines_list, 'NumberOfCouplers', ATTR_TYPE_INTEGER, False, 0, 999)
        if value != None and value.isdigit() and int(value) > 0:
            for idx in range(1, int(value)+1):
                self.check_attribute_value(object_uid, lines_list, f'Coupler{str(idx).zfill(3)}', ATTR_TYPE_OBJECT_REF, True)

        value = self.check_attribute_value(object_uid, lines_list, 'NumberOfDivisionals', ATTR_TYPE_INTEGER, False, 0, 999)
        if value != None and value.isdigit() and int(value) > 0:
            for idx in range(1, int(value)+1):
                self.check_attribute_value(object_uid, lines_list, f'Divisional{str(idx).zfill(3)}', ATTR_TYPE_OBJECT_REF, True)

        value = self.check_attribute_value(object_uid, lines_list, 'NumberOfStops', ATTR_TYPE_INTEGER, False, 0, 999)
        if value != None and value.isdigit() and int(value) > 0:
            for idx in range(1, int(value)+1):
                self.check_attribute_value(object_uid, lines_list, f'Stop{str(idx).zfill(3)}', ATTR_TYPE_OBJECT_REF, True)

        max = self.objects_type_number_get('Switch')
        value = self.check_attribute_value(object_uid, lines_list, 'NumberOfSwitches', ATTR_TYPE_INTEGER, False, 0, max)
        if value != None and value.isdigit() and int(value) > 0:
            for idx in range(1, int(value)+1):
                self.check_attribute_value(object_uid, lines_list, f'Switch{str(idx).zfill(3)}', ATTR_TYPE_OBJECT_REF, True)

        max = self.objects_type_number_get('Tremulant')
        value = self.check_attribute_value(object_uid, lines_list, 'NumberOfTremulants', ATTR_TYPE_INTEGER, False, 0, max)
        if value != None and value.isdigit() and int(value) > 0:
            for idx in range(1, int(value)+1):
                self.check_attribute_value(object_uid, lines_list, f'Tremulant{str(idx).zfill(3)}', ATTR_TYPE_OBJECT_REF, True)

        # optional attributes
        for idx in range(0, 128):
            self.check_attribute_value(object_uid, lines_list, f'MIDIKey{str(idx).zfill(3)}', ATTR_TYPE_INTEGER, False, 0, 127)

        self.check_attribute_value(object_uid, lines_list, 'MIDIInputNumber', ATTR_TYPE_INTEGER, False, 0, 200)
        self.check_attribute_value(object_uid, lines_list, 'Displayed', ATTR_TYPE_BOOLEAN, False)

        # get the dimensions of the parent panel
        parent_panel_uid = self.object_parent_panel_get(object_uid)
        value = self.object_attr_value_get(parent_panel_uid, 'DispScreenSizeHoriz')
        panel_width = int(value) if value != None and value.isdigit() else 3000
        value = self.object_attr_value_get(parent_panel_uid, 'DispScreenSizeVert')
        panel_height = int(value) if value != None and value.isdigit() else 2000

        self.check_attribute_value(object_uid, lines_list, 'PositionX', ATTR_TYPE_INTEGER, False, 0, panel_width)
        self.check_attribute_value(object_uid, lines_list, 'PositionY', ATTR_TYPE_INTEGER, False, 0, panel_height)

        self.check_attribute_value(object_uid, lines_list, 'DispKeyColourInverted', ATTR_TYPE_BOOLEAN, False)
        self.check_attribute_value(object_uid, lines_list, 'DispKeyColourWooden', ATTR_TYPE_BOOLEAN, False)
        self.check_attribute_value(object_uid, lines_list, 'DisplayFirstNote', ATTR_TYPE_INTEGER, False, 0, 127)

        value = self.check_attribute_value(object_uid, lines_list, 'DisplayKeys', ATTR_TYPE_INTEGER, False, 1, accessible_keys_nb)
        if value != None and value.isdigit() and int(value) > 0:
            for idx in range(1, int(value)+1):
                self.check_attribute_value(object_uid, lines_list, f'DisplayKey{str(idx).zfill(3)}', ATTR_TYPE_INTEGER, False, 0, 127)
                self.check_attribute_value(object_uid, lines_list, f'DisplayKey{str(idx).zfill(3)}Note', ATTR_TYPE_INTEGER, False, 0, 127)

        # optional attributes with the KEYTYPE format
        ImageOn_First_keytype = None # variable to store if the first attribute have been already checked for the ImageOn key type
        ImageOff_First_keytype = None
        MaskOn_First_keytype = None
        MaskOff_First_keytype = None
        Width_First_keytype = None
        Offset_First_keytype = None
        YOffset_First_keytype = None

        ImageOn_Last_keytype = None
        ImageOff_Last_keytype = None
        MaskOn_Last_keytype = None
        MaskOff_Last_keytype = None
        Width_Last_keytype = None
        Offset_Last_keytype = None
        YOffset_Last_keytype = None

        if object_uid == 'Panel000Element001':
            pass

        for keytype in ('C', 'Cis', 'D', 'Dis', 'E', 'F', 'Fis', 'G', 'Gis', 'A', 'Ais', 'B'):
            self.check_attribute_value(object_uid, lines_list, f'ImageOn_{keytype}', ATTR_TYPE_FILE_NAME, False)
            self.check_attribute_value(object_uid, lines_list, f'ImageOff_{keytype}', ATTR_TYPE_FILE_NAME, False)
            self.check_attribute_value(object_uid, lines_list, f'MaskOn_{keytype}', ATTR_TYPE_FILE_NAME, False)
            self.check_attribute_value(object_uid, lines_list, f'MaskOff_{keytype}', ATTR_TYPE_FILE_NAME, False)
            self.check_attribute_value(object_uid, lines_list, f'Width_{keytype}', ATTR_TYPE_INTEGER, False, 0, 500)
            self.check_attribute_value(object_uid, lines_list, f'Offset_{keytype}', ATTR_TYPE_INTEGER, False, -500, 500)
            self.check_attribute_value(object_uid, lines_list, f'YOffset_{keytype}', ATTR_TYPE_INTEGER, False, -500, 500)
            # the First and Last attributes are checked only once for each key property
            # so if there is more than one First or Last definition it will appear in the warning logs because it will not have been checked here
            if ImageOn_First_keytype == None : ImageOn_First_keytype = self.check_attribute_value(object_uid, lines_list, f'ImageOn_First{keytype}', ATTR_TYPE_FILE_NAME, False)
            if ImageOff_First_keytype == None : ImageOff_First_keytype = self.check_attribute_value(object_uid, lines_list, f'ImageOff_First{keytype}', ATTR_TYPE_FILE_NAME, False)
            if MaskOn_First_keytype == None : MaskOn_First_keytype = self.check_attribute_value(object_uid, lines_list, f'MaskOn_First{keytype}', ATTR_TYPE_FILE_NAME, False)
            if MaskOff_First_keytype == None : MaskOff_First_keytype = self.check_attribute_value(object_uid, lines_list, f'MaskOff_First{keytype}', ATTR_TYPE_FILE_NAME, False)
            if Width_First_keytype == None : Width_First_keytype = self.check_attribute_value(object_uid, lines_list, f'Width_First{keytype}', ATTR_TYPE_INTEGER, False, 0, 500)
            if Offset_First_keytype == None : Offset_First_keytype = self.check_attribute_value(object_uid, lines_list, f'Offset_First{keytype}', ATTR_TYPE_INTEGER, False, -500, 500)
            if YOffset_First_keytype == None : YOffset_First_keytype = self.check_attribute_value(object_uid, lines_list, f'YOffset_First{keytype}', ATTR_TYPE_INTEGER, False, 0, 500)

            if ImageOn_Last_keytype == None : ImageOn_Last_keytype = self.check_attribute_value(object_uid, lines_list, f'ImageOn_Last{keytype}', ATTR_TYPE_FILE_NAME, False)
            if ImageOff_Last_keytype == None : ImageOff_Last_keytype = self.check_attribute_value(object_uid, lines_list, f'ImageOff_Last{keytype}', ATTR_TYPE_FILE_NAME, False)
            if MaskOn_Last_keytype == None : MaskOn_Last_keytype = self.check_attribute_value(object_uid, lines_list, f'MaskOn_Last{keytype}', ATTR_TYPE_FILE_NAME, False)
            if MaskOff_Last_keytype == None : MaskOff_Last_keytype = self.check_attribute_value(object_uid, lines_list, f'MaskOff_Last{keytype}', ATTR_TYPE_FILE_NAME, False)
            if Width_Last_keytype == None : Width_Last_keytype = self.check_attribute_value(object_uid, lines_list, f'Width_Last{keytype}', ATTR_TYPE_INTEGER, False, 0, 500)
            if Offset_Last_keytype == None : Offset_Last_keytype = self.check_attribute_value(object_uid, lines_list, f'Offset_Last{keytype}', ATTR_TYPE_INTEGER, False, -500, 500)
            if YOffset_Last_keytype == None : YOffset_Last_keytype = self.check_attribute_value(object_uid, lines_list, f'YOffset_Last{keytype}', ATTR_TYPE_INTEGER, False, 0, 500)

    #-------------------------------------------------------------------------------------------------
    def check_object_Panel(self, object_uid, lines_list):
        # check the data of a Panel object section which the lines are in the given lines list

        is_additional_panel = not(object_uid in ('Panel000', 'Organ')) # it is an additional panel, in addition to the Panel000 or Organ (old format) panel

        if self.new_panel_format_bool:

            # required attributes (new panel format)
            self.check_attribute_value(object_uid, lines_list, 'Name', ATTR_TYPE_STRING, is_additional_panel)
            self.check_attribute_value(object_uid, lines_list, 'HasPedals', ATTR_TYPE_BOOLEAN, True)

            value = self.check_attribute_value(object_uid, lines_list, 'NumberOfGUIElements', ATTR_TYPE_INTEGER, True, 0, 999)
            if value != None and value.isdigit() and int(value) >= 0:
                count = self.objects_type_number_get(f'{object_uid}Element')
                if count != int(value):
                    logs.add(f"ERROR in {object_uid} : NumberOfGUIElements={value} whereas {count} {object_uid}Element object(s) defined")

            # optional attributes (new panel format)
            self.check_attribute_value(object_uid, lines_list, 'Group', ATTR_TYPE_STRING, False)

            value = self.check_attribute_value(object_uid, lines_list, 'NumberOfImages', ATTR_TYPE_INTEGER, False, 0, 999)
            if value != None and value.isdigit() and int(value) >= 0:
                count = self.objects_type_number_get(f'{object_uid}Image')
                if count != int(value):
                    logs.add(f"ERROR in {object_uid} : NumberOfImages={value} whereas {count} {object_uid}Image object(s) defined")

        elif is_additional_panel:  # additional panel in the old panel format (for the main panel, the non display metrics attributes are defined in the Organ object)

            # required attributes (old panel format, additional panel)
            self.check_attribute_value(object_uid, lines_list, 'Name', ATTR_TYPE_STRING, True)
            self.check_attribute_value(object_uid, lines_list, 'HasPedals', ATTR_TYPE_BOOLEAN, True)

            value = self.check_attribute_value(object_uid, lines_list, 'NumberOfCouplers', ATTR_TYPE_INTEGER, True, 0, 999)
            if value != None and value.isdigit() and int(value) >= 0:
                for idx in range(1, int(value)+1):
                    self.check_attribute_value(object_uid, lines_list, f"Coupler{str(idx).zfill(3)}", ATTR_TYPE_OBJECT_REF, True)
                    self.check_attribute_value(object_uid, lines_list, f"Coupler{str(idx).zfill(3)}Manual", ATTR_TYPE_OBJECT_REF, True)
                count = self.objects_type_number_get(f'{object_uid}Coupler')
                if count != int(value):
                    logs.add(f"ERROR in {object_uid} : NumberOfCouplers={value} whereas {count} {object_uid}Coupler object(s) defined")

            value = self.check_attribute_value(object_uid, lines_list, 'NumberOfDivisionals', ATTR_TYPE_INTEGER, True, 0, 999)
            if value != None and value.isdigit() and int(value) >= 0:
                for idx in range(1, int(value)+1):
                    self.check_attribute_value(object_uid, lines_list, f"Divisional{str(idx).zfill(3)}", ATTR_TYPE_OBJECT_REF, True)
                    self.check_attribute_value(object_uid, lines_list, f"Divisional{str(idx).zfill(3)}Manual", ATTR_TYPE_OBJECT_REF, True)
                count = self.objects_type_number_get(f'{object_uid}Divisional')
                if count != int(value):
                    logs.add(f"ERROR in {object_uid} : NumberOfDivisionals={value} whereas {count} {object_uid}Divisional object(s) defined")

            value = self.check_attribute_value(object_uid, lines_list, 'NumberOfDivisionalCouplers', ATTR_TYPE_INTEGER, True, 0, 8)
            if value != None and value.isdigit() and int(value) >= 0:
                for idx in range(1, int(value)+1):
                    self.check_attribute_value(object_uid, lines_list, f"DivisionalCoupler{str(idx).zfill(3)}", ATTR_TYPE_OBJECT_REF, True)
                count = self.objects_type_number_get(f'{object_uid}DivisionalCoupler')
                if count != int(value):
                    logs.add(f"ERROR in {object_uid} : NumberOfDivisionalCouplers={value} whereas {count} {object_uid}DivisionalCoupler object(s) defined")

            value = self.check_attribute_value(object_uid, lines_list, 'NumberOfEnclosures', ATTR_TYPE_INTEGER, True, 0, 50)
            if value != None and value.isdigit() and int(value) >= 0:
                for idx in range(1, int(value)+1):
                    self.check_attribute_value(object_uid, lines_list, f"Enclosure{str(idx).zfill(3)}", ATTR_TYPE_OBJECT_REF, True)
                count = self.objects_type_number_get(f'{object_uid}Enclosure')
                if count != int(value):
                    logs.add(f"ERROR in {object_uid} : NumberOfEnclosures={value} whereas {count} {object_uid}Enclosure object(s) defined")

            value = self.check_attribute_value(object_uid, lines_list, 'NumberOfGenerals', ATTR_TYPE_INTEGER, True, 0, 99)
            if value != None and value.isdigit() and int(value) >= 0:
                for idx in range(1, int(value)+1):
                    self.check_attribute_value(object_uid, lines_list, f"General{str(idx).zfill(3)}", ATTR_TYPE_OBJECT_REF, True)
                count = self.objects_type_number_get(f'{object_uid}General')
                if count != int(value):
                    logs.add(f"ERROR in {object_uid} : NumberOfGenerals={value} whereas {count} {object_uid}General object(s) defined")

            value = self.check_attribute_value(object_uid, lines_list, 'NumberOfImages', ATTR_TYPE_INTEGER, True, 0, 999)
            if value != None and value.isdigit() and int(value) >= 0:
                count = self.objects_type_number_get(f'{object_uid}Image')
                if count != int(value):
                    logs.add(f"ERROR in {object_uid} : NumberOfImages={value} whereas {count} {object_uid}Image object(s) defined")

            value = self.check_attribute_value(object_uid, lines_list, 'NumberOfLabels', ATTR_TYPE_INTEGER, True, 0, 999)
            if value != None and value.isdigit() and int(value) >= 0:
                count = self.objects_type_number_get(f'{object_uid}Label')
                if count != int(value):
                    logs.add(f"ERROR in {object_uid} : NumberOfLabels={value} whereas {count} {object_uid}Label object(s) defined")

            value = self.check_attribute_value(object_uid, lines_list, 'NumberOfManuals', ATTR_TYPE_INTEGER, True, 0, 16)
            if value != None and value.isdigit() and int(value) >= 0:
                for idx in range(1, int(value)+1):
                    self.check_attribute_value(object_uid, lines_list, f"Manual{str(idx).zfill(3)}", ATTR_TYPE_OBJECT_REF, True)

            value = self.check_attribute_value(object_uid, lines_list, 'NumberOfReversiblePistons', ATTR_TYPE_INTEGER, True, 0, 32)
            if value != None and value.isdigit() and int(value) >= 0:
                for idx in range(1, int(value)+1):
                    self.check_attribute_value(object_uid, lines_list, f"ReversiblePiston{str(idx).zfill(3)}", ATTR_TYPE_OBJECT_REF, True)
                count = self.objects_type_number_get(f'{object_uid}ReversiblePiston')
                if count != int(value):
                    logs.add(f"ERROR in {object_uid} : NumberOfReversiblePistons={value} whereas {count} {object_uid}ReversiblePiston object(s) defined")

            value = self.check_attribute_value(object_uid, lines_list, 'NumberOfStops', ATTR_TYPE_INTEGER, True, 0, 999)
            if value != None and value.isdigit() and int(value) >= 0:
                for idx in range(1, int(value)+1):
                    self.check_attribute_value(object_uid, lines_list, f"Stop{str(idx).zfill(3)}", ATTR_TYPE_OBJECT_REF, True)
                    self.check_attribute_value(object_uid, lines_list, f"Stop{str(idx).zfill(3)}Manual", ATTR_TYPE_OBJECT_REF, True)
                count = self.objects_type_number_get(f'{object_uid}Stop')
                if count != int(value):
                    logs.add(f"ERROR in {object_uid} : NumberOfStops={value} whereas {count} {object_uid}Stop object(s) defined")

            value = self.check_attribute_value(object_uid, lines_list, 'NumberOfTremulants', ATTR_TYPE_INTEGER, True, 0, 10)
            if value != None and value.isdigit() and int(value) >= 0:
                for idx in range(1, int(value)+1):
                    self.check_attribute_value(object_uid, lines_list, f"Tremulant{str(idx).zfill(3)}", ATTR_TYPE_OBJECT_REF, True)
                count = self.objects_type_number_get(f'{object_uid}Tremulant')
                if count != int(value):
                    logs.add(f"ERROR in {object_uid} : NumberOfTremulants={value} whereas {count} {object_uid}Tremulant object(s) defined")

            # optional attributes (old panel format, additional panel)
            self.check_attribute_value(object_uid, lines_list, 'Group', ATTR_TYPE_STRING, False)

            value = self.check_attribute_value(object_uid, lines_list, 'NumberOfSetterElements', ATTR_TYPE_INTEGER, False, 0, 8)
            if value != None and value.isdigit() and int(value) >= 0:
                count = self.objects_type_number_get(f'{object_uid}SetterElement')
                if count != int(value):
                    logs.add(f"ERROR in {object_uid} : NumberOfSetterElements={value} whereas {count} {object_uid}SetterElement object(s) defined")

            value = self.check_attribute_value(object_uid, lines_list, 'NumberOfSwitches', ATTR_TYPE_INTEGER, False, 0, 999)
            if value != None and value.isdigit() and int(value) >= 0:
                for idx in range(1, int(value)+1):
                    self.check_attribute_value(object_uid, lines_list, f"Switch{str(idx).zfill(3)}", ATTR_TYPE_OBJECT_REF, True)
                count = self.objects_type_number_get(f'{object_uid}Switch')
                if count != int(value):
                    logs.add(f"ERROR in {object_uid} : NumberOfSwitches={value} whereas {count} {object_uid}Switch object(s) defined")


        # display metrics (common to old and new panel formats)

        # required attributes (panel display metrics)
        self.check_attribute_value(object_uid, lines_list, 'DispScreenSizeHoriz', ATTR_TYPE_PANEL_SIZE, True)
        self.check_attribute_value(object_uid, lines_list, 'DispScreenSizeVert', ATTR_TYPE_PANEL_SIZE, True)
        self.check_attribute_value(object_uid, lines_list, 'DispDrawstopBackgroundImageNum', ATTR_TYPE_INTEGER, True, 1, 64)
        self.check_attribute_value(object_uid, lines_list, 'DispConsoleBackgroundImageNum', ATTR_TYPE_INTEGER, True, 1, 64)
        self.check_attribute_value(object_uid, lines_list, 'DispKeyHorizBackgroundImageNum', ATTR_TYPE_INTEGER, True, 1, 64)
        self.check_attribute_value(object_uid, lines_list, 'DispKeyVertBackgroundImageNum', ATTR_TYPE_INTEGER, True, 1, 64)
        self.check_attribute_value(object_uid, lines_list, 'DispDrawstopInsetBackgroundImageNum', ATTR_TYPE_INTEGER, True, 1, 64)
        self.check_attribute_value(object_uid, lines_list, 'DispControlLabelFont', ATTR_TYPE_STRING, True)
        self.check_attribute_value(object_uid, lines_list, 'DispShortcutKeyLabelFont', ATTR_TYPE_STRING, True)
        self.check_attribute_value(object_uid, lines_list, 'DispShortcutKeyLabelColour', ATTR_TYPE_COLOR, True)
        self.check_attribute_value(object_uid, lines_list, 'DispGroupLabelFont', ATTR_TYPE_STRING, True)
        self.check_attribute_value(object_uid, lines_list, 'DispDrawstopCols', ATTR_TYPE_INTEGER, True, 2, 12)
        self.check_attribute_value(object_uid, lines_list, 'DispDrawstopRows', ATTR_TYPE_INTEGER, True, 1, 20)
        cols_offset = self.check_attribute_value(object_uid, lines_list, 'DispDrawstopColsOffset', ATTR_TYPE_BOOLEAN, True)
        self.check_attribute_value(object_uid, lines_list, 'DispPairDrawstopCols', ATTR_TYPE_BOOLEAN, True)
        self.check_attribute_value(object_uid, lines_list, 'DispExtraDrawstopRows', ATTR_TYPE_INTEGER, True, 0, 99)
        self.check_attribute_value(object_uid, lines_list, 'DispExtraDrawstopCols', ATTR_TYPE_INTEGER, True, 0, 40)
        self.check_attribute_value(object_uid, lines_list, 'DispButtonCols', ATTR_TYPE_INTEGER, True, 1, 32)
        self.check_attribute_value(object_uid, lines_list, 'DispExtraButtonRows', ATTR_TYPE_INTEGER, True, 0, 99)
        extra_pedal_buttons = self.check_attribute_value(object_uid, lines_list, 'DispExtraPedalButtonRow', ATTR_TYPE_BOOLEAN, True)
        self.check_attribute_value(object_uid, lines_list, 'DispButtonsAboveManuals', ATTR_TYPE_BOOLEAN, True)
        self.check_attribute_value(object_uid, lines_list, 'DispExtraDrawstopRowsAboveExtraButtonRows', ATTR_TYPE_BOOLEAN, True)
        self.check_attribute_value(object_uid, lines_list, 'DispTrimAboveManuals', ATTR_TYPE_BOOLEAN, True)
        self.check_attribute_value(object_uid, lines_list, 'DispTrimBelowManuals', ATTR_TYPE_BOOLEAN, True)
        self.check_attribute_value(object_uid, lines_list, 'DispTrimAboveExtraRows', ATTR_TYPE_BOOLEAN, True)

        # optional attributes (panel display metrics)
        self.check_attribute_value(object_uid, lines_list, 'DispDrawstopWidth', ATTR_TYPE_INTEGER, False, 1, 150)
        self.check_attribute_value(object_uid, lines_list, 'DispDrawstopHeight', ATTR_TYPE_INTEGER, False, 1, 150)
        self.check_attribute_value(object_uid, lines_list, 'DispDrawstopOuterColOffsetUp', ATTR_TYPE_BOOLEAN, True if cols_offset != None and cols_offset == 'Y' else False)
        self.check_attribute_value(object_uid, lines_list, 'DispExtraPedalButtonRowOffset', ATTR_TYPE_BOOLEAN, True if extra_pedal_buttons != None and extra_pedal_buttons == 'Y' else False)
        self.check_attribute_value(object_uid, lines_list, 'DispExtraPedalButtonRowOffsetRight', ATTR_TYPE_BOOLEAN, False)
        self.check_attribute_value(object_uid, lines_list, 'DispPistonWidth', ATTR_TYPE_INTEGER, False, 1, 150)
        self.check_attribute_value(object_uid, lines_list, 'DispPistonHeight', ATTR_TYPE_INTEGER, False, 1, 150)
        self.check_attribute_value(object_uid, lines_list, 'DispEnclosureWidth', ATTR_TYPE_INTEGER, False, 1, 150)
        self.check_attribute_value(object_uid, lines_list, 'DispEnclosureHeight', ATTR_TYPE_INTEGER, False, 1, 150)
        self.check_attribute_value(object_uid, lines_list, 'DispPedalHeight', ATTR_TYPE_INTEGER, False, 1, 500)
        self.check_attribute_value(object_uid, lines_list, 'DispPedalKeyWidth', ATTR_TYPE_INTEGER, False, 1, 500)
        self.check_attribute_value(object_uid, lines_list, 'DispManualHeight', ATTR_TYPE_INTEGER, False, 1, 500)
        self.check_attribute_value(object_uid, lines_list, 'DispManualKeyWidth', ATTR_TYPE_INTEGER, False, 1, 500)

    #-------------------------------------------------------------------------------------------------
    def check_object_PanelElement(self, object_uid, lines_list):
        # check the data of a Panel Element object section which the lines are in the given lines list

        # required attributes
        type = self.check_attribute_value(object_uid, lines_list, 'Type', ATTR_TYPE_ELEMENT_TYPE, True)

        if type == None:
            pass
        elif type == 'Coupler':
            self.check_attribute_value(object_uid, lines_list, 'Manual', ATTR_TYPE_OBJECT_REF, True)
            self.check_attribute_value(object_uid, lines_list, 'Coupler', ATTR_TYPE_OBJECT_REF, True)
            self.check_object_Coupler(object_uid, lines_list)
        elif type == 'Divisional':
            self.check_attribute_value(object_uid, lines_list, 'Manual', ATTR_TYPE_OBJECT_REF, True)
            self.check_attribute_value(object_uid, lines_list, 'Divisional', ATTR_TYPE_OBJECT_REF, True)
            self.check_object_Divisional(object_uid, lines_list)
        elif type == 'DivisionalCoupler':
            self.check_attribute_value(object_uid, lines_list, 'DivisionalCoupler', ATTR_TYPE_OBJECT_REF, True)
            self.check_object_DivisionalCoupler(object_uid, lines_list)
        elif type == 'Enclosure':
            self.check_attribute_value(object_uid, lines_list, 'Enclosure', ATTR_TYPE_OBJECT_REF, True)
            self.check_object_Enclosure(object_uid, lines_list)
        elif type == 'General':
            self.check_attribute_value(object_uid, lines_list, 'General', ATTR_TYPE_OBJECT_REF, True)
            self.check_object_General(object_uid, lines_list)
        elif type == 'Label':
            self.check_object_Label(object_uid, lines_list)
        elif type == 'Manual':
            self.check_attribute_value(object_uid, lines_list, 'Manual', ATTR_TYPE_OBJECT_REF, True)
            self.check_object_Manual(object_uid, lines_list)
        elif type == 'ReversiblePiston':
            self.check_attribute_value(object_uid, lines_list, 'ReversiblePiston', ATTR_TYPE_OBJECT_REF, True)
            self.check_object_ReversiblePiston(object_uid, lines_list)
        elif type == 'Stop':
            self.check_attribute_value(object_uid, lines_list, 'Manual', ATTR_TYPE_OBJECT_REF, True)
            self.check_attribute_value(object_uid, lines_list, 'Stop', ATTR_TYPE_OBJECT_REF, True)
            self.check_object_Stop(object_uid, lines_list)
        elif type == 'Swell':
            self.check_object_Enclosure(object_uid, lines_list)
        elif type == 'Switch':
            self.check_attribute_value(object_uid, lines_list, 'Switch', ATTR_TYPE_OBJECT_REF, True)
            self.check_object_Switch(object_uid, lines_list)
        elif type == 'Tremulant':
            self.check_attribute_value(object_uid, lines_list, 'Tremulant', ATTR_TYPE_OBJECT_REF, True)
            self.check_object_Tremulant(object_uid, lines_list)
        else:
            self.check_object_SetterElement(object_uid, lines_list, type)

    #-------------------------------------------------------------------------------------------------
    def check_object_PanelOther(self, object_uid, lines_list):
        # check the data of an other kind of Panel object section (Panel999Coupler999, Panel999Divisional999, ...) which the lines are in the given lines list

        # get the panel elemnt type from the object UID (for example Coupler from Panel999Coupler999)
        panel_element_type = object_uid[8:-3]

        # check the attributes of the object depending on the object type
        if panel_element_type == 'Coupler':
            self.check_object_Coupler(object_uid, lines_list)
        elif panel_element_type == 'Divisional':
            self.check_object_Divisional(object_uid, lines_list)
        elif panel_element_type == 'DivisionalCoupler':
            self.check_object_DivisionalCoupler(object_uid, lines_list)
        elif panel_element_type == 'Enclosure':
            self.check_object_Enclosure(object_uid, lines_list)
        elif panel_element_type == 'General':
            self.check_object_General(object_uid, lines_list)
        elif panel_element_type == 'Image':
            self.check_object_Image(object_uid, lines_list)
        elif panel_element_type == 'Label':
            self.check_object_Label(object_uid, lines_list)
        elif panel_element_type == 'ReversiblePiston':
            self.check_object_ReversiblePiston(object_uid, lines_list)
        elif panel_element_type == 'SetterElement':
            self.check_object_SetterElement(object_uid, lines_list)
        elif panel_element_type == 'Stop':
            self.check_object_Stop(object_uid, lines_list)
        elif panel_element_type == 'Switch':
            self.check_object_Switch(object_uid, lines_list)
        elif panel_element_type == 'Tremulant':
            self.check_object_Tremulant(object_uid, lines_list)

    #-------------------------------------------------------------------------------------------------
    def check_object_Piston(self, object_uid, lines_list):
        # check the data of a Piston object section which the lines are in the given lines list

        # required attributes
        value = self.check_attribute_value(object_uid, lines_list, 'ObjectType', ATTR_TYPE_PISTON_TYPE, True)
        self.check_attribute_value(object_uid, lines_list, 'ManualNumber', ATTR_TYPE_OBJECT_REF, value in ('STOP', 'COUPLER'))
        self.check_attribute_value(object_uid, lines_list, 'ObjectNumber', ATTR_TYPE_INTEGER, False, 1, 200)

        # a Piston has also the attributes of a Push Button
        self.check_object_PushButton(object_uid, lines_list)

    #-------------------------------------------------------------------------------------------------
    def check_object_PushButton(self, object_uid, lines_list):
        # check the data of a Push Button object section which the lines are in the given lines list

        # a Push Button has only the attributes of a Button
        self.check_object_Button(object_uid, lines_list)

    #-------------------------------------------------------------------------------------------------
    def check_object_Rank(self, object_uid, lines_list):
        # check the data of a Rank object section which the lines are in the given lines list

        is_rank_obj = (self.object_type_get(object_uid) == 'Rank') # some mandatory attributes are not mandatory for objects which inherit the Rank attributes (like Stop)

        # required attributes
        self.check_attribute_value(object_uid, lines_list, 'Name', ATTR_TYPE_STRING, True)
        self.check_attribute_value(object_uid, lines_list, 'FirstMidiNoteNumber', ATTR_TYPE_INTEGER, is_rank_obj, 0, 256)
        self.check_attribute_value(object_uid, lines_list, 'WindchestGroup', ATTR_TYPE_OBJECT_REF, True)
        self.check_attribute_value(object_uid, lines_list, 'Percussive', ATTR_TYPE_BOOLEAN, True)

        # optional attributes
        self.check_attribute_value(object_uid, lines_list, 'AmplitudeLevel', ATTR_TYPE_FLOAT, False, 0, 1000)
        self.check_attribute_value(object_uid, lines_list, 'Gain', ATTR_TYPE_FLOAT, False, -120, 40)
        self.check_attribute_value(object_uid, lines_list, 'PitchTuning', ATTR_TYPE_FLOAT, False, -1200, 1200)
        self.check_attribute_value(object_uid, lines_list, 'TrackerDelay', ATTR_TYPE_INTEGER, False, 0, 10000)
        self.check_attribute_value(object_uid, lines_list, 'HarmonicNumber', ATTR_TYPE_FLOAT, False, 1, 1024)
        self.check_attribute_value(object_uid, lines_list, 'PitchCorrection', ATTR_TYPE_FLOAT, False, -1200, 1200)
        self.check_attribute_value(object_uid, lines_list, 'MinVelocityVolume', ATTR_TYPE_FLOAT, False, 0, 1000)
        self.check_attribute_value(object_uid, lines_list, 'MaxVelocityVolume', ATTR_TYPE_FLOAT, False, 0, 1000)
        self.check_attribute_value(object_uid, lines_list, 'AcceptsRetuning', ATTR_TYPE_BOOLEAN, False)

        value = self.check_attribute_value(object_uid, lines_list, 'NumberOfLogicalPipes', ATTR_TYPE_INTEGER, is_rank_obj, 1, 192)
        if value != None and value.isdigit():
            for idx in range(1, int(value)+1):  # Pipe999xxx attributes
                self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}', ATTR_TYPE_PIPE_WAVE, True)
                self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}Percussive', ATTR_TYPE_BOOLEAN, False)
                self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}AmplitudeLevel', ATTR_TYPE_FLOAT, False, 0, 1000)
                self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}Gain', ATTR_TYPE_FLOAT, False, -120, 40)
                self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}PitchTuning', ATTR_TYPE_FLOAT, False, -1200, 1200)
                self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}TrackerDelay', ATTR_TYPE_FLOAT, False, 0, 10000)
                self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}LoadRelease', ATTR_TYPE_BOOLEAN, False)
                self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}AttackVelocity', ATTR_TYPE_INTEGER, False, 0, 127)
                self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}MaxTimeSinceLastRelease', ATTR_TYPE_INTEGER, False, -1, 100000)
                self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}IsTremulant', ATTR_TYPE_INTEGER, False, -1, 1)
                self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}MaxKeyPressTime', ATTR_TYPE_INTEGER, False, -1, 100000)
                self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}AttackStart', ATTR_TYPE_INTEGER, False, 0, 158760000)
                self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}CuePoint', ATTR_TYPE_INTEGER, False, -1, 158760000)
                self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}ReleaseEnd', ATTR_TYPE_INTEGER, False, -1, 158760000)
                self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}HarmonicNumber', ATTR_TYPE_FLOAT, False, 1, 1024)
                self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}MIDIKeyNumber', ATTR_TYPE_INTEGER, False, -1, 127)
                self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}PitchCorrection', ATTR_TYPE_FLOAT, False, -1200, 1200)
                self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}AcceptsRetuning', ATTR_TYPE_BOOLEAN, False)
                self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}WindchestGroup', ATTR_TYPE_OBJECT_REF, False)
                self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}MinVelocityVolume', ATTR_TYPE_FLOAT, False, 0, 1000)
                self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}MaxVelocityVolume', ATTR_TYPE_FLOAT, False, 0, 1000)

                ret1 = self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}LoopCount', ATTR_TYPE_INTEGER, False, 1, 100)
                if ret1 != None and ret1.isdigit():
                    for idx1 in range(1, int(ret1)+1):  # Pipe999Loop999xxx attributes
                        value = self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}Loop{str(idx1).zfill(3)}Start', ATTR_TYPE_INTEGER, False, 0, 158760000)
                        loop_start = int(value) if value.isdigit() else 1
                        self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}Loop{str(idx1).zfill(3)}End', ATTR_TYPE_INTEGER, False, loop_start + 1, 158760000)

                ret1 = self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}AttackCount', ATTR_TYPE_INTEGER, False, 1, 100)
                if ret1 != None and ret1.isdigit():
                    for idx1 in range(1, int(ret1)+1):  # Pipe999Attack999xxx attributes
                        self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}Attack{str(idx1).zfill(3)}', ATTR_TYPE_FILE_NAME, True)
                        self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}Attack{str(idx1).zfill(3)}LoadRelease', ATTR_TYPE_BOOLEAN, False)
                        self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}Attack{str(idx1).zfill(3)}AttackVelocity', ATTR_TYPE_INTEGER, False, 0, 127)
                        self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}Attack{str(idx1).zfill(3)}MaxTimeSinceLastRelease', ATTR_TYPE_INTEGER, False, -1, 100000)
                        self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}Attack{str(idx1).zfill(3)}IsTremulant', ATTR_TYPE_INTEGER, False, -1, 1)
                        self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}Attack{str(idx1).zfill(3)}MaxKeyPressTime', ATTR_TYPE_INTEGER, False, -1, 100000)
                        self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}Attack{str(idx1).zfill(3)}AttackStart', ATTR_TYPE_INTEGER, False, 0, 158760000)
                        self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}Attack{str(idx1).zfill(3)}CuePoint', ATTR_TYPE_INTEGER, False, -1, 158760000)
                        self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}Attack{str(idx1).zfill(3)}ReleaseEnd', ATTR_TYPE_INTEGER, False, -1, 158760000)

                        ret2 = self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}Attack{str(idx1).zfill(3)}LoopCount', ATTR_TYPE_INTEGER, False, 1, 100)
                        if ret2 != None and ret2.isdigit():
                            for idx2 in range(1, int(ret2)+1):  # Pipe999Attack999Loop999xxx attributes
                                value = self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}Attack{str(idx1).zfill(3)}Loop{str(idx2).zfill(3)}Start', ATTR_TYPE_INTEGER, True, 0, 158760000)
                                loop_start = int(value) if value != None and value.isdigit() else 1
                                self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}Attack{str(idx1).zfill(3)}Loop{str(idx2).zfill(3)}End', ATTR_TYPE_INTEGER, True, loop_start + 1, 158760000)

                ret1 = self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}ReleaseCount', ATTR_TYPE_INTEGER, False, 1, 100)
                if ret1 != None and ret1.isdigit():
                    for idx1 in range(1, int(ret1)+1):  # Pipe999Release999xxx attributes
                        self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}Release{str(idx1).zfill(3)}', ATTR_TYPE_FILE_NAME, True)
                        self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}Release{str(idx1).zfill(3)}IsTremulant', ATTR_TYPE_INTEGER, False, -1, 1)
                        self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}Release{str(idx1).zfill(3)}MaxKeyPressTime', ATTR_TYPE_INTEGER, False, -1, 100000)
                        self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}Release{str(idx1).zfill(3)}CuePoint', ATTR_TYPE_INTEGER, False, -1, 158760000)
                        self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}Release{str(idx1).zfill(3)}ReleaseEnd', ATTR_TYPE_INTEGER, False, -1, 158760000)

                self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}LoopCrossfadeLength', ATTR_TYPE_INTEGER, False, 0, 3000)
                self.check_attribute_value(object_uid, lines_list, f'Pipe{str(idx).zfill(3)}ReleaseCrossfadeLength', ATTR_TYPE_INTEGER, False, 0, 3000)

    #-------------------------------------------------------------------------------------------------
    def check_object_ReversiblePiston(self, object_uid, lines_list):
        # check the data of a Reversible Piston object section which the lines are in the given lines list

        # unkown expected attributes...
        pass

     #-------------------------------------------------------------------------------------------------
    def check_object_SetterElement(self, object_uid, lines_list, type = None):
        # check the data of a Setter Element object section which the lines are in the given lines list

        # required attributes
        if type == None:
            # type not provided by the caller, recover it from the object lines list
            type = self.check_attribute_value(object_uid, lines_list, 'Type', ATTR_TYPE_ELEMENT_TYPE, True)

        if type == None:
            pass
        elif type == 'CrescendoLabel':
            self.check_object_Label(object_uid, lines_list)
        elif type in ('CrescendoA', 'CrescendoB', 'CrescendoC', 'CrescendoD'):
            self.check_object_Button(object_uid, lines_list)
        elif type in ('CrescendoPrev', 'CrescendoNext', 'CrescendoCurrent'):
            self.check_object_Button(object_uid, lines_list)
        elif type in ('Current', 'Full', 'GC'):
            self.check_object_Button(object_uid, lines_list)
        elif type[:7] == "General" and len(type) == 9 and type[7:9].isdigit() and int(type[7:9]) in range(1, 51):
            self.check_object_Button(object_uid, lines_list)
        elif type == 'GeneralLabel':
            self.check_object_Label(object_uid, lines_list)
        elif type in ('GeneralPrev', 'GeneralNext', 'Home', 'Insert', 'Delete'):
            self.check_object_Button(object_uid, lines_list)
        elif type[:1] == "L" and len(type) == 2 and type[1:2].isdigit() and int(type[1:2]) in range(0, 10):
            self.check_object_Button(object_uid, lines_list)
        elif type in ('M100', 'M10', 'M1', 'P1', 'P10', 'P100'):
            self.check_object_Button(object_uid, lines_list)
        elif type == 'PitchLabel':
            self.check_object_Label(object_uid, lines_list)
        elif type in ('PitchM100', 'PitchM10', 'PitchM1', 'PitchP1', 'PitchP10', 'PitchP100'):
            self.check_object_Button(object_uid, lines_list)
        elif type in ('Prev', 'Next', 'Set'):
            self.check_object_Button(object_uid, lines_list)
        elif type in ('Regular', 'Scope', 'Scoped', 'Save'):
            self.check_object_Button(object_uid, lines_list)
        elif type in ('SequencerLabel', 'TemperamentLabel'):
            self.check_object_Label(object_uid, lines_list)
        elif type in ('TemperamentPrev', 'TemperamentNext'):
            self.check_object_Button(object_uid, lines_list)
        elif type in ('TransposeDown', 'TransposeUp'):
            self.check_object_Button(object_uid, lines_list)
        elif type == 'TransposeLabel':
            self.check_object_Label(object_uid, lines_list)

    #-------------------------------------------------------------------------------------------------
    def check_object_Stop(self, object_uid, lines_list):
        # check the data of a Stop object section which the lines are in the given lines list

        is_stop_obj = (self.object_type_get(object_uid) == 'Stop') # some mandatory attributes are not mandatory for objects which inherit the Stop attributes

        # optional attribute
        value = self.check_attribute_value(object_uid, lines_list, 'NumberOfRanks', ATTR_TYPE_INTEGER, False, 0, 999)
        if value == None or (value != None and not value.isdigit()):
            # number of ranks not defined or not a number
            nb_ranks = 0
        else:
            nb_ranks = int(value)

        # required attributes
        self.check_attribute_value(object_uid, lines_list, 'FirstAccessiblePipeLogicalKeyNumber', ATTR_TYPE_INTEGER, is_stop_obj, 1, 128)
        self.check_attribute_value(object_uid, lines_list, 'FirstAccessiblePipeLogicalPipeNumber', ATTR_TYPE_INTEGER, nb_ranks == 0, 1, 192)

        value = self.check_attribute_value(object_uid, lines_list, 'NumberOfAccessiblePipes', ATTR_TYPE_INTEGER, True, 1, 192)
        nb_pipes = int(value) if value != None and value.isdigit() else 192

        # optional attributes
        if nb_ranks > 0:
            for idx in range(1, nb_ranks+1):
                self.check_attribute_value(object_uid, lines_list, f'Rank{str(idx).zfill(3)}', ATTR_TYPE_OBJECT_REF, True)
                self.check_attribute_value(object_uid, lines_list, f'Rank{str(idx).zfill(3)}FirstPipeNumber', ATTR_TYPE_INTEGER, False, 1, nb_pipes)
                self.check_attribute_value(object_uid, lines_list, f'Rank{str(idx).zfill(3)}PipeCount', ATTR_TYPE_INTEGER, False, 0, nb_pipes)
                self.check_attribute_value(object_uid, lines_list, f'Rank{str(idx).zfill(3)}FirstAccessibleKeyNumber', ATTR_TYPE_INTEGER, False, 1, nb_pipes)
        elif nb_ranks == 0:
            # number of ranks set at 0, the Stop must contain rank attributes
            self.check_object_Rank(object_uid, lines_list)

        # a Stop has also the attributes of a Drawstop
        self.check_object_DrawStop(object_uid, lines_list)

    #-------------------------------------------------------------------------------------------------
    def check_object_Switch(self, object_uid, lines_list):
        # check the data of a Switch object section which the lines are in the given lines list

        # a Switch has only the attributes of a Drawstop
        self.check_object_DrawStop(object_uid, lines_list)

    #-------------------------------------------------------------------------------------------------
    def check_object_Tremulant(self, object_uid, lines_list):
        # check the data of a Tremulant object section which the lines are in the given lines list

        # optional attributes
        value = self.check_attribute_value(object_uid, lines_list, 'TremulantType', ATTR_TYPE_TREMULANT_TYPE, False)
        is_synth = (value == 'Synth')
        self.check_attribute_value(object_uid, lines_list, 'Period', ATTR_TYPE_INTEGER, is_synth, 32, 44100)
        self.check_attribute_value(object_uid, lines_list, 'StartRate', ATTR_TYPE_INTEGER, is_synth, 1, 100)
        self.check_attribute_value(object_uid, lines_list, 'StopRate', ATTR_TYPE_INTEGER, is_synth, 1, 100)
        self.check_attribute_value(object_uid, lines_list, 'AmpModDepth', ATTR_TYPE_INTEGER, is_synth, 1, 100)

        # a Tremulant has also the attributes of a Drawstop
        self.check_object_DrawStop(object_uid, lines_list)

    #-------------------------------------------------------------------------------------------------
    def check_object_WindchestGroup(self, object_uid, lines_list):
        # check the data of a WindChest Group object section which the lines are in the given lines list

        # required attributes
        max = self.objects_type_number_get('Enclosure')
        value = self.check_attribute_value(object_uid, lines_list, 'NumberOfEnclosures', ATTR_TYPE_INTEGER, True, 0, max)
        if value != None and value.isdigit():
            for idx in range(1, int(value)+1):
                self.check_attribute_value(object_uid, lines_list, f'Enclosure{str(idx).zfill(3)}', ATTR_TYPE_OBJECT_REF, True)

        max = self.objects_type_number_get('Tremulant')
        value = self.check_attribute_value(object_uid, lines_list, 'NumberOfTremulants', ATTR_TYPE_INTEGER, True, 0, max)
        if value != None and value.isdigit():
            for idx in range(1, int(value)+1):
                self.check_attribute_value(object_uid, lines_list, f'Tremulant{str(idx).zfill(3)}', ATTR_TYPE_OBJECT_REF, True)

        # optional attributes
        self.check_attribute_value(object_uid, lines_list, 'Name', ATTR_TYPE_STRING, False)

    #-------------------------------------------------------------------------------------------------
    def check_attribute_value(self, object_uid, lines_list, attribute_name, attribute_value_type, required_attribute_bool, attribute_value_min=0, attribute_value_max=0):
        # check if the given attribute name is present in the given object lines list (sorted)
        # and if its value is correct for its value type and min/max values
        # the min and max values are ignored if max <= min. The given lines list is considered to be sorted
        # returns the value of the attribute if it has been found and without error, else return None

        # check that the given max value is higher or equal to the min value (this should never happen)
        if attribute_value_max < attribute_value_max:
            logs.add(f"INTERNAL ERROR check_attribute_value called with max < min for {object_uid} / {attribute_name} : min={attribute_value_min}, max={attribute_value_max}")
            return None

        # search in the given lines list the line with the attribute to check
        attr_value = None
        line = None
        for i, line in enumerate(lines_list):
            if line[:len(attribute_name)] > attribute_name:
                # the given lines list being sorted, exit the loop if the current line starts by a string higher than the one of the attribute name
                break
            if line.startswith(attribute_name + '='):
                # line found
                (error_msg, attr_name, attr_value, comment) = self.object_line_split(line)
                if error_msg != None:
                    logs.add(f'ERROR in {object_uid} section, line "{line}" : {error_msg}')
                if attr_name != None and attr_value != None:
                    # the current line contains the attribute to check
                    self.checked_attr_nb += 1
                     # remove the line of the found attribute, to know at the end of the object check which of its attributes have not been checked
                    lines_list.pop(i)
                    break

        if attr_value != None:
            # the attribute has been found

            # check the attribute value according to the given type

            if attribute_value_type == ATTR_TYPE_INTEGER:
                if (not attr_value.lstrip("-+").isdigit() or
                    ((int(attr_value) < attribute_value_min or int(attr_value) > attribute_value_max))):
                    logs.add(f"ERROR in {object_uid} {line} : the assigned value must be an integer in the range [{attribute_value_min} - {attribute_value_max}]")

            elif attribute_value_type == ATTR_TYPE_FLOAT:
                if (not(attr_value.lstrip("-+").replace('.', '', 1).isdigit()) or
                    ((float(attr_value) < attribute_value_min or float(attr_value) > attribute_value_max))):
                    logs.add(f"ERROR in {object_uid} {line} : the assigned value must be an integer or decimal in the range [{attribute_value_min} - {attribute_value_max}]")
                    attr_value = ''

            elif attribute_value_type == ATTR_TYPE_BOOLEAN:
                if attr_value.upper() not in ('Y', 'N'):
                    logs.add(f"ERROR in {object_uid} {line} : the assigned value must be Y or N (boolean attribute)")
                    attr_value = ''

            elif attribute_value_type == ATTR_TYPE_STRING:
                pass # nothing to check in case of string value

            elif attribute_value_type == ATTR_TYPE_COLOR:
                if (not(attr_value.upper() in ('BLACK', 'BLUE', 'DARK BLUE', 'GREEN', 'DARK GREEN', 'CYAN', 'DARK CYAN', 'RED', 'DARK RED',
                                               'MAGENTA', 'DARK MAGENTA', 'YELLOW', 'DARK YELLOW', 'LIGHT GREY', 'DARK GREY', 'WHITE', 'BROWN')) and
                    not(len(attr_value) == 7 and attr_value[0] == '#' and attr_value[1:].isalnum())):  # check of the HTML format #RRGGBB
                    logs.add(f"ERROR in {object_uid} {line} : the assigned value is not a valid color (look at the help)")
                    attr_value = ''

            elif attribute_value_type == ATTR_TYPE_FONT_SIZE:
                if (not(attr_value.upper() in ('SMALL', 'NORMAL', 'LARGE')) and
                    not(attr_value.isdigit() and int(attr_value) >= 1 and int(attr_value) <= 50)):
                    logs.add(f"ERROR in {object_uid} {line} : the assigned value is not a valid font size (look at the help)")
                    attr_value = ''

            elif attribute_value_type == ATTR_TYPE_PANEL_SIZE:
                if (not(attr_value.upper() in ('SMALL', 'MEDIUM', 'MEDIUM LARGE', 'LARGE')) and
                    not(attr_value.isdigit() and int(attr_value) >= 100 and int(attr_value) <= 4000)):
                    logs.add(f"ERROR in {object_uid} {line} : the assigned value is not a valid panel size (look at the help)")
                    attr_value = ''

            elif attribute_value_type == ATTR_TYPE_OBJECT_REF:  # for example Switch002=12 or ManualNumber=2 or Stop003Manual=2 or Pipe015WindchestGroup=1
                if attribute_name[-3:].isdigit():
                    attribute_name = attribute_name[:-3]   # remove the three digits at the end of the attribute name to get the object name

                if attribute_name[-6:] == 'Number':
                    attribute_name = attribute_name[:-6]   # remove the 'Number' string at the end, used in General and Piston objects
                elif attribute_name[-6:] == 'Manual':
                    attribute_name = 'Manual'         # keep only the 'Manual' string, used in General object
                elif attribute_name[-14:] == 'WindchestGroup':
                    attribute_name = 'WindchestGroup' # keep only the 'WindchestGroup' string, used in Rank object

                attr_value = attr_value.lstrip("+-") # remove possible + or - at the beginning of the value, used in General or Divisional objects

                if not(attribute_name + attr_value.zfill(3)) in self.odf_data_dic:
                    logs.add(f"ERROR in {object_uid} {line} : the object {attribute_name + attr_value.zfill(3)} does not exist")
                    attr_value = ''

            elif attribute_value_type == ATTR_TYPE_ELEMENT_TYPE:
                if (not(attr_value in ('Coupler', 'Divisional', 'DivisionalCoupler', 'Enclosure', 'General', 'Label', 'Manual', 'ReversiblePiston', 'Stop', 'Swell',
                                      'Switch', 'Tremulant', 'CrescendoA', 'CrescendoB', 'CrescendoC', 'CrescendoD', 'CrescendoPrev', 'CrescendoNext', 'CrescendoCurrent',
                                      'Current', 'Full', 'GC', 'GeneralLabel', 'GeneralPrev', 'GeneralNext', 'Home', 'Insert', 'Delete', 'M100', 'M10', 'M1', 'P1', 'P10', 'P100',
                                      'PitchLabel', 'PitchP1', 'PitchP10', 'PitchP100', 'PitchM1', 'PitchM10', 'PitchM100', 'Prev', 'Next', 'Set', 'Regular', 'Scope', 'Scoped',
                                      'Save', 'SequencerLabel', 'TemperamentLabel', 'TemperamentPrev', 'TemperamentNext', 'TransposeDown', 'TransposeUp', 'TransposeLabel')) and
                    not(attr_value[0] == 'L' and attr_value[1].isdigit() and int(attr_value[1]) in range(0, 10)) and
                    not(attr_value[:14] == 'CrescendoLabel' and attr_value[14:].isdigit() and int(attr_value[14:]) in range(1, 33)) and
                    not(attr_value[:7] == 'General' and attr_value[7:].isdigit() and int(attr_value[7:]) in range(1, 51))):
                    logs.add(f"ERROR in {object_uid} {line} : the assigned value is not a valid panel element type (look at the help)")
                    attr_value = ''
                pass

            elif attribute_value_type == ATTR_TYPE_COUPLER_TYPE:
                if not(attr_value.upper() in ('NORMAL', 'BASS', 'MELODY')):
                    logs.add(f"ERROR in {object_uid} {line} : the assigned value is not a valid coupler type (look at the help)")
                    attr_value = ''

            elif attribute_value_type == ATTR_TYPE_TREMULANT_TYPE:
                if not(attr_value.upper() in ('SYNTH', 'WAVE')):
                    logs.add(f"ERROR in {object_uid} {line} : the assigned value is not a valid tremulant type (look at the help)")
                    attr_value = ''

            elif attribute_value_type == ATTR_TYPE_PISTON_TYPE:
                if not(attr_value.upper() in ('STOP', 'COUPLER', 'SWITCH', 'TREMULANT')):
                    logs.add(f"ERROR in {object_uid} {line} : the assigned value is not a valid piston type (look at the help)")
                    attr_value = ''

            elif attribute_value_type == ATTR_TYPE_DRAWSTOP_FCT:
                if not(attr_value in ('Input', 'Not', 'And', 'Xor', 'Nand', 'Nor', 'Or')):
                    logs.add(f"ERROR in {object_uid} {line} : the assigned value is not a valid drawstop function (look at the help)")
                    attr_value = ''

            elif attribute_value_type == ATTR_TYPE_FILE_NAME:
                if self.check_files_names_bool and not os.path.isfile(os.path.dirname(self.odf_file_name) + os.sep + path2ospath(attr_value)):
                    logs.add(f"ERROR in {object_uid} {line} : file does not exist")
                    attr_value = ''

            elif attribute_value_type == ATTR_TYPE_PIPE_WAVE and self.check_files_names_bool :
                if attr_value.upper()[-4:] == '.WAV':
                    if self.check_files_names_bool and not os.path.isfile(os.path.dirname(self.odf_file_name) + os.sep + path2ospath(attr_value)):
                        logs.add(f"ERROR in {object_uid} {line} : file not found")
                        attr_value = ''
                elif attr_value[:4] == 'REF:':  # for example REF:001:005:007
                    if not (attr_value[5:7].isdigit and attr_value[7] == ':' and
                            attr_value[8:11].isdigit and attr_value[11] == ':' and
                            attr_value[12:15].isdigit and len(attr_value) == 15):
                        logs.add(f"ERROR in {object_uid} {line} : wrong pipe referencing, expected REF:999:999:999")
                        attr_value = ''
                elif attr_value != 'EMPTY':
                    logs.add(f"ERROR in {object_uid} {line} : wrong pipe definition")
                    attr_value = ''

        elif required_attribute_bool:
            # the attribute has not been found and it is required
            logs.add(f"ERROR in {object_uid} : the attribute {attribute_name} is expected, it is missing or misspelled")

        return attr_value

    #-------------------------------------------------------------------------------------------------
    def check_attributes_unicity(self, object_uid, lines_list):
        # check in the given object lines list if each attribute is unique

        # copy the attributes names of the given lines list in an attributes list
        attributes_list = []
        for line in lines_list:
            pos = line.find('=', 1)
            if pos != -1 and line[0] != ';':
                # line with an attribute
                attributes_list.append(line[:pos])

        # sort the attributes list
        attributes_list.sort()

        # check if there are consecutive names in the sorted list
        for i in range(0, len(attributes_list) - 1):
            if attributes_list[i] == attributes_list[i+1]:
                logs.add(f"ERROR in {object_uid} : the attribute {attributes_list[i]} is defined more than once")

#-------------------------------------------------------------------------------------------------
class C_ODF_MISC:
    # class containing miscellaneous functions to manage data of GO ODF objects

    def compass_extend_manual(self, manual_uid, midi_note_ext):
        # extends the compass of the given manual of the ODF up to the given MIDI note included

        manual_dic = self.object_dic_get(manual_uid)
        if manual_dic == None:
            # the given manual UID does not exist
            logs.add(f'ERROR : section {manual_uid} does not exist')
            return

        # get the current compass attributes of the given manual and check if they are actually defined
        manual_first_access_key_nb = myint(self.object_attr_value_get(manual_dic, 'FirstAccessibleKeyLogicalKeyNumber'))
        if manual_first_access_key_nb == None:
            logs.add(f'ERROR : attribute FirstAccessibleKeyLogicalKeyNumber is not defined in {manual_uid}')
            return

        manual_first_access_key_midi_note = myint(self.object_attr_value_get(manual_dic, 'FirstAccessibleKeyMIDINoteNumber'))
        if manual_first_access_key_midi_note == None:
            logs.add(f'ERROR : attribute FirstAccessibleKeyMIDINoteNumber is not defined in {manual_uid}')
            return

        manual_access_keys_nb = myint(self.object_attr_value_get(manual_dic, 'NumberOfAccessibleKeys'))
        if manual_access_keys_nb == None:
            logs.add(f'ERROR : attribute NumberOfAccessibleKeys is not defined in {manual_uid}')
            return

        manual_last_access_key_midi_note = manual_first_access_key_midi_note + manual_access_keys_nb - 1

        manual_logical_keys_nb = myint(self.object_attr_value_get(manual_dic, 'NumberOfLogicalKeys'))
        if manual_logical_keys_nb == None:
            logs.add(f'ERROR : attribute NumberOfLogicalKeys is not defined in {manual_uid}')
            return

        # set the new compass of the manual
        if midi_note_ext < manual_first_access_key_midi_note:
            # extension below the current compass
            new_manual_first_access_key_midi_note = midi_note_ext
            new_manual_last_access_key_midi_note = manual_last_access_key_midi_note

            manual_first_access_key_nb_shift = new_manual_first_access_key_midi_note - manual_first_access_key_midi_note
            new_manual_first_access_key_nb = min(1, manual_first_access_key_nb + manual_first_access_key_nb_shift)
            new_manual_access_keys_nb = manual_access_keys_nb - manual_first_access_key_nb_shift
            extention_side = 'below'
        elif midi_note_ext > manual_last_access_key_midi_note:
            # extension above the current compass
            new_manual_first_access_key_midi_note = manual_first_access_key_midi_note
            new_manual_last_access_key_midi_note = midi_note_ext

            manual_first_access_key_nb_shift = 0
            new_manual_first_access_key_nb = manual_first_access_key_nb
            new_manual_access_keys_nb = manual_access_keys_nb + new_manual_last_access_key_midi_note - manual_last_access_key_midi_note
            extention_side = 'above'
        else:
            # no extension to do, the given MIDI note is inside the current compass of the manual
            logs.add(f'no compass extension to do in {manual_uid}, MIDI note {midi_note_ext} is inside its current compass {manual_first_access_key_midi_note} -> {manual_last_access_key_midi_note}')
            return

        new_manual_logical_keys_nb = max(manual_logical_keys_nb, new_manual_first_access_key_nb + new_manual_access_keys_nb - 1)

        for stop_uid in self.object_kinship_list_get(manual_uid, TO_CHILD, 'Stop'):
            # scan the stops belonging to the manual

            if (self.object_attr_value_get(stop_uid, 'AcceptsRetuning') == 'N' or
                self.object_attr_value_get(stop_uid, 'NumberOfLogicalPipes') == '1'):
                # it is a stop corresponding to noise samples, no need to extend it
                logs.add(f'{stop_uid} is skipped, it contains noise sample')
            else:
                # recover the current MIDI notes compass of the stop
                stop_first_access_pipe_key_nb = myint(self.object_attr_value_get(stop_uid, 'FirstAccessiblePipeLogicalKeyNumber'))
                if stop_first_access_pipe_key_nb == None:
                    logs.add(f'ERROR : attribute FirstAccessiblePipeLogicalKeyNumber is not defined in {stop_uid}')
                    return
                stop_access_pipes_nb = myint(self.object_attr_value_get(stop_uid, 'NumberOfAccessiblePipes'))
                if stop_access_pipes_nb == None:
                    logs.add(f'ERROR : attribute NumberOfAccessiblePipes is not defined in {stop_uid}')
                    return
                stop_first_midi_note_nb = manual_first_access_key_midi_note + stop_first_access_pipe_key_nb - 1
                stop_last_midi_note_nb = stop_first_midi_note_nb + stop_access_pipes_nb - 1

                # set the new compass of the stop
                if midi_note_ext < stop_first_midi_note_nb:
                    # extension below the current compass
                    new_manual_first_access_key_midi_note = midi_note_ext
                    new_manual_last_access_key_midi_note = manual_last_access_key_midi_note

                    manual_first_access_key_nb_shift = new_manual_first_access_key_midi_note - manual_first_access_key_midi_note
                    new_manual_first_access_key_nb = min(1, manual_first_access_key_nb + manual_first_access_key_nb_shift)
                    new_manual_access_keys_nb = manual_access_keys_nb - manual_first_access_key_nb_shift
                    extention_side = 'below'
                elif midi_note_ext > stop_last_midi_note_nb:
                    # extension above the current compass
                    new_manual_first_access_key_midi_note = manual_first_access_key_midi_note
                    new_manual_last_access_key_midi_note = midi_note_ext

                    manual_first_access_key_nb_shift = 0
                    new_manual_first_access_key_nb = manual_first_access_key_nb
                    new_manual_access_keys_nb = manual_access_keys_nb + new_manual_last_access_key_midi_note - manual_last_access_key_midi_note
                    extention_side = 'above'
                else:
                    # no extension to do, the given MIDI note is inside the current compass of the manual
                    pass

                if ((extention_side == 'below' and stop_first_midi_note_nb == manual_first_access_key_midi_note) or
                    (extention_side == 'above' and stop_last_midi_note_nb == manual_last_access_key_midi_note)):
                    # the stop is covering the first or last MIDI note of the manual (whether the extension has to be done respectively below or above the manual compass)
                    # it has to be extended

                    if self.object_attr_value_get(stop_uid, 'WindchestGroup') != None:
                        # the current stop contains rank attributes inside it

                        stop_first_access_pipe_nb = myint(self.object_attr_value_get(stop_uid, 'FirstAccessiblePipeLogicalPipeNumber'), 1)
                        if stop_first_access_pipe_nb == None:
                            logs.add(f'ERROR : attribute FirstAccessiblePipeLogicalPipeNumber is not defined in {stop_uid}')
                            return

                        # extend the rank of the stop
                        self.compass_extend_rank(stop_uid, midi_note_ext, manual_first_access_key_midi_note + stop_first_access_pipe_nb - 1)
                        if compass != None:
                            # the extension has been done
                            new_manual_first_key_midi_note = min(new_manual_first_key_midi_note, compass[0])
                            new_manual_last_key_midi_note = max(new_manual_last_key_midi_note, compass[1])

                            # update the attributes of the stop to reflect the extension

#++++++++++++++++++++
                    else:
                        stop_ranks_nb = myint(self.object_attr_value_get(stop_uid, 'NumberOfRanks'))
                        if stop_ranks_nb == None:
                            logs.add(f'ERROR : attribute NumberOfRanks is not defined in {stop_uid}')
                            return

                        for attr_rank_idx in range(1, stop_ranks_nb):

                            attr_rank_name = 'Rank' + str(attr_rank_idx).zfill(3)
                            rank_id = myint(self.object_attr_value_get(stop_uid, attr_rank_name))
                            if rank_id == None:
                                logs.add(f'ERROR : attribute {attr_rank_name} is not defined in {stop_uid}')
                                return
                            rank_uid = 'Rank' + str(rank_id).zfill(3)

                            rank_first_pipe_nb = myint(self.object_attr_value_get(stop_uid, rank_id + 'FirstPipeNumber'), 1)
                            rank_first_access_key_nb = myint(self.object_attr_value_get(stop_uid, rank_id + 'FirstAccessibleKeyNumber'), 1)
                            rank_pipe_count = myint(self.object_attr_value_get(stop_uid, rank_id + 'PipeCount'), 1)
    #---------------------------
                            # recover the accessible MIDI notes compass of the rank in the Stop

                            compass = self.compass_extend_rank(rank_uid, midi_note_ext, manual_first_access_key_midi_note)
                            if compass != None:
                                new_manual_first_key_midi_note = min(new_manual_first_key_midi_note, compass[0])
                                new_manual_last_key_midi_note = max(new_manual_last_key_midi_note, compass[1])


        # extend the manual compass in order to cover the possible ranks extension
        first_key_shift = manual_first_access_key_midi_note - new_manual_first_key_midi_note
        new_first_key_nb = max(1, manual_first_access_key_nb + first_key_shift)
        new_keys_nb = new_manual_last_key_midi_note - new_manual_first_key_midi_note + 1

        self.object_attr_value_set(manual_dic, 'FirstAccessibleKeyLogicalKeyNumber', new_first_key_nb)
        self.object_attr_value_set(manual_dic, 'FirstAccessibleKeyMIDINoteNumber', new_manual_first_key_midi_note)
        self.object_attr_value_set(manual_dic, 'NumberOfAccessibleKeys', new_keys_nb)

        if manual_logical_keys_nb < new_keys_nb:
            self.object_attr_value_set(manual_dic, 'NumberOfLogicalKeys', new_keys_nb)



        for stop_uid in self.object_kinship_list_get(manual_uid, TO_CHILD, 'Stop'):
            # extend the pipe ranks of the stops attached to the manual, if applicable

            if self.object_attr_value_get(stop_uid, 'WindchestGroup') != None:
                # the current stop contains rank attributes inside it
                compass = self.compass_extend_rank(stop_uid, midi_note_ext, manual_first_access_key_midi_note)
                if compass != None:
                    new_manual_first_key_midi_note = min(new_manual_first_key_midi_note, compass[0])
                    new_manual_last_key_midi_note = max(new_manual_last_key_midi_note, compass[1])

            else:
                for rank_uid in self.object_kinship_list_get(stop_uid, TO_CHILD, 'Rank'):
                    compass = self.compass_extend_rank(rank_uid, midi_note_ext, manual_first_access_key_midi_note)
                    if compass != None:
                        new_manual_first_key_midi_note = min(new_manual_first_key_midi_note, compass[0])
                        new_manual_last_key_midi_note = max(new_manual_last_key_midi_note, compass[1])

        # update the compass of the manual based on the overall extended compass of the associated pipe ranks
        first_key_shift = manual_first_access_key_midi_note - new_manual_first_key_midi_note
        new_first_key_nb = max(1, manual_first_access_key_nb + first_key_shift)
        new_keys_nb = new_manual_last_key_midi_note - new_manual_first_key_midi_note + 1

        self.object_attr_value_set(manual_dic, 'FirstAccessibleKeyLogicalKeyNumber', new_first_key_nb)
        self.object_attr_value_set(manual_dic, 'FirstAccessibleKeyMIDINoteNumber', new_manual_first_key_midi_note)
        self.object_attr_value_set(manual_dic, 'NumberOfAccessibleKeys', new_keys_nb)

        if manual_logical_keys_nb < new_keys_nb:
            self.object_attr_value_set(manual_dic, 'NumberOfLogicalKeys', new_keys_nb)

        if new_keys_nb > manual_access_keys_nb:
            logs.add(f'{manual_uid} MIDI notes compass extended from {manual_first_access_key_midi_note} -> {manual_first_access_key_midi_note + manual_access_keys_nb - 1} to {new_manual_first_key_midi_note} -> {new_manual_first_key_midi_note + new_keys_nb - 1}')

        # update the compass of the stops linked to the manual
        for stop_uid in self.object_kinship_list_get(manual_uid, TO_CHILD, 'Stop'):

            if self.object_attr_value_get(stop_uid, 'WindchestGroup') != None:
                # the current stop contains rank attributes inside it
                pass

            else:
                for rank_uid in self.object_kinship_list_get(stop_uid, TO_CHILD, 'Rank'):
                    pass


        # extend the keys of the manual
        if new_keys_nb > manual_access_keys_nb:
            pass

    #-------------------------------------------------------------------------------------------------
    def compass_extend_rank(self, object_uid, midi_note_ext, manual_first_access_midi_note=None, check_only=False):
        # extends the compass of the given object UID (rank or stop with rank inside) of the GO ODF, up/down to the given MIDI note (included)
        # the manual first accessible MIDI note is required in case of given Stop object UID (the first accessible MIDI note is not defined in the Stop)
        # try to borrow existings pipes of the rank with one octave of interval, if not possible (more than 1200 cents of pitch tuning needed) use closer existing pipe
        # return in a tuple the first and last MIDI notes of the rank if it has been extended, if not or if error return None

        object_dic = self.object_dic_get(object_uid)
        if object_dic == None:
            return None
        object_type = self.object_type_get(object_uid)

        if (self.object_attr_value_get(object_uid, 'AcceptsRetuning') == 'N' or
            self.object_attr_value_get(object_uid, 'NumberOfLogicalPipes') == '1'):
            # it is a rank/stop with noise samples, no need to extend it, it cannot be retuned
            if not check_only: logs.add(f'{object_uid} is skipped, it contains noise samples')
            return None

        # get the current MIDI notes compass of the given rank
        first_midi_note_cur = myint(self.object_attr_value_get(object_dic, 'FirstMidiNoteNumber'), manual_first_access_midi_note)
        if first_midi_note_cur == None and object_type == 'Rank':
            logs.add(f'ERROR : attribute FirstMidiNoteNumber is not defined in {object_uid}')
            return None

        pipes_nb = myint(self.object_attr_value_get(object_dic, 'NumberOfLogicalPipes'))
        if pipes_nb == None:
            logs.add(f'ERROR : attribute NumberOfLogicalPipes is not defined in {object_uid}')
            return None

        last_midi_note_cur = first_midi_note_cur + pipes_nb - 1

        # define the extended MIDI notes compass of the given rank
        if midi_note_ext < first_midi_note_cur:
            # extension below the current compass
            first_midi_note_ext = midi_note_ext
            last_midi_note_ext = last_midi_note_cur
        elif midi_note_ext > last_midi_note_cur:
            # extension above the current compass
            first_midi_note_ext = first_midi_note_cur
            last_midi_note_ext = midi_note_ext
        else:
            # no extension to do, the given MIDI note is inside the rank compass
            if not check_only: logs.add(f'{object_uid} does not need to be extended, MIDI note {midi_note_ext} is already in its MIDI notes compass {first_midi_note_cur} -> {last_midi_note_cur}')
            return None

        # build a dictionary having as keys the MIDI notes of the extended rank
        # and for each MIDI note a tuple value with : the pipe number of the current rank to map for this MIDI note
        #                                             the pitch tuning in cents to apply to the pipe number to play the MIDI note
        pipes_mapping_dic = {}
        for midi_note_nb in range(first_midi_note_ext, last_midi_note_ext + 1):
            # scan the MIDI notes of the extended compass

            # determine if a pipe borrowing with pitch tuning is needed and if yes in which direction
            if midi_note_nb < first_midi_note_cur:
                # the current MIDI note is before the first pipe of the rank : need to apply a negative pitch tuning of a borrowed pipe
                pitch_tuning_factor = -1
            elif midi_note_nb > last_midi_note_cur:
                # the current MIDI note is after the last pipe of the rank : need to apply a positive pitch tuning of a borrowed pipe
                pitch_tuning_factor = 1
            else:
                # the current MIDI note is within the current pipes range : no pitch tuning to apply
                pitch_tuning_factor = 0

            mapped_midi_note_cur = midi_note_nb # MIDI note of the current compass which will be mapped to the MIDI note of the extended compass

            if pitch_tuning_factor != 0:
                # a pipe borrowing has to be done to play the MIDI note
                # search which of the existing pipes can be borrowed for the MIDI note
                pitch_tuning_cents = 1200 * pitch_tuning_factor # by default borrows a note at one octave of interval from the MIDI note
                while pitch_tuning_cents != 0:
                    # check if with the current pitch tuning we can find a pipe to borrow
                    mapped_midi_note_cur = midi_note_nb - int(pitch_tuning_cents / 100)
                    if mapped_midi_note_cur in range(first_midi_note_cur, last_midi_note_cur + 1):
                        # the MIDI note to borrow is inside the current MIDI notes range
                        # check if the borrowed pipe can be actually used if it is already a borrowed pipe
                        mapped_pipe_id_cur = 'Pipe' + str(mapped_midi_note_cur - first_midi_note_cur + 1).zfill(3)
                        mapped_pipe_pitch_tuning = myint(self.object_attr_value_get(object_dic, mapped_pipe_id_cur + 'PitchTuning'), 0)
                        if pitch_tuning_cents + mapped_pipe_pitch_tuning > 1200:
                            # the pitch tuning to apply + the pitch already applied to the pipe is higher than 1200
                            # this is not allowed in the Pipe999PitchTuning attribute
                            # try to borrow the next pipe closer to the MIDI note
                            pitch_tuning_cents -= pitch_tuning_factor * 100
                        else:
                            # the current pitch tuning value can be used to borrow an existing pipe
                            pitch_tuning_cents += mapped_pipe_pitch_tuning
                            break
                    else:
                        # none pipe can be borrowed
                        pitch_tuning_cents = None
                        break

                if pitch_tuning_cents == 0:
                    # none pipe can be borrowed
                    pitch_tuning_cents = None
            else:
                # no pipe borrowing to do
                mapped_pipe_id_cur = 'Pipe' + str(mapped_midi_note_cur - first_midi_note_cur + 1).zfill(3)
                pitch_tuning_cents = myint(self.object_attr_value_get(object_dic, mapped_pipe_id_cur + 'PitchTuning'), 0)

            # add an entry in the mapping dictionary for the current MIDI note
            if pitch_tuning_cents != None:
                pipe_nb_cur = mapped_midi_note_cur - first_midi_note_cur + 1
                pipes_mapping_dic[midi_note_nb] = (pipe_nb_cur, pitch_tuning_cents)
            else:
                if not check_only: logs.add(f'{object_uid} : none existing pipe of the rank can be borrowed to play the MIDI note {midi_note_nb} with 1200 cents of pitch tuning or less')
                pipes_mapping_dic[midi_note_nb] = (None, 0)

        # check if consecutive MIDI notes at the beginning or the end of the extended compass have no mapped pipe in order to remove them
        for midi_note_nb in list(pipes_mapping_dic.keys()):
            if pipes_mapping_dic[midi_note_nb][0] == None:
                pipes_mapping_dic.pop(midi_note_nb)
            else:
                # stop the loop at the first mapped pipe
                break
        for midi_note_nb in reversed(list(pipes_mapping_dic.keys())):
            if pipes_mapping_dic[midi_note_nb][0] == None:
                pipes_mapping_dic.pop(midi_note_nb)
            else:
                break
        # update the MIDI notes extended compass
        first_midi_note_ext = 999
        last_midi_note_ext = 0
        for midi_note_nb in pipes_mapping_dic.keys():
            first_midi_note_ext = min(midi_note_nb, first_midi_note_ext)
            last_midi_note_ext = max(midi_note_nb, last_midi_note_ext)

        if first_midi_note_ext == first_midi_note_cur and last_midi_note_ext == last_midi_note_cur:
            # no extension will be done finally, exit
            logs.add(f'{object_uid} : compass not extended due to the impossibility to retune existing pipes')
            return None

        if check_only:
            # only the possible compass extension check was requested
            return (first_midi_note_ext, last_midi_note_ext)

        # create an object to put in it the extended rank/stop copied from the given rank/stop
        new_object_dic = self.object_new(object_uid)
        new_object_dic['names'] = object_dic['names']
        new_object_dic['parents'] = object_dic['parents']
        new_object_dic['children'] = object_dic['children']
        # move in the extended rank/stop all the attributes of the current one except the pipe attributes
        for line in object_dic['lines']:
            if line[:4] != 'Pipe':
                new_object_dic['lines'].append(line)

        # update the compass attributes
        self.object_attr_value_set(new_object_dic, 'NumberOfLogicalPipes', last_midi_note_ext - first_midi_note_ext + 1)
        if object_type == 'Rank':
            self.object_attr_value_set(new_object_dic, 'FirstMidiNoteNumber', first_midi_note_ext)
        else:
            self.object_attr_value_set(new_object_dic, 'NumberOfAccessiblePipes', last_midi_note_ext - first_midi_note_ext + 1)
            if self.object_attr_value_get(new_object_dic, 'FirstMidiNoteNumber') != None:
                # the attribute FirstMidiNoteNumber is defined in the Stop, update it
                self.object_attr_value_set(new_object_dic, 'FirstMidiNoteNumber', first_midi_note_ext)

        # build the pipe attributes of the extended rank/stop
        for (midi_note_nb, (pipe_nb_cur, pitch_tuning_cents)) in pipes_mapping_dic.items():
            # scan the MIDI notes of the mapping dictionary
            pipe_nb_new = midi_note_nb - first_midi_note_ext + 1
            pipe_id_new = 'Pipe' + str(pipe_nb_new).zfill(3)
            if pipe_nb_cur != None:
                # a pipe of the current rank can be used for the current extended pipe nb
                pipe_id_cur = 'Pipe' + str(pipe_nb_cur).zfill(3)

                # recover the attributes of the current pipe nb
                pipe_lines_list = self.object_lines_search(object_uid, pipe_id_cur)

                # add or update the PitchTuning attribute in case of need to borrow another pipe
                if pitch_tuning_cents != 0:
                    # search if the current pipe has already a PitchTuning attribute
                    pitch_line_found = False
                    for i, line in enumerate(pipe_lines_list):
                        if line.startswith(pipe_id_cur + 'PitchTuning='):
                            pitch_line_found = True
                            (error_msg, attr_name, attr_value, comment) = self.object_line_split(line)
                            pipe_lines_list[i] = self.object_line_join(attr_name, pitch_tuning_cents, comment)
                    if not pitch_line_found:
                        pipe_lines_list.insert(0, pipe_id_new + 'PitchTuning=' + str(pitch_tuning_cents))

                # rename the pipe ID if the extended pipe nb is different from the current pipe nb
                # then add the current pipe attributes to the new object
                for line in pipe_lines_list:
                    if pipe_nb_new != pipe_nb_cur:
                        line = line.replace(pipe_id_cur, pipe_id_new)
                    new_object_dic['lines'].append(line)
            else:
                new_object_dic['lines'].append(pipe_id_new + '=DUMMY')

        logs.add(f'{object_uid} MIDI notes compass extended from {first_midi_note_cur} -> {last_midi_note_cur} to {first_midi_note_ext} -> {last_midi_note_ext}')

        # delete in the ODF the current rank/stop
        self.odf_data_dic.pop(object_uid)

        # add in the ODF the extended rank/stop
        self.odf_data_dic[object_uid] = new_object_dic

        return (first_midi_note_ext, last_midi_note_ext)

#-------------------------------------------------------------------------------------------------
class C_ODF_DATA(C_ODF_DATA_CHECK, C_ODF_MISC):
    # class to store and manage GO ODF data

    odf_file_name = ""      # name of the ODF which the data have been loaded
    odf_file_encoding = ""  # encoding type of the loaded ODF

    new_panel_format_bool = False  # flag indicating if the ODF data use the new panel format or not

    odf_data_dic = {}  # dictionary in which are stored the data of the loaded GrandOrgue ODF
                       # it has the following structure with two nested dictionaries :
                       #   {object UID: string (for example Organ, Panel001, Rank003)
                       #       {"names": list of strings (names to identify better the object)
                       #        "parents": list of strings (UID)
                       #        "children": list of strings (UID)
                       #        "lines": list of strings (data lines of the object), the first line contains the object UID between brackets
                       #       }
                       #    ...
                       #   }

    # dictionary containing the possible GO objects types and their possible child objects types
    go_objects_children_dic = {
        'Header': [],
        'Organ': ['General', 'Manual', 'Panel', 'WindchestGroup'],
        'Coupler': ['Switch'],
        'Divisional': ['Coupler', 'Stop', 'Switch', 'Tremulant'],
        'DivisionalCoupler': ['Manual', 'Switch'],
        'Enclosure': [],
        'General': ['Coupler', 'DivisionalCoupler', 'Stop', 'Switch', 'Tremulant'],
        'Manual': ['Coupler', 'Divisional', 'Stop', 'Switch', 'Tremulant'],
        'Panel': ['PanelElement', 'PanelImage'],
        'PanelElement': ['Coupler', 'Divisional', 'DivisionalCoupler', 'Enclosure', 'General', 'Manual', 'Stop', 'Switch', 'Tremulant'],
        'PanelImage': [],
        'Rank': [],
        'Stop': ['Rank', 'Switch'],
        'Switch': ['Switch'],
        'Tremulant': ['Switch'],
        'WindchestGroup': ['Enclosure', 'Stop', 'Rank', 'Tremulant'],
        # old panel format
        'Image': [],
        'Label': [],
        'SetterElement': [],
        'PanelCoupler': ['Coupler'],
        'PanelDivisional': ['Divisional'],
        'PanelDivisionalCoupler': ['DivisionalCoupler'],
        'PanelEnclosure': ['Enclosure'],
        'PanelGeneral': ['General'],
        'PanelLabel': ['Label'],
        'PanelSetterElement': ['SetterElement'],
        'PanelStop': ['Stop'],
        'PanelSwitch': ['Switch'],
        'PanelTremulant': ['Tremulant'],
        }

    # dictionary containing the possible GO objects types and their possible parent objects types
    # it is built automatically from go_objects_children_dic in the function objects_templates_load
    go_objects_parents_dic = {}

    # dictionary in which are stored the GO objects templates (loaded from the file GoObjectsTemplates.txt located in the resources sub-folder)
    go_templates_dic = {}

    #-------------------------------------------------------------------------------------------------
    def reset_all_data(self):
        # reset all the data of the class

        self.odf_file_name = ''
        self.odf_file_encoding = ENCODING_ISO_8859_1
        self.new_panel_format_bool = False
        self.odf_data_dic.clear()

    #-------------------------------------------------------------------------------------------------
    def objects_templates_load(self):
        # load the GO objects templates from the file GoObjectsTemplates.txt (if it is present and there is no error)
        # return True or False whether the operation has succeeded or not

        # initialize the go_objects_parents_dic dictionary from the keys of the go_objects_children_dic dictionary
        for object_type in self.go_objects_children_dic.keys():
            self.go_objects_parents_dic[object_type] = []
        # build the go_objects_parents_dic dictionary from the go_objects_children_dic dictionary content (create the opposite kinship)
        for parent_object_type, object_children_list in self.go_objects_children_dic.items():
            # scan the objects types of the object children dictionary
            for child_object_type in object_children_list:
                if parent_object_type not in ('Organ'): # do not include Organ in the parents
                    self.go_objects_parents_dic[child_object_type].append(parent_object_type)

        if len(self.go_templates_dic) == 0:
            # the dictionary has not been loaded yet

            file_name = os.path.dirname(__file__) + os.sep + 'resources' + os.sep + 'GoObjectsTemplates.txt'

            try:
                with open(file_name, 'r') as f:
                    self.go_templates_dic = eval(f.read())

            except OSError as err:
                # it has not be possible to open the file
                logs.add(f'ERROR Cannot open the file "{file_name}" : {err}')
            except SyntaxError as err:
                # syntax error in the dictionary structure which is in the file
                logs.add(f'ERROR Syntax error in the file "{file_name}" : {err}')
                logs.add( 'ERROR Fix the issue in the file then restart OdfEdit')
            except:
                # other error
                logs.add(f'ERROR while opening the file "{file_name}"')
            return False
        else:
            return True

    #-----------------------------------------------------------------------------------------------
    def load_from_file(self, file_name):
        # load the data of the given ODF
        # returns True/False whether the file has been loaded correctly or not

        file_name = path2ospath(file_name)

        # open the given ODF in read mode, and check its encoding format
        try:
            file = open(file_name, mode='r', encoding=ENCODING_ISO_8859_1)
        except OSError as err:
            # it has not be possible to open the file
            logs.add(f"Cannot open the file. {err}")
            valid_odf_file_bool = False
        else:
            if file.readline(3) == "Ã¯Â»Â¿":  # UTF-8 BOM file encoding header
                # close the file
                file.close()
                # reopen the file with the proper encoding format
                file = open(file_name, mode='r', encoding=ENCODING_UTF8_BOM)
                self.odf_file_encoding = ENCODING_UTF8_BOM
            else:
                file.seek(0)  # reset the position of the cursor at the beginning of the file
                self.odf_file_encoding = ENCODING_ISO_8859_1
            # store the name of the ODF
            self.odf_file_name = file_name
            valid_odf_file_bool = True

            # clear data before to scan the file
            self.odf_data_dic.clear()

            object_types_list = []  # list containing the types of objects loaded from the ODF, to display statistics
            object_uid = 'Header'   # UID of the object currently recovered, header section by default
            object_dic = self.object_new(object_uid)    # dictionary of the object currently recovered
            total_attr_nb = 0       # number of whole attributes in the loaded ODF
            file_lines_nb = 0       # number of lines in the loaded ODF
            max_new_id = 999

            for line in file:
                # scan the lines of the ODF to load
                file_lines_nb += 1

                # remove the ending \n character if present in the current line
                if line[-1:] == '\n': line = line[:-1]

                # recover and check the syntax of the data present in the current line
                (error_msg, attr_name, attr_value, comment) = self.object_line_split(line)
                if error_msg != None:
                    logs.add(f'ERROR in {object_uid} section, line "{line}" : {error_msg}')
                    line = ';!!! ' + line
                    attr_name = None

                if attr_name == 'uid':
                    # line containing an object UID

                    # add in the ODF data the object in construction for the previous UID, if it has lines inside
                    # in case of Header the UID line is not considered, so 2 lines min are expected
                    if (object_uid == 'Header' and len(object_dic['lines']) > 1) or len(object_dic['lines']) > 0:
                        self.odf_data_dic[object_uid] = object_dic

                    object_uid = attr_value

                    while object_uid in self.odf_data_dic.keys() and max_new_id > 0:
                        object_uid = object_uid[:-3] + str(max_new_id).zfill(3)
                        max_new_id -= 1
                    if object_uid != attr_value:
                        logs.add(f"WARNING : another occurence of the object {attr_value} is present in the ODF, it has been renamed in {object_uid}")

                    # create the next object in construction
                    object_dic = self.object_new(object_uid)

                    # store the object type for statistics
                    object_type = self.object_type_get(object_uid)
                    if not object_type in object_types_list:
                        object_types_list.append(object_type)

                elif attr_name != None and object_uid == 'Header':
                    # attribute line in the header : it is an error
                    logs.add('ERROR only comments are allowed in the header section')
                    line = ';!!! ' + line
                    attr_name = None

                elif attr_name != None :
                    total_attr_nb += 1

                # add the current line to the object in construction
                if len(line) > 0:
                    object_dic['lines'].append(line)

            # add in the ODF dictionary the dictionary of the last loaded object
            if len(object_dic) > 0:
                self.odf_data_dic[object_uid] = object_dic

            # close the ODF
            file.close()

            # update the kinship links between the objects
            self.objects_kinship_update()

            # reset the check files names flag
            self.check_files_names_bool = None

            if self.odf_file_encoding == ENCODING_UTF8_BOM:
                file_encoding = 'UTF-8-BOM'
            else:
                file_encoding = 'ISO_8859_1'

            logs.add(f'GrandOrgue ODF loaded "{file_name}"')
            logs.add(f'{file_lines_nb:,} lines, file encoding {file_encoding}')

            logs.add(f'{total_attr_nb:,} attributes among {len(self.odf_data_dic)-1:,} sections among {len(object_types_list)} section types')

            # update the panel format flag from the ODF data content
            self.check_panel_format()

        return valid_odf_file_bool

    #-------------------------------------------------------------------------------------------------
    def save_to_file(self, file_name, file_encoding):
        # save the odf_data_dic in the given ODF and with the given encoding format (ENCODING_ISO_8859_1 or ENCODING_UTF8_BOM)
        # if no file name is given, the saving is done in the already loaded ODF file ('Save as' feature)
        # returns True/False whether the writting in file has been done correctly or not

        if file_encoding not in (ENCODING_ISO_8859_1, ENCODING_UTF8_BOM):
            logs.add(f"INTERNAL ERROR wrong encoding {file_encoding} given to save_to_file")
            return False

        file_saved_bool = False

        if len(self.odf_data_dic) == 0:
            # the ODF dictionary is empty, there are no data to save
            logs.add(f"None data to save in the file {file_name}")
        elif file_name == '' and self.odf_file_name == '':
            # no file name known, should not occur, so no possibility to make the save operation
            pass
        else:
            # open the given ODF in write mode
            if file_name == '':
                # no given file name, make the saving in the already loaded ODF
                file_name = self.odf_file_name

            # check if the file name has an extension, if not add the .organ extension
            if file_name[-6:] != '.organ':
                file_name += '.organ'

            try:
                file = open(file_name, mode='w', encoding=file_encoding)
            except OSError as err:
                logs.add(f"Cannot write in the file. {err}")
            else:
                # write the ODF data dictionary content in the ODF
                # eliminating the blank lines and ensuring a blanck line before each object section start
                # write the Header and Organ objects if defined
                for object_uid in ('Header', 'Organ'):
                    if object_uid in self.odf_data_dic.keys():
                        for line in self.odf_data_dic[object_uid]['lines']:
                            if line != '':
                                if line[0] == '[':
                                    # start of a section : add a blank line before
                                    file.write('\n\n' + line)
                                else:
                                    file.write('\n' + line)
                # write the other objects by UID ascending order
                for object_uid in sorted(self.odf_data_dic.keys()):
                    # scan the sorted objects of the ODF data
                    if object_uid not in ('Header', 'Organ'):
                        for line in self.odf_data_dic[object_uid]['lines']:
                            # scan the lines of the current object
                            if line != '':
                                if line[0] == '[':
                                    # start of a section : add a blank line before
                                    file.write('\n\n' + line)
                                else:
                                    file.write('\n' + line)

                file.close()
                file_saved_bool = True

                # store the name of the ODF file
                self.odf_file_name = file_name

                if file_encoding == ENCODING_UTF8_BOM:
                    file_enc = 'UTF-8-BOM'
                else:
                    file_enc = 'ISO_8859_1'

                logs.add(f'Data saved in file "{self.odf_file_name}" with encoding {file_enc}')

        return file_saved_bool

    #-------------------------------------------------------------------------------------------------
    def object_line_split(self, line):
        # check the syntax of the given object line and extract from it the attribute name + attribute value + comment
        # return a tuple containing : (error message, attribute name, attribute value, comment)
        # attribute name = 'uid' if the given line contains an object UID between brackets, the UID is in the attribute value
        # error message = an error description message in case a syntax error has been detected in the given line, or None if no error found

        return self.check_object_line(line)

    #-------------------------------------------------------------------------------------------------
    def object_line_join(self, attr_name, attr_value, comment=None):
        # join in a single string line in ODF format the provided data, return this line

        attr_value = str(attr_value)
        line = ''

        if attr_name == 'uid':
            # UID of the object, start of a section
            if comment != None:
                line = '[' + attr_value + ']' + comment
            else:
                line = '[' + attr_value + ']'

        elif attr_name != None:
            # attribute line
            if comment != None:
                line = attr_name + '=' + attr_value + comment
            else:
                line = attr_name + '=' + attr_value

        elif comment != None:
            # comment line
            line = comment

        return line

    #-------------------------------------------------------------------------------------------------
    def object_lines_read(self, object_uid):
        # return in a list the lines of the given object UID (the first line contains the object UID in brackets)
        # or an empty list if the object UID doesn't exist

        object_dic = self.object_dic_get(object_uid)
        if object_dic != None:
            return list(object_dic['lines'])
        else:
            return []

    #-------------------------------------------------------------------------------------------------
    def object_lines_search(self, object_uid, text_to_search):
        # return in a list the lines of the given object UID which contain the given text to search
        # or an empty list if the object UID doesn't exist or no line found

        object_dic = self.object_dic_get(object_uid)
        if object_dic != None:
            found_lines_list = []
            for line in object_dic['lines']:
                if text_to_search in line:
                    found_lines_list.append(line)
            return found_lines_list
        else:
            return []

    #-------------------------------------------------------------------------------------------------
    def object_lines_write(self, object_lines_list, expected_object_uid=None, parent_object_uid=None):
        # write the given object attributes lines in the ODF
        # the first line of the list must contain an object UID between brackets else the lines are considered as being the Header section
        # if expected_object_uid is given, it is the UID expected in the first line of the given lines list
        # if parent_object_uid is given, link the object defined in the lines (if is new in the ODF) to this parent
        # return the UID of the added/updated/renamed object or None if a syntax error has been detected

        # expected_object_uid | object_uid (defined in lines)    | action in the ODF
        # --------------------|----------------------------------|------------------------------------
        # None                | Object999 (not in ODF)           | Object999 added
        # None                | Object999 (in ODF)               | Object999 updated
        # Object999           | Object999 (not in ODF)           | Object999 added
        # Object999           | Object999 (in ODF)               | Object999 updated
        # Object999           | Object888 (different type)       | error, Object999 cannot be renamed in Object888 which has different object type
        # Object999           | Object888 (same type in ODF)     | error, Object999 cannot be renamed in Object888 which already exists
        # Object999           | Object888 (same type not in ODF) | Object999 renamed in Object888 and Object888 updated

        # set the initial object UID before to scan the given lines lise
        if expected_object_uid == None:
            object_uid = 'Header'   # Header object by default if no expected UID
        else:
            object_uid = expected_object_uid

        tmp_object_dic = self.object_new(object_uid)  # object to store the provided lines and their UID

        for i, line in enumerate(object_lines_list):
            # scan the lines of the given list to check them, to recover the UID and store them in tmp_object_dic

            # recover and check the data present in the current line
            (error_msg, attr_name, attr_value, comment) = self.object_line_split(line)

            if error_msg != None:
                logs.add(f'ERROR in line "{line}" : {error_msg}')
                return None
            elif i == 0 and attr_name != 'uid' and object_uid != 'Header':
                logs.add('ERROR : an object identifier is expected in the first line')
                return None
            elif i > 0 and attr_name == 'uid':
                logs.add('ERROR : an object identifier can be defined only in the first line')
                return None
            elif i == 0 and attr_name == 'uid' and attr_value != None:
                # there is a valid UID in first line
                object_uid = attr_value
            elif object_uid == 'Header' and attr_name != None:
                logs.add('ERROR : only comments are allowed in the header section')
                return None

            # add the current line to the temporary object
            tmp_object_dic['lines'].append(line)

        # recover the object corresponding to the UID defined in the first of the given lines if defined in the ODF
        object_dic = self.object_dic_get(object_uid)

        if expected_object_uid != None and self.object_type_get(expected_object_uid) != self.object_type_get(object_uid):
            logs.add(f'ERROR : {expected_object_uid} cannot be renamed in {object_uid} which is of different type')
            object_uid = None

        elif expected_object_uid != None and expected_object_uid != object_uid and object_dic != None:
            logs.add(f'ERROR : {expected_object_uid} cannot be renamed in {object_uid} which is already defined in the ODF')
            object_uid = None

        elif object_dic == None and (expected_object_uid == None or expected_object_uid == object_uid):
            # the object UID defined in the given lines is not present in the ODF
            # and there is no expected UID or it is equal to the UID defined in the given lines
            # add an object in the ODF with the given lines
            self.odf_data_dic[object_uid] = tmp_object_dic
            logs.add(f"{object_uid} : added")

            if parent_object_uid != None:
                # link the new object to its parent if provided
                self.object_parent2child_link(parent_object_uid, object_uid, 'link')
            elif self.object_type_get(object_uid) in ('PanelElement', 'PanelImage'):
                # link the new object to its parent panel if it is PanelElement or PanelImage object
                self.object_parent2child_link(object_uid[:8], object_uid, 'link')

        else:
            # other cases
            if expected_object_uid != None and expected_object_uid != object_uid:
                # the UID defined in the lines is not the expected one
                # rename the expected object UID to the UID defined in the lines
                object_uid = self.object_rename(expected_object_uid, object_uid)
                object_dic = self.object_dic_get(object_uid)

            if object_dic != None:
                # update the object having the UID defined in the lines
                object_dic['lines'] = tmp_object_dic['lines']
                logs.add(f"{object_uid} : updated")

        # update the kinship links between the objects
        self.objects_kinship_update()
        # update the number of object type in the Organ object if necessary
        self.object_organ_numbers_update(object_uid)

        return object_uid

    #-------------------------------------------------------------------------------------------------
    def object_new(self, object_uid):
        # return the dictionary of a new object having the given UID and all other fields void

        object_dic = {}
        object_dic['names'] = []    # list with the various names of the object
        object_dic['parents'] = []  # list with the UID of parent objects
        object_dic['children'] = [] # list with the UID of children objects
        object_dic['lines'] = [] # list with the data lines (including the UID) of the object

        return object_dic

    #-------------------------------------------------------------------------------------------------
    def object_add(self, object_type, parent_uid, object_lines_list=[]):
        # add in the ODF data an object corresponding to the given object type
        # and having the attributes of the given lines list if provided or of the template if defined
        # return the UID of the created object, or None if an error occured

        if not object_type in self.go_objects_children_dic.keys():
            logs.add(f'INTERNAL ERROR in object_add : object type {object_type} is unknown')
            return None

        if len(object_lines_list) == 0:
            # no object lines list provided, recover the one from the template if defined
            if object_type in self.go_templates_dic.keys():
                # the given object type has a template defined
                # recover the lines of the template
                object_lines_list = list(self.go_templates_dic[object_type])

        # define the UID of the object to add
        object_uid = self.object_type_free_uid_get(object_type, parent_uid)

        if object_uid != None:
            # a new object can be added
            # add the object UID in first line of the attribute lines list if it is not the Header
            if object_uid != 'Header':
                object_lines_list.insert(0, '[' + object_uid + ']')

            # add the object and its attribute lines in the ODF and recover the result (can be None in case of error in the lines)
            object_uid = self.object_lines_write(object_lines_list, object_uid, parent_uid)

        return object_uid

    #-------------------------------------------------------------------------------------------------
    def object_copy(self, copied_object_uid, parent_uid):
        # make a copy of the given copied object UID and place it as child of the given parent object UID (can be None)
        # return the UID of the copied object, or None if an error occured

        # recover the lines of the object to copy
        attribute_lines_list = self.object_lines_read(copied_object_uid)
        if len(attribute_lines_list) > 0:
            # remove the first line which contains the original object UID (the new UID will be added in object_add)
            attribute_lines_list.pop(0)
            # add a copy of the copied object
            copied_object_type = self.object_type_get(copied_object_uid)
            new_object_uid = self.object_add(copied_object_type, parent_uid, attribute_lines_list)
        else:
            new_object_uid = None

        if new_object_uid != None:
            logs.add(f'{new_object_uid} : copied from {copied_object_uid}')
        else:
            logs.add(f'ERROR cannot make a copy of {copied_object_uid}')

        return new_object_uid

    #-------------------------------------------------------------------------------------------------
    def object_link(self, object_uid, kinship_objects_list, relationship):
        # link the given object to the objects of the given kinship objects list with the given relationship (TO_PARENT or TO_CHILD)
        # return the object_uid (which can have be renamed in case of children of a Panel or Manual) or None if an issue occured

        if relationship not in (TO_PARENT, TO_CHILD):
            logs.add(f'INTERNAL ERROR in object_link : wrong given relationship {relationship}')

        object_dic = self.object_dic_get(object_uid)
        if object_dic == None:
            return None
        object_type = self.object_type_get(object_uid)

        # recover the list of the current kinship list (parents or children) of the given object
        current_kinship_list = sorted(self.object_kinship_list_get(object_uid, relationship))

        # build a dictionary with as keys the object types which are present in the given kinship objects list
        #                     and as values their number in the list
        kinship_objects_types_dic = {}
        for obj_uid in kinship_objects_list:
            obj_type = self.object_type_get(obj_uid)
            if obj_type not in kinship_objects_types_dic.keys():
                kinship_objects_types_dic[obj_type] = 0
            kinship_objects_types_dic[obj_type] += 1

        # check if the given kinship list contains more parents/children type than allowed for the given object type
        if relationship == TO_PARENT:
            if object_type in ('PanelElement', 'PanelImage'):
                if 'Panel' in kinship_objects_types_dic.keys():
                    if kinship_objects_types_dic['Panel'] > 1:
                        # PanelElement or PanelImage with more than one Panel parent
                        messagebox.showerror(title='Selection error', message=f'A {object_type} object cannot have more than one parent Panel, please select a single parent Panel.')
                        return None
                else:
                    # PanelElement or PanelImage with none Panel parent
                    messagebox.showerror(title='Selection error', message=f'A {object_type} object must have one parent Panel, please select a parent Panel.')
                    return None
            elif (object_type in ('Rank', 'Stop') and
                  'WindchestGroup' in kinship_objects_types_dic.keys() and kinship_objects_types_dic['WindchestGroup'] > 1):
                # Rank and Stop object with more than one parent WindchestGroup
                messagebox.showerror(title='Selection error', message=f'A {object_type} object cannot have more than one parent WindchestGroup, please select a single parent WindchestGroup.')
                return None
        else: # TO_CHILD
            if object_type == 'PanelElement' and len(kinship_objects_list) > 1:
                # a PanelElement with more than one child object
                messagebox.showerror(title='Selection error', message=f'A {object_type} object can have only one child object, please select a single child for {object_uid}.')
                return None

        ret_object_uid = object_uid  # UID which will be returned by the function
        if relationship == TO_PARENT:
            # unlink the given object from its current parents which have no more to be a parent
            if object_type not in ('PanelElement', 'PanelImage'):
                # no need to unlink PanelElement and PanelImage
                for parent_uid in current_kinship_list:
                    # scan the current parent objects of the given object
                    if parent_uid not in kinship_objects_list:
                        # the current parent has no more to be a parent : remove the link
                        self.object_parent2child_link(parent_uid, object_uid, 'unlink')

            # link the given object to the objects which must be now a parent
            for parent_uid in kinship_objects_list:
                # scan the given parent objects
                if parent_uid not in current_kinship_list:
                    # it is not yet a parent : add the link
                    ret_object_uid = self.object_parent2child_link(parent_uid, object_uid, 'link')
        else:
            # unlink the given object from its current children which have no more to be a child
            if object_type != 'Panel':
                # no need to unlink PanelElement and PanelImage
                for child_uid in current_kinship_list:
                    # scan the current child objects of the given object
                    if child_uid not in kinship_objects_list:
                        # the current child has no more to be a child : remove the link
                        self.object_parent2child_link(object_uid, child_uid, 'unlink')

            # link the given object to the objects which must be now a child
            for child_uid in kinship_objects_list:
                # scan the given children objects
                if child_uid not in current_kinship_list:
                    # it is not yet a child : add the link
                    self.object_parent2child_link(object_uid, child_uid, 'link')

        # update the kinship links between the objects of the ODF
        self.objects_kinship_update()

        return ret_object_uid

    #-------------------------------------------------------------------------------------------------
    def object_rename(self, old_object_uid, new_object_uid, update_links_bool=True):
        # rename in the ODF data the object having the given UID to the given new UID (only the three last digits of the UID can be changed)
        # return the new UID of the object, or None if failure

        # check the provided object UIDs
        object_dic = self.object_dic_get(new_object_uid)
        if object_dic != None:
            logs.add(f"Warning : cannot rename {old_object_uid} in {new_object_uid} which already exits")
            return None

        object_dic = self.object_dic_get(old_object_uid)
        if object_dic == None:
            logs.add(f"INTERNAL ERROR in object_rename : object {old_object_uid} does not exit")
            return None

        object_type = self.object_type_get(old_object_uid)
        if object_type != self.object_type_get(new_object_uid):
            logs.add(f"INTERNAL ERROR in object_rename : old object type {old_object_uid} and new object type {new_object_uid} are not the same")
            return None

        # rename the reference to the new object UID in its parents or children objects if necessary
        if object_type == 'Panel':
            # rename the UID of the children of the renamed panel (PanelElement and PanelImage)
            for old_child_uid in object_dic['children']:
                # scan the children of the renamed Panel
                new_child_uid = new_object_uid + old_child_uid[8:]   # for example from Panel000Element001 to Panel001Element001
                # move the child object data under another key which has its new UID
                self.odf_data_dic[new_child_uid] = self.odf_data_dic.pop(old_child_uid)
                # update the UID in the first line of the child object
                (error_msg, attr_name, attr_value, comment) = self.object_line_split(self.odf_data_dic[new_child_uid]['lines'][0])
                if attr_name == 'uid':
                    self.odf_data_dic[new_child_uid]['lines'][0] = self.object_line_join(attr_name, new_child_uid, comment)
                logs.add(f"{old_child_uid} : renamed in {new_child_uid}")

        elif object_type == 'WindchestGroup':
            # rename the reference to the new WindchestGroup UID in its children objects Stop or Rank
            windchest_id = self.object_id_get(new_object_uid)
            if windchest_id != None:
                for child_uid in object_dic['children']:
                    # scan the children of the renamed WindchestGroup
                    if self.object_type_get(child_uid) in ('Stop', 'Rank'):
                        self.object_attr_value_set(child_uid, 'WindchestGroup', int(windchest_id))
                        logs.add(f"{child_uid} : attribute WindchestGroup set to {windchest_id}")

        elif object_type not in ('PanelElement', 'PanelImage'):
            # other kinds of objects (but PanelElement and PanelImage) : rename the reference to the new object UID in its parents
            for parent_uid in sorted(object_dic['parents']):
                # scan the parents of the renamed object

                parent_type = self.object_type_get(parent_uid)
                parent_dic = self.object_dic_get(parent_uid)
                if parent_dic != None:

                    # define the name of the attribute in the parent which refers to the type of the renamed object
                    ref_attr_name = object_type
                    if parent_type == 'General':
                        ref_attr_name += 'Number'

                    parent_lines_list = parent_dic['lines']
                    for i in range(len(parent_lines_list)):
                        # scan the lines of the parent object to recover the references to objects of the type of the renamed object
                        if parent_lines_list[i].startswith(ref_attr_name):
                            # the current line contains a reference to the renamed object type
                            (error_msg, attr_name, attr_value, comment) = self.object_line_split(parent_lines_list[i])
                            if (attr_name != None and attr_value != '' and (attr_name == ref_attr_name or attr_name[:-3] == ref_attr_name) and
                                abs(int(attr_value)) == int(old_object_uid[-3:])):
                                # the current line contains a reference to the renamed object
                                # write in this line the new reference ID
                                sign = '-' if attr_value[0] == '-' else ''
                                self.object_attr_value_set(parent_dic, attr_name, sign + new_object_uid[-3:])
                                logs.add(f"{parent_uid} : reference to {old_object_uid} changed to {new_object_uid}")
                                break

            if object_type == 'Manual':
                # if a manual is renamed, rename the StopManual and CouplerManual attributes value in General objects
                for obj_uid in self.odf_data_dic.keys():
                    # scan the objects of the ODF data
                    if obj_uid.startswith('General'):
                        # the current object is a General
                        obj_dic = self.object_dic_get(obj_uid)
                        lines_list = obj_dic['lines']
                        for i in range(len(lines_list)):
                            # scan the lines of the current General object
                            if lines_list[i].startswith(('StopManual', 'CouplerManual')):
                                # the current line contains a reference to a manual
                                (error_msg, attr_name, attr_value, comment) = self.object_line_split(lines_list[i])
                                if attr_name != None and int(attr_value) == int(old_object_uid[-3:]):
                                    # the current line contains a reference to the old UID of the renamed Manual
                                    self.object_attr_value_set(obj_dic, attr_name, new_object_uid[-3:])
                                    logs.add(f"{obj_uid} : attribute {attr_name} updated")

                # rename as well the ID of the children Coupler, Divisional, Stop objects to align it on the new manual ID (first digit of the ID)
                manual_id = int(new_object_uid[-3:])
                for child_uid in list(object_dic['children']):
                    # scan the children of the renamed Manual
                    if self.object_type_get(child_uid) in ('Coupler', 'Divisional', 'Stop'):
                        # rename the current object UID by changing the first digit of its ID with the number of the parent manual
                        self.object_rename(child_uid, child_uid[:-3] + str(manual_id) + child_uid[-2:], False)

        # move the given object under another key in the ODF data dictionary which has the new UID
        object_dic = self.odf_data_dic[new_object_uid] = self.odf_data_dic.pop(old_object_uid)

        # update the UID in the first line with the new object UID
        (error_msg, attr_name, attr_value, comment) = self.object_line_split(object_dic['lines'][0])
        if attr_name == 'uid':
            object_dic['lines'][0] = self.object_line_join(attr_name, new_object_uid, comment)

        logs.add(f"{old_object_uid} : renamed in {new_object_uid}")

        if update_links_bool:
            # update in the Organ object the number of objects type corresponding to the rename object if needed
            self.object_organ_numbers_update(new_object_uid)

            # update the kinship links between the objects
            self.objects_kinship_update()

        return new_object_uid

    #-------------------------------------------------------------------------------------------------
    def object_delete(self, object_uid):
        # delete in the ODF data the object having the given UID
        # return True or False whether the deletion has been done or not

        object_dic = self.object_dic_get(object_uid)
        if object_dic != None:
            # unlink the given object with its parents
            for parent_uid in object_dic['parents']:
                self.object_parent2child_link(parent_uid, object_uid, 'unlink')

            # delete the given object in the ODF data
            del self.odf_data_dic[object_uid]
            logs.add(f"{object_uid} : deleted")

            # update the number of object type in the Organ object if necessary
            self.object_organ_numbers_update(object_uid)

            # update the kinship links between the objects
            self.objects_kinship_update()

            return True
        else:
            logs.add(f"ERROR {object_uid} cannot be deleted because not found")
            return False

    #-------------------------------------------------------------------------------------------------
    def object_id_get(self, object_uid):
        # return the ID (integer) of the given object UID (for example from Stop012 will return 12)
        # return None if the ID is not valid : there are not 3 digits at the end of the UID

        if not(object_uid[-3:].isdigit()):
            # the last 3 characters are not all digits
            return None
        else:
            return int(object_uid[-3:])

    #-------------------------------------------------------------------------------------------------
    def object_type_get(self, object_uid):
        # return the type (string) of the given object UID (for example from Panel012 will return Panel) or None if not type provided

        if object_uid not in (None, ''):
            # remove the digits which are inside the UID string
            object_type = ''
            for c in object_uid:
                if not c.isdigit():
                    object_type += c
        else:
            object_type = None

        return object_type

    #-------------------------------------------------------------------------------------------------
    def object_type_free_uid_get(self, object_type, parent_uid=None):
        # return the first unused object UID for the given object type and being child of the given parent UID if provided (required for Manual and Panel parents)

        if object_type in ('Header', 'Organ'):
            if object_type in self.odf_data_dic.keys():
                # there is already a Header or Organ object in the ODF
                return None
            else:
                return object_type

        if object_type in ('Manual', 'Panel'):
            # Manual and Panel ID can start from 0 and need a given parent UID
            free_id = 0
        else:
            free_id = 1
        id_size = 3

        parent_type = self.object_type_get(parent_uid)
        if parent_type == 'Panel':
            object_type = parent_uid + object_type[5:]   # it gives for example Panel0001Element or Panel002Image
        elif parent_type == 'Manual' and object_type in ('Coupler', 'Divisional', 'Stop'):
            object_type = object_type + parent_uid[-1]   # it gives for example Stop1, only the last two digits can be set
            id_size = 2

        while free_id <= 999 :
            free_uid = object_type + str(free_id).zfill(id_size)
            if free_uid not in self.odf_data_dic.keys():
                # the current UID is not present in the ODF
                return free_uid
            else:
                free_id += 1
        return None

    #-------------------------------------------------------------------------------------------------
    def object_dic_get(self, object_uid):
        # return the dictionary of the object of the ODF dictionary having the given UID

        try:
            return self.odf_data_dic[object_uid]
        except:
            # object not existing
            return None

    #-------------------------------------------------------------------------------------------------
    def object_names_get(self, object_uid):
        # return the UID followed by the names between parenthesis (if defined) of the given object UID

        object_dic = self.object_dic_get(object_uid)
        if object_dic != None and len(object_dic['names']) > 0:
            return object_uid + ' (' + ' | '.join(object_dic['names']) + ')'
        else:
            return object_uid

    #-------------------------------------------------------------------------------------------------
    def object_attr_value_get(self, object_dic_or_uid, attribute_name):
        # return the value of the given attribute defined in the given object dictionary or UID
        # return None if the given object or the attribute doesn't exist

        if object_dic_or_uid == None:
            return None

        elif isinstance(object_dic_or_uid, str):
            # the given parameter is a string, so an UID
            object_dic = self.object_dic_get(object_dic_or_uid)
        else:
            # the given parameter is not a string, so an object dictionary
            object_dic = object_dic_or_uid

        if object_dic != None:
            for line in object_dic['lines']:
                # scan the attribute lines of the object
                if line.startswith(attribute_name):
                    (error_msg, attr_name, attr_value, comment) = self.object_line_split(line)
                    if attr_name == attribute_name:
                        # given attribute found : return its value
                        return attr_value

        return None

    #-------------------------------------------------------------------------------------------------
    def object_attr_value_set(self, object_dic_or_uid, attribute_name, attribute_value):
        # write the given value in the given attribute defined in the given object dictionary or UID
        # return True or False whether it has been possible or not to the set the value

        if isinstance(object_dic_or_uid, str):
            # the given parameter is a string, so an UID
            object_dic = self.object_dic_get(object_dic_or_uid)
        else:
            # the given parameter is not a string, so an object dictionary
            object_dic = object_dic_or_uid

        if object_dic != None:
            comment = None # no comment put in the line
            for i, line in enumerate(object_dic['lines']):
                # scan the attribute lines of the object
                if line.startswith(attribute_name):
                    (error_msg, attr_name, attr_value, comment) = self.object_line_split(line)
                    if attr_name == attribute_name:
                        # given attribute found : update its value
                        object_dic['lines'][i] = self.object_line_join(attribute_name, attribute_value, comment)
                        return True

            # attribute not present in the object lines, add a line for it
            object_dic['lines'].append(self.object_line_join(attribute_name, attribute_value, comment))
            return True
        else:
            return False

    #-------------------------------------------------------------------------------------------------
    def object_parent2child_link(self, parent_object_uid, child_object_uid, operation):
        # link/unlink the given child object to the given parent object (both must already exist in the ODF data)
        # operation parameter can be 'link' or 'unlink'
        # return the UID of the child object (can be renamed in case of child of Panel) or None if an error occured

        # types of referencing parent to child :
        #   WindchestGroup -> Stop (rank inside) or Rank : WindchestGroup ID is set in the attribute WindchestGroup of the Stop or Rank object
        #   Panel -> PanelElement or PanelImage : PanelElement or PanelImage UID starts with the parent Panel UID
        #   PanelElement -> Coupler/General/Manual/... : only one child can be defined
        #   Stop -> Switch (example) : the value of the attribute Switchxxx of the Stop is the Rank ID

        if (parent_object_uid == None or child_object_uid == None):
            return None

        if operation not in ('link', 'unlink'):
            logs.add(f'INTERNAL ERROR in object_parent2child_link : wrong requested operation name "{operation}"')
            return None

        # recover the dictionary, type and ID of the given parent
        parent_object_dic = self.object_dic_get(parent_object_uid)
        if parent_object_dic == None:
            logs.add(f"INTERNAL ERROR in object_parent2child_link : parent object {parent_object_uid} does not exit")
            return None
        parent_object_type = self.object_type_get(parent_object_uid)
        parent_object_id = self.object_id_get(parent_object_uid)
        if parent_object_type in ('Organ', 'Header'):
            # the Organ and Header objects cannot be linked to a child
            return None

        # recover the dictionary, type and ID of the given child
        child_object_dic = self.object_dic_get(child_object_uid)
        if child_object_dic == None:
            logs.add(f"INTERNAL ERROR in object_parent2child_link : child object {child_object_uid} does not exit")
            return None
        child_object_type = self.object_type_get(child_object_uid)
        child_object_id = self.object_id_get(child_object_uid)

        # check that the given parent object can have the given child object as a child
        if not child_object_type in self.go_objects_children_dic[parent_object_type]:
            logs.add(f"INTERNAL ERROR in object_parent2child_link : the object type {parent_object_type} cannot have the object type {child_object_type} as a child")
            return None

        if parent_object_type == 'WindchestGroup' and child_object_type in ('Rank', 'Stop'):
            # link change between parent WindchestGroup and child Rank or Stop object, the referencing is done in the Rank or Stop object
            # set or erase the ID of the parent WindchestGroup in the attribute WindchestGroup of the child Rank or Stop object
            if operation == 'link':
                self.object_attr_value_set(child_object_dic, 'WindchestGroup', int(parent_object_id))
                logs.add(f"{child_object_uid} : reference to {parent_object_uid} added")
            else:
                self.object_attr_value_set(child_object_dic, 'WindchestGroup', '')
                logs.add(f"{child_object_uid} : reference to {parent_object_uid} removed")
            return child_object_uid

        elif parent_object_type == 'Panel':
            # link change between parent Panel and child PanelElement or PanelImage object
            # store the parent panel UID present in the child UID before to rename it
            prev_parent_panel_uid = child_object_uid[:8]
            if operation == 'link' and parent_object_uid != prev_parent_panel_uid:
                # link to do and the given child PanelElement or PanelImage doesn't refer already to the given parent panel UID
                # get a free new UID for the child
                new_child_object_uid = self.object_type_free_uid_get(child_object_type, parent_object_uid)

                # move the object data of the child object under another key which has the new child UID
                new_object_dic = self.odf_data_dic[new_child_object_uid] = self.odf_data_dic.pop(child_object_uid)

                # write the new UID in the first line of the new object
                (error_msg, attr_name, attr_value, comment) = self.object_line_split(new_object_dic['lines'][0])
                if attr_name == 'uid':
                    new_object_dic['lines'][0] = self.object_line_join(attr_name, new_child_object_uid, comment)

                logs.add(f"{child_object_uid} : renamed in {new_child_object_uid}")

                # update the NumberOf attribute of the previous parent Panel object which doesn't contain anymore the child object
                if child_object_type == 'PanelElement':
                    nb = self.objects_type_number_get(prev_parent_panel_uid + 'Element')
                    self.object_attr_value_set(prev_parent_panel_uid, 'NumberOfGUIElements', nb)
                    logs.add(f"{prev_parent_panel_uid} : attribute NumberOfGUIElements updated")
                else:
                    nb = self.objects_type_number_get(prev_parent_panel_uid + 'Image')
                    self.object_attr_value_set(prev_parent_panel_uid, 'NumberOfImages', nb)
                    logs.add(f"{prev_parent_panel_uid} : attribute NumberOfImages updated")

                child_object_uid = new_child_object_uid

            # unlink to parent panel is possible only if the child object PanelElement or PanelImage is going to be deleted

            # update the NumberOf attribute of the parent Panel object to take into account the link change
            if child_object_type == 'PanelElement':
                nb = self.objects_type_number_get(parent_object_uid + 'Element')
                if operation == 'unlink': nb -= 1  # remove 1 to take into account the child which will be deleted later
                self.object_attr_value_set(parent_object_uid, 'NumberOfGUIElements', nb)
                logs.add(f"{parent_object_uid} : attribute NumberOfGUIElements updated")
            else:
                nb = self.objects_type_number_get(parent_object_uid + 'Image')
                if operation == 'unlink': nb -= 1  # remove 1 to take into account the child which will be deleted later
                self.object_attr_value_set(parent_object_uid, 'NumberOfImages', nb)
                logs.add(f"{parent_object_uid} : attribute NumberOfImages updated")

            return child_object_uid

        elif parent_object_type == 'PanelElement':
            # link change between a parent PanelElement and a child object which has to be unique
            # remove in the PanelElement object all the lines with Type or referencing attributes
            i = 0
            parent_lines_list = parent_object_dic['lines']
            while i < len(parent_lines_list):
                # scan the lines of the parent object
                (error_msg, attr_name, attr_value, comment) = self.object_line_split(parent_lines_list[i])
                if attr_name != None and (attr_name in self.go_objects_children_dic['PanelElement'] or attr_name == 'Type'):
                    # the current line contains an attribute to remove
                    del parent_object_dic['lines'][i]
                    i -= 1
                i += 1
            if operation == 'link':
                # add the type and reference to the child object to link to the parent
                parent_object_dic['lines'].insert(1, f'Type={child_object_type}')
                parent_object_dic['lines'].insert(2, f'{child_object_type}={str(child_object_id).zfill(3)}')
                logs.add(f"{parent_object_uid} : link to {child_object_uid} added")
            else:
                # add an empty "Type=" attribute
                parent_object_dic['lines'].insert(1, 'Type=')
                logs.add(f"{parent_object_uid} : link to {child_object_uid} removed")

            return child_object_uid

        else:
            # management of the other types of objects links
            # add/remove in the parent object the attribute which refers to the child object and update the NumberOf attribute of the parent for the child type

            # if the parent is a Manual and the child a Coupler/Divisional/Stop, rename the ID of the child to be aligned to the parent manual ID
            if operation == 'link' and parent_object_type == 'Manual' and child_object_type in ('Coupler', 'Divisional', 'Stop'):
                manual_id = int(parent_object_uid[-3:])
                if int(child_object_uid[-3]) != manual_id:
                    new_child_object_uid = self.object_type_free_uid_get(child_object_type, parent_object_uid)
                    if self.object_rename(child_object_uid, new_child_object_uid) != None:
                        child_object_uid = new_child_object_uid
                        child_object_id = self.object_id_get(child_object_uid)

            # define the name of the attribute in the parent object which defines the number of child objects type
            if parent_object_type in ('Coupler', 'DivisionalCoupler', 'Stop', 'Switch', 'Tremulant') and child_object_type == 'Switch':
                nb_of_attr_name = 'SwitchCount'
            else:
                if child_object_type == 'Switch':
                    nb_of_attr_name = 'NumberOfSwitches'
                else:
                    nb_of_attr_name = 'NumberOf' + child_object_type + 's'

            # define the name of the attributes in the parent object which refers to the child objects type
            if parent_object_type == 'General':
                object_type_attr_name = child_object_type + 'Number'
                if child_object_type in ('Coupler', 'Stop'):
                    object_type_attr_name2 = child_object_type + 'Manual'
                else:
                    object_type_attr_name2 = None
            else:
                object_type_attr_name = child_object_type
                object_type_attr_name2 = None

            # make the list of the references to the child object type in the parent object and delete the lines having these references
            references_list = []
            nb_of_attr_name_line_nb = None  # line number in the parent where is located the NumberOf attributes
            i = 0
            parent_lines_list = parent_object_dic['lines']
            while i < len(parent_lines_list):
                # scan the lines of the parent object
                if parent_lines_list[i].startswith(child_object_type):
                    # the current line should contain a reference to the child object type
                    (error_msg, attr_name, attr_value, comment) = self.object_line_split(parent_lines_list[i])
                    if attr_name != None and attr_value not in ('', None):
                        # the current line contains a not empty attribute
                        if attr_name[:-3] == object_type_attr_name:
                            # the attribute is referencing a child object
                            if abs(int(attr_value)) != child_object_id:
                                # store the reference of the child object and the comment if the current line doesn't refer to the child object ID
                                references_list.append((attr_value, comment))
                            # delete the referencing line
                            del parent_object_dic['lines'][i]
                            i -= 1
                        elif attr_name[:-3] == object_type_attr_name2:
                            # the attribute is referencing a manual to which contains a child object
                            # delete the referencing line
                            del parent_object_dic['lines'][i]
                            i -= 1

                if parent_lines_list[i].startswith(nb_of_attr_name + '='):
                    # line containing the NumberOf or Count attribute
                    nb_of_attr_name_line_nb = i
                i += 1

            if nb_of_attr_name_line_nb == None:
                # attribute NumberOf or Count not found : add it in the last line of the parent object
                parent_object_dic['lines'].append(nb_of_attr_name + '=0')
                nb_of_attr_name_line_nb = len(parent_object_dic['lines']) - 1

            # add the reference to the child object in the references list without comment
            if operation == 'link':
                references_list.append((str(child_object_id).zfill(3), None))

            # set in the parent object the new references number
            self.object_attr_value_set(parent_object_dic, nb_of_attr_name, len(references_list))

            # insert all the references in the parent object after the NumberOf line
            insert_idx = nb_of_attr_name_line_nb + 1
            for ref_idx in range(len(references_list)):
                line = self.object_line_join(object_type_attr_name + str(ref_idx + 1).zfill(3), references_list[ref_idx][0], references_list[ref_idx][1])
                parent_object_dic['lines'].insert(insert_idx, line)
                insert_idx += 1
                if object_type_attr_name2 != None:
                    # need to add an attribute CouplerManual999 or StopManual999 after the attribute CouplerNumber999 or StopNumber999
                    # recover the referenced Coupler or Manual
                    ref_object_dic = self.object_dic_get(child_object_type + str(references_list[ref_idx][0]).zfill(3))
                    if ref_object_dic != None:
                        # recover the UID of the parent Manual object if any
                        for parent_uid in ref_object_dic['parents']:
                            if parent_uid[:6] == 'Manual':
                                # add a line with the reference to the Manual
                                line = self.object_line_join(object_type_attr_name2 + str(ref_idx + 1).zfill(3), parent_uid[-3:])
                                parent_object_dic['lines'].insert(insert_idx, line)
                                insert_idx += 1

            if operation == 'link':
                logs.add(f"{parent_object_uid} : reference to {child_object_uid} added")
            else:
                logs.add(f"{parent_object_uid} : reference to {child_object_uid} removed")
            logs.add(f"{parent_object_uid} : attribute {nb_of_attr_name} updated")

            return child_object_uid

        return None

    #-------------------------------------------------------------------------------------------------
    def object_parent_panel_get(self, object_uid):
        # returns the UID of the panel (Panel999 or Organ if old panel format) to which belongs the given object UID
        # returns None if it has no parent panel

        if object_uid[:5] == 'Panel':
            if len(object_uid) == 8:
                # Panel999 : it has no parent panel
                parent_panel_uid = None
            else:
                # Panel999NNNNN999
                parent_panel_uid = object_uid[:8]
        else:
            # the object UID is not Panel999 or Panel999Element999, so it is necessarily displayed in the main panel
            if self.new_panel_format_bool:
                parent_panel_uid = 'Panel000'
            else:
                parent_panel_uid = 'Organ'

        return parent_panel_uid

    #-------------------------------------------------------------------------------------------------
    def object_parent_manual_get(self, object_uid):
        # returns the UID of the manual (Manual999) to which belongs the given object UID
        # returns None if it has no parent manuel

        for parent_uid in self.object_kinship_list_get(object_uid, TO_PARENT):
            if parent_uid[:6] == 'Manual':
                return parent_uid

        return None

    #-------------------------------------------------------------------------------------------------
    def object_kinship_list_add(self, object_uid, ref_object_uid, relationship):
        # add in the parents/children list of the given object UID the given referenced object UID
        # the given relationship must be TO_PARENT or TO_CHILD

        object_dic = self.object_dic_get(object_uid)
        if object_dic != None:
            ref_object_dic = self.object_dic_get(ref_object_uid)
            if ref_object_dic != None:
                # both the given object and referenced object are defined
                if relationship == TO_CHILD:
                    # the target object is child of the given object
                    if ref_object_uid not in object_dic['children']: object_dic['children'].append(ref_object_uid)
                    if object_uid     not in ref_object_dic['parents']:  ref_object_dic['parents'].append(object_uid)
                elif relationship == TO_PARENT:
                    # the target object is parent of the given object
                    if ref_object_uid not in object_dic['parents']:  object_dic['parents'].append(ref_object_uid)
                    if object_uid     not in ref_object_dic['children']: ref_object_dic['children'].append(object_uid)
                else:
                    logs.add('INTERNAL ERROR undefined link type given to object_kinship_list_add')
            else:
                logs.add(f'WARNING cannot link {object_uid} to {ref_object_uid} which does not exist')

    #-------------------------------------------------------------------------------------------------
    def object_kinship_list_get(self, object_uid, relationship, object_type=None):
        # get the parents/children list of the given object UID
        # if an object type is given only the objects of this type are returned
        # the given relationship must be TO_PARENT or TO_CHILD

        object_dic = self.object_dic_get(object_uid)
        if object_dic != None:
            if relationship == TO_PARENT:
                kinship_list = list(object_dic['parents'])
            elif relationship == TO_CHILD:
                kinship_list = list(object_dic['children'])
            else:
                logs.add('INTERNAL ERROR undefined link type given to object_kinship_link_get')
                kinship_list = []
        else:
            kinship_list = []

        if object_type != None:
            for obj_uid in list(kinship_list):  # scan a copy of the list in which elements may be removed
                if self.object_type_get(obj_uid) != object_type:
                    kinship_list.remove(obj_uid)

        return kinship_list

    #-------------------------------------------------------------------------------------------------
    def objects_kinship_update(self):
        # update the kinship links between the objects of the ODF dictionary

        for object_uid, object_dic in self.odf_data_dic.items():
            # scan the objects of the ODF dictionary to reset their internal attributes
            object_dic['names'] = []
            object_dic['parents'] = []
            object_dic['children'] = []

        for object_uid, object_dic in self.odf_data_dic.items():
            # scan the objects of the ODF dictionary to define their parent/child kinship links and their name to display in the objects list/tree
            object_type = self.object_type_get(object_uid)

            for line in object_dic['lines']:
                # scan the lines of the current object to detect links toward other objects or names to display
                (error_msg, attr_name, attr_value, comment) = self.object_line_split(line)
                if attr_name != None and attr_value != None and attr_value != '':
                    # the attribute has a name and a value

                    # get possible names to display in the objects list/tree
                    if attr_name in ['Name', 'ChurchName', 'Comment'] or attr_name[-4:] == 'Text':
                        object_name = attr_value
                    elif object_type == 'PanelImage' and attr_name == 'Image':
                        # image attribute, the value is the path of the image : keep from the image path only the file name (string after the last separator character)
                        object_name = path2ospath(attr_value)
                        path_elements_list = object_name.split(os.sep)
                        object_name = path_elements_list[len(path_elements_list)-1]
                    else:
                        object_name = None
                    # add the found name in the names list of the current object
                    if object_name != None:
                        object_dic['names'].append(object_name)

                    if attr_name[-3:].isdigit() and (attr_value.isdigit() or (len(attr_value) > 0 and attr_value[0] == '-' and attr_value[1:].isdigit())):
                        # attribute which ends with 3 digits (like Coupler999) : it contains in its value the reference to another object
                        # link the current object to the referenced object as child
                        ref_object_type = attr_name[:-3]
                        if object_type == 'General':
                            if ref_object_type[-6:] == 'Number'  : ref_object_type = ref_object_type[:-6]  # remove the string 'Number'
                            elif ref_object_type[-6:] == 'Manual': ref_object_type = None
                        if ref_object_type not in (None, 'MIDIKey', 'DisplayKey'):
                            ref_object_uid = ref_object_type + str(abs(int(attr_value))).zfill(3)
                            self.object_kinship_list_add(object_uid, ref_object_uid, TO_CHILD)

                    elif attr_name == 'WindchestGroup' and attr_value.isdigit():
                        # attribute WindchestGroup : it contains in its value the reference to a WindchestGroup
                        # link the current object to the referenced WindchestGroup as parent
                        ref_object_uid = attr_name + str(int(attr_value)).zfill(3)
                        self.object_kinship_list_add(object_uid, ref_object_uid, TO_PARENT)

                    elif object_type == 'PanelElement' and attr_name in self.go_objects_children_dic['PanelElement']:
                        # Panel999Element999 object with a reference to a child object
                        # link the current object to the child object
                        ref_object_uid = attr_name + str(int(attr_value)).zfill(3)
                        self.object_kinship_list_add(object_uid, ref_object_uid, TO_CHILD)

                    elif object_type == 'Coupler' and attr_name == 'DestinationManual':
                        # link the coupler to the destination manual as child
                        ref_object_uid = 'Manual' + str(int(attr_value)).zfill(3)
                        self.object_kinship_list_add(object_uid, ref_object_uid, TO_CHILD)

            if object_type.startswith('Panel') and len(object_type) > 5:
                # Panel999xxxx object type
                # link the current object to its Panel parent
                panel_uid = object_uid[:8]
                self.object_kinship_list_add(object_uid, panel_uid, TO_PARENT)

                # add to the object names the name of its parent panel
                panel_dic = self.object_dic_get(panel_uid)
                if panel_dic != None:
                    name = self.object_attr_value_get(panel_dic, 'Name')
                    if name not in (None, ''):
                        object_dic['names'].append(name)

                # add to the object names the UID of the referenced child object element if any or the type of the element
                if object_type == 'PanelElement':
                    ref_object_type = self.object_attr_value_get(object_dic, 'Type')
                    ref_object_id = self.object_attr_value_get(object_dic, ref_object_type)
                    if ref_object_id != None:
                        # generate the UID of the referenced object
                        ref_object_uid = ref_object_type + str(int(ref_object_id)).zfill(3)
                        ref_object_dic = self.object_dic_get(ref_object_uid)
                        if ref_object_dic != 'None':
                            # get the name of the referenced object
                            ref_object_name = self.object_attr_value_get(ref_object_dic, 'Name')
                            if ref_object_name != None:
                                # add this name to the PanelElement names list
                                object_dic['names'].insert(0, ref_object_name)
                                object_dic['names'].insert(0, ref_object_uid)
                    else:
                        object_dic['names'].insert(0, ref_object_type)

    #-------------------------------------------------------------------------------------------------
    def object_organ_numbers_update(self, object_uid):
        # update in the Organ object the NumberOf attribute corresponding to the given object

        object_type = self.object_type_get(object_uid)

        if object_type == 'Switch':
            nb_of_attr_name = 'NumberOfSwitches'
        elif object_type in ('Enclosure', 'General', 'Manual', 'Panel', 'Rank', 'Tremulant', 'WindchestGroup'):
            nb_of_attr_name = 'NumberOf' + object_type + 's'
        else:
            nb_of_attr_name = None

        if nb_of_attr_name != None:
            nb = self.objects_type_number_get(object_type)
            if ((object_type == 'Manual' and 'Manual000' in self.odf_data_dic.keys()) or
                (object_type == 'Panel' and 'Panel000' in self.odf_data_dic.keys())):
                # Manual000 and Panel000 are not counted
                    nb -= 1
            if self.object_attr_value_set('Organ', nb_of_attr_name, nb):
                logs.add(f'Organ : attribute {nb_of_attr_name} updated')

    #-------------------------------------------------------------------------------------------------
    def objects_number_get(self):
        # return the total number of objects defined in the ODF data

        return len(self.odf_data_dic)

    #-------------------------------------------------------------------------------------------------
    def objects_type_number_get(self, object_type):
        # return the number of objects defined in the ODF data having the given type (Manual, Enclosure, PanelElement, PanelImage, ...)
        # if the given type is Panel999Element or Panel999Image, returns the number of defined Panel999Element or Panel999Image objects

        # check if Panel999Element or Panel999Image type is given
        nb_in_panel_bool = (object_type[:5] == 'Panel' and object_type[5:8].isdigit and len(object_type) > 8)

        number = 0
        for object_uid in self.odf_data_dic.keys():
            # scan the objects of the ODF data
            if ((nb_in_panel_bool and object_uid.startswith(object_type)) or
                (not nb_in_panel_bool and self.object_type_get(object_uid) == object_type)):
                number += 1

        return number

    #-------------------------------------------------------------------------------------------------
    def objects_list_get(self):
        # return the list of the objects UID of the ODF data

        return list(self.odf_data_dic.keys())

    #-------------------------------------------------------------------------------------------------
    def object_poss_kinship_list_get(self, object_uid):
        # return two lists in a tuple : the one with the objects UID of the ODF data which can be possibly parent of the given object UID
        #                               the one with the objects UID of the ODF data which can be possibly children of the given object UID

        object_dic = self.object_dic_get(object_uid)
        if object_dic == None: return ([], [])

        object_type = self.object_type_get(object_uid)
        parents_list = []
        children_list = []

        if object_type in ('Header', 'Organ'):
            # no parent and no child for these object types
            return (parents_list, children_list)

        # recover the lists of possible parents/children object types for the given object type
        parent_types_list = list(self.go_objects_parents_dic[object_type])
        child_types_list = list(self.go_objects_children_dic[object_type])

        # if the given object is a Stop not refering to a WindchestGroup (it has not a rank defined inside), remove the WindchestGroup parent
        if object_type == 'Stop' and self.object_attr_value_get(object_dic, 'WindchestGroup') == None:
            parent_types_list.remove('WindchestGroup')

        # recover from the ODF data the objects UID which have a type which can be parent/child of the given object
        for obj_uid in self.odf_data_dic.keys():
            # scan the objects of the ODF dictionary
            obj_type = self.object_type_get(obj_uid)
            if obj_type in parent_types_list and obj_uid != object_uid:
                # the current object has a type which can be parent of the given object
                if obj_type == 'PanelElement':
                    if self.object_attr_value_get(obj_uid, 'Type') == object_type:
                        parents_list.append(obj_uid)
                else:
                    parents_list.append(obj_uid)
            if obj_type in child_types_list and obj_uid != object_uid:
                # the current object has a type which can be child of the given object
                children_list.append(obj_uid)

        return (parents_list, children_list)

    #-------------------------------------------------------------------------------------------------
    def object_poss_children_type_list_get(self, object_uid):
        # return the list of the object types which can be possibly children of the given object or which doesn't need a parent (Header and Organ if not already existing)

        object_dic = self.object_dic_get(object_uid)
        object_type = self.object_type_get(object_uid)

        # define the objects types which can be created as child of the given object type
        if   object_type == 'Organ':   child_types_list = ['General', 'Manual', 'Panel', 'WindchestGroup']
        elif object_type == 'Coupler': child_types_list = ['Switch']
        elif object_type == 'General': child_types_list = ['Switch']
        elif object_type == 'Manual':  child_types_list = ['Coupler', 'Divisional', 'Stop', 'Switch', 'Tremulant']
        elif object_type == 'Panel':   child_types_list = ['PanelElement', 'PanelImage']
        elif object_type == 'PanelElement': child_types_list = ['Coupler', 'Divisional', 'DivisionalCoupler', 'Enclosure', 'General', 'Manual', 'Stop', 'Tremulant']
        elif object_type == 'Stop':    child_types_list =   ['Rank', 'Switch']
        elif object_type == 'Switch':  child_types_list = ['Switch']
        elif object_type == 'Tremulant':      child_types_list = ['Switch']
        elif object_type == 'WindchestGroup': child_types_list = ['Enclosure', 'Stop', 'Rank', 'Tremulant']
        else: child_types_list = []

        # if the given object is a Stop refering to a WindchestGroup (it has a rank defined inside), remove the Rank child
        if object_type == 'Stop' and self.object_attr_value_get(object_dic, 'WindchestGroup') != None:
            child_types_list.remove('Rank')

        # if the given object is a PanelElement with a type defined and it is the type of an object, let only this type in the child types list
        if object_type == 'PanelElement':
            element_type = self.object_attr_value_get(object_dic, 'Type')
            if element_type != None:
                if element_type in child_types_list:
                    # the element type is one of the possible children of a PanelElement
                    child_types_list.clear()
                    child_types_list.append(element_type)
                else:
                    child_types_list.clear()

        return child_types_list

#-------------------------------------------------------------------------------------------------
class C_ODF_HW2GO():
    # class to manage the conversion of a Hauptwerk ODF in a GrandOrgue ODF

    HW_sample_set_path = ''     # path of the folder containing the loaded Hauptwerk sample set (which contains the sub-folders OrganDefinitions and OrganInstallationPackages)
    HW_sample_set_odf_path = '' # path of the folder containing the ODF of the loaded Hauptwerk sample set (folder OrganDefinitions)
    HW_odf_file_name = ''   # path of the loaded Hauptwerk ODF (which is inside the sub-folder OrganDefinitions)

    silent_loop_file_used = False  # flag to indicate that the file SilentLoop.wav is used by a built GO Stop

    HW_odf_dic = {}  # dictionary in which are stored the data of the loaded Hauptwerk ODF file (XML file)
                     # it has the following structure with three nested dictionaries :
                     #   {ObjectType:                      -> string, for example _General, KeyImageSet, DisplayPage
                     #       {ObjectID:                    -> integer, from 1 to 999999, recovered from the HW ODF objects ID when possible, else set by increment
                     #           {Attribute: Value, ...},  -> string: string
                     #        ...
                     #       },
                     #       ...
                     #    ...
                     #   }
                     # the ObjectUID (unique ID) is a string made by the concatenation of the ObjectType and the ObjectID on 6 digits, for example DisplayPage000006
                     # exception : the ObjectType _General has the ObjectUID _General

    GO_odf_dic = {}  # dictionary in which are stored the data of the GrandOrgue ODF built from the Hauptwerk ODF dictionary
                     # it has the following structure with two nested dictionaries :
                     #   {ObjectUID:                   -> string, for example Organ, Panel001, Rank003
                     #       {Attribute: Value, ...}   -> string: string or integer if number / dimension / code
                     #    ...
                     #   }

    HW_odf_attr_dic = {} # dictionary which contains the definition of the various HW object types and their attributes (loaded from the file HwObjectsAttributesDict.txt)
                         # it has the following structure with two nested dictionaries :
                         #   {ObjectType:                                  -> string, for example _General, KeyImageSet, DisplayPage
                         #       {AttributeLetter: AttributeFullName, ...} -> string: string
                         #    ...
                         #   }

    HW_looping_switches_lists = []  # list containing sub-lists with the ensemble of HW switch which are controlling each other in loop

    available_HW_packages_id_list = []  # list storing the ID of the installation packages which are actually accessible in the sample set package

    HW_default_display_page_dic = None # dictionary of the HW default display page (which is displayed by default on organ loading and will be the GO Panel000)
    HW_console_display_page_dic = None # dictionary of the HW console display page (which contains the displayed keyboards, can be different from the default display page)

    HW_general_dic = None  # dictionary of the HW _General object

    alt_rank_status = None # value indicating how to manage the alterante ranks : 'integrated', 'separated' or None

    # flag saying if the alternate ranks have to be converted and taken as alternate rank in the main stop/rank which they are the alternate rank
    alt_rank_integrated = None

    # flag saying if the alternate ranks have to be converted and taken as main stop/rank controlled in opposite of the main rank which they are the alternate rank
    alt_rank_separated = None

    progress_status_show_function = None # address of a callback function to call to show a progression message during the ODF building

    GO_object_ext_ID = 800

    #-------------------------------------------------------------------------------------------------
    def reset_all_data(self):
        # reset all the data of the class, except the HW_odf_attr_dic dictionary

        self.HW_odf_dic.clear()
        self.HW_looping_switches_lists.clear()
        self.GO_odf_dic.clear()
        self.available_HW_packages_id_list = []
        self.HW_odf_file_name = ''
        self.HW_sample_set_path = ''
        self.silent_loop_file_used = False

    #-------------------------------------------------------------------------------------------------
    def HW_ODF_load_from_file(self, file_name):
        # fill the Hauptwerk ODF dictionary from the data of the given Hauptwerk ODF XML file
        # return True or False whether the operation has succeeded or not

        """
        the considered Hauptwerk ODF XML syntax is :

        <Hauptwerk FileFormat="Organ" FileFormatVersion="xxxxxx">
            <ObjectList ObjectType="ObjectTypeName">
                <"ObjectTypeName">
                    <"Attribute1">Value</"Attribute1">
                    <"Attribute2">Value</"Attribute2">
                    ...
                </"ObjectTypeName">
                ...
                <o>                    -> compressed format
                    <a>Value</a>
                    <b>Value</b>
                    ...
                </o>
                ...
            </ObjectList>
               ...
        </Hauptwerk>

        the attributes letters are converted to attributes full name thanks to the dictionary HW_odf_attr_dic
        """

        file_name = path2ospath(file_name)

        # check the extension of the given file name
        filename_str, file_extension_str = os.path.splitext(file_name)
        if file_extension_str != '.Organ_Hauptwerk_xml' and file_extension_str != '.xml':
            logs.add(f'ERROR : The file "{file_name}" does not have the expected extension .xml or .Organ_Hauptwerk_xml')
            return False

        # check the existence of the given file name
        if not(os.path.isfile(file_name)):
            logs.add(f'ERROR : The file "{file_name}" does not exist')
            return False

        # load the dictionary HwObjectsAttributesDict if not already loaded
        if not self.HW_ODF_attr_dic_file_load():
            # error occurred while loading the dictionary
            return False

        # load the content of the HW XML file as an elements tree
        HW_ODF_xml_tree = etree.parse(file_name, etree.XMLParser(remove_comments=True))

        # check that it is actually an Hauptwerk ODF and recover the file format version
        HW_xml_id_tag_str = HW_ODF_xml_tree.xpath("/Hauptwerk")
        HW_file_format_str = HW_xml_id_tag_str[0].get("FileFormat")
        HW_file_format_version_str = HW_xml_id_tag_str[0].get("FileFormatVersion")
        if HW_file_format_str != 'Organ':
            # it is not an ODF
            logs.add(f'ERROR : The file "{file_name}" is not a supported Hauptwerk organ definition file')
            return False

        object_type_nb_int = 0  # total number of object types found
        object_elem_nb_int = 0  # total number of object elements found
        object_attr_nb_int = 0  # total number of object attributes found
        for xml_object_type in HW_ODF_xml_tree.xpath("/Hauptwerk/ObjectList"):
            # scan the object types defined in the XML file (in the tags <ObjectList ObjectType="xxxx">)
            object_type_nb_int += 1

            # recover the name of the current object type
            HW_object_type = xml_object_type.get("ObjectType")

            if HW_object_type not in self.HW_odf_attr_dic.keys():
                # the recovered HW object type is not known in the HW ODF types/attributes dictionary
                # it can be due to a problem of characters case in the XML, tries to recover the correct object name characters case from the dictionary
                for HW_obj_type in self.HW_odf_attr_dic.keys():
                    if HW_object_type.upper() == HW_obj_type.upper():
                        HW_object_type = HW_obj_type
                        break

            self.progress_status_show_function(f'Loading the Hauptwerk ODF... {HW_object_type}')

            # create an entry in the HW dictionary for the current object type
            object_type_dic = self.HW_odf_dic[HW_object_type] = {}

            if HW_object_type in self.HW_odf_attr_dic.keys():
                # the current object type is defined in the HW attributes dictionary
                # get the dictionary defining the attributes of the current object type
                object_type_attr_dic = self.HW_odf_attr_dic[HW_object_type]
                # recover the name of the attribute of the object elements of the current object type which define the ID of each element, if it exists
                object_id_attr_name_str = object_type_attr_dic['IDattr']

                object_id_counter_int = 0  # ID which can be assigned to the current object element inside the current object type if it has not an ID defined in the attributes
                for xml_object_element in xml_object_type:
                    # scan the object elements defined in the current object type
                    object_elem_nb_int += 1
                    object_id_counter_int += 1
                    object_id_int = 0

                    # create a new object element dictionary
                    object_dic = {}

                    # add at the beginning of the current object element dictionary some custom attributes used for the GO ODF building
                    object_dic['_HW_uid'] = ''  # Unique ID of the HW object
                    object_dic['_GO_uid'] = ''  # Unique ID of the corresponding built GO object
                    object_dic['_parents'] = []   # list of the parent HW objects dictionaries
                    object_dic['_children'] = []  # list of the children HW objects dictionaries

                    for xml_object_attribute in xml_object_element:
                        # scan the attributes defined in the current object element
                        object_attr_nb_int += 1
                        attribute_name_str = xml_object_attribute.tag
                        attribute_value_str = xml_object_attribute.text

                        if attribute_value_str != '' and attribute_value_str != None:
                            # the attributes with an empty or undefined value are ignored
                            if len(attribute_name_str) <= 2:
                                # the attribute name is defined by a tag of one or two characters (this is the Hauptwerk XML compressed format)
                                # recover the attribute long name corresponding to this tag
                                try:
                                    attribute_name_str = object_type_attr_dic[attribute_name_str]
                                except:
                                    # no attribute long name known
                                    attribute_name_str = attribute_name_str + '???'

                            # add the current attribute name and value to the current object
                            object_dic[attribute_name_str] = attribute_value_str

                            if object_id_int == 0 and object_id_attr_name_str != '' and attribute_name_str == object_id_attr_name_str:
                                # the current attribute is the attribute which contains the ID of the object in the current object type
                                if not attribute_value_str.isnumeric():
                                    logs.add(f'ERROR : attribute {attribute_name_str}={attribute_value_str} has not a numeric value in the object {HW_object_type} #{object_id_counter_int}')
                                else:
                                    object_id_int = int(attribute_value_str)

                    if object_id_int == 0:
                        # no object ID recovered from the attributes
                        if object_id_attr_name_str != '':
                            # the object should have had an ID attribute
                            logs.add(f'ERROR : attribute {object_id_attr_name_str} not found in the object {HW_object_type} #{object_id_counter_int}')
                        # use as object ID the objects counter
                        object_id_int = object_id_counter_int

                    # store in the object its UID (unique ID)
                    if HW_object_type == '_General':
                        object_dic['_HW_uid'] = '_General'
                    else:
                        object_dic['_HW_uid'] = HW_object_type + str(object_id_int).zfill(6)

                    if object_id_int in object_type_dic.keys():
                        logs.add(f'WARNING: HW object {object_dic["_HW_uid"]} has an ID which is not unique !')

                    # add the object dictionary to the current object type dictionary
                    object_type_dic[object_id_int] = object_dic

            else:
                logs.add(f'INTERNAL ERROR : object type {HW_object_type} unknown in the HW attributes dictionary')

        logs.add(f'Hauptwerk ODF loaded "{file_name}"')
        logs.add(f'Hauptwerk organ file format version {HW_file_format_version_str}')
        logs.add(f'{object_attr_nb_int:,} attributes among {object_elem_nb_int:,} sections among {object_type_nb_int} section types')

        self.HW_odf_file_name = path2ospath(file_name)
        self.HW_sample_set_path = path2ospath(os.path.dirname(os.path.dirname(file_name)))
        self.HW_sample_set_odf_path = self.HW_sample_set_path + os.sep + 'OrganDefinitions'

        return True

    #-------------------------------------------------------------------------------------------------
    def HW_ODF_attr_dic_file_load(self):
        # load the Hauptwerk attributes dictionary from the file HwObjectsAttributesDict.txt (if it is present and there is no error)
        # return True or False whether the operation has succeeded or not

        if len(self.HW_odf_attr_dic) == 0:
            # the dictionary has not been loaded yet

            file_name = os.path.dirname(__file__) + os.sep + 'resources' + os.sep + 'HwObjectsAttributesDict.txt'

            try:
                with open(file_name, 'r') as f:
                    self.HW_odf_attr_dic = eval(f.read())
                    return True
            except OSError as err:
                # it has not be possible to open the file
                logs.add(f'ERROR Cannot open the file "{file_name}" : {err}')
            except SyntaxError as err:
                # syntax error in the dictionary structure which is in the file
                logs.add(f'ERROR Syntax error in the file "{file_name}" : {err}')
            except:
                # other error
                logs.add(f'ERROR while opening the file "{file_name}"')

            return False

        else:
            return True

    #-------------------------------------------------------------------------------------------------
    def HW_ODF_do_links_between_objects(self):
        # set in the Hauptwerk ODF dictionary the relationships (parent, children) between the various objects
        # add in the objects of the HW_odf_dic the attributes "_parents" and "_children" with as value the list of the respective parent or child objects

        HW_general_object_dic = None
        HW_object_type = '_General'
        self.progress_status_show_function(f'Building the Hauptwerk ODF objects tree... {HW_object_type}')
        if HW_object_type in self.HW_odf_dic.keys():
            for HW_object_dic in self.HW_odf_dic[HW_object_type].values():
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'OrganInfo_InstallationPackageID', 'RequiredInstallationPackage', TO_CHILD)
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'SpecialObjects_DefaultDisplayPageID', 'DisplayPage', TO_CHILD)
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'SpecialObjects_MasterCaptureSwitchID', 'Switch', TO_CHILD)
                HW_general_object_dic = HW_object_dic
        if HW_general_object_dic == None:
            logs.add('ERROR : no _General object defined in the Hauptwerk ODF')
            return False

        HW_object_type = 'DivisionInput'
        self.progress_status_show_function(f'Building the Hauptwerk ODF objects tree... {HW_object_type}')
        if HW_object_type in self.HW_odf_dic.keys():
            for HW_object_dic in self.HW_odf_dic[HW_object_type].values():
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'DivisionID', 'Division', TO_PARENT)
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'SwitchID', 'Switch', TO_PARENT)

        HW_object_type = 'Keyboard'
        self.progress_status_show_function(f'Building the Hauptwerk ODF objects tree... {HW_object_type}')
        if HW_object_type in self.HW_odf_dic.keys():
            for HW_object_dic in self.HW_odf_dic[HW_object_type].values():
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'KeyGen_DisplayPageID', 'DisplayPage', TO_PARENT)
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'KeyGen_KeyImageSetID', 'KeyImageSet',  TO_CHILD)
                # link the keyboard to its division
                HW_division_dic = self.HW_ODF_get_object_by_ref_id('Division', HW_object_dic, 'Hint_PrimaryAssociatedDivisionID')
                if HW_division_dic == None:
                    # find the division ID from the keyboard code, supposing to the following matching :
                    #     keyboard code 1 = division 1 = Pedal
                    #     keyboard code 2 = division 2 = Manual 1
                    #     keyboard code 3 = division 3 = Manual 2
                    #     ...
                    HW_division_dic = self.HW_ODF_get_object_by_ref_id('Division', HW_object_dic, 'DefaultInputOutputKeyboardAsgnCode')
                if HW_division_dic != None:
                    self.HW_ODF_do_link_between_obj(HW_object_dic, HW_division_dic, TO_PARENT)

        HW_object_type = 'KeyAction'
        self.progress_status_show_function(f'Building the Hauptwerk ODF objects tree... {HW_object_type}')
        if HW_object_type in self.HW_odf_dic.keys():
            for HW_object_dic in self.HW_odf_dic[HW_object_type].values():
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'SourceKeyboardID', 'Keyboard', TO_PARENT)
                HW_cond_switch_dic = self.HW_ODF_get_attribute_value(HW_object_dic, 'ConditionSwitchID')
                if self.HW_ODF_get_attribute_value(HW_object_dic, 'DestDivisionID') != None:
                    # the key action destination is a division
                    self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'DestDivisionID', 'Division', TO_CHILD)
                    # link directly the source keyboard to the destination division if there is no conditional switch
                    # this link may have been done already while processing the Keyboard objects above
                    if HW_cond_switch_dic == None:
                        HW_source_keyboard_dic = self.HW_ODF_get_object_by_ref_id('Keyboard', HW_object_dic, 'SourceKeyboardID')
                        HW_dest_division_dic = self.HW_ODF_get_object_by_ref_id('Division', HW_object_dic, 'DestDivisionID')
                        self.HW_ODF_do_link_between_obj(HW_source_keyboard_dic, HW_dest_division_dic, TO_PARENT)
                else:
                    # the key action destination is a keyboard
                    self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'DestKeyboardID', 'Keyboard', TO_CHILD)
                    # link directly the source keyboard to the destination keyboard
                    # this link may have been done already while processing the Keyboard objects above
                    if HW_cond_switch_dic == None:
                        HW_source_keyboard_dic = self.HW_ODF_get_object_by_ref_id('Keyboard', HW_object_dic, 'SourceKeyboardID')
                        HW_dest_keyboard_dic = self.HW_ODF_get_object_by_ref_id('Keyboard', HW_object_dic, 'DestKeyboardID')
                        self.HW_ODF_do_link_between_obj(HW_source_keyboard_dic, HW_dest_keyboard_dic, TO_CHILD)
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'ConditionSwitchID', 'Switch', TO_PARENT)

        HW_object_type = 'KeyboardKey'
        self.progress_status_show_function(f'Building the Hauptwerk ODF objects tree... {HW_object_type}')
        if HW_object_type in self.HW_odf_dic.keys():
            for HW_object_dic in self.HW_odf_dic[HW_object_type].values():
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'KeyboardID', 'Keyboard', TO_PARENT)
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'SwitchID', 'Switch', TO_PARENT)

        HW_object_type = 'KeyImageSet'
        self.progress_status_show_function(f'Building the Hauptwerk ODF objects tree... {HW_object_type}')
        if HW_object_type in self.HW_odf_dic.keys():
            for HW_object_dic in self.HW_odf_dic[HW_object_type].values():
                for obj_attr_name in list(HW_object_dic.keys()):
                    if obj_attr_name.startswith('KeyShapeImageSetID'):
                        self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, obj_attr_name, 'ImageSet', TO_CHILD)

        HW_object_type = 'ImageSetElement'
        self.progress_status_show_function(f'Building the Hauptwerk ODF objects tree... {HW_object_type}')
        if HW_object_type in self.HW_odf_dic.keys():
            for HW_object_dic in self.HW_odf_dic[HW_object_type].values():
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'ImageSetID', 'ImageSet', TO_PARENT)

        HW_object_type = 'TextInstance'
        self.progress_status_show_function(f'Building the Hauptwerk ODF objects tree... {HW_object_type}')
        if HW_object_type in self.HW_odf_dic.keys():
            for HW_object_dic in self.HW_odf_dic[HW_object_type].values():
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'DisplayPageID', 'DisplayPage', TO_PARENT)
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'TextStyleID', 'TextStyle', TO_CHILD)
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'AttachedToImageSetInstanceID', 'ImageSetInstance', TO_CHILD)

        HW_object_type = 'Switch'
        self.progress_status_show_function(f'Building the Hauptwerk ODF objects tree... {HW_object_type}')
        if HW_object_type in self.HW_odf_dic.keys():
            for HW_object_dic in self.HW_odf_dic[HW_object_type].values():
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'Disp_ImageSetInstanceID', 'ImageSetInstance', TO_CHILD)
                # if the Switch is linked to an ImageSetInstance object, link it to the DisplayPage in which it is displayed
                HW_image_set_inst_dic = self.HW_ODF_get_object_by_ref_id('ImageSetInstance', HW_object_dic, 'Disp_ImageSetInstanceID')
                if HW_image_set_inst_dic != None:
                    HW_display_page_dic = self.HW_ODF_get_object_by_ref_id('DisplayPage', HW_image_set_inst_dic, 'DisplayPageID')
                    self.HW_ODF_do_link_between_obj(HW_object_dic, HW_display_page_dic, TO_PARENT)

        HW_object_type = 'SwitchLinkage'
        self.progress_status_show_function(f'Building the Hauptwerk ODF objects tree... {HW_object_type}')
        if HW_object_type in self.HW_odf_dic.keys():
            for HW_object_dic in self.HW_odf_dic[HW_object_type].values():
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'SourceSwitchID', 'Switch', TO_PARENT)
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'DestSwitchID', 'Switch', TO_CHILD)
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'ConditionSwitchID', 'Switch', TO_PARENT)
                if DEV_MODE:
                    # only in development mode to speed up the links creation in application mode, this parent/child association is not used to convert the HW to GO ODF
                    # make direct link between source and destination switches
                    HW_source_switch_dic = self.HW_ODF_get_object_by_ref_id('Switch', HW_object_dic, 'SourceSwitchID')
                    HW_dest_switch_dic = self.HW_ODF_get_object_by_ref_id('Switch', HW_object_dic, 'DestSwitchID')
                    HW_cond_switch_dic = self.HW_ODF_get_object_by_ref_id('Switch', HW_object_dic, 'ConditionSwitchID')
                    if HW_source_switch_dic != None and HW_dest_switch_dic != None :
                        self.HW_ODF_do_link_between_obj(HW_source_switch_dic, HW_dest_switch_dic, TO_CHILD)
                        if HW_cond_switch_dic != None:
                            self.HW_ODF_do_link_between_obj(HW_cond_switch_dic, HW_dest_switch_dic, TO_CHILD)

        HW_object_type = 'SwitchExclusiveSelectGroupElement'
        self.progress_status_show_function(f'Building the Hauptwerk ODF objects tree... {HW_object_type}')
        if HW_object_type in self.HW_odf_dic.keys():
            for HW_object_dic in self.HW_odf_dic[HW_object_type].values():
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'SwitchID', 'Switch', TO_CHILD)
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'GroupID', 'SwitchExclusiveSelectGroup', TO_PARENT)

        HW_object_type = 'WindCompartment'
        self.progress_status_show_function(f'Building the Hauptwerk ODF objects tree... {HW_object_type}')
        if HW_object_type in self.HW_odf_dic.keys():
            for HW_object_dic in self.HW_odf_dic[HW_object_type].values():
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'PressureOutputContinuousControlID', 'ContinuousControl', TO_PARENT)

        HW_object_type = 'WindCompartmentLinkage'
        self.progress_status_show_function(f'Building the Hauptwerk ODF objects tree... {HW_object_type}')
        if HW_object_type in self.HW_odf_dic.keys():
            for HW_object_dic in self.HW_odf_dic[HW_object_type].values():
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'FirstWindCompartmentID', 'WindCompartment', TO_PARENT)
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'SecondWindCompartmentID', 'WindCompartment', TO_CHILD)
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'ValveControllingContinuousControlID', 'ContinuousControl', TO_PARENT)
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'ValveControllingSwitchID', 'Switch', TO_PARENT)
                if DEV_MODE:
                    # make direct link between source and destination wind compartments
                    HW_first_wind_comp_dic = self.HW_ODF_get_object_by_ref_id('WindCompartment', HW_object_dic, 'FirstWindCompartmentID')
                    HW_second_wind_comp_dic = self.HW_ODF_get_object_by_ref_id('WindCompartment', HW_object_dic, 'SecondWindCompartmentID')
                    if HW_first_wind_comp_dic != None and HW_second_wind_comp_dic != None :
                        self.HW_ODF_do_link_between_obj(HW_first_wind_comp_dic, HW_second_wind_comp_dic, TO_CHILD)

        HW_object_type = 'Stop'
        self.progress_status_show_function(f'Building the Hauptwerk ODF objects tree... {HW_object_type}')
        if HW_object_type in self.HW_odf_dic.keys():
            for HW_object_dic in self.HW_odf_dic[HW_object_type].values():
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'DivisionID', 'Division', TO_PARENT)
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'ControllingSwitchID', 'Switch', TO_PARENT)
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'Hint_PrimaryAssociatedRankID', 'Rank', TO_CHILD)

        HW_object_type = 'StopRank'
        self.progress_status_show_function(f'Building the Hauptwerk ODF objects tree... {HW_object_type}')
        if HW_object_type in self.HW_odf_dic.keys():
            for HW_object_dic in self.HW_odf_dic[HW_object_type].values():
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'StopID', 'Stop', TO_PARENT)
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'RankID', 'Rank', TO_CHILD)
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'SwitchIDToSwitchToAlternateRank', 'Switch', TO_PARENT)
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'AlternateRankID', 'Rank', TO_CHILD)

        HW_object_type = 'Combination'
        self.progress_status_show_function(f'Building the Hauptwerk ODF objects tree... {HW_object_type}')
        if HW_object_type in self.HW_odf_dic.keys():
            for HW_object_dic in self.HW_odf_dic[HW_object_type].values():
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'ActivatingSwitchID', 'Switch', TO_PARENT)

        HW_object_type = 'CombinationElement'
        self.progress_status_show_function(f'Building the Hauptwerk ODF objects tree... {HW_object_type}')
        if HW_object_type in self.HW_odf_dic.keys():
            for HW_object_dic in self.HW_odf_dic[HW_object_type].values():
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'CombinationID', 'Combination', TO_PARENT)
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'ControlledSwitchID', 'Switch', TO_CHILD)
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'CapturedSwitchID', 'Switch', TO_CHILD)
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'MemorySwitchID', 'Switch', TO_CHILD)

        HW_object_type = 'Pipe_SoundEngine01'
        self.progress_status_show_function(f'Building the Hauptwerk ODF objects tree... {HW_object_type}')
        if HW_object_type in self.HW_odf_dic.keys():
            for HW_object_dic in self.HW_odf_dic[HW_object_type].values():
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'RankID', 'Rank', TO_PARENT)
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'ControllingPalletSwitchID', 'Switch', TO_PARENT)
                if DEV_MODE:
                    # only in development mode to speed up the links creation in application mode, this parent/child association is not used to convert the HW to GO ODF
                    self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'WindSupply_SourceWindCompartmentID', 'WindCompartment', TO_PARENT)
                    self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'WindSupply_OutputWindCompartmentID', 'WindCompartment', TO_CHILD)

        HW_object_type = 'Pipe_SoundEngine01_Layer'
        self.progress_status_show_function(f'Building the Hauptwerk ODF objects tree... {HW_object_type}')
        if HW_object_type in self.HW_odf_dic.keys():
            for HW_object_dic in self.HW_odf_dic[HW_object_type].values():
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'PipeID', 'Pipe_SoundEngine01', TO_PARENT)
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'AmpLvl_ScalingContinuousControlID', 'ContinuousControl', TO_PARENT)

        HW_object_type = 'Pipe_SoundEngine01_AttackSample'
        self.progress_status_show_function(f'Building the Hauptwerk ODF objects tree... {HW_object_type}')
        if HW_object_type in self.HW_odf_dic.keys():
            for HW_object_dic in self.HW_odf_dic[HW_object_type].values():
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'LayerID', 'Pipe_SoundEngine01_Layer', TO_PARENT)
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'SampleID', 'Sample', TO_CHILD)

        HW_object_type = 'Pipe_SoundEngine01_ReleaseSample'
        self.progress_status_show_function(f'Building the Hauptwerk ODF objects tree... {HW_object_type}')
        if HW_object_type in self.HW_odf_dic.keys():
            for HW_object_dic in self.HW_odf_dic[HW_object_type].values():
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'LayerID', 'Pipe_SoundEngine01_Layer', TO_PARENT)
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'SampleID', 'Sample', TO_CHILD)

        HW_object_type = 'ContinuousControlStageSwitch'
        self.progress_status_show_function(f'Building the Hauptwerk ODF objects tree... {HW_object_type}')
        if HW_object_type in self.HW_odf_dic.keys():
            for HW_object_dic in self.HW_odf_dic[HW_object_type].values():
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'ContinuousControlID', 'ContinuousControl', TO_PARENT)
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'ControlledSwitchID', 'Switch', TO_CHILD)

        HW_object_type = 'ContinuousControlLinkage'
        self.progress_status_show_function(f'Building the Hauptwerk ODF objects tree... {HW_object_type}')
        if HW_object_type in self.HW_odf_dic.keys():
            for HW_object_dic in self.HW_odf_dic[HW_object_type].values():
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'SourceControlID', 'ContinuousControl', TO_PARENT)
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'DestControlID', 'ContinuousControl', TO_CHILD)
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'ConditionSwitchID', 'Switch', TO_PARENT)

        HW_object_type = 'ContinuousControl'
        self.progress_status_show_function(f'Building the Hauptwerk ODF objects tree... {HW_object_type}')
        if HW_object_type in self.HW_odf_dic.keys():
            for HW_object_dic in self.HW_odf_dic[HW_object_type].values():
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'ImageSetInstanceID', 'ImageSetInstance', TO_CHILD)
                # if the ContinuousControl is linked to an ImageSetInstance object, link it to the DisplayPage in which it is displayed
                HW_image_set_inst_dic = self.HW_ODF_get_object_by_ref_id('ImageSetInstance', HW_object_dic, 'ImageSetInstanceID')
                if HW_image_set_inst_dic != None:
                    HW_display_page_dic = self.HW_ODF_get_object_by_ref_id('DisplayPage', HW_image_set_inst_dic, 'DisplayPageID')
                    self.HW_ODF_do_link_between_obj(HW_object_dic, HW_display_page_dic, TO_PARENT)

        HW_object_type = 'ContinuousControlImageSetStage'
        self.progress_status_show_function(f'Building the Hauptwerk ODF objects tree... {HW_object_type}')
        if HW_object_type in self.HW_odf_dic.keys():
            for HW_object_dic in self.HW_odf_dic[HW_object_type].values():
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'ImageSetID', 'ImageSet', TO_PARENT)

        HW_object_type = 'ContinuousControlDoubleLinkage'
        self.progress_status_show_function(f'Building the Hauptwerk ODF objects tree... {HW_object_type}')
        if HW_object_type in self.HW_odf_dic.keys():
            for HW_object_dic in self.HW_odf_dic[HW_object_type].values():
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'FirstSourceControl_UID', 'ContinuousControl', TO_PARENT)
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'SecondSourceControl_UID', 'ContinuousControl', TO_PARENT)
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'DestControl_UID', 'ContinuousControl', TO_CHILD)

        HW_object_type = 'Enclosure'
        self.progress_status_show_function(f'Building the Hauptwerk ODF objects tree... {HW_object_type}')
        if HW_object_type in self.HW_odf_dic.keys():
            for HW_object_dic in self.HW_odf_dic[HW_object_type].values():
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'ShutterPositionContinuousControlID', 'ContinuousControl', TO_PARENT)

        HW_object_type = 'EnclosurePipe'
        self.progress_status_show_function(f'Building the Hauptwerk ODF objects tree... {HW_object_type}')
        if HW_object_type in self.HW_odf_dic.keys():
            for HW_object_dic in self.HW_odf_dic[HW_object_type].values():
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'EnclosureID', 'Enclosure', TO_PARENT)
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'PipeID', 'Pipe_SoundEngine01', TO_CHILD)

        HW_object_type = 'TremulantWaveformPipe'
        if HW_object_type in self.HW_odf_dic.keys():
            for HW_object_dic in self.HW_odf_dic[HW_object_type].values():
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'PipeID', 'Pipe_SoundEngine01', TO_CHILD)
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'TremulantWaveformID', 'TremulantWaveform', TO_PARENT)

        HW_object_type = 'Tremulant'
        self.progress_status_show_function(f'Building the Hauptwerk ODF objects tree... {HW_object_type}')
        if HW_object_type in self.HW_odf_dic.keys():
            for HW_object_dic in self.HW_odf_dic[HW_object_type].values():
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'ControllingSwitchID', 'Switch', TO_PARENT)

        HW_object_type = 'TremulantWaveform'
        self.progress_status_show_function(f'Building the Hauptwerk ODF objects tree... {HW_object_type}')
        if HW_object_type in self.HW_odf_dic.keys():
            for HW_object_dic in self.HW_odf_dic[HW_object_type].values():
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'TremulantID', 'Tremulant', TO_PARENT)
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'PitchAndFundamentalWaveformSampleID', 'Sample', TO_CHILD)

        HW_object_type = 'ImageSetInstance'
        self.progress_status_show_function(f'Building the Hauptwerk ODF objects tree... {HW_object_type}')
        if HW_object_type in self.HW_odf_dic.keys():
            for HW_object_dic in self.HW_odf_dic[HW_object_type].values():
                if len(HW_object_dic['_parents']) == 0:
                    # this ImageSetInstance object has none parent, link it with its DisplayPage
                    self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'DisplayPageID', 'DisplayPage', TO_PARENT)
                self.HW_ODF_do_link_between_obj_by_id(HW_object_dic, 'ImageSetID', 'ImageSet', TO_CHILD)

        # link to _General all the Division objects
        HW_object_type = 'Division'
        self.progress_status_show_function(f'Building the Hauptwerk ODF objects tree... {HW_object_type}')
        if HW_object_type in self.HW_odf_dic.keys():
            for HW_object_dic in self.HW_odf_dic[HW_object_type].values():
                self.HW_ODF_do_link_between_obj(HW_object_dic, HW_general_object_dic, TO_PARENT)

        # link to _General all the DisplayPage objects
        HW_object_type = 'DisplayPage'
        self.progress_status_show_function(f'Building the Hauptwerk ODF objects tree... {HW_object_type}')
        if HW_object_type in self.HW_odf_dic.keys():
            for HW_object_dic in self.HW_odf_dic[HW_object_type].values():
                self.HW_ODF_do_link_between_obj(HW_object_dic, HW_general_object_dic, TO_PARENT)

        # link to _General all the Tremulant objects (to find them more easily in the objects tree)
        HW_object_type = 'Tremulant'
        if HW_object_type in self.HW_odf_dic.keys():
            for HW_object_dic in self.HW_odf_dic[HW_object_type].values():
                self.HW_ODF_do_link_between_obj(HW_object_dic, HW_general_object_dic, TO_PARENT)

        # link to _General all the WindCompartment objects which have no parent
        HW_object_type = 'WindCompartment'
        self.progress_status_show_function(f'Building the Hauptwerk ODF objects tree... {HW_object_type}')
        if HW_object_type in self.HW_odf_dic.keys():
            for HW_object_dic in self.HW_odf_dic[HW_object_type].values():
                if len(HW_object_dic['_parents']) == 0:
                    self.HW_ODF_do_link_between_obj(HW_object_dic, HW_general_object_dic, TO_PARENT)

        return True

    #-------------------------------------------------------------------------------------------------
    def HW_ODF_do_link_between_obj_by_id(self, HW_object_dic, HW_attr_id_name_str, linked_object_type_str, link_type):
        # do a link between the given HW object dict and the given linked HW object type dict based on an ID
        # the given link_type must be TO_PARENT or TO_CHILD

        # recover the value of the ID permitting to establish a linkage between the two objects
        linkage_id_value_int = myint(self.HW_ODF_get_attribute_value(HW_object_dic, HW_attr_id_name_str), 0)

        if linkage_id_value_int != 0:
            try:
                linked_object_dic = self.HW_odf_dic[linked_object_type_str][linkage_id_value_int]
            except:
                logs.add(f'INTERNAL ERROR : {HW_object_dic["_HW_uid"]} - not found reference to object type {linked_object_type_str} with ID {linkage_id_value_int}')
                return False
            else:
                return self.HW_ODF_do_link_between_obj(HW_object_dic, linked_object_dic, link_type)
        else:
            return False

    #-------------------------------------------------------------------------------------------------
    def HW_ODF_do_link_between_obj(self, HW_object_dic, linked_HW_object_dic, link_type):
        # do a link between the given HW object dict and the given linked HW object dict
        # the given link_type must be TO_PARENT or TO_CHILD

        if link_type == TO_CHILD:
            self.HW_ODF_add_attribute_value(HW_object_dic, '_children', linked_HW_object_dic)
            self.HW_ODF_add_attribute_value(linked_HW_object_dic, '_parents', HW_object_dic)
        elif link_type == TO_PARENT:
            self.HW_ODF_add_attribute_value(HW_object_dic, '_parents', linked_HW_object_dic)
            self.HW_ODF_add_attribute_value(linked_HW_object_dic, '_children', HW_object_dic)
        else:
            logs.add('INTERNAL ERROR : undefined link type given to HW_ODF_do_link_between_obj')
            return False

        return True

    #-------------------------------------------------------------------------------------------------
    def HW_ODF_add_attribute_value(self, HW_object_dic, attr_name, attr_value):
        # add the given attribute value to the list of the given attribute name in the given HW object dictionary (for _xxx attributes which contain a list)
        # if the given value already exists in the list, it is not added to avoid doubles

        try:
            if attr_value not in HW_object_dic[attr_name]:
                HW_object_dic[attr_name].append(attr_value)
        except:
            # the attr_name doesn't exist, create it and add the value
            HW_object_dic[attr_name] = []
            HW_object_dic[attr_name].append(attr_value)

    #-------------------------------------------------------------------------------------------------
    def HW_ODF_get_attribute_value(self, HW_object_dic, attr_name, mandatory_bool=False):
        # return the string value of the given attribute defined in the given object sub-dictionary of the Hauptwerk ODF dictionary
        # generate a log in case of attribute not found and if mandatory_bool=MANDATORY (True), mandatory_bool=False permits to get silently an attribute which the presence is optional
        # return None if the attribute name is not defined in the given dictionary

        if HW_object_dic == None:
            return None

        try:
            attr_value = HW_object_dic[attr_name]
        except:
            attr_value = None
            if mandatory_bool:
                logs.add(f'ERROR : unable to read the attribute "{attr_name}" in the sample set object {HW_object_dic["_HW_uid"]}')

        return attr_value

    #-------------------------------------------------------------------------------------------------
    def HW_ODF_get_object_dic(self, HW_object_type_or_uid, HW_object_id = None):
        # return the HW object dictionary having the given object type and ID or only the given UID (unique ID) if object_id_int = -1 or not defined
        # if the HW object type is '_General' then the object ID parameter has not to be provided
        # return None if the object has not been found with the given data

        if HW_object_type_or_uid == None:
            return None

        # define the object type and ID
        if HW_object_id == None:
            # no object ID provided : object UID is provided
            if HW_object_type_or_uid == '_General':
                HW_object_type = '_General'
                HW_object_id = 1
            elif HW_object_type_or_uid[-6:].isdigit():
                HW_object_type = HW_object_type_or_uid[:-6]    # remove the last 6 digits of the UID
                HW_object_id = int(HW_object_type_or_uid[-6:])  # keep only the last 6 digits of the UID
            else:
                HW_object_id = 0
        else:
            # object type + ID is provided
            HW_object_type = HW_object_type_or_uid

        if HW_object_id == 0:
            return None

        try:
            # recover the dictionary of the object having the given type and ID
            return self.HW_odf_dic[HW_object_type][HW_object_id]
        except:
            # object dictionary not existing for the given type and/or ID
            return None

    #-------------------------------------------------------------------------------------------------
    def HW_ODF_get_object_by_ref_id(self, HW_object_type, ref_HW_object_dic, ref_HW_attr_id_name_str):
        # return the HW object dictionary having the given object type and which the ID is defined in the given referencing object dictionary and its referencing attribute ID

        # get the ID of the referenced object
        HW_object_id = myint(self.HW_ODF_get_attribute_value(ref_HW_object_dic, ref_HW_attr_id_name_str))

        if HW_object_id != None:
            return self.HW_ODF_get_object_dic(HW_object_type, HW_object_id)
        else:
            return None

    #-------------------------------------------------------------------------------------------------
    def HW_ODF_get_linked_objects_by_type(self, HW_object_dic, object_type, link_type, first_occurence=False, sorted_id_list_bool=False, sorted_name_list_bool=False):
        # return a list containing the dictionary of the HW objects which are parent/child (according to link_type) of the given object and which has the given object type
        # link_type must be equal to TO_PARENT or TO_CHILD
        # if sorted_id_list_bool is equal to True, the returned objects list is sorted by object ID order
        # if sorted_name_list_bool is equal to True (and sorted_id_list_bool is equal to False), the returned objects list is sorted by object name order
        # if first_occurence = FIRST_ONE (True), only the first occurence of the linked object is returned as a dictionary, not as a list
        # return an empty list or None (if first_occurence=True) if there is no parent/child found

        HW_linked_objects_dic_list = []
        HW_linked_object_dic = None

        if HW_object_dic != None:
            if link_type == TO_PARENT:
                for HW_obj_dic in HW_object_dic['_parents']:
                    # scan the parents of the given object
                    if HW_obj_dic['_HW_uid'][:-6] == object_type:
                        # the current parent has the expected type
                        if first_occurence:
                            # only the first occurence of a parent has to be returned
                            HW_linked_object_dic = HW_obj_dic
                            break
                        else:
                            # all the occurences of the parents have to be returned, add the current one in a list
                            HW_linked_objects_dic_list.append(HW_obj_dic)

            elif link_type == TO_CHILD:
                for HW_obj_dic in HW_object_dic['_children']:
                    # scan the children of the given object
                    if HW_obj_dic['_HW_uid'][:-6] == object_type:
                        # the current child has the expected type
                        if first_occurence:
                            # only the first occurence of a child has to be returned
                            HW_linked_object_dic = HW_obj_dic
                            break
                        else:
                            # all the occurences of the children have to be returned, add the current one in a list
                            HW_linked_objects_dic_list.append(HW_obj_dic)
            else:
                logs.add('INTERNAL ERROR : undefined link type given to HW_ODF_get_linked_objects_by_type')

        if first_occurence:
            # return the first found occurence of the parent/child object having the requested type
            return HW_linked_object_dic
        else:
            if (sorted_id_list_bool or sorted_name_list_bool) and len(HW_linked_objects_dic_list) > 1:
                # the returned list has to be sorted by object ID or name
                id_list = []
                name_id_list = []
                for HW_obj_dic in HW_linked_objects_dic_list:
                    # scan the list of parents/children object dictionaries to build one list with the ID and one list with the name + ID
                    id_list.append(int(HW_obj_dic['_HW_uid'][-6:]))
                    name_id_list.append(HW_obj_dic['Name'] + '=' + HW_obj_dic['_HW_uid'][-6:])
                HW_linked_objects_dic_list = []
                if sorted_id_list_bool:
                    # rebuild the parents/children list by object ID order
                    for id in sorted(id_list):
                        HW_linked_objects_dic_list.append(self.HW_ODF_get_object_dic(object_type, id))
                else:
                    # rebuild the parents/children list by object name order
                    for name_id in sorted(name_id_list):
                        name, id = name_id.split('=')
                        HW_linked_objects_dic_list.append(self.HW_ODF_get_object_dic(object_type, int(id)))

            return HW_linked_objects_dic_list

    #-------------------------------------------------------------------------------------------------
    def HW_ODF_get_object_attr_list(self, HW_object_uid):
        # return a list containing the object attributes name/value of the given object UID (for display purpose in the GUI)
        # or None if the given HW object doesn't exist

        HW_object_dic = self.HW_ODF_get_object_dic(HW_object_uid)

        if HW_object_dic != None:
            data_list = []
            for obj_attr_name, obj_attr_value in HW_object_dic.items():
                if obj_attr_name in ('_parents', '_children'):
                    # this attribute value contains a list of objects dictionaries
                    attr_value = ''
                    for HW_object_dic2 in obj_attr_value:
                        attr_value += (HW_object_dic2['_HW_uid'] + ' ')
                    if len(attr_value) > 250:
                        attr_value = attr_value[:250] + ' ...'
                    obj_attr_value = attr_value
                elif obj_attr_name in ('_GO_windchests_uid_list'):
                    # this attribute value contains a list of objects uid strings
                    attr_value = ''
                    for HW_object_uid in obj_attr_value:
                        attr_value += (HW_object_uid + ' ')
                    if len(attr_value) > 250:
                        attr_value = attr_value[:250] + ' ...'
                    obj_attr_value = attr_value
                data_list.append(f'{obj_attr_name}={obj_attr_value}')
            return data_list
        else:
            return None

    #-------------------------------------------------------------------------------------------------
    def HW_ODF_get_image_attributes(self, HW_object_dic, HW_image_attr_dic, HW_image_index_in_set = None):
        # fill the given HW_image_attr_dic dictionary with the following HW attributes recovered from
        # the given object (can be ImageSetInstance or ImageSet) and its linked ImageSet / ImageSetElement objects
        #    Name (string)
        #    LeftXPosPixels (integer, default 0)
        #    TopYPosPixels (integer, default 0)
        #    ImageWidthPixels (integer, default None)
        #    ImageHeightPixels (integer, default None)
        #    ImageWidthPixelsTiling (integer, default None)
        #    ImageHeightPixelsTiling (integer, default None)
        #    ClickableAreaLeftRelativeXPosPixels (integer, default None)
        #    ClickableAreaRightRelativeXPosPixels (integer, default None)
        #    ClickableAreaTopRelativeYPosPixels (integer, default None)
        #    ClickableAreaBottomRelativeYPosPixels (integer, default None)
        #    InstallationPackageID (integer)
        #    BitmapFilename (string, default None)
        #    TransparencyMaskBitmapFilename (string, default None)
        # if HW_image_index_in_set = None, use the ImageSetInstance attribute DefaultImageIndexWithinSet if available, else use the index 1 by default
        # return True or False whether the operation has succeeded or not

        if HW_object_dic['_HW_uid'][:-6] == 'ImageSetInstance':
            # ImageSetInstance object provided

            HW_image_set_inst_dic = HW_object_dic

            # recover the ImageSet object associated to the given ImageSetInstance object
            HW_image_set_dic = self.HW_ODF_get_object_by_ref_id('ImageSet', HW_image_set_inst_dic, 'ImageSetID')
            if HW_image_set_dic == None:
                return False

            HW_image_attr_dic['Name'] = self.HW_ODF_get_attribute_value(HW_image_set_inst_dic, 'Name')

            HW_image_attr_dic['LeftXPosPixels'] = myint(self.HW_ODF_get_attribute_value(HW_image_set_inst_dic, 'LeftXPosPixels'), 0)
            HW_image_attr_dic['TopYPosPixels'] = myint(self.HW_ODF_get_attribute_value(HW_image_set_inst_dic, 'TopYPosPixels'), 0)

            HW_image_attr_dic['ImageWidthPixelsTiling'] = myint(self.HW_ODF_get_attribute_value(HW_image_set_inst_dic, 'RightXPosPixelsIfTiling'))
            if HW_image_attr_dic['ImageWidthPixelsTiling'] == 0:  # some sample sets define 0 to mean None
                HW_image_attr_dic['ImageWidthPixelsTiling'] = None

            HW_image_attr_dic['ImageHeightPixelsTiling'] = myint(self.HW_ODF_get_attribute_value(HW_image_set_inst_dic, 'BottomYPosPixelsIfTiling'))
            if HW_image_attr_dic['ImageHeightPixelsTiling'] == 0:  # some sample sets define 0 to mean None
                HW_image_attr_dic['ImageHeightPixelsTiling'] = None

        elif HW_object_dic['_HW_uid'][:-6] == 'ImageSet':
            # ImageSet object provided

            HW_image_set_inst_dic = None
            HW_image_set_dic = HW_object_dic

            HW_image_attr_dic['Name'] = self.HW_ODF_get_attribute_value(HW_image_set_dic, 'Name')

            # set the default values of the ImageSetInstance attributes
            HW_image_attr_dic['LeftXPosPixels'] = 0
            HW_image_attr_dic['TopYPosPixels'] = 0
            HW_image_attr_dic['ImageWidthPixelsTiling'] = None
            HW_image_attr_dic['ImageHeightPixelsTiling'] = None

        else:
            return False

        if HW_image_index_in_set == None:
            # image index not provided in parameter of the function : use the default index from the ImageSetInstance object if known, else use index 1
            HW_image_index_in_set = myint(self.HW_ODF_get_attribute_value(HW_image_set_inst_dic, 'DefaultImageIndexWithinSet'), 1)

        # recover the image dimensions
        if HW_image_attr_dic['ImageWidthPixelsTiling'] != None:
            HW_image_attr_dic['ImageWidthPixels'] = myint(HW_image_attr_dic['ImageWidthPixelsTiling'])
        else:
            HW_image_attr_dic['ImageWidthPixels'] = myint(self.HW_ODF_get_attribute_value(HW_image_set_dic, 'ImageWidthPixels'))

        if HW_image_attr_dic['ImageHeightPixelsTiling'] != None:
            HW_image_attr_dic['ImageHeightPixels'] = myint(HW_image_attr_dic['ImageHeightPixelsTiling'])
        else:
            HW_image_attr_dic['ImageHeightPixels'] = myint(self.HW_ODF_get_attribute_value(HW_image_set_dic, 'ImageHeightPixels'))

        # recover the clickable area dimensions
        HW_image_attr_dic['ClickableAreaLeftRelativeXPosPixels'] = myint(self.HW_ODF_get_attribute_value(HW_image_set_dic, 'ClickableAreaLeftRelativeXPosPixels'))
        HW_image_attr_dic['ClickableAreaRightRelativeXPosPixels'] = myint(self.HW_ODF_get_attribute_value(HW_image_set_dic, 'ClickableAreaRightRelativeXPosPixels'))
        HW_image_attr_dic['ClickableAreaTopRelativeYPosPixels'] = myint(self.HW_ODF_get_attribute_value(HW_image_set_dic, 'ClickableAreaTopRelativeYPosPixels'))
        HW_image_attr_dic['ClickableAreaBottomRelativeYPosPixels'] = myint(self.HW_ODF_get_attribute_value(HW_image_set_dic, 'ClickableAreaBottomRelativeYPosPixels'))

        # correct the clickable area width if greater than the image width
        if (HW_image_attr_dic['ImageWidthPixels'] != None and HW_image_attr_dic['ClickableAreaRightRelativeXPosPixels'] != None and
            HW_image_attr_dic['ClickableAreaRightRelativeXPosPixels'] > HW_image_attr_dic['ImageWidthPixels'] - 1):
            HW_image_attr_dic['ClickableAreaRightRelativeXPosPixels'] = HW_image_attr_dic['ImageWidthPixels'] - 1
        # correct the clickable area height if greater than the image height
        if (HW_image_attr_dic['ImageHeightPixels'] != None and HW_image_attr_dic['ClickableAreaBottomRelativeYPosPixels'] != None and
            HW_image_attr_dic['ClickableAreaBottomRelativeYPosPixels'] > HW_image_attr_dic['ImageHeightPixels'] - 1):
            HW_image_attr_dic['ClickableAreaBottomRelativeYPosPixels'] = HW_image_attr_dic['ImageHeightPixels'] - 1

        # recover the image installation package ID
        HW_image_attr_dic['InstallationPackageID'] = myint(self.HW_ODF_get_attribute_value(HW_image_set_dic, 'InstallationPackageID', MANDATORY))

        # recover the bitmap file of the transparency image if any
        file_name = self.HW_ODF_get_attribute_value(HW_image_set_dic, 'TransparencyMaskBitmapFilename')
        if file_name != None:
            HW_image_attr_dic['TransparencyMaskBitmapFilename'] = self.convert_HW2GO_file_name(file_name, HW_image_attr_dic['InstallationPackageID'])
        else:
            HW_image_attr_dic['TransparencyMaskBitmapFilename'] = None

        # recover the bitmap file corresponding to the given or default image index
        HW_image_attr_dic['BitmapFilename'] = None
        for image_set_elem_dic in self.HW_ODF_get_linked_objects_by_type(HW_image_set_dic, 'ImageSetElement', TO_CHILD):
            # scan the ImageSetElement objects which are children of the ImageSet object to find the one having the given or default image index
            image_index = myint(self.HW_ODF_get_attribute_value(image_set_elem_dic, 'ImageIndexWithinSet'), 1)
            if image_index == HW_image_index_in_set:
                # it is the expected index of ImageSetElement object
                file_name = self.HW_ODF_get_attribute_value(image_set_elem_dic, 'BitmapFilename')
                if file_name != None:
                    HW_image_attr_dic['BitmapFilename'] = self.convert_HW2GO_file_name(file_name, HW_image_attr_dic['InstallationPackageID'])
                else:
                    HW_image_attr_dic['BitmapFilename'] = None
                break

        return True

    #-------------------------------------------------------------------------------------------------
    def HW_ODF_get_text_attributes(self, HW_text_inst_dic, HW_text_attr_dic):
        # fill the given HW_text_attr_dic dictionary with the following HW attributes recovered from
        # the given TextInstance object and its linked TextStyle object, and from the linked ImageSetInstance object if any
        # the not defined attributes are set at None
        #    Text (string, default ?)
        #    XPosPixels (integer, default 0)
        #    YPosPixels (integer, default 0)
        #    PosRelativeToTopLeftOfImage : Y or N (string, default N)
        #    WordWrapWithinABoundingBox : Y or N (string, default Y)
        #    BoundingBoxWidthPixelsIfWordWrap (integer, default 0)
        #    BoundingBoxHeightPixelsIfWordWrap (integer, default 0)
        #    Face_WindowsName (string, default Arial)
        #    Font_SizePixels (integer, default 10)
        #    Font_WeightCode : 1 = light, 2 = normal, 3 = bold (integer, default 2)
        #    Colour_Red (integer, default 0)
        #    Colour_Green (integer, default 0)
        #    Colour_Blue (integer, default 0)
        #    HorizontalAlignmentCode : 0 or 3 = center, 1 = left, 2 = right  (integer, default 0)
        #    VerticalAlignmentCode   : 0 = center, 1 = top,  2 = bottom (integer, default 1)
        #    ImageSetInstanceDic : dictionary of the linked ImageSetInstance object if any, else None
        #    + the attributes returned by HW_ODF_get_image_attributes if an ImageSetInstance object is linked

        # recover the data from the given TextInstance object
        HW_text_attr_dic['Text'] = mystr(self.HW_ODF_get_attribute_value(HW_text_inst_dic, 'Text'), '?')
        HW_text_attr_dic['XPosPixels'] = myint(self.HW_ODF_get_attribute_value(HW_text_inst_dic, 'XPosPixels'), 0)
        HW_text_attr_dic['YPosPixels'] = myint(self.HW_ODF_get_attribute_value(HW_text_inst_dic, 'YPosPixels'), 0)
        HW_text_attr_dic['PosRelativeToTopLeftOfImage'] = mystr(self.HW_ODF_get_attribute_value(HW_text_inst_dic, 'PosRelativeToTopLeftOfImageSetInstance'), 'N')
        HW_text_attr_dic['WordWrapWithinABoundingBox'] = mystr(self.HW_ODF_get_attribute_value(HW_text_inst_dic, 'WordWrapWithinABoundingBox'), 'Y')
        HW_text_attr_dic['BoundingBoxWidthPixelsIfWordWrap'] = myint(self.HW_ODF_get_attribute_value(HW_text_inst_dic, 'BoundingBoxWidthPixelsIfWordWrap'), 0)
        HW_text_attr_dic['BoundingBoxHeightPixelsIfWordWrap'] = myint(self.HW_ODF_get_attribute_value(HW_text_inst_dic, 'BoundingBoxHeightPixelsIfWordWrap'), 0)

        # recover the data from the TextStyle object associated to the given TextInstance object
        HW_text_style_dic = self.HW_ODF_get_object_by_ref_id('TextStyle', HW_text_inst_dic, 'TextStyleID')
        HW_text_attr_dic['Face_WindowsName'] = mystr(self.HW_ODF_get_attribute_value(HW_text_style_dic, 'Face_WindowsName'), 'Arial')
        HW_text_attr_dic['Font_SizePixels'] = myint(self.HW_ODF_get_attribute_value(HW_text_style_dic, 'Font_SizePixels'), 10)
        HW_text_attr_dic['Font_WeightCode'] = myint(self.HW_ODF_get_attribute_value(HW_text_style_dic, 'Font_WeightCode'), 2)
        HW_text_attr_dic['Colour_Red'] = myint(self.HW_ODF_get_attribute_value(HW_text_style_dic, 'Colour_Red'), 0)
        HW_text_attr_dic['Colour_Green'] = myint(self.HW_ODF_get_attribute_value(HW_text_style_dic, 'Colour_Green'), 0)
        HW_text_attr_dic['Colour_Blue'] = myint(self.HW_ODF_get_attribute_value(HW_text_style_dic, 'Colour_Blue'), 0)
        HW_text_attr_dic['HorizontalAlignmentCode'] = myint(self.HW_ODF_get_attribute_value(HW_text_style_dic, 'HorizontalAlignmentCode'), 0)
        HW_text_attr_dic['VerticalAlignmentCode'] = myint(self.HW_ODF_get_attribute_value(HW_text_style_dic, 'VerticalAlignmentCode'), 1)

        # add in the HW_text_attr_dic the attributes of the associated ImageSetInstance object if one is defined
        HW_image_set_inst_dic = self.HW_ODF_get_object_by_ref_id('ImageSetInstance', HW_text_inst_dic, 'AttachedToImageSetInstanceID')
        HW_text_attr_dic['ImageSetInstanceDic'] = HW_image_set_inst_dic
        if HW_image_set_inst_dic != None:
            self.HW_ODF_get_image_attributes(HW_image_set_inst_dic, HW_text_attr_dic)

        return True

    #-------------------------------------------------------------------------------------------------
    def HW_ODF_get_linked_controlling_switches(self, HW_switchlinkage_dic, main_branch_switches_list, current_branch_switches_list, main_branch_bool):
        # function called by HW_ODF_get_controlling_switches
        # return in a dictionary the logical formula applied by the given HW SwitchLinkage on its input source and condition switches
        # the state of the source and condition switches can be inverted, and a logical AND is applied between them if a condition is present
        # return an empty dictionary if the given SwitchLinkage has empty input formulas

        if HW_switchlinkage_dic == None:
            return {}

        # check the action codes of the given SwitchLinkage
        engage_action_code = myint(self.HW_ODF_get_attribute_value(HW_switchlinkage_dic, 'EngageLinkActionCode'), 1)
        disengage_action_code = myint(self.HW_ODF_get_attribute_value(HW_switchlinkage_dic, 'DisengageLinkActionCode'), 2)
        if not (engage_action_code in (1, 4) and disengage_action_code in (2, 7)):
            # ignore the linkages which have not the standard action codes
            if LOG_HW2GO_ctrl_switch: print(f"          {HW_switchlinkage_dic['_HW_uid']} has other action codes : engage {engage_action_code}, disengage {disengage_action_code}, ====> SKIPPED")
            return {}

        # recover the inputs and properties of the given SwitchLinkage
        source_switch_dic = self.HW_ODF_get_object_by_ref_id('Switch', HW_switchlinkage_dic, 'SourceSwitchID')
        cond_switch_dic = self.HW_ODF_get_object_by_ref_id('Switch', HW_switchlinkage_dic, 'ConditionSwitchID')
        source_switch_link_if_engaged = self.HW_ODF_get_attribute_value(HW_switchlinkage_dic, 'SourceSwitchLinkIfEngaged')
        cond_switch_link_if_engaged = self.HW_ODF_get_attribute_value(HW_switchlinkage_dic, 'ConditionSwitchLinkIfEngaged')

        # get the formula coming from the condition switch (it is in a conditional branch so not in main branch) and apply it a NOT if necessary
        cond_formula = self.HW_ODF_get_controlling_switches(cond_switch_dic, main_branch_switches_list, current_branch_switches_list, False)
        if cond_formula != {} and cond_switch_link_if_engaged == 'N':
            cond_formula = {'*Not': [cond_formula]}

        # get the formula coming from the source switch (it is in the same branch as the one of the SwitchLinkage) and apply it a NOT if necessary
        source_formula = self.HW_ODF_get_controlling_switches(source_switch_dic, main_branch_switches_list, current_branch_switches_list, main_branch_bool)
        if source_formula != {} and source_switch_link_if_engaged == 'N':
            source_formula = {'*Not': [source_formula]}

        if cond_formula == {}:
            # SwitchLinkage without conditional switch, return the source switch formula
            formula = source_formula
        elif source_formula != {}:
            # SwitchLinkage with conditional switch, return an AND of the source and condition switches formula
            # since source and condition formulas will be inserted in an And condition, if they are themself an And condition as well, remove the condition
            formula = {'*And':[]}
            if isinstance(source_formula, dict) and '*And' in source_formula.keys():
                # the source switch has returned an And logical formula
                # since the SwitchLinkage applies itself an And, the formula coming from the source switch can be added to the data of the And formula
                for item in source_formula['*And']:
                    formula['*And'].append(item)
            else:
                # the source switch has returned another logical formula or only its own dictionary
                # add the source switch formula as a new input of the SwitchLinkage And formula
                formula['*And'].append(source_formula)

            if isinstance(cond_formula, dict) and '*And' in cond_formula.keys():
                for item in cond_formula['*And']:
                    formula['*And'].append(item)
            else:
                formula['*And'].append(cond_formula)
        else:
            # SwitchLinkage with none formula from its input switches
            formula = {}

        return formula

    #-------------------------------------------------------------------------------------------------
    def HW_ODF_get_controlling_switches(self, HW_switch_dic, main_branch_switches_list, current_branch_switches_list = [], main_branch_bool=True):
        # fonction which returns in nested dictionaries the logical formula (with *Or, *And or *Not as keys and a list of switches or nested dict as values)
        # indicating the UID of the HW switches controlling the given HW Switch (himself included) and the logical relationship between them
        # the * character permits to identify a key which is a logical formula from a key of a switch dictionary
        # the value current_branch_switches_list contains the list of the HW switches which are controlling the given switch in the same controlling branch
        # examples of returned formulas :
        #     {'*Or': ['Switch011028', 'Switch012028', 'Switch013028']}
        #     {'*And': [{'*Or': ['Switch011001', 'Switch012001', 'Switch013001']}, {'*Or': ['Switch011029', 'Switch012029', 'Switch013029']}, {'*Not': ['Switch012999']}]}

        # used HW objects :
        #   Switch C> SwitchLinkage C> Switch
        #   SwitchLinkage attributes :
        #     ConditionSwitchID            : if defined and condition switch is at OFF state, the destination switch is forced at OFF state
        #                                                                          ON  state, the source switch state is forwarded to the destination switch
        #     SourceSwitchLinkIfEngaged    : default 'Y', if ='N' the inverted source switch state is applied to the destination switch
        #     ConditionSwitchLinkIfEngaged : default 'Y', if ='N' the inverted conditional switch state is used for the source to destination state forwarding

        if HW_switch_dic == None:
            return {}

        if HW_switch_dic in current_branch_switches_list:
            # the given HW switch is already in the given switches branch : the branch is looping on itself (case of switches of different panels having the same functional effect)
            formula = {}
            # add in a sub-list of the list HW_looping_switches_lists two switches if not already present :
            # the current one and the previous one in the branch, which are linked together in a loop
            switch1_dic = HW_switch_dic
            switch2_dic = current_branch_switches_list[-1]  # last switch of the current switches branch list
            list_found_bool = False
            for looping_switches_list in self.HW_looping_switches_lists:
                # scan the existing switches lists in the main looping switches list
                if switch1_dic in looping_switches_list:
                    list_found_bool = True
                    if switch2_dic not in looping_switches_list:
                        looping_switches_list.append(switch2_dic)
                elif switch2_dic in looping_switches_list:
                    list_found_bool = True
                    if switch1_dic not in looping_switches_list:
                        looping_switches_list.append(switch1_dic)
            if not list_found_bool:
                # switches not already present in the main list, add them in a sub-list of the main list
                self.HW_looping_switches_lists.append([switch1_dic, switch2_dic])

        else:
            # the given HW switch can be processed
            # add it in the current switches branch list
            extended_current_branch_list = list(current_branch_switches_list)
            extended_current_branch_list.append(HW_switch_dic)

            # add the given HW switch to the main branch list if it is in the main branch
            if main_branch_bool:
                main_branch_switches_list.append(HW_switch_dic)

            # get properties of the given HW switch
            clickable = self.HW_ODF_get_attribute_value(HW_switch_dic, 'Clickable')
            default_to_engage = self.HW_ODF_get_attribute_value(HW_switch_dic, 'DefaultToEngaged')

            # build a list containing the formulas of the switches controlling the given HW switch
            formulas_list = []
            if clickable == 'Y':
                # it is a clickable switch, add it to the list
                formulas_list.append(HW_switch_dic)
            for HW_switchlinkage_dic in self.HW_ODF_get_linked_objects_by_type(HW_switch_dic, 'SwitchLinkage', TO_PARENT):
                # scan the parent SwitchLinkage objects of the given HW switch
                form = self.HW_ODF_get_linked_controlling_switches(HW_switchlinkage_dic, main_branch_switches_list, extended_current_branch_list, main_branch_bool)
                if form != {}:
                    # a formula comes from the current SwitchLinkage, take it into account
                    formulas_list.append(form)

            if len(formulas_list) == 0:
                # no parent controlling switches, the given HW switch is at the top of a branch
                if default_to_engage == 'Y':
                    # the given HW switch is engaged by default, take it into account
                    formula = HW_switch_dic
                else:
                    formula = {}
            elif len(formulas_list) == 1:
                # only one controlling switch, take it as it is
                formula = formulas_list[0]
            else:
                # in case of several controlling switches, link them together by an OR logical formula
                # since formulas will be inserted in a Or condition, if they are themself a Or condition as well, remove the condition
                formula = {'*Or':[]}
                for form in formulas_list:
                    if isinstance(form, dict) and '*Or' in form.keys():
                        for item in form['*Or']:
                            formula['*Or'].append(item)
                    else:
                        formula['*Or'].append(form)

        if  len(current_branch_switches_list) == 0 and len(formula) > 0 and list(formula.keys())[0][0] != '*':  # the first digit of the first key doesn't start by * (so not *And, *Not, *Or)
            # first level call of this recursive function and formula without logical condition : it is a single switch dictionary
            # place this switch in a list under a OR formula, because the returned formula must be a dictionary with logical condition
            formula = {'*Or':[formula]}

        return formula

    #-------------------------------------------------------------------------------------------------
    def HW_ODF_get_controlled_switches(self, HW_switch_dic, switches_dic_list):
        # recursive fonction which fills the list switches_dic_list with the HW switches which are controlled by the given HW Switch (himself included)
        # through standard switch linkage (EngageLinkActionCode = 1 and DisengageLinkActionCode = 2) and not as a condition switch
        # return the kind of switches link : starndard or conditional or not supported

        ret = 'standard'
        if HW_switch_dic not in switches_dic_list:
            # the given HW switch has not been already checked (to avoid loops between switches)
            switches_dic_list.append(HW_switch_dic)

            # check the HW Switch objects controlled by the given HW Switch
            for HW_switch_linkage_dic in self.HW_ODF_get_linked_objects_by_type(HW_switch_dic, 'SwitchLinkage', TO_CHILD):
                # scan the children HW SwitchLinkage objects of the given HW Switch
                HW_engage_action_code = myint(self.HW_ODF_get_attribute_value(HW_switch_linkage_dic, 'EngageLinkActionCode'), 1)
                HW_disengage_action_code = myint(self.HW_ODF_get_attribute_value(HW_switch_linkage_dic, 'DisengageLinkActionCode'), 2)
                HW_source_switch_dic = self.HW_ODF_get_object_by_ref_id('Switch', HW_switch_linkage_dic, 'SourceSwitchID')
                if HW_switch_dic == HW_source_switch_dic:
                    # the HW Switch is the source of the current linkage
                    if HW_engage_action_code in (1, 4) and HW_disengage_action_code in (2, 6, 7):
                        # the HW Switch is making an action through a standard linking action code
                        # check the destination switch of the current linkage
                        HW_dest_switch_dic = self.HW_ODF_get_object_by_ref_id('Switch', HW_switch_linkage_dic, 'DestSwitchID')
                        ret = self.HW_ODF_get_controlled_switches(HW_dest_switch_dic, switches_dic_list)
                    else:
                        # the action of the switch is not supported by GrandOrgue
                        ret ="not_supported"

                else:
                    # the HW Switch is not the source of the current linkage : it is a conditional switch
                    ret = 'conditional'

        return ret

    #-------------------------------------------------------------------------------------------------
    def HW_ODF_get_controlling_continuous_controls(self, HW_cont_ctrl_dic, cont_ctrl_dic_list):
        # recursive fonction which fills the given list cont_ctrl_dic_list with the HW Continuous controls which are controlling the given HW Continuous Control
        # and which have a graphical interface and without conditional control linkage

        if HW_cont_ctrl_dic not in cont_ctrl_dic_list:
            # the given HW continuous control has not been already checked (to avoid loops between controls)
            if self.HW_ODF_get_object_by_ref_id('ImageSetInstance', HW_cont_ctrl_dic, 'ImageSetInstanceID') != None:
                # it has a graphical interface
                cont_ctrl_dic_list.append(HW_cont_ctrl_dic)

            # check the HW continuous control objects controlling the given HW continuous control
            for HW_cont_ctrl_link_dic in self.HW_ODF_get_linked_objects_by_type(HW_cont_ctrl_dic, 'ContinuousControlLinkage', TO_PARENT):
                # scan the panent HW ContinuousControlLinkage objects
                if self.HW_ODF_get_object_by_ref_id('ContinuousControl', HW_cont_ctrl_link_dic, 'ConditionSwitchID') == None:
                    # it is not a conditional linkage
                    HW_source_cont_ctrl_dic = self.HW_ODF_get_object_by_ref_id('ContinuousControl', HW_cont_ctrl_link_dic, 'SourceControlID')
                    if HW_source_cont_ctrl_dic != None:
                        self.HW_ODF_get_controlling_continuous_controls(HW_source_cont_ctrl_dic, cont_ctrl_dic_list)

    #-------------------------------------------------------------------------------------------------
    def HW_ODF_get_tremulant_division(self, HW_tremulant_dic):
        # returns the HW division to which belongs the first pipe associated with the given HW tremulant
        # returns None if no HW division found

        # used HW objects :
        #   Tremulant C> TremulantWaveform C> TremulantWaveformPipe C> Pipe_SoundEngine01 P> Rank P> StopRank P> Stop P> Division
        #   Tremulant C> TremulantWaveform C> TremulantWaveformPipe C> Pipe_SoundEngine01 P> Rank P> Stop P> Division

        for HW_trem_wave_form_dic in self.HW_ODF_get_linked_objects_by_type(HW_tremulant_dic, 'TremulantWaveform', TO_CHILD):
            for HW_trem_wave_form_pipe_dic in self.HW_ODF_get_linked_objects_by_type(HW_trem_wave_form_dic, 'TremulantWaveformPipe', TO_CHILD):
                HW_pipe_dic = self.HW_ODF_get_object_by_ref_id('Pipe_SoundEngine01', HW_trem_wave_form_pipe_dic, 'PipeID')
                if HW_pipe_dic != None:
                    HW_rank_dic = self.HW_ODF_get_object_by_ref_id('Rank', HW_pipe_dic, 'RankID')
                    if HW_rank_dic != None:
                        HW_stop_rank_dic = self.HW_ODF_get_linked_objects_by_type(HW_rank_dic, 'StopRank', TO_PARENT, FIRST_ONE)
                        if HW_stop_rank_dic != None:
                            HW_stop_dic = self.HW_ODF_get_object_by_ref_id('Stop', HW_stop_rank_dic, 'StopID')
                        else:
                            HW_stop_dic = self.HW_ODF_get_linked_objects_by_type(HW_rank_dic, 'Stop', TO_PARENT, FIRST_ONE)
                        if HW_stop_dic != None:
                            HW_division_dic = self.HW_ODF_get_object_by_ref_id('Division', HW_stop_dic, 'DivisionID')
                            if HW_division_dic != None:
                                return HW_division_dic

        return None

    #-------------------------------------------------------------------------------------------------
    def HW_ODF_save2textfile(self, file_name):
        # save the Hauptwerk ODF objects dictionary into the given text file path/name in a GrandOrgue ODF format (for development/debug purpose)

        with open(file_name, 'w', encoding=ENCODING_UTF8_BOM) as f:
            f.write(';Hauptwerk ODF XML formatted in a GrandOrgue ODF manner\n')
            f.write('\n')
            for object_type_dic in self.HW_odf_dic.values():
                for HW_object_dic in object_type_dic.values():
                    f.write(f'[{HW_object_dic["_HW_uid"]}]\n')
                    for obj_attr_name, obj_attr_value in HW_object_dic.items():
                        if obj_attr_name in ('_parents', '_children'):
                            # this attribute contains a list of objects dictionaries
                            relations = ''
                            for HW_object_dic2 in obj_attr_value:
                                relations += (HW_object_dic2['_HW_uid'] + '  ')
                            obj_attr_value = relations
                        f.write(f'{obj_attr_name}={obj_attr_value}\n')
                    f.write('\n')

    #-------------------------------------------------------------------------------------------------
    def GO_ODF_save2organfile(self, file_name, file_encoding):
        # save the GrandOrgue ODF objects dictionary into the given .organ ODF file and in the given file encoding (ISO_8859_1 or UTF-8)
        # return True or False whether the saving has succeeded or not

        # check the extension of the given file name
        filename_str, file_extension_str = os.path.splitext(file_name)
        if file_extension_str != '.organ':
            logs.add(f'The file "{file_name}" does not have the expected extension .organ')
            return False

        with open(file_name, 'w', encoding=file_encoding) as f:
            # set the list of objects UID to save : Organ in first, then the others by alphabetical order
            uid_list = sorted(self.GO_odf_dic.keys())
            uid_list.remove('Organ')
            uid_list.insert(0, 'Organ')
            # write a comment in the header
            f.write('; ' + ODF_COMMENT + '\n')
            f.write('\n')
            # write the objects
            for object_uid in uid_list:
                f.write(f'[{object_uid}]\n')
                for obj_attr_name, obj_attr_value in self.GO_odf_dic[object_uid].items():
                    if obj_attr_name[0] != '_': # it is not a temporary attribute created for HW to GO conversion
                        line = obj_attr_name + '=' + str(obj_attr_value) + '\n'
                        if file_encoding == ENCODING_ISO_8859_1:
                            # convert the line from UTF-8 to ISO_8859_1 format
                            line = line.encode('utf-8', errors='ignore').decode('ISO-8859-1', errors='ignore')
                        f.write(line)
                f.write('\n')  # insert an empty line between each object section

        return True

    #-------------------------------------------------------------------------------------------------
    def GO_ODF_build_from_HW_ODF(self, HW_odf_file_name, GO_odf_file_name, progress_status_update_fct,
                                 build_unused_ranks_bool, conv_alt_ranks_bool, alt_ranks_in_main_bool, GO_odf_encoding):
        # build and save a GrandOrgue ODF from the given Hauptwerk ODF and its associated sample set (which is not touched)
        # use the given function callback to display a progression status in the GUI
        # return False if an issue has occured, else return True

        self.reset_all_data()

        self.progress_status_show_function = progress_status_update_fct

        if conv_alt_ranks_bool:
            # the alternate ranks have to be converted from HW to GO
            if alt_ranks_in_main_bool:
                # the alternate ranks have to be integrated in the main stops/ranks which they are the alternate rank
                self.alt_rank_status = 'integrated'
            else:
                # the alternate ranks have to be separated in specific stops/ranks, activated in opposite to the main stops/ranks
                self.alt_rank_status = 'separated'
        else:
            self.alt_rank_status = None

        # load the HW ODF in the HW ODF dictionary
        progress_status_update_fct('Loading the Hauptwerk ODF...')
        if self.HW_ODF_load_from_file(HW_odf_file_name):
            # the loading has been done with success

            # store the list of the HW display pages and divisions sorted by ascending ID order
            HW_sorted_display_pages_id_list = sorted(self.HW_odf_dic['DisplayPage'].keys())
            HW_sorted_divisions_id_list = sorted(self.HW_odf_dic['Division'].keys())

            # link the HW objects together
            progress_status_update_fct('Building the Hauptwerk ODF objects tree...')
            self.HW_ODF_do_links_between_objects()

            # build the various GO objects in the GO ODF dictionary from the HW ODF
            # the order of calling the below functions is important, there are dependencies between some of them

            progress_status_update_fct('Building the GrandOrgue Organ object...')
            if self.GO_ODF_build_Organ_object() == None:
                logs.add('ERROR : issue occured while building the GO Organ object')
                return False

            # build the GO Panel objects by sorted HW DisplayPage ID order
            progress_status_update_fct('Building the GrandOrgue Panels...')
            for HW_disp_page_id in HW_sorted_display_pages_id_list:
                HW_disp_page_dic = self.HW_ODF_get_object_dic('DisplayPage', HW_disp_page_id)
                self.GO_ODF_build_Panel_object(HW_disp_page_dic)

            # build the GO Manual objects by sorted HW Division ID order
            progress_status_update_fct('Building the GrandOrgue Manuals...')
            for HW_division_id in HW_sorted_divisions_id_list:
                HW_division_dic = self.HW_odf_dic['Division'][HW_division_id]
                self.GO_ODF_build_Manual_object(HW_division_dic)

            # build the GO Coupler objects by sorted HW Division ID -> Keyboard -> KeyAction
            for HW_division_id in HW_sorted_divisions_id_list:
                HW_division_dic = self.HW_odf_dic['Division'][HW_division_id]
                for HW_keyboard_dic in self.HW_ODF_get_linked_objects_by_type(HW_division_dic, 'Keyboard', TO_CHILD, sorted_id_list_bool=True):
                    # scan the HW Keyboard objects belonging to the current HW Division
                    for HW_key_action_dic in self.HW_ODF_get_linked_objects_by_type(HW_keyboard_dic, 'KeyAction', TO_CHILD, sorted_id_list_bool=True):
                        # scan the HW KeyAction objects belonging to the current HW Keyboard
                        progress_status_update_fct(f'Building the GrandOrgue Coupler "{HW_key_action_dic["Name"]}"...')
                        self.GO_ODF_build_Drawstop_objects(HW_key_action_dic, HW_division_dic)

            # build the GO Stop objects by sorted HW Division ID
            for HW_division_id in HW_sorted_divisions_id_list:
                HW_division_dic = self.HW_odf_dic['Division'][HW_division_id]
                for HW_stop_dic in self.HW_ODF_get_linked_objects_by_type(HW_division_dic, 'Stop', TO_CHILD, sorted_id_list_bool=True):
                    # scan the HW Stop objects belonging to the current HW Division for the stop pipes or noise objects
                    progress_status_update_fct(f'Building the GrandOrgue Stop "{HW_stop_dic["Name"]}"...')
                    self.GO_ODF_build_Drawstop_objects(HW_stop_dic, HW_division_dic)
                # build the GO Stop objects for keyboard noises
                progress_status_update_fct(f'Building the GrandOrgue Stop for division "{HW_division_dic["Name"]}" keys noise...')
                self.GO_ODF_build_Stop_keys_noise_objects(HW_division_dic)

            # by default the other drawstops or tremulants without division are assigned to the last division
            HW_default_division_dic = self.HW_odf_dic['Division'][HW_sorted_divisions_id_list[-1]]

            # build the GO Tremulant objects if any are defined
            if 'Tremulant' in self.HW_odf_dic.keys():
                for HW_tremulant_dic in self.HW_odf_dic['Tremulant'].values():
                    progress_status_update_fct(f'Building the GrandOrgue Tremulant "{HW_tremulant_dic["Name"]}"...')
                    HW_division_dic = self.HW_ODF_get_tremulant_division(HW_tremulant_dic)
                    if HW_division_dic == None:
                        HW_division_dic = HW_default_division_dic
                    self.GO_ODF_build_Drawstop_objects(HW_tremulant_dic, HW_division_dic)

            # build GO Stop objects not built before, parsing the HW switches of the display pages which have not be converted yet to GO object
            progress_status_update_fct('Building other GrandOrgue stops...')
            for HW_disp_page_id in HW_sorted_display_pages_id_list:
                HW_disp_page_dic = self.HW_ODF_get_object_dic('DisplayPage', HW_disp_page_id)

                if ('CRESC' not in HW_disp_page_dic['Name'].upper() and
                    'MATRIX' not in HW_disp_page_dic['Name'].upper()):
                    # switches of crescendo and matrix named pages are skipped
                    if HW_disp_page_dic['_GO_uid'] != '':
                        # the current HW display page has been converted in a GO panel
                        for HW_switch_dic in self.HW_ODF_get_linked_objects_by_type(HW_disp_page_dic, 'Switch', TO_CHILD):
                            # scan the HW Switch objects displayed in the current HW DisplayPage
                            if self.HW_ODF_get_linked_objects_by_type(HW_switch_dic, 'KeyboardKey', TO_CHILD, FIRST_ONE) == None and HW_switch_dic['_GO_uid'] == '':
                                # it is not the switch of a keyboard key and it has not been converted in a GO switch
                                self.GO_ODF_build_Drawstop_objects(HW_switch_dic, HW_default_division_dic)

            # build the labels
            progress_status_update_fct('Building the GrandOrgue Labels...')
            for HW_disp_page_id in HW_sorted_display_pages_id_list:
                HW_disp_page_dic = self.HW_ODF_get_object_dic('DisplayPage', HW_disp_page_id)
                if HW_disp_page_dic['_GO_uid'] != '':
                    # the current HW display page has been converted in a GO panel
                    # recover the corresponding GO panel
                    GO_panel_uid = HW_disp_page_dic['_GO_uid']
                    for HW_text_inst_dic in self.HW_ODF_get_linked_objects_by_type(HW_disp_page_dic, 'TextInstance', TO_CHILD):
                        # scan the HW TextInstance objects of the current display page
                        self.GO_ODF_build_Label_object(HW_text_inst_dic, GO_panel_uid)

            if build_unused_ranks_bool:
                # build the GO Ranks objects corresponding to HW Ranks of pipes not converted in GO Ranks previously
                for HW_rank_dic in self.HW_odf_dic['Rank'].values():
                    if HW_rank_dic['_GO_uid'] == '':
                        # HW Rank not converted in a GO Rank
                        progress_status_update_fct(f'Building unused GrandOrgue Rank "{HW_rank_dic["Name"]}"...')
                        GO_rank_uid = self.GO_ODF_build_Rank_object(HW_rank_dic, None, 0)
                        if GO_rank_uid != None:
                            self.GO_odf_dic[GO_rank_uid]['Name'] += ' UNUSED'


            progress_status_update_fct('Completing the building operation...')

            # apply in the GO objects the references to children by object types alphabetical order
            for object_uid in self.GO_odf_dic.keys():
                self.GO_ODF_apply_children_ref(object_uid)

            if self.silent_loop_file_used:
                # the file SilentLoop.wav is referenced in the GO ODF for a GO Sdrawstop noise
                # copy it in the root folder of the HW sample set
                if not(os.path.exists(self.HW_sample_set_path + os.sep + 'SilentLoop.wav')):
                    # the file is not already present in the HW sample set root folder, copy it
                    shutil.copy(os.path.dirname(__file__) + os.sep + 'resources' + os.sep + 'SilentLoop.wav', self.HW_sample_set_path)
            else:
                # the file SilentLoop.wav is not referenced in the GO ODF
                # remove it in the root folder of the HW sample set if it present
                if os.path.exists(self.HW_sample_set_path + os.sep + 'SilentLoop.wav'):
                    # the file is present in the HW sample set root folder, delete it
                    os.remove(self.HW_sample_set_path + os.sep + 'SilentLoop.wav')

            # save the HW ODF data in a GO ODF text format (for development/debug purpose, more easy to read than a xml file)
##            self.HW_ODF_save2textfile(HW_odf_file_name + '.txt')

            # save the built GO ODF data in a .organ file
            if self.GO_ODF_save2organfile(GO_odf_file_name, GO_odf_encoding):
                logs.add(f'GrandOrgue ODF built and saved in "{GO_odf_file_name}"')

        # clear the last progression message
        progress_status_update_fct('')

        return True

    #-------------------------------------------------------------------------------------------------
    def GO_ODF_build_Organ_object(self):
        # build the GO Organ object from the HW ODF
        # return None if an issue has occured, else return the UID of the created GO Organ

        # used HW objects :
        #   _General, RequiredInstallationPackage

        # get the dictionary of the HW _General object
        self.HW_general_dic = self.HW_ODF_get_object_dic('_General')
        if self.HW_general_dic == None:
            logs.add('ERROR : missing _General object in the Hauptwerk ODF dictionary')
            return None

        # check if the folders of the required installation packages are present in the folder OrganInstallationPackages
        self.available_HW_packages_id_list = []
        for HW_install_pack_dic in self.HW_odf_dic['RequiredInstallationPackage'].values():
            # scan and check the defined HW RequiredInstallationPackage objects
            HW_package_id = myint(self.HW_ODF_get_attribute_value(HW_install_pack_dic, 'InstallationPackageID', MANDATORY))
            if HW_package_id == None:
                logs.add('ERROR : no installation package ID defined in the HW ODF')
                return None

            HW_package_name = self.HW_ODF_get_attribute_value(HW_install_pack_dic, 'Name', MANDATORY)
            HW_package_supplier = self.HW_ODF_get_attribute_value(HW_install_pack_dic, 'SupplierName', MANDATORY)
            if HW_package_name == None or HW_package_supplier == None:
                logs.add('ERROR : no installation package name or supplier defined in the HW ODF')
                return None

            folder_name = os.path.join(self.HW_sample_set_path, 'OrganInstallationPackages', str(HW_package_id).zfill(6))
            if not os.path.isdir(folder_name):
                # the folder doesn't exist in the sample set package
                logs.add(f'WARNING : The package ID {HW_package_id} named "{HW_package_name}" provided by "{HW_package_supplier}"')
                logs.add(f'          is not present in the folder {path2ospath(folder_name)}')
                logs.add( '          some graphical or sound elements of this organ may be not rendered in GrandOrgue')
            else:
                self.available_HW_packages_id_list.append(HW_package_id)

        # recover the main installation package ID
        HW_install_package_id = myint(self.HW_ODF_get_attribute_value(self.HW_general_dic, 'OrganInfo_InstallationPackageID', MANDATORY))
        if HW_install_package_id == None:
            logs.add('ERROR : no main installation package ID defined in the HW ODF')
            return None

        # add an entry in the GO ODF dictionary for the Organ object
        GO_organ_uid = 'Organ'
        GO_organ_dic = self.GO_odf_dic[GO_organ_uid] = {}

        GO_organ_dic['ChurchName'] = mystr(self.HW_ODF_get_attribute_value(self.HW_general_dic, 'Identification_Name'))
        GO_organ_dic['ChurchAddress'] = mystr(self.HW_ODF_get_attribute_value(self.HW_general_dic, 'OrganInfo_Location'))
        GO_organ_dic['OrganBuilder'] = mystr(self.HW_ODF_get_attribute_value(self.HW_general_dic, 'OrganInfo_Builder'))
        GO_organ_dic['OrganBuildDate'] = mystr(self.HW_ODF_get_attribute_value(self.HW_general_dic, 'OrganInfo_BuildDate'))
        GO_organ_dic['OrganComments'] = ODF_COMMENT
        GO_organ_dic['RecordingDetails'] = mystr(self.HW_ODF_get_attribute_value(self.HW_general_dic, 'Control_OrganDefinitionSupplierName', MANDATORY))

        GO_organ_dic['HasPedals'] = 'N'  # will be set later in GO_ODF_build_Manual_objects
        GO_organ_dic['NumberOfManuals'] = 0
        GO_organ_dic['NumberOfPanels'] = 0
        GO_organ_dic['NumberOfWindchestGroups'] = 0
        GO_organ_dic['NumberOfRanks'] = 0
        GO_organ_dic['NumberOfSwitches'] = 0
        GO_organ_dic['NumberOfEnclosures'] = 0
        GO_organ_dic['NumberOfTremulants'] = 0
        GO_organ_dic['NumberOfGenerals'] = 0
        GO_organ_dic['NumberOfDivisionalCouplers'] = 0
        GO_organ_dic['NumberOfReversiblePistons'] = 0

        GO_organ_dic['GeneralsStoreDivisionalCouplers'] = 'Y'
        GO_organ_dic['DivisionalsStoreTremulants'] = 'Y'
        GO_organ_dic['DivisionalsStoreIntermanualCouplers'] = 'Y'
        GO_organ_dic['DivisionalsStoreIntramanualCouplers'] = 'Y'
        GO_organ_dic['CombinationsStoreNonDisplayedDrawstops'] = 'N'

        # recover the ID of the HW default display page (will be used in other GO_ODF_build_xxx functions)
        self.HW_default_display_page_dic = self.HW_ODF_get_object_by_ref_id('DisplayPage', self.HW_general_dic, 'SpecialObjects_DefaultDisplayPageID')
        if self.HW_default_display_page_dic == None:
            # cannot continue the convertion if there is no default display page defined
            logs.add('ERROR : no default display page defined in the HW ODF')
            return None

        # define the organ pitch tuning if the organ base pitch is defined
        organ_base_pitch = myfloat(self.HW_ODF_get_attribute_value(self.HW_general_dic, 'AudioEngine_BasePitchHz'), 440)
        if organ_base_pitch != 0:
            organ_base_pitch_correction = delta_freq_to_cent(organ_base_pitch, 440)
            if organ_base_pitch_correction != 0:
                GO_organ_dic['PitchTuning'] = organ_base_pitch_correction

        gain = myfloat(self.HW_ODF_get_attribute_value(self.HW_general_dic, 'AudioOut_AmplitudeLevelAdjustDecibels'), 0)
        if gain != 0:
            GO_organ_dic['Gain'] = gain

        # add in the HW _General object the ID of the corresponding GO object
        self.HW_general_dic['_GO_uid'] = 'Organ'

        return GO_organ_uid

    #-------------------------------------------------------------------------------------------------
    def GO_ODF_build_Panel_object(self, HW_disp_page_dic):
        # build a GO Panel999 corresponding to the given HW DisplayPage
        # build also the image and label objects which are defined in this panel
        # return the UID of the created GO Panel object or None in case of error

        # used HW objects :
        #   _General
        #   DisplayPage
        #   DisplayPage C> Keyboard
        #   DisplayPage C> ImageSetInstance C> ImageSet C> ImageSetElement (in function GO_ODF_build_Image_object)
        #   DisplayPage C> TextInstance C> TextStyle                       (in function GO_ODF_build_Label_object)
        #   DisplayPage C> TextInstance C> ImageSetInstance C> ImageSet C> ImageSetElement  (idem as above line)

        if self.HW_ODF_get_linked_objects_by_type(HW_disp_page_dic, 'Keyboard', TO_CHILD, FIRST_ONE) != None:
            # the current HW DisplayPage object contains at least one Keyboard object in his children, so it is the HW console page
            self.HW_console_display_page_dic = HW_disp_page_dic

        if HW_disp_page_dic == self.HW_default_display_page_dic:
            # this is the HW default display page, so assigned to the GO Panel000
            GO_panel_uid = 'Panel000'
        else:
            self.GO_odf_dic['Organ']['NumberOfPanels'] += 1  # Panel000 is not counted
            GO_panel_uid = 'Panel' + str(self.GO_odf_dic['Organ']['NumberOfPanels']).zfill(3)
        # add an GO Panel object in the GO ODF dictionary
        GO_panel_dic = self.GO_odf_dic[GO_panel_uid] = {}

        GO_panel_dic['_GO_uid'] = GO_panel_uid
        GO_panel_dic['Name'] = self.HW_ODF_get_attribute_value(HW_disp_page_dic, 'Name')
        GO_panel_dic['HasPedals'] = 'N'  # will be set later in GO_ODF_build_Manual_objects
        GO_panel_dic['NumberOfGUIElements'] = 0
        GO_panel_dic['NumberOfImages'] = 0

        if HW_disp_page_dic == self.HW_console_display_page_dic:
            # the current HW DisplayPage object is the HW console page, get the dimensions of the console page defined in the HW _General object
            GO_panel_dic['DispScreenSizeHoriz'] = myint(self.HW_ODF_get_attribute_value(self.HW_general_dic, 'Display_ConsoleScreenWidthPixels'), 0)
            GO_panel_dic['DispScreenSizeVert'] = myint(self.HW_ODF_get_attribute_value(self.HW_general_dic, 'Display_ConsoleScreenHeightPixels'), 0)
        else:
            GO_panel_dic['DispScreenSizeHoriz'] = 0  # will be set later when GO_ODF_build_Panel_size_update will be called
            GO_panel_dic['DispScreenSizeVert'] = 0

        # set the other mandatory attributes of a GO panel at a default value, no import from Hauptwerk ODF for the GO built-in console drawing
        GO_panel_dic['DispDrawstopBackgroundImageNum'] = '1'
        GO_panel_dic['DispDrawstopInsetBackgroundImageNum'] = '1'
        GO_panel_dic['DispConsoleBackgroundImageNum'] = '1'
        GO_panel_dic['DispKeyHorizBackgroundImageNum'] = '1'
        GO_panel_dic['DispKeyVertBackgroundImageNum'] = '1'
        GO_panel_dic['DispControlLabelFont'] = 'Arial'
        GO_panel_dic['DispShortcutKeyLabelFont'] = 'Arial'
        GO_panel_dic['DispShortcutKeyLabelColour'] = 'Black'
        GO_panel_dic['DispGroupLabelFont'] = 'Arial'
        GO_panel_dic['DispDrawstopCols'] = '2'
        GO_panel_dic['DispDrawstopRows'] = '1'
        GO_panel_dic['DispDrawstopColsOffset'] = 'N'
        GO_panel_dic['DispPairDrawstopCols'] = 'N'
        GO_panel_dic['DispExtraDrawstopRows'] = '0'
        GO_panel_dic['DispExtraDrawstopCols'] = '0'
        GO_panel_dic['DispButtonCols'] = '1'
        GO_panel_dic['DispExtraButtonRows'] = '0'
        GO_panel_dic['DispExtraPedalButtonRow'] = 'N'
        GO_panel_dic['DispButtonsAboveManuals'] = 'N'
        GO_panel_dic['DispExtraDrawstopRowsAboveExtraButtonRows'] = 'N'
        GO_panel_dic['DispTrimAboveManuals'] = 'N'
        GO_panel_dic['DispTrimBelowManuals'] = 'N'
        GO_panel_dic['DispTrimAboveExtraRows'] = 'N'

        # add in the HW DisplayPage object the ID of the corresponding GO object
        HW_disp_page_dic['_GO_uid'] = GO_panel_uid

        # build the GO static images of the panel by order of layer number (to be sure they will be visible in GO as designed in the HW ODF)
        HW_images_list_per_layer_dict = {}
        for HW_img_set_inst_dic in self.HW_ODF_get_linked_objects_by_type(HW_disp_page_dic, 'ImageSetInstance', TO_CHILD):
            # scan the HW ImageSetInstance objects of the given HW DisplayPage
            # to store in a local dictionary the static images of the given HW DisplayPage grouped by layer number
            if len(HW_img_set_inst_dic['_parents']) == 1:
                # the current HW ImageSetInstance object has a single parent (a DisplayPage) : it is a static image
                HW_layer_nb_int = myint(self.HW_ODF_get_attribute_value(HW_img_set_inst_dic, 'ScreenLayerNumber'), 1)  # default to 1
                if HW_layer_nb_int not in HW_images_list_per_layer_dict.keys():
                    # there is not yet an entry in the dictionary for the layer number of the current HW ImageSetInstance
                    # add one entry initialized with an empty list
                    HW_images_list_per_layer_dict[HW_layer_nb_int] = []
                # add the current HW ImageSetInstance to the list of the layer numbers
                HW_images_list_per_layer_dict[HW_layer_nb_int].append(HW_img_set_inst_dic)
        for HW_layer_nb_int in sorted(HW_images_list_per_layer_dict.keys()):
            # scan the HW display layers of the page by ascending order in order to build the images in this same order in the GO panel
            for HW_img_set_inst_dic in HW_images_list_per_layer_dict[HW_layer_nb_int]:
                # scan the HW ImageSetInstance objects of the current display layer
                self.GO_ODF_build_Image_object(HW_img_set_inst_dic, GO_panel_dic)

        return GO_panel_uid

    #-------------------------------------------------------------------------------------------------
    def GO_ODF_build_Panel_size_update(self, GO_panel_dic, x, y):
        # increase the width or height of the given GO panel so that the given coordinates are visible in this panel

        if x != None and x > GO_panel_dic['DispScreenSizeHoriz']: GO_panel_dic['DispScreenSizeHoriz'] = x
        if y != None and y > GO_panel_dic['DispScreenSizeVert']: GO_panel_dic['DispScreenSizeVert'] = y

    #-------------------------------------------------------------------------------------------------
    def GO_ODF_build_Image_object(self, HW_img_set_inst_dic, GO_panel_dic):
        # build a GO Panel999Image999 object corresponding to the given HW ImageSetInstance and in the given GO Panel
        # sub-function of GO_ODF_build_Panel_object
        # return the UID of the created GO PanelImage object or None if no panel image created

        # used HW objects :
        #   ImageSetInstance C> ImageSet C> ImageSetElement

        image_attr_dic = {}
        if self.HW_ODF_get_image_attributes(HW_img_set_inst_dic, image_attr_dic) and image_attr_dic['BitmapFilename'] != None:
            # the data about the current HW ImageSetInstance object have been recovered successfully and an image file name is defined

            if image_attr_dic['ImageWidthPixels'] == None or image_attr_dic['ImageHeightPixels'] == None:
                # if one dimension of the image is not defined, get the dimensions of the image in the bitmap file
                image_filename = os.path.dirname(self.HW_odf_file_name) + os.sep + path2ospath(image_attr_dic['BitmapFilename'])
                if os.path.isfile(image_filename):
                    im = Image.open(image_filename)
                    image_attr_dic['ImageWidthPixels'] = im.size[0]
                    image_attr_dic['ImageHeightPixels'] = im.size[1]
                else:
                    image_attr_dic['ImageWidthPixels'] = None
                    image_attr_dic['ImageHeightPixels'] = None

            # create a GO Panel999Image999 object for the given GO Panel
            GO_panel_uid = GO_panel_dic['_GO_uid']
            self.GO_odf_dic[GO_panel_uid]['NumberOfImages'] += 1
            GO_panel_image_uid = GO_panel_uid + 'Image' + str(self.GO_odf_dic[GO_panel_uid]['NumberOfImages']).zfill(3)
            GO_panel_image_dic = self.GO_odf_dic[GO_panel_image_uid] = {}

            # set the position and sizes of the image
            image_max_x = image_max_y = 0
            if image_attr_dic['LeftXPosPixels'] > 0:
                GO_panel_image_dic['PositionX'] = image_attr_dic['LeftXPosPixels']
            if image_attr_dic['TopYPosPixels'] > 0:
                GO_panel_image_dic['PositionY'] = image_attr_dic['TopYPosPixels']
            if image_attr_dic['ImageWidthPixels'] != None:
                GO_panel_image_dic['Width'] = image_attr_dic['ImageWidthPixels']
                image_max_x = image_attr_dic['LeftXPosPixels'] + image_attr_dic['ImageWidthPixels']
            if image_attr_dic['ImageHeightPixels'] != None:
                GO_panel_image_dic['Height'] = image_attr_dic['ImageHeightPixels']
                image_max_y = image_attr_dic['TopYPosPixels'] + image_attr_dic['ImageHeightPixels']

            # set the image and its mask if any
            GO_panel_image_dic['Image'] = image_attr_dic['BitmapFilename']
            if image_attr_dic['TransparencyMaskBitmapFilename'] != None:
                GO_panel_image_dic['Mask'] = image_attr_dic['TransparencyMaskBitmapFilename']

            # increase if necessary the GO panel dimensions to display entirely the image
            self.GO_ODF_build_Panel_size_update(GO_panel_dic, image_max_x, image_max_y)

            # add in the HW ImageSetInstance object the ID of the corresponding GO object
            HW_img_set_inst_dic['_GO_uid'] = GO_panel_image_uid

            return GO_panel_image_uid
        else:
            return None

    #-------------------------------------------------------------------------------------------------
    def GO_ODF_build_Label_object(self, HW_text_inst_dic, GO_panel_uid):
        # build a GO Panel999Element999 object with type=Label corresponding to the given HW TextInstance and in the given GO Panel
        # sub-function of GO_ODF_build_Panel_object
        # return the UID of the created GO Panel Element object, or None if no panel element created

        # used HW objects :
            #   TextInstance C> TextStyle
            #   TextInstance C> ImageSetInstance C> ImageSet C> ImageSetElement


        # recover the attributes of the given HW TextInstance object and his linked HW ImageSetInstance object if any
        text_attr_dic = {}
        if not self.HW_ODF_get_text_attributes(HW_text_inst_dic, text_attr_dic):
            return False

        # create a GO Panel999Element999 object with label type in the given GO panel
        self.GO_odf_dic[GO_panel_uid]['NumberOfGUIElements'] += 1
        GO_panel_element_uid = GO_panel_uid + 'Element' + str(self.GO_odf_dic[GO_panel_uid]['NumberOfGUIElements']).zfill(3)
        GO_panel_element_dic = self.GO_odf_dic[GO_panel_element_uid] = {}

        GO_panel_element_dic['Type'] = 'Label'
        GO_panel_element_dic['Name'] = text_attr_dic['Text'].replace('\n', ' ')  # replace eventual carriage returns by black space

        # set the font size/name and text colour
        GO_panel_element_dic['DispLabelFontSize'] = text_attr_dic['Font_SizePixels']
        GO_panel_element_dic['DispLabelFontName'] = text_attr_dic['Face_WindowsName']
        GO_panel_element_dic['DispLabelColour'] = '#%02x%02x%02x' % (text_attr_dic['Colour_Red'],
                                                                     text_attr_dic['Colour_Green'],
                                                                     text_attr_dic['Colour_Blue'])

        # recover the display dimensions of the label text according to the font name/size/weight
        text_font = tkf.Font(family=text_attr_dic['Face_WindowsName'], size=1 * text_attr_dic['Font_SizePixels'],
                             weight='bold' if text_attr_dic['Font_WeightCode'] == 3 else 'normal')
        text_width = text_font.measure(text_attr_dic['Text'])
        text_height = text_font.metrics('ascent') + text_font.metrics('descent')

        # move the XPosPixels value at the left of the text according to the text horizontal alignment attribute
        if text_attr_dic['HorizontalAlignmentCode'] in (0, 3): # centered : move by the half of the text width
            text_attr_dic['XPosPixels'] -= int(text_width / 2)
        elif text_attr_dic['HorizontalAlignmentCode'] == 2: # right aligned : move by the text width
            text_attr_dic['XPosPixels'] -= text_width
        if text_attr_dic['XPosPixels'] < 0:
            text_attr_dic['XPosPixels'] = 0

        # move the YPosPixels value at the top of the text according to the text vertical alignment attribute
        if text_attr_dic['VerticalAlignmentCode'] == 0: # centered : move by the half of the text height
            text_attr_dic['YPosPixels'] -= int(text_height / 2)
        elif text_attr_dic['VerticalAlignmentCode'] == 2: # bottom aligned : move by the text height
            text_attr_dic['YPosPixels'] -= text_height
        if text_attr_dic['YPosPixels'] < 0:
            text_attr_dic['YPosPixels'] = 0

        # get the absolute position of the top left corner of the text
        if text_attr_dic['ImageSetInstanceDic'] == None or text_attr_dic['PosRelativeToTopLeftOfImage'] == 'N':
            # no image attached to the text or text not placed relatively to an eventual attached image : XPosPixels / YPosPixels are already absolute values
            text_abs_x = text_attr_dic['XPosPixels']
            text_abs_y = text_attr_dic['YPosPixels']
        else:
            # an image is attached to the text and the text is placed relatively to the position of its attached image
            text_abs_x = text_attr_dic['LeftXPosPixels'] + text_attr_dic['XPosPixels']
            text_abs_y = text_attr_dic['TopYPosPixels'] + text_attr_dic['YPosPixels']


        if text_attr_dic['ImageSetInstanceDic'] == None or text_attr_dic['BitmapFilename'] == None:
            # no image attached to the text or the attached image is not found (image from Hauptwerk default images bank for example)
            # build a GO label without background image

            GO_panel_element_dic['DispImageNum'] = 0  # no background image

            # set the text position
            GO_panel_element_dic['PositionX'] = text_abs_x
            GO_panel_element_dic['PositionY'] = text_abs_y

            # set the width and height attributes with the text width and height to be sure that the text is displayed entirely and in a single ligne by GO
            GO_panel_element_dic['Width'] = text_width
            GO_panel_element_dic['Height'] = text_height

        else:
            # the text has a background image

            # set the image file name
            GO_panel_element_dic['Image'] = text_attr_dic['BitmapFilename']
            # set the image mask file name
            if text_attr_dic['TransparencyMaskBitmapFilename'] != None:
                GO_panel_element_dic['Mask'] = text_attr_dic['TransparencyMaskBitmapFilename']

            # get the image dimensions if they are not defined in the HW ODF
            img_w = img_h = None
            if text_attr_dic['ImageWidthPixels'] == None or text_attr_dic['ImageHeightPixels'] == None:
                image_path = self.HW_sample_set_odf_path + os.sep + path2ospath(text_attr_dic['BitmapFilename'])
                if os.path.isfile(image_path):
                    im = Image.open(image_path)
                    text_attr_dic['ImageWidthPixels'] = im.size[0]
                    text_attr_dic['ImageHeightPixels'] = im.size[1]

            # set the position of the image
            GO_panel_element_dic['PositionX'] = text_attr_dic['LeftXPosPixels']
            GO_panel_element_dic['PositionY'] = text_attr_dic['TopYPosPixels']

            # set the image dimensions
            if text_attr_dic['ImageWidthPixels'] != None:
                GO_panel_element_dic['Width'] = text_attr_dic['ImageWidthPixels']
            if text_attr_dic['ImageHeightPixels'] != None:
                GO_panel_element_dic['Height'] = text_attr_dic['ImageHeightPixels']

            # set the text position relatively to the image position
            GO_panel_element_dic['TextRectLeft'] = text_abs_x - GO_panel_element_dic['PositionX']
            GO_panel_element_dic['TextRectTop'] = text_abs_y - GO_panel_element_dic['PositionY']

            # set the text dimensions
            if text_attr_dic['BoundingBoxWidthPixelsIfWordWrap'] > 0:
                # a text boundary is defined in the HW ODF
                GO_panel_element_dic['TextRectWidth'] = text_attr_dic['BoundingBoxWidthPixelsIfWordWrap']
            else:
                # use text width for the text rectangle width
                GO_panel_element_dic['TextRectWidth'] = text_width

            if text_attr_dic['BoundingBoxHeightPixelsIfWordWrap'] > 0:
                # a text boundary is defined in the HW ODF
                GO_panel_element_dic['TextRectHeight'] = text_attr_dic['BoundingBoxHeightPixelsIfWordWrap']
            else:
                # use text height for the text rectangle width
                GO_panel_element_dic['TextRectHeight'] = text_height

            if ('Width' in GO_panel_element_dic.keys() and
                GO_panel_element_dic['TextRectLeft'] + GO_panel_element_dic['TextRectWidth'] > GO_panel_element_dic['Width']):
                # the text width is larger than the image width (can occur in case of carriage returns removed in the text)
                # use the full rectangle of the image to display the text (which is centered inside by GO)
                GO_panel_element_dic['TextRectLeft'] = 0
                GO_panel_element_dic['TextRectTop'] = 0
                GO_panel_element_dic['TextRectWidth'] = GO_panel_element_dic['Width']
                GO_panel_element_dic['TextRectHeight'] = GO_panel_element_dic['Height']


        # check if the label is overlapping a GO panel element (but Manual or Label) of the given panel
        # if yes set the DispLabelText of the GO panel element with the name of the label and delete the GO label element just build before
        for object_uid in self.GO_odf_dic.keys():
            # scan the objects of the GO ODF
            if len(object_uid) == 18 and object_uid[:8] == GO_panel_uid:
                # Panel999Element999 object of the given panel
                GO_panelem_dic = self.GO_odf_dic[object_uid]
                if GO_panelem_dic['Type'] not in ('Manual', 'Label'):
                    if (GO_panel_element_dic['PositionX'] in range(GO_panelem_dic['PositionX'], GO_panelem_dic['PositionX'] + GO_panelem_dic['Width']) and
                        GO_panel_element_dic['PositionY'] in range(GO_panelem_dic['PositionY'], GO_panelem_dic['PositionY'] + GO_panelem_dic['Height'])):
                        # the top left corner of the label is inside the panel element area, so it is overlapping it
                        if 'DispLabelText' in GO_panelem_dic.keys():
                            GO_panelem_dic['DispLabelText'] += GO_panel_element_dic['Name'] + ' '  # use addition in case several labels are overlapping the panel element
                        else:
                            GO_panelem_dic['DispLabelText'] = GO_panel_element_dic['Name'] + ' '
                        GO_panelem_dic['DispLabelFontSize'] = 11
                        GO_panelem_dic['DispLabelColour'] = 'Black'

                        if GO_panelem_dic['Type'] == 'Switch':
                            # remove the image attributes of the switch else the image will hide the text
                            if 'ImageOn' in GO_panelem_dic.keys(): del GO_panelem_dic['ImageOn']
                            if 'ImageOff' in GO_panelem_dic.keys(): del GO_panelem_dic['ImageOff']
                            if 'MaskOn' in GO_panelem_dic.keys(): del GO_panelem_dic['MaskOn']
                            if 'MaskOff' in GO_panelem_dic.keys(): del GO_panelem_dic['MaskOff']
                            if 'TextBreakWidth' in GO_panelem_dic.keys(): del GO_panelem_dic['TextBreakWidth']
                            # set the dimensions of the default drawstop image of GrangOrgue
                            if 'Width' in GO_panelem_dic.keys(): GO_panelem_dic['Width'] = 65
                            if 'Height' in GO_panelem_dic.keys(): GO_panelem_dic['Height'] = 65
                            if 'MouseRectWidth' in GO_panelem_dic.keys(): GO_panelem_dic['MouseRectWidth'] = 65
                            if 'MouseRectHeight' in GO_panelem_dic.keys(): GO_panelem_dic['MouseRectHeight'] = 65

                        # get the absolute position of the label
                        if 'TextRectLeft' in GO_panel_element_dic.keys():
                            label_abs_x = GO_panel_element_dic['PositionX'] + GO_panel_element_dic['TextRectLeft']
                        else:
                            label_abs_x = GO_panel_element_dic['PositionX']

                        if 'TextRectTop' in GO_panel_element_dic.keys():
                            label_abs_y = GO_panel_element_dic['PositionY'] + GO_panel_element_dic['TextRectTop']
                        else:
                            label_abs_y = GO_panel_element_dic['PositionY']

                        # get the position of the label relatively to the position of the hosting panel element
                        label_rel_x = label_abs_x - GO_panelem_dic['PositionX']
                        label_rel_y = label_abs_y - GO_panelem_dic['PositionY']

                        # place the label inside the hosting panel element
                        if 'TextRectLeft' not in GO_panelem_dic.keys() or GO_panelem_dic['TextRectLeft'] > label_rel_x:
                            GO_panelem_dic['TextRectLeft'] = label_rel_x
                        if 'TextRectTop' not in GO_panelem_dic.keys() or GO_panelem_dic['TextRectTop'] > label_rel_y:
                            GO_panelem_dic['TextRectTop'] = label_rel_y

                        # delete the label built before in this function
                        self.GO_odf_dic.pop(GO_panel_element_uid)
                        self.GO_odf_dic[GO_panel_uid]['NumberOfGUIElements'] -= 1
                        return None

        # add in the HW TextInstance and ImageSetInstance objects the ID of the corresponding GO object
        HW_text_inst_dic['_GO_uid'] = GO_panel_element_uid
        if text_attr_dic['ImageSetInstanceDic'] != None:
            text_attr_dic['ImageSetInstanceDic']['_GO_uid'] = GO_panel_element_uid

        return GO_panel_element_uid

    #-------------------------------------------------------------------------------------------------
    def GO_ODF_build_Manual_object(self, HW_division_dic):
        # build a GO Manual999 object based on the given HW Division
        # return the UID of the GO Manuel object build or already existing

        # used HW objects :
        #   Division C> Keyboard C> KeyboardKey P> Switch C> ImageSetInstance C> ImageSet C> ImageSetElement  ==> keyboard_display_mode = 1
        #   Division C> Keyboard C> KeyImageSet C> ImageSet C> ImageSetElement                                ==> keyboard_display_mode = 2

        if HW_division_dic['_GO_uid'] != '':
            # a GO manual has been already assigned to the HW division, we can exit
            return HW_division_dic['_GO_uid']

        # get the first visible HW Keyboard associated to the given HW Division
        HW_keyboard_dic = None
        for HW_keyb_dic in self.HW_ODF_get_linked_objects_by_type(HW_division_dic, 'Keyboard', TO_CHILD):
            # scan the HW Keyboard objects belonging to the given HW Division, to search the first one which has a KeyImageSet or KeyboardKey child
            if (self.HW_ODF_get_linked_objects_by_type(HW_keyb_dic, 'KeyImageSet', TO_CHILD, FIRST_ONE) != None or
                self.HW_ODF_get_linked_objects_by_type(HW_keyb_dic, 'KeyboardKey', TO_CHILD, FIRST_ONE) != None):
                HW_keyboard_dic = HW_keyb_dic
                break

        # get how the HW keyboard is graphically defined
        keyboard_display_mode = 0  # by default the keyboard is not visible
        if HW_keyboard_dic != None:
            if self.HW_ODF_get_linked_objects_by_type(HW_keyboard_dic, 'KeyboardKey', TO_CHILD, FIRST_ONE) != None:
                keyboard_display_mode = 1  # the keyboard is graphically defined by KeyboardKey objects (which should be linked to a Switch + ImageSetInstance)
            elif self.HW_ODF_get_attribute_value(HW_keyboard_dic, 'KeyGen_KeyImageSetID') != None:
                keyboard_display_mode = 2  # the keyboard is graphically defined by a KeyImageSet object

        # define the GO Manual999 object to associate to this HW Division
        HW_division_id = int(HW_division_dic['_HW_uid'][-6:])
        if HW_division_id == 1:
            # Pedal division
            GO_manual_uid = 'Manual000'
        else:
            self.GO_odf_dic['Organ']['NumberOfManuals'] += 1
            GO_manual_uid = 'Manual' + str(self.GO_odf_dic['Organ']['NumberOfManuals']).zfill(3)
        GO_manual_dic = self.GO_odf_dic[GO_manual_uid] = {}
        GO_manual_dic['_GO_uid'] = GO_manual_uid

        # add in the HW Division and Keyboard objects the UID of the corresponding GO object
        HW_division_dic['_GO_uid'] = GO_manual_uid
        if HW_keyboard_dic != None:
            HW_keyboard_dic['_GO_uid'] = GO_manual_uid

        # update in the GO Organ and Panel objects the HasPedal attribute value
        if GO_manual_uid == 'Manual000':
            self.GO_odf_dic['Organ']['HasPedals'] = 'Y'
            if self.HW_console_display_page_dic != None:
                self.GO_odf_dic[self.HW_console_display_page_dic['_GO_uid']]['HasPedals'] = 'Y'

        # recover the number of keys of the keyboard and its first and last MIDI note numbers
        if keyboard_display_mode == 1:
            # recover this from the HW KeyboardKey objects belonging to the HW Keyboard and being linked to an ImageSetInstance
            first_midi_note_nb_int = 999
            last_midi_note_nb_int = 0
            nb_keys_int = 0
            keys_switch_dic = {}  # dictionary with as key the MIDI note number and as value the corresponding HW Switch object
            for HW_keyboard_key_dic in self.HW_ODF_get_linked_objects_by_type(HW_keyboard_dic, 'KeyboardKey', TO_CHILD):
                # scan the HW KeyboardKey objects which are children of the HW Keyboard
                # recover the HW ImageSetInstance associated to the HW Switch associated to the current HW KeyboardKey
                HW_switch_dic = self.HW_ODF_get_object_by_ref_id('Switch', HW_keyboard_key_dic, 'SwitchID')
                HW_img_set_instance_id = myint(self.HW_ODF_get_attribute_value(HW_switch_dic, 'Disp_ImageSetInstanceID'))
                if HW_img_set_instance_id != None:
                    # the current HW KeyboardKey has an associated HW ImageSetInstance (in Grabowski Enerlo the highest keys have no image)
                    nb_keys_int += 1
                    # get the MIDI note number of the current HW KeyboardKey object
                    midi_note_nb_int = myint(self.HW_ODF_get_attribute_value(HW_keyboard_key_dic, 'NormalMIDINoteNumber'))
                    if midi_note_nb_int == None: midi_note_nb_int = 60 # observed with Sound Paradisi sample sets, the MIDI note 60 is not defined
                    # update the first and last MIDI note numbers
                    if midi_note_nb_int < first_midi_note_nb_int: first_midi_note_nb_int = midi_note_nb_int
                    if midi_note_nb_int > last_midi_note_nb_int:  last_midi_note_nb_int = midi_note_nb_int
                    # add an entry in the keys switch dictionary with the HW Switch associated to the current HW KeyboardKey
                    keys_switch_dic[midi_note_nb_int] = self.HW_ODF_get_object_by_ref_id('Switch', HW_keyboard_key_dic, 'SwitchID')
                    # add in the HW KeyboardKey object the UID of the corresponding GO object
                    HW_keyboard_key_dic['_GO_uid'] = GO_manual_uid
        elif keyboard_display_mode == 2:
            # recover this from the KeyGen attributes of the HW Keyboard
            nb_keys_int = myint(self.HW_ODF_get_attribute_value(HW_keyboard_dic, 'KeyGen_NumberOfKeys'))
            first_midi_note_nb_int = myint(self.HW_ODF_get_attribute_value(HW_keyboard_dic, 'KeyGen_MIDINoteNumberOfFirstKey'))
            last_midi_note_nb_int = first_midi_note_nb_int + nb_keys_int - 1
        else: # keyboard_display_mode == 0 (not visible keyboards)
            # recover this from the InpGen attributes of the HW Division or the KeyGen attributes of the HW Keyboard
            nb_keys_int = myint(self.HW_ODF_get_attribute_value(HW_division_dic, 'InpGen_NumberOfInputs'))
            if nb_keys_int == None:
                nb_keys_int = myint(self.HW_ODF_get_attribute_value(HW_keyboard_dic, 'KeyGen_NumberOfKeys'))

            first_midi_note_nb_int = myint(self.HW_ODF_get_attribute_value(HW_division_dic, 'InpGen_MIDINoteNumberOfFirstInput'))
            if first_midi_note_nb_int == None:
                first_midi_note_nb_int = myint(self.HW_ODF_get_attribute_value(HW_keyboard_dic, 'KeyGen_MIDINoteNumberOfFirstKey'))

            # if still not know, try to recover from the number of HW DivisionInput objects
            if nb_keys_int == None:
                HW_div_inputs_list = self.HW_ODF_get_linked_objects_by_type(HW_division_dic, 'DivisionInput', TO_CHILD)
                if len(HW_div_inputs_list) > 0:
                    nb_keys_int = len(HW_div_inputs_list)
                    first_midi_note_nb_int = 999
                    for HW_div_input_dic in HW_div_inputs_list:
                        midi_not_nb = myint(self.HW_ODF_get_attribute_value(HW_div_input_dic, 'NormalMIDINoteNumber'))
                        if midi_not_nb != None and midi_not_nb < first_midi_note_nb_int:
                            first_midi_note_nb_int = midi_not_nb

            if nb_keys_int != None and first_midi_note_nb_int != None:
                last_midi_note_nb_int = first_midi_note_nb_int + nb_keys_int - 1
            else:
                nb_keys_int = first_midi_note_nb_int = last_midi_note_nb_int = 0

        # get the HW DisplayPage in which is displayed the keyboard
        if keyboard_display_mode == 1:
            # recover this from the HW ImageSetInstance of the first key of the keyboard
            HW_img_set_instance_id = myint(self.HW_ODF_get_attribute_value(keys_switch_dic[first_midi_note_nb_int], 'Disp_ImageSetInstanceID', MANDATORY))
            HW_img_set_instance_dic = self.HW_ODF_get_object_dic('ImageSetInstance', HW_img_set_instance_id)
            keyboard_disp_page_id = myint(self.HW_ODF_get_attribute_value(HW_img_set_instance_dic, 'DisplayPageID'))
        elif keyboard_display_mode == 2:
            keyboard_disp_page_id = myint(self.HW_ODF_get_attribute_value(HW_keyboard_dic, 'KeyGen_DisplayPageID'))

        GO_manual_dic['Name'] = self.HW_ODF_get_attribute_value(HW_division_dic, 'Name')
        GO_manual_dic['NumberOfLogicalKeys'] = nb_keys_int
        GO_manual_dic['NumberOfAccessibleKeys'] = nb_keys_int
        GO_manual_dic['FirstAccessibleKeyLogicalKeyNumber'] = 1
        GO_manual_dic['FirstAccessibleKeyMIDINoteNumber'] = first_midi_note_nb_int
        GO_manual_dic['NumberOfCouplers'] = 0
        GO_manual_dic['NumberOfDivisionals'] = 0
        GO_manual_dic['NumberOfStops'] = 0
        GO_manual_dic['NumberOfSwitches'] = 0
        GO_manual_dic['NumberOfTremulants'] = 0

        if keyboard_display_mode == 0:
            # the keyboard is not visible, we can stop here the definition of the GO Manual
            return GO_manual_uid

        # define the manual graphical attributes in a Panel999Element999 object with Type = Manual

        # get the GO Panel UID in which to display the keyboard
        HW_disp_page_dic = self.HW_ODF_get_object_dic('DisplayPage', keyboard_disp_page_id)
        GO_panel_uid = HW_disp_page_dic['_GO_uid']

        # create the GO Panel999Element999 object to display the keyboard
        self.GO_odf_dic[GO_panel_uid]['NumberOfGUIElements'] += 1
        GO_panel_element_uid = GO_panel_uid + 'Element' + str(self.GO_odf_dic[GO_panel_uid]['NumberOfGUIElements']).zfill(3)
        GO_panel_element_dic = self.GO_odf_dic[GO_panel_element_uid] = {}

        GO_panel_element_dic['Type'] = 'Manual'
        GO_panel_element_dic['Manual'] = str(int(GO_manual_uid[-3:])).zfill(3)

        GO_panel_element_dic['_GO_uid'] = GO_manual_uid

        # define the graphical properties of the GO Manual
        if keyboard_display_mode == 1:
            # keys graphical aspect is defined for each key
            for midi_note_nb_int in range(first_midi_note_nb_int, last_midi_note_nb_int + 1):
                # scan the switches of the HW Keyboard by increasing MIDI note number
                GO_key_nb = midi_note_nb_int - first_midi_note_nb_int + 1

                if midi_note_nb_int < last_midi_note_nb_int:
                    # it is not the latest key of the keyboard
                    self.GO_ODF_build_Manual_keyimage_by_switch(keys_switch_dic[midi_note_nb_int], keys_switch_dic[midi_note_nb_int + 1], GO_panel_element_dic, GO_key_nb)
                else:
                    self.GO_ODF_build_Manual_keyimage_by_switch(keys_switch_dic[midi_note_nb_int], None, GO_panel_element_dic, GO_key_nb)

        else:
            # keys graphical aspect is defined for one octave + the first and last keys

            # get the HW KeyImageSet associated to the HW Keyboard
            HW_key_img_set_dic = self.HW_ODF_get_object_by_ref_id('KeyImageSet', HW_keyboard_dic, 'KeyGen_KeyImageSetID')

            # set the GO Manual position
            GO_panel_element_dic['PositionX'] = myint(self.HW_ODF_get_attribute_value(HW_keyboard_dic, 'KeyGen_DispKeyboardLeftXPos'))
            GO_panel_element_dic['PositionY'] = myint(self.HW_ODF_get_attribute_value(HW_keyboard_dic, 'KeyGen_DispKeyboardTopYPos'))

            # set the GO Manual keys width
            GO_panel_element_dic['Width_A']   = self.HW_ODF_get_attribute_value(HW_key_img_set_dic, 'HorizSpacingPixels_LeftOfDASharpFromLeftOfDA')
            GO_panel_element_dic['Width_Ais'] = self.HW_ODF_get_attribute_value(HW_key_img_set_dic, 'HorizSpacingPixels_LeftOfEBFromLeftOfDASharp')
            GO_panel_element_dic['Width_B']   = self.HW_ODF_get_attribute_value(HW_key_img_set_dic, 'HorizSpacingPixels_LeftOfNaturalFromLeftOfNatural')
            GO_panel_element_dic['Width_C']   = self.HW_ODF_get_attribute_value(HW_key_img_set_dic, 'HorizSpacingPixels_LeftOfCFSharpFromLeftOfCF')
            GO_panel_element_dic['Width_Cis'] = self.HW_ODF_get_attribute_value(HW_key_img_set_dic, 'HorizSpacingPixels_LeftOfDGFromLeftOfCFSharp')
            GO_panel_element_dic['Width_D']   = self.HW_ODF_get_attribute_value(HW_key_img_set_dic, 'HorizSpacingPixels_LeftOfDASharpFromLeftOfDA')
            GO_panel_element_dic['Width_Dis'] = self.HW_ODF_get_attribute_value(HW_key_img_set_dic, 'HorizSpacingPixels_LeftOfEBFromLeftOfDASharp')
            GO_panel_element_dic['Width_E']   = self.HW_ODF_get_attribute_value(HW_key_img_set_dic, 'HorizSpacingPixels_LeftOfNaturalFromLeftOfNatural')
            GO_panel_element_dic['Width_F']   = self.HW_ODF_get_attribute_value(HW_key_img_set_dic, 'HorizSpacingPixels_LeftOfCFSharpFromLeftOfCF')
            GO_panel_element_dic['Width_Fis'] = self.HW_ODF_get_attribute_value(HW_key_img_set_dic, 'HorizSpacingPixels_LeftOfDGFromLeftOfCFSharp')
            GO_panel_element_dic['Width_G']   = self.HW_ODF_get_attribute_value(HW_key_img_set_dic, 'HorizSpacingPixels_LeftOfGSharpFromLeftOfG')
            GO_panel_element_dic['Width_Gis'] = self.HW_ODF_get_attribute_value(HW_key_img_set_dic, 'HorizSpacingPixels_LeftOfAFromLeftOfGSharp')

            # set the GO Manual keys offset
            GO_panel_element_dic['Offset_A']   = '0'
            GO_panel_element_dic['Offset_Ais'] = '0'
            GO_panel_element_dic['Offset_B']   = '0'
            GO_panel_element_dic['Offset_C']   = '0'
            GO_panel_element_dic['Offset_Cis'] = '0'
            GO_panel_element_dic['Offset_D']   = '0'
            GO_panel_element_dic['Offset_Dis'] = '0'
            GO_panel_element_dic['Offset_E']   = '0'
            GO_panel_element_dic['Offset_F']   = '0'
            GO_panel_element_dic['Offset_Fis'] = '0'
            GO_panel_element_dic['Offset_G']   = '0'
            GO_panel_element_dic['Offset_Gis'] = '0'

            # get the key up (not pressed) and key down (pressed) images index within image set if defined, else set default index
            key_up_img_index = myint(self.HW_ODF_get_attribute_value(HW_key_img_set_dic, 'ImageIndexWithinImageSets_Disengaged'))
            if key_up_img_index == None: key_up_img_index = 1
            HW_key_img_set_dic['_key_up_img_index'] = key_up_img_index

            key_down_img_index = myint(self.HW_ODF_get_attribute_value(HW_key_img_set_dic, 'ImageIndexWithinImageSets_Engaged'))
            if key_down_img_index == None: key_down_img_index = 2
            HW_key_img_set_dic['_key_down_img_index'] = key_down_img_index

            # set the GO Manual keys images
            self.GO_ODF_build_Manual_keyimage_by_keytype(HW_key_img_set_dic, 'CF', GO_panel_element_dic, 'C')
            self.GO_ODF_build_Manual_keyimage_by_keytype(HW_key_img_set_dic, 'CF', GO_panel_element_dic, 'F')
            self.GO_ODF_build_Manual_keyimage_by_keytype(HW_key_img_set_dic, 'D', GO_panel_element_dic, 'D')
            self.GO_ODF_build_Manual_keyimage_by_keytype(HW_key_img_set_dic, 'EB', GO_panel_element_dic, 'E')
            self.GO_ODF_build_Manual_keyimage_by_keytype(HW_key_img_set_dic, 'EB', GO_panel_element_dic, 'B')
            self.GO_ODF_build_Manual_keyimage_by_keytype(HW_key_img_set_dic, 'G', GO_panel_element_dic, 'G')
            self.GO_ODF_build_Manual_keyimage_by_keytype(HW_key_img_set_dic, 'A', GO_panel_element_dic, 'A')
            self.GO_ODF_build_Manual_keyimage_by_keytype(HW_key_img_set_dic, 'Sharp', GO_panel_element_dic, 'Ais')
            self.GO_ODF_build_Manual_keyimage_by_keytype(HW_key_img_set_dic, 'Sharp', GO_panel_element_dic, 'Cis')
            self.GO_ODF_build_Manual_keyimage_by_keytype(HW_key_img_set_dic, 'Sharp', GO_panel_element_dic, 'Dis')
            self.GO_ODF_build_Manual_keyimage_by_keytype(HW_key_img_set_dic, 'Sharp', GO_panel_element_dic, 'Fis')
            self.GO_ODF_build_Manual_keyimage_by_keytype(HW_key_img_set_dic, 'Sharp', GO_panel_element_dic, 'Gis')

            # set the GO Manual first key image and width
            first_note_name, octave = midi_number_to_note(int(first_midi_note_nb_int))
            if first_note_name == 'D':
                self.GO_ODF_build_Manual_keyimage_by_keytype(HW_key_img_set_dic, 'FirstKeyDA', GO_panel_element_dic, 'FirstD')
                GO_panel_element_dic['Width_FirstD'] = self.HW_ODF_get_attribute_value(HW_key_img_set_dic, 'HorizSpacingPixels_LeftOfDASharpFromLeftOfDA')
            elif first_note_name == 'A':
                self.GO_ODF_build_Manual_keyimage_by_keytype(HW_key_img_set_dic, 'FirstKeyDA', GO_panel_element_dic, 'FirstA')
                GO_panel_element_dic['Width_FirstA'] = self.HW_ODF_get_attribute_value(HW_key_img_set_dic, 'HorizSpacingPixels_LeftOfDASharpFromLeftOfDA')
            elif first_note_name == 'G':
                self.GO_ODF_build_Manual_keyimage_by_keytype(HW_key_img_set_dic, 'FirstKeyG', GO_panel_element_dic, 'FirstG')
                GO_panel_element_dic['Width_FirstG'] = self.HW_ODF_get_attribute_value(HW_key_img_set_dic, 'HorizSpacingPixels_LeftOfGSharpFromLeftOfG')
            elif first_note_name == 'C':
                self.GO_ODF_build_Manual_keyimage_by_keytype(HW_key_img_set_dic, 'CF', GO_panel_element_dic, 'FirstC')
                GO_panel_element_dic['Width_FirstC'] = self.HW_ODF_get_attribute_value(HW_key_img_set_dic, 'HorizSpacingPixels_LeftOfCFSharpFromLeftOfCF')

            # set the GO Manual last key image and width
            last_note_name, octave = midi_number_to_note(int(last_midi_note_nb_int))
            if last_note_name == 'D':
                self.GO_ODF_build_Manual_keyimage_by_keytype(HW_key_img_set_dic, 'LastKeyDG', GO_panel_element_dic, 'LastD')
                GO_panel_element_dic['Width_LastD'] = self.HW_ODF_get_attribute_value(HW_key_img_set_dic, 'HorizSpacingPixels_LeftOfNaturalFromLeftOfNatural')
            elif last_note_name == 'G':
                self.GO_ODF_build_Manual_keyimage_by_keytype(HW_key_img_set_dic, 'LastKeyDG', GO_panel_element_dic, 'LastG')
                GO_panel_element_dic['Width_LastG'] = self.HW_ODF_get_attribute_value(HW_key_img_set_dic, 'HorizSpacingPixels_LeftOfNaturalFromLeftOfNatural')
            elif last_note_name == 'A':
                self.GO_ODF_build_Manual_keyimage_by_keytype(HW_key_img_set_dic, 'LastKeyA', GO_panel_element_dic, 'LastA')
                GO_panel_element_dic['Width_LastA'] = self.HW_ODF_get_attribute_value(HW_key_img_set_dic, 'HorizSpacingPixels_LeftOfNaturalFromLeftOfNatural')
            elif last_note_name == 'C':
                self.GO_ODF_build_Manual_keyimage_by_keytype(HW_key_img_set_dic, 'WholeNatural', GO_panel_element_dic, 'LastC')
                GO_panel_element_dic['Width_LastC'] = self.HW_ODF_get_attribute_value(HW_key_img_set_dic, 'HorizSpacingPixels_LeftOfNaturalFromLeftOfNatural')
            elif last_note_name == 'F':
                self.GO_ODF_build_Manual_keyimage_by_keytype(HW_key_img_set_dic, 'WholeNatural', GO_panel_element_dic, 'LastF')
                GO_panel_element_dic['Width_LastF'] = self.HW_ODF_get_attribute_value(HW_key_img_set_dic, 'HorizSpacingPixels_LeftOfNaturalFromLeftOfNatural')

        return GO_manual_uid

    #-------------------------------------------------------------------------------------------------
    def GO_ODF_build_Manual_keyimage_by_keytype(self, HW_key_img_set_dic, HW_key_type, GO_panel_element_dic, GO_key_type):
        # add in the given GO panel element the key images attributes of the given HW key type
        # sub-function of GO_ODF_build_Manual_object

        HW_image_set_id = myint(self.HW_ODF_get_attribute_value(HW_key_img_set_dic, 'KeyShapeImageSetID_' + HW_key_type))
        if HW_image_set_id != None:
            HW_image_set_dic = self.HW_ODF_get_object_dic('ImageSet', HW_image_set_id)

            # image for key up (not pressed)
            image_attr_dic = {}
            self.HW_ODF_get_image_attributes(HW_image_set_dic, image_attr_dic, HW_key_img_set_dic['_key_up_img_index'])
            if image_attr_dic['BitmapFilename'] != None:
                GO_panel_element_dic['ImageOff_' + GO_key_type] = image_attr_dic['BitmapFilename']
            if image_attr_dic['TransparencyMaskBitmapFilename'] != None:
                GO_panel_element_dic['MaskOff_' + GO_key_type] = image_attr_dic['TransparencyMaskBitmapFilename']

            # image for key down (pressed)
            image_attr_dic = {}
            self.HW_ODF_get_image_attributes(HW_image_set_dic, image_attr_dic, HW_key_img_set_dic['_key_down_img_index'])
            if image_attr_dic['BitmapFilename'] != None:
                GO_panel_element_dic['ImageOn_' + GO_key_type] = image_attr_dic['BitmapFilename']
            if image_attr_dic['TransparencyMaskBitmapFilename'] != None:
                GO_panel_element_dic['MaskOn_' + GO_key_type] = image_attr_dic['TransparencyMaskBitmapFilename']

    #-------------------------------------------------------------------------------------------------
    def GO_ODF_build_Manual_keyimage_by_switch(self, HW_switch_dic, HW_next_switch_dic, GO_panel_element_dic, GO_key_nb):
        # add in the given GO panel element the key images attributes of the given HW Switch
        # sub-function of GO_ODF_build_Manual_object

        if HW_switch_dic == None: return

        HW_img_set_instance_id = myint(self.HW_ODF_get_attribute_value(HW_switch_dic, 'Disp_ImageSetInstanceID', MANDATORY))
        HW_img_set_instance_dic = self.HW_ODF_get_object_dic('ImageSetInstance', HW_img_set_instance_id)

        # get the key engaged and disengaged images indexes
        key_up_img_index = myint(self.HW_ODF_get_attribute_value(HW_switch_dic, 'Disp_ImageSetIndexDisengaged', MANDATORY))
        key_down_img_index = myint(self.HW_ODF_get_attribute_value(HW_switch_dic, 'Disp_ImageSetIndexEngaged', MANDATORY))

        # add in the HW Switch and ImageSetInstance objects the UID of the corresponding GO object
        HW_switch_dic['_GO_uid'] = GO_panel_element_dic['_GO_uid']
        HW_img_set_instance_dic['_GO_uid'] = GO_panel_element_dic['_GO_uid']

        key_nb_3digit_str = str(GO_key_nb).zfill(3)

        if GO_key_nb == 1:
            # set the GO keyboard position which is the position of the first key
            image_attr_dic = {}
            self.HW_ODF_get_image_attributes(HW_img_set_instance_dic, image_attr_dic, key_up_img_index)
            GO_panel_element_dic['PositionX'] = image_attr_dic['LeftXPosPixels']
            GO_panel_element_dic['PositionY'] = image_attr_dic['TopYPosPixels']

        # image for key up (not pressed)
        image_attr_dic = {}
        self.HW_ODF_get_image_attributes(HW_img_set_instance_dic, image_attr_dic, key_up_img_index)
        if image_attr_dic['BitmapFilename'] != None:
            GO_panel_element_dic['Key' + key_nb_3digit_str + 'ImageOff'] = image_attr_dic['BitmapFilename']
        if image_attr_dic['TransparencyMaskBitmapFilename'] != None:
            GO_panel_element_dic['Key' + key_nb_3digit_str + 'MaskOff'] = image_attr_dic['TransparencyMaskBitmapFilename']

        # image for key down (pressed)
        image_attr_dic = {}
        self.HW_ODF_get_image_attributes(HW_img_set_instance_dic, image_attr_dic, key_down_img_index)
        if image_attr_dic['BitmapFilename'] != None:
            GO_panel_element_dic['Key' + key_nb_3digit_str + 'ImageOn'] = image_attr_dic['BitmapFilename']
        if image_attr_dic['TransparencyMaskBitmapFilename'] != None:
            GO_panel_element_dic['Key' + key_nb_3digit_str + 'MaskOn'] = image_attr_dic['TransparencyMaskBitmapFilename']

        # width/offset of the key, width calculated by the diff of XPos of the key and its next one
        if HW_next_switch_dic != None:
            HW_next_img_set_instance_id = myint(self.HW_ODF_get_attribute_value(HW_next_switch_dic, 'Disp_ImageSetInstanceID', MANDATORY))
            HW_next_img_set_instance_dic = self.HW_ODF_get_object_dic('ImageSetInstance', HW_next_img_set_instance_id)

            next_image_dic = {}
            self.HW_ODF_get_image_attributes(HW_next_img_set_instance_dic, next_image_dic, key_up_img_index)
            key_width = int(next_image_dic['LeftXPosPixels']) - int(image_attr_dic['LeftXPosPixels'])
            GO_panel_element_dic['Key' + key_nb_3digit_str + 'Width'] = str(key_width)
            GO_panel_element_dic['Key' + key_nb_3digit_str + 'Offset'] = '0'

            if GO_panel_element_dic['PositionY'] != image_attr_dic['TopYPosPixels']:
                GO_panel_element_dic['Key' + key_nb_3digit_str + 'YOffset'] = image_attr_dic['TopYPosPixels'] - GO_panel_element_dic['PositionY']

    #-------------------------------------------------------------------------------------------------
    def GO_ODF_build_Drawstop_objects(self, HW_object_dic, HW_division_dic):
        # build the GO drawstop objects (Stop, Coupler, Tremulant, Setter) from the given HW object (Stop, KeyAction, Tremulant, Switch) and build their engage/disengage noise stops
        # return the UID of the built main Stop / Coupler / Tremulant / Setter

        # possible created GO drawstops :
        #   Switch + Coupler + Stop (attack noise) + Stop (release noise)
        #   Switch + Stop (pipes ranks) + alternate Stop (pipes rank) + Stop (attack noise) + Stop (release noise)
        #   Switch + Stop (attack noise : blower, nachtigall...)
        #   the Switch is created with its controlling switches

        # used HW objects :
        #   coupler :
        #     Switch C> KeyAction
        #   tremulant :
        #     Switch C> Tremulant
        #   pipes ranks stop :
        #     Switch C> Stop C> StopRank(s) (ActionTypeCode = 1, ActionEffectCode = 1) C> Rank C> Pipe_SoundEngine01 ... (main or alternate rank)
        #     Switch C> Stop (Hint_PrimaryAssociatedRankID) C> Rank C> Pipe_SoundEngine01 ... (for some demo sample sets where there is no StopRank object defined)
        #   engage noise stop :
        #     Switch C> Stop C> StopRank (ActionTypeCode = 21, ActionEffectCode = 2) C> Rank C> Pipe_SoundEngine01 ...
        #     Switch C> SwitchLinkage (EngageLinkActionCode=4, DisengageLinkActionCode=7) C> Switch C> Pipe_SoundEngine01 ...
        #   engage noise stop or general noise stop (i.e. blower) :
        #     Switch C> Pipe_SoundEngine01 C> Pipe_SoundEngine01Layer C> Pipe_SoundEngine01_AttackSample (no ReleaseSample) ...
        #   disengage noise stop :
        #     Switch C> Stop C> StopRank (ActionTypeCode = 21, ActionEffectCode = 3) C> Rank C> Pipe_SoundEngine01 ...
        #     Switch C> SwitchLinkage (EngageLinkActionCode=7, DisengageLinkActionCode=4) C> Switch C> Pipe_SoundEngine01 ...
        #     Switch C> SwitchLinkage (EngageLinkActionCode=1, DisengageLinkActionCode=2, SourceSwitchLinkIfEngaged=N) C> Switch C> Pipe_SoundEngine01 ...
        #     Switch C> Pipe_SoundEngine01 C> Pipe_SoundEngine01Layer C> Pipe_SoundEngine01_ReleaseSample (AttackSample ignored) ...
        #   general noise stop (i.e. blower) :
        #     Switch C> Stop C> StopRank (ActionTypeCode = 21, ActionEffectCode = 1) C> Rank C> Pipe_SoundEngine01 ...
        #   alternate rank control switch :
        #     Switch C> StopRank(s)
        #   not supported :
        #     Switch C> DivisionInput
        #     Switch C> ContinuousControlLinkage

        if HW_object_dic == None:
            return None

        HW_object_type = HW_object_dic['_HW_uid'][:-6]
        HW_object_name = HW_object_dic['Name']

        if LOG_HW2GO_drawstop: print(f"{HW_object_dic['_HW_uid']} '{HW_object_name}'")

        if HW_object_dic['_GO_uid'] != '':
            # the given HW object has been already converted to a GO object, return its UID
            if LOG_HW2GO_drawstop: print(f"      already converted to GO {HW_object_dic['_GO_uid']}")
            return HW_object_dic['_GO_uid']

        # recover the GO manual corresponding to the given HW division
        if HW_division_dic != None:
            GO_manual_uid = HW_division_dic['_GO_uid']
            GO_manual_id = int(GO_manual_uid[-3:])
            GO_manual_dic = self.GO_odf_dic[GO_manual_uid]
            if LOG_HW2GO_drawstop: print(f"  in HW division {HW_division_dic['Name']} and GO {GO_manual_uid}")
        else:
            return None

        #----------------------------------
        # find the HW switches associated to the given HW KeyAction / Stop / Tremulant / Switch

        # recover the HW switch controlling the given HW object, or itself if it is a switch
        if HW_object_type in ('Stop', 'Tremulant'):
            HW_cntrl_switch_dic = self.HW_ODF_get_object_by_ref_id('Switch', HW_object_dic, 'ControllingSwitchID')
        elif HW_object_type == 'KeyAction':
            HW_cntrl_switch_dic = self.HW_ODF_get_object_by_ref_id('Switch', HW_object_dic, 'ConditionSwitchID')
        elif HW_object_type == 'Switch':
            HW_cntrl_switch_dic = HW_object_dic
            if 'CRESC' in HW_object_dic['Name'].upper():
                # a switch related to the crescendo is skipped
                return None
        else:
            if LOG_HW2GO_drawstop: print(f"ERROR : wrong HW object type given to GO_ODF_build_Drawstop_objects")
            return None

        HW_switches_ctrl_formula_dic = {}  # logical formula describing how are acting together all the various switches controlling the given HW object
        HW_switches_main_branch_list = []  # list of HW switches in the main branch (i.e. without condition) linked to the given HW object

        switch_has_cond_effect = False

        # recover the logical formula describing how are acting together the various HW switches controlling the given HW object
        # recover as well the list of the HW switches controlled without condition (main branch) by the given HW object or its controlling switch
        if HW_cntrl_switch_dic != None:
            HW_switches_ctrl_formula_dic = self.HW_ODF_get_controlling_switches(HW_cntrl_switch_dic, HW_switches_main_branch_list)
            if LOG_HW2GO_drawstop: print(f"     controlled by {self.HW_DIC2UID(HW_switches_ctrl_formula_dic)}")
            if LOG_HW2GO_drawstop: print(f"     main controlling branch is {self.HW_DIC2UID(HW_switches_main_branch_list)}")

            # get the list of HW switches controlled by the controlling HW Switch by standard action codes and without condition
            HW_controlled_switches_list = []
            ret = self.HW_ODF_get_controlled_switches(HW_cntrl_switch_dic, HW_controlled_switches_list)
            if LOG_HW2GO_drawstop: print(f"     controlled switches are {self.HW_DIC2UID(HW_controlled_switches_list)}")
            if ret == 'conditional' and HW_object_type == 'Switch':
                switch_has_cond_effect = True
            elif ret == 'not_supported' and HW_object_type == 'Switch':
                # the given HW Switch has action codes not converted in GO ODF
                return None
            else:
                # add the controlled switches to the main switches branch list
                for HW_switch_dic in HW_controlled_switches_list:
                    if HW_switch_dic not in HW_switches_main_branch_list:
                        HW_switches_main_branch_list.append(HW_switch_dic)

        else:
            # the given HW object has no controlling switch
            if HW_object_type == 'KeyAction':
                # a KeyAction between different division/keyboard and without controlling switch
                # can be converted to a coupler engaged by default
                GO_coupler_attr_dic = self.GO_ODF_build_Coupler_attributes(HW_object_dic)
                if GO_coupler_attr_dic != None:
                    # create the GO coupler object in the ODF and in the manual, engaged by default, without switch and graphic interface
                    GO_manual_dic['NumberOfCouplers'] += 1
                    GO_object_uid = 'Coupler' + str(GO_manual_id).zfill(1) + str(GO_manual_dic['NumberOfCouplers']).zfill(2)
                    GO_object_dic = self.GO_odf_dic[GO_object_uid] = {}
                    GO_manual_dic['Coupler' + str(GO_manual_dic['NumberOfCouplers']).zfill(3)] = GO_object_uid[-3:]
                    # copy in it the GO coupler attributes
                    for key, value in GO_coupler_attr_dic.items():
                        if key[0] != '_':
                            GO_object_dic[key] = value
                    GO_object_dic['DefaultToEngaged'] = 'Y'
                    if LOG_HW2GO_drawstop: print(f"     GO Coupler {GO_object_uid} built, engaged by default")
                    return GO_object_uid
                else:
                    if LOG_HW2GO_drawstop: print(f"     GO Coupler attributes NOT built from {HW_object_dic['_HW_uid']} and none controlling switch found")
                    return None
            else:
                if LOG_HW2GO_drawstop: print(f"     None controlling switch found")
                return None

        #----------------------------------
        # build GO coupler / stops (pipes, noises) / tremulant / switch from each HW switch of the main controlling branch depending on what each one is controlling
        # and only if it will have a functional effect in GrandOrgue

        GO_objects_attr_list = []     # list containing dictionaries with the attributes of the GO functional objects linked to the given HW object
        nb_couplers = 0
        nb_pipes_stops = 0
        nb_noise_stops = 0
        nb_tremulants = 0
        has_cc_linkage = False        # set at True if one switch is controlling a ContinuousControlLinkage object
        has_wc_linkage = False        # set at True if one switch is controlling a WindCompartmentLinkage object
        is_alt_rank_switch = False    # set at True if the given switch is controlling the activation of an alternate rank
        one_clickable_switch = False  # set at True if one switch of the branch is visible
        one_default_engaged_switch = False  # set at True if one switch of the branch is engaged by default
        alt_HW_switch_dic = None      # HW switch permitting to switch to the alternate rank for the given HW Stop if any
        HW_switch_asgn_code = None    # default assignment code of one switch of the branch if defined
        HW_noise_pipes_list = []      # list of the HW noise pipes already checked

        for HW_switch_dic in HW_switches_main_branch_list:
            # scan the HW switches of the main controlling branch

            if HW_object_type == 'Switch':
                if self.HW_ODF_get_linked_objects_by_type(HW_switch_dic, 'ContinuousControlLinkage', TO_CHILD, FIRST_ONE) != None:
                    # the current HW switch is controlling a ContinuousControlLinkage object
                    has_cc_linkage = True

                if self.HW_ODF_get_linked_objects_by_type(HW_switch_dic, 'WindCompartmentLinkage', TO_CHILD, FIRST_ONE) != None:
                    # the current HW switch is controlling a WindCompartmentLinkage
                    has_wc_linkage = True

            # check the Switch C> KeyAction use cases
            if HW_object_type == 'KeyAction' and nb_couplers == 0:
                for HW_key_action_dic in self.HW_ODF_get_linked_objects_by_type(HW_switch_dic, 'KeyAction', TO_CHILD):
                    # scan the HW KeyAction objects which are children of the current HW Switch object if any
                    GO_coupler_attr_dic = self.GO_ODF_build_Coupler_attributes(HW_key_action_dic)
                    if GO_coupler_attr_dic != None:
                        GO_coupler_attr_dic['_object_types_list'] = ['Coupler']
                        nb_couplers += 1
                        GO_objects_attr_list.append(GO_coupler_attr_dic)
                        if LOG_HW2GO_drawstop: print(f"     GO Coupler attributes built from {HW_key_action_dic['_HW_uid']}")
                    else:
                        if LOG_HW2GO_drawstop: print(f"     GO Coupler attributes NOT built from {HW_key_action_dic['_HW_uid']}")

            # check the Switch C> Tremulant use cases
            if HW_object_type == 'Tremulant':
                for HW_tremulant_dic in self.HW_ODF_get_linked_objects_by_type(HW_switch_dic, 'Tremulant', TO_CHILD):
                    # scan the HW Tremulant objects which are children of the current HW Switch object if any
                    GO_tremulant_attr_dic = self.GO_ODF_build_Tremulant_attributes(HW_tremulant_dic)
                    if GO_tremulant_attr_dic != None:
                        GO_tremulant_attr_dic['_object_types_list'] = ['Tremulant']
                        nb_tremulants += 1
                        GO_objects_attr_list.append(GO_tremulant_attr_dic)
                        if LOG_HW2GO_drawstop: print(f"     GO Tremulant attributes built from {HW_tremulant_dic['_HW_uid']}")
                    else:
                        if LOG_HW2GO_drawstop: print(f"     GO Tremulant attributes NOT built from {HW_tremulant_dic['_HW_uid']}")


            # check the following use cases
            #   Switch C> Stop C> StopRank(s) (ActionTypeCode = 1, ActionEffectCode = 1) C> Rank C> Pipe_SoundEngine01 ...
            #   Switch C> Stop (Hint_PrimaryAssociatedRankID) C> Rank C> Pipe_SoundEngine01 ...
            #   Switch C> Stop C> StopRank (ActionTypeCode = 21, ActionEffectCode = 1) C> Rank C> Pipe_SoundEngine01 ...
            #   Switch C> Stop C> StopRank (ActionTypeCode = 21, ActionEffectCode = 2) C> Rank C> Pipe_SoundEngine01 ...
            #   Switch C> Stop C> StopRank (ActionTypeCode = 21, ActionEffectCode = 3) C> Rank C> Pipe_SoundEngine01 ...
            #   Switch C> StopRank(s) (ActionTypeCode = 1, ActionEffectCode = 1)
            for HW_stop_dic in self.HW_ODF_get_linked_objects_by_type(HW_switch_dic, 'Stop', TO_CHILD):
                # scan the HW Stop objects which are children of the current HW Switch object if any
                if HW_object_type == 'Switch':
                    if LOG_HW2GO_drawstop: print(f"     {HW_object_dic['_HW_uid']} controls a Stop ====> SKIPPED")
                    # if the given HW object is a swith and it is controlling a stop, it will be managed
                    # when this stop will be given to this function, so it can be ignored here
                    return None

                if HW_stop_dic['_GO_uid'] == '':
                    # HW Stop not yet converted to a GO Stops
                    for HW_stop_rank_dic in self.HW_ODF_get_linked_objects_by_type(HW_stop_dic, 'StopRank', TO_CHILD):
                        # scan the HW StopRank objects which are children of the current HW Stop object to find a pipes rank
                        HW_rank_dic = self.HW_ODF_get_object_by_ref_id('Rank', HW_stop_rank_dic, 'RankID')
                        HW_rank_nb_pipes = len(self.HW_ODF_get_linked_objects_by_type(HW_rank_dic, 'Pipe_SoundEngine01', TO_CHILD))
                        if HW_rank_nb_pipes > 0:
                            HW_action_type_code = myint(self.HW_ODF_get_attribute_value(HW_stop_rank_dic, 'ActionTypeCode'), 1)
                            HW_action_effect_code = myint(self.HW_ODF_get_attribute_value(HW_stop_rank_dic, 'ActionEffectCode'), 1)
                            if HW_action_type_code == 1 and HW_action_effect_code == 1 and nb_pipes_stops == 0:
                                # matching attributes for building a pipes stop object
                                if myint(self.HW_ODF_get_attribute_value(HW_stop_rank_dic, 'AlternateRankID'), 0) > 0 and self.alt_rank_status != None:
                                    # an alternate rank is defined and it must be converted
                                    if self.alt_rank_status == 'integrated':
                                        # the alternate rank must be integrated in the main rank, build both the main and alternate ranks under the same stop
                                        GO_stop_attr_dic = self.GO_ODF_build_Stop_pipes_attributes(HW_stop_dic, GO_manual_dic, 'main_alt')
                                        GO_alt_stop_attr_dic = None
                                    else:
                                        # alternate rank must be build separately from the main rank, build both the main and alternate ranks under the same stop
                                        GO_stop_attr_dic = self.GO_ODF_build_Stop_pipes_attributes(HW_stop_dic, GO_manual_dic, 'main')
                                        GO_alt_stop_attr_dic = self.GO_ODF_build_Stop_pipes_attributes(HW_stop_dic, GO_manual_dic, 'alt')
                                    # get the HW switch permitting to switch to the alternate rank
                                    alt_HW_switch_dic = self.HW_ODF_get_object_by_ref_id('Switch', HW_stop_rank_dic, 'SwitchIDToSwitchToAlternateRank')
                                else:
                                    # alternate rank must be ignored, build only the main rank under a stop
                                    GO_stop_attr_dic = self.GO_ODF_build_Stop_pipes_attributes(HW_stop_dic, GO_manual_dic, 'main')
                                    GO_alt_stop_attr_dic = None
                                    alt_HW_switch_dic = None

                                if GO_stop_attr_dic != None:
                                    GO_stop_attr_dic['_object_types_list'] = ['Stop', 'pipes']
                                    nb_pipes_stops += 1
                                    GO_objects_attr_list.append(GO_stop_attr_dic)
                                    if LOG_HW2GO_drawstop: print(f"     GO Stop pipes attributes built from {HW_stop_dic['_HW_uid']}")
                                else:
                                    if LOG_HW2GO_drawstop: print(f"     {HW_stop_dic['_HW_uid']} CANNOT be converted to a GO pipes Stop")

                                if GO_alt_stop_attr_dic != None:
                                    GO_alt_stop_attr_dic['_object_types_list'] = ['Stop', 'pipes', 'alternate']
                                    nb_pipes_stops += 1
                                    GO_objects_attr_list.append(GO_alt_stop_attr_dic)
                                    if LOG_HW2GO_drawstop: print(f"     GO Stop alternate pipes attributes built from {HW_stop_dic['_HW_uid']}")
                                elif alt_HW_switch_dic != None and self.alt_rank_status == 'separated':
                                    if LOG_HW2GO_drawstop: print(f"     {HW_stop_dic['_HW_uid']} alternate rank CANNOT be converted to a GO pipes Stop")

                            elif HW_action_type_code == 21 and HW_action_effect_code in (1, 2, 3):
                                # matching use case for a noise sample control (general, attack, release)
                                HW_pipe_dic = None
                                # take into account a MIDI note increment if defined to use the proper Pipe_SoundEngine01 object
                                HW_div_midi_note_increment_to_rank = myint(self.HW_ODF_get_attribute_value(HW_stop_rank_dic, 'MIDINoteNumIncrementFromDivisionToRank'))
                                if HW_div_midi_note_increment_to_rank != None and HW_div_midi_note_increment_to_rank != 0:
                                    # search for the Pipe_SoundEngine01 object having the given MIDI note number
                                    for HW_pipe_check_dic in self.HW_ODF_get_linked_objects_by_type(HW_rank_dic, 'Pipe_SoundEngine01', TO_CHILD):
                                        midi_note_nb = myint(self.HW_ODF_get_attribute_value(HW_pipe_check_dic, 'NormalMIDINoteNumber'))
                                        if midi_note_nb == None: midi_note_nb = 60
                                        if midi_note_nb == HW_div_midi_note_increment_to_rank:
                                            HW_pipe_dic = HW_pipe_check_dic
                                            break
                                if HW_pipe_dic == None:
                                    # Pipe_SoundEngine01 object not found, take the first Pipe_SoundEngine01 child of the Rank
                                    HW_pipe_dic = self.HW_ODF_get_linked_objects_by_type(HW_rank_dic, 'Pipe_SoundEngine01', TO_CHILD, FIRST_ONE)
                                if HW_pipe_dic != None:
                                    # a Pipe_SoundEngine01 is defined
                                    if HW_pipe_dic not in HW_noise_pipes_list:
                                        if HW_action_effect_code in (1, 2): # drawstop engage noise or general noise
                                            attack_bool = True
                                        else: # HW_action_effect_code == 3: # drawstop disengage noise
                                            attack_bool = False
                                        GO_stop_attr_dic = self.GO_ODF_build_Stop_noise_attributes(HW_pipe_dic, HW_object_name, attack_bool)
                                        if GO_stop_attr_dic != None:
                                            GO_stop_attr_dic['_object_types_list'] = ['Stop', 'noise']
                                            nb_noise_stops += 1
                                            GO_objects_attr_list.append(GO_stop_attr_dic)
                                            HW_noise_pipes_list.append(HW_pipe_dic)
                                            if LOG_HW2GO_drawstop: print(f"     GO Stop noise attributes built from {HW_stop_dic['_HW_uid']} and {HW_pipe_dic['_HW_uid']} with attack={attack_bool}")
                                        else:
                                            if LOG_HW2GO_drawstop: print(f"     GO Stop noise attributes NOT built from {HW_stop_dic['_HW_uid']} and {HW_pipe_dic['_HW_uid']} with attack={attack_bool}")
                                    else:
                                        if LOG_HW2GO_drawstop: print(f"     {HW_pipe_dic['_HW_uid']} already used")

                    if nb_pipes_stops == 0:
                        # if no pipes stop found, try using the hint primary rank information
                        if myint(self.HW_ODF_get_attribute_value(HW_stop_dic, 'Hint_PrimaryAssociatedRankID')) != None:
                            GO_stop_attr_dic = self.GO_ODF_build_Stop_pipes_attributes(HW_stop_dic, GO_manual_dic, 'main')
                            if GO_stop_attr_dic != None:
                                GO_stop_attr_dic['_object_types_list'] = ['Stop', 'pipes']
                                nb_pipes_stops += 1
                                GO_objects_attr_list.append(GO_stop_attr_dic)
                                if LOG_HW2GO_drawstop: print(f"     GO Stop pipes attributes built from {HW_stop_dic['_HW_uid']} as primary rank hint")
                            else:
                                if LOG_HW2GO_drawstop: print(f"     GO Stop pipes attributes NOT built from {HW_stop_dic['_HW_uid']} as primary rank hint")

                    if LOG_HW2GO_drawstop and nb_pipes_stops == 0 and nb_noise_stops == 0:
                        print(f"     {HW_stop_dic['_HW_uid']} CANNOT be converted to neither pipes nor noise GO stop")
                else:
                    if LOG_HW2GO_drawstop: print(f"     {HW_stop_dic['_HW_uid']} already checked")

            # check the Switch C> SwitchLinkage use cases
            for HW_switch_linkage_dic in self.HW_ODF_get_linked_objects_by_type(HW_switch_dic, 'SwitchLinkage', TO_CHILD):
                # scan the HW SwitchLinkage objects which are children of the given HW Switch object if any
                EngageLinkActionCode = myint(self.HW_ODF_get_attribute_value(HW_switch_linkage_dic, 'EngageLinkActionCode'))
                DisengageLinkActionCode = myint(self.HW_ODF_get_attribute_value(HW_switch_linkage_dic, 'DisengageLinkActionCode'))
                SourceSwitchLinkIfEngaged = self.HW_ODF_get_attribute_value(HW_switch_linkage_dic, 'SourceSwitchLinkIfEngaged')
                HW_dest_switch_dic = self.HW_ODF_get_object_by_ref_id('Switch', HW_switch_linkage_dic, 'DestSwitchID')
                if HW_dest_switch_dic != None:
                    HW_pipe_dic = self.HW_ODF_get_linked_objects_by_type(HW_dest_switch_dic, 'Pipe_SoundEngine01', TO_CHILD, FIRST_ONE)
                    if HW_pipe_dic != None:
                        if HW_pipe_dic not in HW_noise_pipes_list:
                            if EngageLinkActionCode == 4 and DisengageLinkActionCode == 7:
                                # matching use case for building a drawstop engage noise
                                attack_bool = True
                            elif ((EngageLinkActionCode == 7 and DisengageLinkActionCode == 4) or
                                  (EngageLinkActionCode == 1 and DisengageLinkActionCode == 2 and SourceSwitchLinkIfEngaged == 'N')):
                                # matching use case for building a drawstop disengage noise
                                attack_bool = False
                            else:
                                attack_bool = None
                            if attack_bool != None:
                                GO_stop_attr_dic = self.GO_ODF_build_Stop_noise_attributes(HW_pipe_dic, HW_object_name, attack_bool)
                                if GO_stop_attr_dic != None:
                                    GO_stop_attr_dic['_object_types_list'] = ['Stop', 'noise']
                                    nb_noise_stops += 1
                                    GO_objects_attr_list.append(GO_stop_attr_dic)
                                    HW_noise_pipes_list.append(HW_pipe_dic)
                                    if LOG_HW2GO_drawstop: print(f"     GO Stop noise attributes built from {HW_dest_switch_dic['_HW_uid']} and {HW_pipe_dic['_HW_uid']} with attack={attack_bool}")
                                else:
                                    if LOG_HW2GO_drawstop: print(f"     GO Stop noise attributes NOT built from {HW_dest_switch_dic['_HW_uid']} and {HW_pipe_dic['_HW_uid']} with attack={attack_bool}")
                        else:
                            if LOG_HW2GO_drawstop: print(f"     {HW_pipe_dic['_HW_uid']} already used")

            # check the Switch C> Pipe_SoundEngine01 use cases
            for HW_pipe_dic in self.HW_ODF_get_linked_objects_by_type(HW_switch_dic, 'Pipe_SoundEngine01', TO_CHILD):
                # scan the HW Pipe_SoundEngine01 objects which are children of the given HW Switch object if any
                if HW_pipe_dic not in HW_noise_pipes_list:
                    attack_bool = True
                    GO_stop_attr_dic = self.GO_ODF_build_Stop_noise_attributes(HW_pipe_dic, HW_object_name, attack_bool)
                    if GO_stop_attr_dic != None:
                        GO_stop_attr_dic['_object_types_list'] = ['Stop', 'noise']
                        nb_noise_stops += 1
                        GO_objects_attr_list.append(GO_stop_attr_dic)
                        HW_noise_pipes_list.append(HW_pipe_dic)
                        if LOG_HW2GO_drawstop: print(f"     GO Stop noise attributes built from {HW_switch_dic['_HW_uid']} and {HW_pipe_dic['_HW_uid']} with attack={attack_bool}")
                    else:
                        if LOG_HW2GO_drawstop: print(f"     GO Stop noise attributes NOT built from {HW_switch_dic['_HW_uid']} and {HW_pipe_dic['_HW_uid']} with attack={attack_bool}")
                else:
                    if LOG_HW2GO_drawstop: print(f"     {HW_pipe_dic['_HW_uid']} already used")

            # check the Switch C> StopRank use case (to switch to an alternate rank)
            if self.HW_ODF_get_linked_objects_by_type(HW_switch_dic, 'StopRank', TO_CHILD, FIRST_ONE):
                is_alt_rank_switch = True
                if LOG_HW2GO_drawstop: print(f"     {HW_switch_dic['_HW_uid']} is an alternate rank selection switch")

            # get some status about the current HW switch
            log_message = f"     {HW_switch_dic['_HW_uid']} checked"
            if self.HW_ODF_get_attribute_value(HW_switch_dic, 'Clickable') == 'Y':
                one_clickable_switch = True
                log_message += ', is clickable'
            if self.HW_ODF_get_attribute_value(HW_switch_dic, 'DefaultToEngaged') == 'Y':
                one_default_engaged_switch = True
                log_message += ', is default engaged'
            asgn_code = myint(self.HW_ODF_get_attribute_value(HW_switch_dic, 'DefaultInputOutputSwitchAsgnCode'))
            if asgn_code != None:
                HW_switch_asgn_code = asgn_code
                log_message += f', asgn code {asgn_code}'
            if LOG_HW2GO_drawstop: print(log_message)

        # check if the given HW Switch has supported setter actions
        GO_setter_name = None
        if HW_object_type == 'Switch':
            if int(HW_cntrl_switch_dic['_HW_uid'][-6:]) == myint(self.HW_ODF_get_attribute_value(self.HW_general_dic, 'SpecialObjects_MasterCaptureSwitchID')):
                # general capture switch defined in the _General object
                HW_switch_asgn_code = 12

            if HW_switch_asgn_code != None:
                if HW_switch_asgn_code == 12:
                    GO_setter_name = 'Set'
                    setter_display_text = 'Set'
                elif HW_switch_asgn_code == 100:
                    GO_setter_name = 'GC'
                    setter_display_text = 'C'
                elif HW_switch_asgn_code in range(101, 200):
                    GO_setter_name = 'General' + str(HW_switch_asgn_code - 100).zfill(2)
                    setter_display_text = str(HW_switch_asgn_code - 100)
                elif HW_switch_asgn_code in range(200, 900):
                    # divisional combination
                    one_clickable_switch = False # not managed, consider it not visible in ordre to skip it
                elif HW_switch_asgn_code == 900369:
                    GO_setter_name = 'Prev'
                    setter_display_text = 'Prev'
                elif HW_switch_asgn_code == 900366:
                    GO_setter_name = 'Next'
                    setter_display_text = 'Next'

        if LOG_HW2GO_drawstop:
            message = '     SYNTHESIS:'
            if nb_couplers > 0: message += f' {nb_couplers} couplers,'
            if nb_tremulants > 0: message += f' {nb_tremulants} tremulants,'
            if nb_pipes_stops > 0: message += f' {nb_pipes_stops} stops,'
            if nb_noise_stops > 0: message += f' {nb_noise_stops} noises,'
            if alt_HW_switch_dic != None: message += ' has alternate rank,'
            if is_alt_rank_switch : message += ' is alternate rank cntrl switch,'
            if HW_switch_asgn_code != None: message += f' assignment code {HW_switch_asgn_code},'
            if GO_setter_name != None: message += f' GO setter name {GO_setter_name},'
            if one_clickable_switch : message += ' at least one clickable switch,'
            if one_default_engaged_switch : message += ' default engaged,'
            if switch_has_cond_effect == True: message += ' switch with conditional effect,'
            if has_cc_linkage: message += ' controlling a ContinuousControlLinkage object,'
            if has_wc_linkage: message += ' controlling a WindCompartmentLinkage object,'
            print(message)

        #----------------------------------
        # based on all the data retrieved previously, decide if coupler/stops/switches have to be built if one of the conditions below is not fulfilled
        # in order to avoid having clickable object without controlled feature (in case of feature not supported or demo sample sets with absent ranks)

        if not((HW_object_type == 'KeyAction' and nb_couplers > 0) or
               (HW_object_type == 'Tremulant' and nb_tremulants > 0) or
               (HW_object_type == 'Stop' and (nb_pipes_stops > 0 or int(nb_noise_stops % 2) != 0)) or
               (HW_object_type == 'Switch' and HW_switch_asgn_code != None and (HW_switch_asgn_code == 1 or GO_setter_name != None)) or
               (HW_object_type == 'Switch' and
                (one_default_engaged_switch or one_clickable_switch) and
                (is_alt_rank_switch or nb_noise_stops == 0 or int(nb_noise_stops % 2) != 0) and
                has_cc_linkage == False and
                (has_wc_linkage == False or nb_noise_stops > 0) and
                (switch_has_cond_effect == False or int(nb_noise_stops % 2) != 0))):
            if LOG_HW2GO_drawstop: print('     ====> SKIPPED : it would have no functional role in the GO ODF')
            return None

        #----------------------------------
        # management of the setter if any
        if GO_setter_name != None:
            for HW_switch_dic in HW_switches_main_branch_list:
                self.GO_ODF_build_Setter_object(HW_switch_dic, GO_setter_name, setter_display_text)
            if LOG_HW2GO_drawstop: print(f'       SETTER built for function {GO_setter_name}')
            return

        #----------------------------------
        # build GO controlling switches

        if len(HW_switches_ctrl_formula_dic) > 0:
            # build the GO controlling switches based on the formula
            if nb_couplers > 0 or nb_pipes_stops > 0 or nb_tremulants > 0:
                # the object is a coupler or a stop for pipes or a tremulant
                gc_state = 0  # the object is set at 0 when general cancel is pressed
            else:
                gc_state = -1 # the object state is unchanged when general cancel is pressed

            if HW_object_type == 'Switch':
                # in case of a switch object, let the sub function define the GO Switch object name
                GO_switch_uid = self.GO_ODF_build_Switch_objects(HW_switches_ctrl_formula_dic, None, gc_state)
            else:
                GO_switch_uid = self.GO_ODF_build_Switch_objects(HW_switches_ctrl_formula_dic, HW_object_name, gc_state)
            # GO_switch_uid is the UID of the switch to link to the GO object (stop, coupler, tremulant)

        if GO_switch_uid == None:
            if LOG_HW2GO_drawstop: print(f"       ERROR : Unable to build control switch(es) for {HW_object_dic['_HW_uid']}")
            return None

        elif HW_object_type in ('KeyAction', 'Stop', 'Tremulant'):
            # add the main source clickable controlling GO switches to the GO Manual
            for HW_switch_dic in HW_switches_main_branch_list:
                if HW_switch_dic['_GO_uid'] != '' and self.HW_ODF_get_attribute_value(HW_switch_dic, 'Clickable') == 'Y':
                    self.GO_ODF_child_add(GO_manual_uid, HW_switch_dic['_GO_uid'])
                    if LOG_HW2GO_drawstop: print(f'       Switch {HW_switch_dic["_GO_uid"]} added to manual {GO_manual_dic["Name"]}')

        if HW_object_type == 'Switch':
            HW_object_dic['_GO_uid'] = GO_switch_uid

        # build the GO switch permitting to switch to the alternate rank if any and if not already built
        alt_GO_switch_uid = None
        alt_not_GO_switch_uid = None
        if alt_HW_switch_dic != None:
            if alt_HW_switch_dic['_GO_uid'] == '':
                if LOG_HW2GO_drawstop: print(f"    +++++ Alternate switch building START")
                alt_GO_switch_uid = self.GO_ODF_build_Drawstop_objects(alt_HW_switch_dic, HW_division_dic)
                if LOG_HW2GO_drawstop: print(f"    +++++ Alternate switch building END")

                if alt_GO_switch_uid != None:
                    # write in the HW object the UID of the corresponding GO object
                    alt_HW_switch_dic['_GO_uid'] = alt_GO_switch_uid
                    if self.alt_rank_status == 'separated':
                        # a NOT switch is needed to disable the normal rank when the alternate separate rank is enabled
                        self.GO_odf_dic['Organ']['NumberOfSwitches'] += 1
                        alt_not_GO_switch_uid = 'Switch' + str(self.GO_odf_dic['Organ']['NumberOfSwitches']).zfill(3)
                        alt_not_GO_switch_dic = self.GO_odf_dic[alt_not_GO_switch_uid] = {}
                        alt_not_GO_switch_dic['Name'] = 'NOT gate'
                        alt_not_GO_switch_dic['Function'] = 'Not'
                        alt_not_GO_switch_dic['Switch001'] = alt_GO_switch_uid[-3:]
                        # write in the HW object the UID of the corresponding GO object
                        alt_HW_switch_dic['_GO_uid_not'] = alt_not_GO_switch_uid
            else:
                alt_GO_switch_uid = alt_HW_switch_dic['_GO_uid']
                if '_GO_uid_not' in alt_HW_switch_dic.keys():
                    # a NOT switch has been created with the alternate rank switch
                    alt_not_GO_switch_uid = alt_HW_switch_dic['_GO_uid_not']

            if LOG_HW2GO_drawstop: print(f"       Alternate rank selection GO switch is {alt_GO_switch_uid}, NOT switch is {alt_not_GO_switch_uid}")

        #----------------------------------
        # build Tremulant (wave) object if needed

        # build if needed a GO wave type Tremulant controlled by the alternate rank switch if the alternate ranke is integrated in the main rank
        if HW_object_type == 'Stop' and alt_GO_switch_uid != None and self.alt_rank_status == 'integrated':
            # an alternate rank switch is defined for the given Stop and the alternate rank is integrated in the main rank
            if '_GO_wav_trem_uid' not in alt_HW_switch_dic.keys():
                # a GO wave type tremulant is not yet defined in link with this alternate rank switch
                if LOG_HW2GO_drawstop: print(f"     GO Wave Tremulant attributes built from {alt_HW_switch_dic['_HW_uid']}")

                # create a new GO Tremulant object in the GO ODF dictionary
                self.GO_odf_dic['Organ']['NumberOfTremulants'] += 1
                GO_object_uid = 'Tremulant' + str(self.GO_odf_dic['Organ']['NumberOfTremulants']).zfill(3)
                GO_object_dic = self.GO_odf_dic[GO_object_uid] = {}

                GO_object_dic['Name'] = alt_HW_switch_dic['Name']
                GO_object_dic['TremulantType'] = 'Wave'

                # add in the tremulant its controlling switch
                GO_object_dic['Function'] = 'And'
                GO_object_dic['SwitchCount'] = 1
                GO_object_dic['Switch001'] = alt_GO_switch_uid[-3:]

                alt_HW_switch_dic['_GO_wav_trem_uid'] = GO_object_uid

            # add the GO Tremulant to the GO WindchestGroups on which it has an effect
            for GO_windchest_uid in HW_object_dic['_GO_windchests_uid_list']:
                self.GO_ODF_child_add(GO_windchest_uid, alt_HW_switch_dic['_GO_wav_trem_uid'])

            # add the GO Tremulant to the GO Manual to which it belongs
            self.GO_ODF_child_add(GO_manual_uid, alt_HW_switch_dic['_GO_wav_trem_uid'])

        #----------------------------------
        # build GO Coupler / Stop(s) / Tremulant (synth) objects

        main_GO_object_uid = None
        for GO_obj_data_dic in GO_objects_attr_list:
            # create each GO object identified earlier in this function
            GO_object_type = GO_obj_data_dic['_object_types_list'][0]

            if GO_object_type != 'Tremulant':
                # define the UID of the GO object (coupler or stop) to create in the GO ODF dictionary
                GO_object_id = self.GO_ODF_child_type_nb_get(GO_manual_uid, GO_object_type) + 1
                if GO_object_id <= 99:
                    # the first digit of GO object UID is the manual ID, the two other digits are for the object number in the parent manual
                    GO_object_uid = GO_object_type + str(GO_manual_id).zfill(1) + str(GO_object_id).zfill(2)
                else:
                    # if there are more than 99 objects of the current object type in the manual, create an UID available over 800
                    GO_object_uid = GO_object_type + str(self.GO_object_ext_ID).zfill(3)
                    while GO_object_uid in self.GO_odf_dic.keys():
                        self.GO_object_ext_ID += 1
                        GO_object_uid = GO_object_type + str(self.GO_object_ext_ID).zfill(3)

                # add the GO object to the GO Manual to which it belongs
                self.GO_ODF_child_add(GO_manual_uid, GO_object_uid)
            else:
                # define the UID of the GO Tremulant to create in the GO ODF dictionary
                self.GO_odf_dic['Organ']['NumberOfTremulants'] += 1
                GO_object_uid = GO_object_type + str(self.GO_odf_dic['Organ']['NumberOfTremulants']).zfill(3)

                # add the GO Tremulant to the GO WindchestGroups on which it has an effect
                for GO_windchest_uid in GO_obj_data_dic['_GO_windchests_uid_list']:
                    self.GO_ODF_child_add(GO_windchest_uid, GO_object_uid)
                # add the GO Tremulant to the GO Manuals to which it belongs
                for GO_manual_uid in GO_obj_data_dic['_GO_manuals_uid_list']:
                    self.GO_ODF_child_add(GO_manual_uid, GO_object_uid)

            # create the object in the GO dictionary
            GO_object_dic = self.GO_odf_dic[GO_object_uid] = {}

            # copy in new GO object the GO object attributes prepared before
            for key, value in GO_obj_data_dic.items():
                if key[0] != '_':
                    GO_object_dic[key] = value

            # write in the HW object the UID of the corresponding GO object
            if ((HW_object_type == 'Stop' and 'pipes' in GO_obj_data_dic['_object_types_list']) or
                (HW_object_type == 'KeyAction' and 'Coupler' in GO_obj_data_dic['_object_types_list']) or
                (HW_object_type == 'Tremulant' and 'Tremulant' in GO_obj_data_dic['_object_types_list'])):
                HW_object_dic['_GO_uid'] = main_GO_object_uid = GO_object_uid

            # add the controlling GO switch in the GO object
            if GO_switch_uid != None:
                GO_object_dic['Function'] = 'And'
                GO_object_dic['SwitchCount'] = 1
                GO_object_dic['Switch001'] = GO_switch_uid[-3:]

                if (self.alt_rank_status == 'separated' and alt_GO_switch_uid != None and alt_not_GO_switch_uid != None and
                    'pipes' in GO_obj_data_dic['_object_types_list']):
                    # the object is a stop pipes controlled by the alternate rank switch
                    GO_object_dic['SwitchCount'] = 2
                    if 'alternate' in GO_obj_data_dic['_object_types_list']:
                        GO_object_dic['Switch002'] = alt_GO_switch_uid[-3:]
                    else:
                        GO_object_dic['Switch002'] = alt_not_GO_switch_uid[-3:]

            elif one_default_engaged_switch:
                GO_object_dic['DefaultToEngaged'] = 'Y'
            else:
                GO_object_dic['DefaultToEngaged'] = 'N'

            if LOG_HW2GO_drawstop: print(f"     GO {GO_object_uid} '{GO_object_dic['Name']}' built, {GO_obj_data_dic['_object_types_list']}, controlled by {GO_switch_uid}")

        if HW_object_type in ('Stop', 'KeyAction', 'Tremulant') and main_GO_object_uid != None:
            if LOG_HW2GO_drawstop: print(f"     returned GO object is {main_GO_object_uid}")
            return main_GO_object_uid
        else:
            if LOG_HW2GO_drawstop: print(f"     returned GO object is {GO_switch_uid}")
            return GO_switch_uid

    #-------------------------------------------------------------------------------------------------
    def GO_ODF_build_Coupler_attributes(self, HW_key_action_dic):
        # build the GO Coupler attributes corresponding to the given HW KeyAction object
        # if the KeyAction is between two different divisions/keyboards or the same but with keys shift
        # return the dictionary of the GO Coupler attributes, or None in case of building issue

        # used HW objects :
        #   KeyAction P> Keyboard P> Division  (source division)
        #   KeyAction C> Keyboard C> Division  (destination division)
        #   KeyAction C> Division              (destination division)

        # get the HW source division of the HW KeyAction
        HW_source_keyboard_dic = self.HW_ODF_get_object_by_ref_id('Keyboard', HW_key_action_dic, 'SourceKeyboardID')
        HW_source_division_dic = self.HW_ODF_get_linked_objects_by_type(HW_source_keyboard_dic, 'Division', TO_PARENT, FIRST_ONE)
        if HW_source_division_dic == None:
            # no existing HW source division/keyboard of the KeyAction, the Coupler cannot be built
            if LOG_HW2GO_coupler: print(f'Unable to find the HW source division of the HW keyboard {HW_source_keyboard_dic["_HW_uid"]}')
            return None

        # get the HW destination division of the HW KeyAction
        HW_dest_division_dic = self.HW_ODF_get_object_by_ref_id('Division', HW_key_action_dic, 'DestDivisionID')
        if HW_dest_division_dic == None:
            HW_dest_keyboard_dic = self.HW_ODF_get_object_by_ref_id('Keyboard', HW_key_action_dic, 'DestKeyboardID')
            if HW_dest_keyboard_dic != None:
                HW_dest_division_dic = self.HW_ODF_get_linked_objects_by_type(HW_dest_keyboard_dic, 'Division', TO_PARENT, FIRST_ONE)
        if HW_dest_division_dic == None:
            # no existing HW destination division/keyboard of the KeyAction, the Coupler cannot be built
            if LOG_HW2GO_coupler: print(f'Unable to find the HW destination division for the KeyAction {HW_key_action_dic["_HW_uid"]}')
            return None

        # get the corresponding GO source and destination Manual UID
        GO_source_manual_uid = HW_source_division_dic['_GO_uid']
        if GO_source_manual_uid == '':
            if LOG_HW2GO_coupler: print(f"Unable to find the GO source manual for the HW source division {HW_source_division_dic['_GO_uid']}")
            return None

        GO_dest_manual_uid = HW_dest_division_dic['_GO_uid']
        if GO_dest_manual_uid == '':
            if LOG_HW2GO_coupler: print(f"Unable to find the GO destination manual for the HW destination division {HW_source_division_dic['_GO_uid']}")
            return None

        keys_shift = myint(self.HW_ODF_get_attribute_value(HW_key_action_dic, 'MIDINoteNumberIncrement'), 0)
        if GO_source_manual_uid == GO_dest_manual_uid and keys_shift == 0:
            if LOG_HW2GO_coupler: print(f"{HW_key_action_dic['_HW_uid']} is linking the same division {HW_source_division_dic['_HW_uid']} / {GO_source_manual_uid} without keys shift, no need to build a GO Coupler")
            return None

        # create a dictionary to store in it the GO Coupler attributes
        GO_coupler_dic = {}

        GO_coupler_dic['Name'] = self.HW_ODF_get_attribute_value(HW_key_action_dic, 'Name')
        GO_coupler_dic['UnisonOff'] = 'N'
        GO_coupler_dic['DestinationManual'] = GO_dest_manual_uid[-3:]
        GO_coupler_dic['DestinationKeyshift'] = keys_shift

        first_key = myint(self.HW_ODF_get_attribute_value(HW_key_action_dic, 'MIDINoteNumOfFirstSourceKey'), 0)
        if first_key != 0:
            GO_coupler_dic['FirstMIDINoteNumber'] = first_key

        keys_number = myint(self.HW_ODF_get_attribute_value(HW_key_action_dic, 'NumberOfKeys'), 0)
        if keys_number != 0:
            GO_coupler_dic['NumberOfKeys'] = keys_number

        GO_coupler_dic['CoupleToSubsequentUnisonIntermanualCouplers'] = 'N'
        GO_coupler_dic['CoupleToSubsequentUpwardIntermanualCouplers'] = 'N'
        GO_coupler_dic['CoupleToSubsequentDownwardIntermanualCouplers'] = 'N'
        GO_coupler_dic['CoupleToSubsequentUpwardIntramanualCouplers'] = 'N'
        GO_coupler_dic['CoupleToSubsequentDownwardIntramanualCouplers'] = 'N'

        if LOG_HW2GO_coupler: print(f"  Built coupler '{GO_coupler_dic['Name']}' from HW_key_action_dic['_HW_uid'] : {GO_source_manual_uid} to {GO_dest_manual_uid}, key shift {keys_shift}, first MIDI note {first_key}, {keys_number} keys")

        return GO_coupler_dic

    #-------------------------------------------------------------------------------------------------
    def GO_ODF_build_Stop_pipes_attributes(self, HW_stop_dic, GO_manual_dic, rank_to_take):
        # build the GO Stop attributes (controlling pipes ranks, normal or alternate) corresponding to the given HW Stop object and linked to the given GO manual
        # rank_to_take can be : 'main', 'main_alt', 'alt'
        # return the dictionary of the Stop attributes, or None in case of building issue or stop without controlled pipes (case of demo sample sets)

        # used HW objects :
        #   Stop
        #   Stop C> StopRank(s) (ActionTypeCode = 1, ActionEffectCode = 1) C> Rank C> Pipe_SoundEngine01 ... (in function GO_ODF_build_Stop_rank_out_attr)

        # create a dictionary to store in it the GO Stop attributes
        GO_stop_dic = {}

        GO_stop_dic['Name'] = self.HW_ODF_get_attribute_value(HW_stop_dic, 'Name')

        if rank_to_take == 'alt':
            GO_stop_dic['Name'] += ' (alt.)'

        # fill the rank attributes of the stop
        self.GO_ODF_build_Stop_rank_out_attr(HW_stop_dic, GO_stop_dic, GO_manual_dic, rank_to_take)

        if GO_stop_dic['NumberOfAccessiblePipes'] == 0:
            # no pipe accessible for the built stop
            return None
        else:
            return GO_stop_dic

    #-------------------------------------------------------------------------------------------------
    def GO_ODF_build_Stop_noise_attributes(self, HW_pipe_dic, object_name, attack_bool):
        # build the GO Stop attributes (controlling noise samples, attack or release) corresponding to the given HW KeyAction object
        # give to the GO Stop the given object name
        # return the dictionary of the Stop attributes, or None in case of building issue

        # used HW objects :
        #   Pipe_SoundEngine01 C> Pipe_SoundEngine01_Layer C> Pipe_SoundEngine01_AttackSample C> Sample   (in function GO_ODF_build_Stop_rank_in_attr)
        #   Pipe_SoundEngine01 C> Pipe_SoundEngine01_Layer C> Pipe_SoundEngine01_ReleaseSample C> Sample  (in function GO_ODF_build_Stop_rank_in_attr)

        if HW_pipe_dic == None:
            return None

        # create a dictionary to store in it the GO Stop attributes
        GO_stop_dic = {}

        GO_stop_dic['Name'] = ''  # defined below, created here to have this attribute in first position

        # fill the GO stop dictionary with the data of the provided HW Pipe_SoundEngine01 object (and update attack_bool if necessary)
        HW_pipes_dic = {0: HW_pipe_dic}
        attack_bool = self.GO_ODF_build_Stop_rank_in_attr(HW_pipes_dic, GO_stop_dic, attack_bool)

        if attack_bool == True:
            GO_stop_dic['Name'] = object_name + ' engage noise'
        elif attack_bool == False:
            GO_stop_dic['Name'] = object_name + ' disengage noise'
        else:
            GO_stop_dic['Name'] = object_name + ' noise'

        return GO_stop_dic

    #-------------------------------------------------------------------------------------------------
    def GO_ODF_build_Stop_keys_noise_objects(self, HW_division_dic):
        # try to build GO Stop data with rank data inside for keyboard keys action noise rendering from the given HW object (Stop or Keyboard)

        # used HW objects :
        #   attack noise (key press) :
        #    Division C> Stop C> StopRank(1 per key) (ActionTypeCode = 1, ActionEffectCode = 2) C> Rank C> Pipe_SoundEngine01 C> Pipe_SoundEngine01Layer C> Pipe_SoundEngine01_AttackSample
        #    Division C> DivisionInput (1 per key) P> Switch C> Pipe_SoundEngine01 C> Pipe_SoundEngine01Layer C> Pipe_SoundEngine01_AttackSample
        #    Division C> Keyboard C> KeyboardKey (1 per key) P> Switch C> Pipe_SoundEngine01 C> Pipe_SoundEngine01Layer C> Pipe_SoundEngine01_AttackSample
        #    Division C> Keyboard C> KeyboardKey (1 per key) P> Switch C> SwitchLinkage (EngageLinkActionCode=4, DisengageLinkActionCode=7) C> Switch C> Pipe_SoundEngine01 C> Pipe_SoundEngine01Layer C> Pipe_SoundEngine01_AttackSample
        #   release noise (key release) :
        #    Division C> Stop C> StopRank(1 per key) (ActionTypeCode = 1, ActionEffectCode = 3) C> Rank C> Pipe_SoundEngine01 C> Pipe_SoundEngine01Layer C> Pipe_SoundEngine01_AttackSample
        #    Division C> DivisionInput (1 per key) P> Switch C> Pipe_SoundEngine01 C> Pipe_SoundEngine01Layer C> Pipe_SoundEngine01_AttackSample (blank) + Pipe_SoundEngine01_ReleaseSample
        #    Division C> DivisionInput (1 per key) P> Switch C> SwitchLinkage (SourceSwitchLinkIfEngaged=N) C> Switch C> Pipe_SoundEngine01 C> Pipe_SoundEngine01Layer C> Pipe_SoundEngine01_AttackSample (blank) + Pipe_SoundEngine01_ReleaseSample
        #    Division C> Keyboard C> KeyboardKey (1 per key) P> Switch C> Pipe_SoundEngine01 C> Pipe_SoundEngine01Layer C> Pipe_SoundEngine01_AttackSample (blank) + Pipe_SoundEngine01_ReleaseSample
        #    Division C> Keyboard C> KeyboardKey (1 per key) P> Switch C> SwitchLinkage (EngageLinkActionCode=7, DisengageLinkActionCode=4) C> Switch C> Pipe_SoundEngine01 C> Pipe_SoundEngine01Layer C> Pipe_SoundEngine01_AttackSample

        # recover the GO manual corresponding to the given HW division
        if HW_division_dic != None:
            GO_manual_uid = HW_division_dic['_GO_uid']
            GO_manual_id = int(GO_manual_uid[-3:])
            GO_manual_dic = self.GO_odf_dic[GO_manual_uid]
        else:
            logs.add(f'ERROR : no GO manual associated to the HW division {HW_division_dic["Name"]}')
            return

        # definition of the dictionaries in which store the reference of the HW Pipe_SoundEngine01 object of each key noise
        # each key of the dictionary is a key MIDI note
        key_press_pipes_dic = {}
        key_release_pipes_dic = {}

        # recover key noises when defined under HW Stop objects
        for HW_stop_dic in self.HW_ODF_get_linked_objects_by_type(HW_division_dic, 'Stop', TO_CHILD):
            # scan the children Stops of the given HW Division
            for HW_stop_rank_dic in self.HW_ODF_get_linked_objects_by_type(HW_stop_dic, 'StopRank', TO_CHILD):
                # scan the children StopRanks of the current Stop
                HW_action_type_code = myint(self.HW_ODF_get_attribute_value(HW_stop_rank_dic, 'ActionTypeCode'), 1)
                HW_action_effect_code = myint(self.HW_ODF_get_attribute_value(HW_stop_rank_dic, 'ActionEffectCode'), 1)
                nb_of_mapped_inputs = myint(self.HW_ODF_get_attribute_value(HW_stop_rank_dic, 'NumberOfMappedDivisionInputNodes'), 0)
                if HW_action_type_code == 1 and HW_action_effect_code in (2, 3) and nb_of_mapped_inputs == 1:
                    # it is a StopRank acting on a key noise sample
                    first_midi_note_nb = myint(self.HW_ODF_get_attribute_value(HW_stop_rank_dic, 'MIDINoteNumOfFirstMappedDivisionInputNode'), 36)
                    midi_note_increment = myint(self.HW_ODF_get_attribute_value(HW_stop_rank_dic, 'MIDINoteNumIncrementFromDivisionToRank'), 0)
                    mapped_midi_note = first_midi_note_nb + midi_note_increment
                    HW_rank_dic = self.HW_ODF_get_object_by_ref_id('Rank', HW_stop_rank_dic, 'RankID')
                    if HW_rank_dic != None :
                        for HW_pipe_dic in self.HW_ODF_get_linked_objects_by_type(HW_rank_dic, 'Pipe_SoundEngine01', TO_CHILD):
                            # scan the children Pipe_SoundEngine01 of the current Rank to find the mapped pipe
                            midi_note_nb = myint(self.HW_ODF_get_attribute_value(HW_pipe_dic, 'NormalMIDINoteNumber'), 60)
                            # see if the current pipe has a child release sample
                            # the current StopRank is mapping a single input
                            if midi_note_nb == mapped_midi_note:
                                # the current pipe is the mapped input
                                if HW_action_effect_code == 2:
                                    # key press noise
                                    key_press_pipes_dic[first_midi_note_nb] = HW_pipe_dic
                                else:
                                    # key release noise
                                    key_release_pipes_dic[first_midi_note_nb] = HW_pipe_dic
                                break # exit the pipes for loop

        # recover key noises when defined under HW DivisionInput objects
        for HW_div_input_dic in self.HW_ODF_get_linked_objects_by_type(HW_division_dic, 'DivisionInput', TO_CHILD):
            # scan the children DivisionInput of the given HW Division
            midi_note_nb = myint(self.HW_ODF_get_attribute_value(HW_div_input_dic, 'NormalMIDINoteNumber'), 60)
            HW_switch_dic = self.HW_ODF_get_object_by_ref_id('Switch', HW_div_input_dic, 'SwitchID')
            if HW_switch_dic != None:
                for HW_pipe_dic in self.HW_ODF_get_linked_objects_by_type(HW_switch_dic, 'Pipe_SoundEngine01', TO_CHILD):
                    # scan the children Pipe_SoundEngine01 of the current Switch
                    for HW_pipe_layer_dic in self.HW_ODF_get_linked_objects_by_type(HW_pipe_dic, 'Pipe_SoundEngine01_Layer', TO_CHILD):
                        # scan the children Pipe_SoundEngine01_Layer of the current Pipe_SoundEngine01
                        if self.HW_ODF_get_linked_objects_by_type(HW_pipe_layer_dic, 'Pipe_SoundEngine01_ReleaseSample', TO_CHILD, FIRST_ONE) != None:
                            # the current pipe layer contains a release sample, it is a key release noise
                            key_release_pipes_dic[midi_note_nb] = HW_pipe_dic
                        else:
                            # key press noise
                            key_press_pipes_dic[midi_note_nb] = HW_pipe_dic
                # check if the current Switch has an inverting SwitchLinkage toward a Pipe_SoundEngine01
                for HW_switch_link_dic in self.HW_ODF_get_linked_objects_by_type(HW_switch_dic, 'SwitchLinkage', TO_CHILD):
                    # scan the children SwitchLinkage of the current Switch
                    if self.HW_ODF_get_attribute_value(HW_switch_link_dic, 'SourceSwitchLinkIfEngaged') == 'N':
                        # it is an inverting switch linkage, to react to the key release by an attack sample in Hauptwerk
                        HW_switch2_dic = self.HW_ODF_get_object_by_ref_id('Switch', HW_switch_link_dic, 'DestSwitchID')
                        if HW_switch2_dic != None:
                            HW_pipe_dic = self.HW_ODF_get_linked_objects_by_type(HW_switch2_dic, 'Pipe_SoundEngine01', TO_CHILD, FIRST_ONE)
                            if HW_pipe_dic != None:
                                # key release noise
                                key_release_pipes_dic[midi_note_nb] = HW_pipe_dic


        # recover key noises when defined under HW KeyboardKey objects
        for HW_keyboard_dic in self.HW_ODF_get_linked_objects_by_type(HW_division_dic, 'Keyboard', TO_CHILD):
            # scan the children Keyboard of the given HW Division
            for HW_key_dic in self.HW_ODF_get_linked_objects_by_type(HW_keyboard_dic, 'KeyboardKey', TO_CHILD):
                # scan the children KeyboardKey of the current HW Keyboard
                midi_note_nb = myint(self.HW_ODF_get_attribute_value(HW_key_dic, 'NormalMIDINoteNumber'), 60)
                HW_switch_dic = self.HW_ODF_get_object_by_ref_id('Switch', HW_key_dic, 'SwitchID')
                if HW_switch_dic != None:
                    for HW_pipe_dic in self.HW_ODF_get_linked_objects_by_type(HW_switch_dic, 'Pipe_SoundEngine01', TO_CHILD):
                        # scan the children Pipe_SoundEngine01 of the current Switch
                        for HW_pipe_layer_dic in self.HW_ODF_get_linked_objects_by_type(HW_pipe_dic, 'Pipe_SoundEngine01_Layer', TO_CHILD):
                            # scan the children Pipe_SoundEngine01_Layer of the current Pipe_SoundEngine01
                            if self.HW_ODF_get_linked_objects_by_type(HW_pipe_layer_dic, 'Pipe_SoundEngine01_ReleaseSample', TO_CHILD, FIRST_ONE) != None:
                                # the current pipe layer contains a release sample, it is a key release noise
                                key_release_pipes_dic[midi_note_nb] = HW_pipe_dic
                            else:
                                # key press noise
                                key_press_pipes_dic[midi_note_nb] = HW_pipe_dic
                    # check if the current Switch has an inverting SwitchLinkage toward a Pipe_SoundEngine01
                    for HW_switch_link_dic in self.HW_ODF_get_linked_objects_by_type(HW_switch_dic, 'SwitchLinkage', TO_CHILD):
                        # scan the children SwitchLinkage of the current Switch
                        HW_engage_action_code = myint(self.HW_ODF_get_attribute_value(HW_switch_link_dic, 'EngageLinkActionCode'))
                        HW_disengage_action_code = myint(self.HW_ODF_get_attribute_value(HW_switch_link_dic, 'DisengageLinkActionCode'))
                        if (HW_engage_action_code == 4 and HW_disengage_action_code == 7) or (HW_engage_action_code == 7 and HW_disengage_action_code == 4):
                            # it is a key noise switch linkage
                            HW_switch2_dic = self.HW_ODF_get_object_by_ref_id('Switch', HW_switch_link_dic, 'DestSwitchID')
                            if HW_switch2_dic != None:
                                HW_pipe_dic = self.HW_ODF_get_linked_objects_by_type(HW_switch2_dic, 'Pipe_SoundEngine01', TO_CHILD, FIRST_ONE)
                                if HW_engage_action_code == 4:
                                    # key press noise
                                    key_press_pipes_dic[midi_note_nb] = HW_pipe_dic
                                else:
                                    # key release noise
                                    key_release_pipes_dic[midi_note_nb] = HW_pipe_dic

        for i in (0, 1):
            # loop to create GO Stops for key press noises (i=0) then for key release noises (i=1)
            if (i == 0 and len(key_press_pipes_dic) > 0) or (i == 1 and len(key_release_pipes_dic) > 0):
                # there are noise samples

                # create a Stop object in the GO ODF
                # the first digit of GO object UID is the manual ID, the two other digits are for the object number in the parent manual
                GO_stop_id = self.GO_ODF_child_type_nb_get(GO_manual_uid, 'Stop') + 1
                GO_stop_uid = 'Stop' + str(GO_manual_id).zfill(1) + str(GO_stop_id).zfill(2)
                GO_stop_dic = self.GO_odf_dic[GO_stop_uid] = {}

                # add the GO stop to the GO Manual to which it belongs
                self.GO_ODF_child_add(GO_manual_uid, GO_stop_uid)

                if i == 0:
                    GO_stop_dic['Name'] = f'{GO_manual_dic["Name"]} keys press noise'
                else:
                    GO_stop_dic['Name'] = f'{GO_manual_dic["Name"]} keys release noise'

                GO_stop_dic['DefaultToEngaged'] = 'Y'

                # fill the Stop with the keys noise pipes
                if i == 0: # key press noises, so attack sample
                    self.GO_ODF_build_Stop_rank_in_attr(key_press_pipes_dic, GO_stop_dic, True)
                else:      # key release noises, so not attack sample
                    self.GO_ODF_build_Stop_rank_in_attr(key_release_pipes_dic, GO_stop_dic, False)

    #-------------------------------------------------------------------------------------------------
    def GO_ODF_build_Tremulant_attributes(self, HW_tremulant_dic):
        # build the GO synthesized type Tremulant attributes corresponding to the given HW Tremulant object
        # return the dictionary of the GO Tremulant attributes, or None in case of building issue
        # place in the GO tremulant object attributes with the list of affected GO WindchestGroup and Manual UID

        # used HW objects :
        #   Tremulant C> TremulantWaveform C> TremulantWaveformPipe C> Pipe_SoundEngine01 P> Rank
        #                                                                                 P> WindCompartment

        # create a dictionary to store in it the GO Tremulant attributes
        GO_tremulant_dic = {}

        GO_tremulant_dic['Name'] = self.HW_ODF_get_attribute_value(HW_tremulant_dic, 'Name')

        GO_tremulant_dic['TremulantType'] = 'Synth'

        freq_hz = myfloat(self.HW_ODF_get_attribute_value(HW_tremulant_dic, 'FrequencyWhenEngagedHz'), 5.0)
        if freq_hz == 0: freq_hz = 5.0
        GO_tremulant_dic['Period'] = int(1000.0 / freq_hz)  # in milliseconds

        GO_tremulant_dic['StartRate'] = myint(myfloat(self.HW_ODF_get_attribute_value(HW_tremulant_dic, 'StartRatePercent'), 1))
        GO_tremulant_dic['StopRate'] = myint(myfloat(self.HW_ODF_get_attribute_value(HW_tremulant_dic, 'StopRatePercent'), 100))

        GO_tremulant_dic['AmpModDepth'] = 15
        # from kerkovits in GitHub GrandOrgue discussion : AmpModDepth is stored in wav files for each pipe.
        # One could multiple the minimum value found in the sample and multiply it by -100 to get AmpModDepth
        # but it is very tedious (an average of all pipes should be calculated),
        # so a default reasonable value (e.g. 15) could be set, which is still better than nothing

        # scan the HW pipes linked to the given HW Tremulant to identify the impacted ranks / wind compartments / manuals
        if LOG_HW2GO_tremulant: print(f"{HW_tremulant_dic['_HW_uid']} {GO_tremulant_dic['Name']} --------------------------------------------------------------------------------")
        GO_tremulant_dic['_GO_windchests_uid_list'] = []
        GO_tremulant_dic['_GO_manuals_uid_list'] = []
        for HW_trem_wave_form_dic in self.HW_ODF_get_linked_objects_by_type(HW_tremulant_dic, 'TremulantWaveform', TO_CHILD):
            # scan the HW TremulantWaveForm objects which are children of the given HW Tremulant object
            if LOG_HW2GO_tremulant: print(f"   {HW_trem_wave_form_dic['_HW_uid']}")
            for HW_trem_wave_form_pipe_dic in self.HW_ODF_get_linked_objects_by_type(HW_trem_wave_form_dic, 'TremulantWaveformPipe', TO_CHILD):
                # scan the HW TremulantWaveFormPipe objects which are children of the HW TremulantWaveform object
                if LOG_HW2GO_tremulant: print(f"      {HW_trem_wave_form_pipe_dic['_HW_uid']}")
                HW_pipe_dic = self.HW_ODF_get_object_by_ref_id('Pipe_SoundEngine01', HW_trem_wave_form_pipe_dic, 'PipeID')
                if HW_pipe_dic != None:
                    # get the HW Rank to which belongs to the current HW Pipe
                    HW_rank_dic = self.HW_ODF_get_linked_objects_by_type(HW_pipe_dic, 'Rank', TO_PARENT, FIRST_ONE)
                    if HW_rank_dic != None and HW_rank_dic['_GO_uid'] != '' and '_GO_manual_uid' in self.GO_odf_dic[HW_rank_dic['_GO_uid']]:
                        # get the GO manual UID to which belongs the HW/GO Rank
                        GO_manual_uid = self.GO_odf_dic[HW_rank_dic['_GO_uid']]['_GO_manual_uid']
                    else:
                        GO_manual_uid = None

                    # get the HW WindCompartment which is source of the current HW Pipe
                    HW_wind_comp_dic = self.HW_ODF_get_object_by_ref_id('WindCompartment', HW_pipe_dic, 'WindSupply_SourceWindCompartmentID')
                    if LOG_HW2GO_tremulant: print(f"         {HW_rank_dic['_HW_uid']} {HW_rank_dic['_GO_uid']}, {HW_wind_comp_dic['_HW_uid']} {HW_wind_comp_dic['_GO_uid']}")
                    # add the GO WindchestGroup UIDs to the list of windchests affected by the tremulant
                    if HW_wind_comp_dic != None and '_GO_uid_list' in HW_wind_comp_dic.keys() :
                        for GO_windchest_uid in HW_wind_comp_dic['_GO_uid_list']:
                            if GO_windchest_uid not in GO_tremulant_dic['_GO_windchests_uid_list']:
                                GO_tremulant_dic['_GO_windchests_uid_list'].append(GO_windchest_uid)
                    # add the GO Manual UID to the list of manuals affected by the tremulant
                    if GO_manual_uid != None and GO_manual_uid not in GO_tremulant_dic['_GO_manuals_uid_list']:
                        GO_tremulant_dic['_GO_manuals_uid_list'].append(GO_manual_uid)

        if LOG_HW2GO_tremulant: print(f"======> {GO_tremulant_dic['Name']} to link to {GO_tremulant_dic['_GO_windchests_uid_list']} and {GO_tremulant_dic['_GO_manuals_uid_list']}")
        return GO_tremulant_dic

    #-------------------------------------------------------------------------------------------------
    def GO_ODF_build_Switch_objects(self, HW_formula, stop_name=None, gc_state=-1):
        # recursive function to build the GO controlling switches corresponding to the given formula (a dictionary returned by HW_ODF_get_controlling_switches)
        # return the GO Switch UID which is controlled by this formula

        if not isinstance(HW_formula, dict):
            logs.add(f'INTERNAL ERROR "{HW_formula}" is not a dictionary given to GO_ODF_build_Switch_objects')
            return None

        # get the function of the formula (it must be AND, OR or NOT), will be the function attribute of the controlled GO Switch to return
        switch_function = list(HW_formula.keys())[0]  # get the first key of the HW formula dictionary
        if not switch_function in ('*And', '*Not', '*Or'):
            logs.add(f'INTERNAL ERROR unknown function "{switch_function}" given to GO_ODF_build_Switch_objects')
            return None

        # get the arguments of the function (a list of dictionaries)
        HW_arguments_list = HW_formula[switch_function]

        # build control switches for each argument
        HW_switch_dic_list = []  # list of HW Switch dictionaries which are present in the arguments of the formula
        GO_switch_uid_list = []  # list of GO Switch UID which have been build from dictionaries arguments
        for HW_argument in HW_arguments_list:
            if list(HW_argument.keys())[0][0] == '*':  # the first character of the first key is *, it is a logical condition name
                # the current argument is a dictionary with a logical condition as first key, create a GO Switch to implement this condition
                GO_switch_uid = self.GO_ODF_build_Switch_objects(HW_argument, stop_name, gc_state)
                if GO_switch_uid != None:
                    # a GO Switch has been build, add it in the GO list
                    GO_switch_uid_list.append(GO_switch_uid)
            else:
                # the current argument is HW Switch dictionary, add it in the HW list
                HW_switch_dic_list.append(HW_argument)

        if len(HW_switch_dic_list) > 0:
            # there are HW switch(es) to convert into GO switch(es)
            if switch_function == '*Or':
                # the switches are linked by a OR function
                for HW_switch_dic in HW_switch_dic_list:
                    # scan the HW switches to convert into GO switches
                    # search if the current HW switch is in the looping switches list
                    found_looping_switches_list = []
                    for looping_switches_list in self.HW_looping_switches_lists:
                        if HW_switch_dic in looping_switches_list:
                            found_looping_switches_list = looping_switches_list
                            break

                    if len(found_looping_switches_list) > 0 and isinstance(found_looping_switches_list[0], str):
                        # the first item of the list is a string and not a dictionary : a GO switch is already associated to the found looping switches ensemble
                        common_GO_switch_uid = found_looping_switches_list[0]
                    else:
                        common_GO_switch_uid = None

                    GO_switch_uid = self.GO_ODF_build_Switch_object(HW_switch_dic, common_GO_switch_uid, stop_name, gc_state)
                    if GO_switch_uid != None:
                        if GO_switch_uid not in GO_switch_uid_list:
                            GO_switch_uid_list.append(GO_switch_uid)
                        if common_GO_switch_uid == None:
                            found_looping_switches_list.insert(0, GO_switch_uid)

            elif switch_function == '*And':
                # the switches are linked by a AND function
                # build a GO switch and a GO PanelElement for each HW Switch
                # the HW switches has to be linked to one GO switch and one GO PanelElement for each
                for HW_switch_dic in HW_switch_dic_list:
                    GO_switch_uid = self.GO_ODF_build_Switch_object(HW_switch_dic, None, stop_name, gc_state)
                    GO_switch_uid_list.append(GO_switch_uid)

            else: # NOT
                # the switche has to be negated
                if len(HW_switch_dic_list) > 1:
                    logs.add(f'INTERNAL ERROR more than one switch in an OR function in formula "{HW_formula}" given to GO_ODF_build_Switch_objects')
                    return None
                else:
                    HW_switch_dic = HW_switch_dic_list[0]
                    GO_switch_uid = self.GO_ODF_build_Switch_object(HW_switch_dic, None, stop_name, gc_state)
                    GO_switch_uid_list.append(GO_switch_uid)

        if len(GO_switch_uid_list) == 1 and switch_function != '*Not':
            # if only one input switch with AND or OR function applied to it, no need to build a switch to execute this function, return the switch directly
            return GO_switch_uid_list[0]

        elif len(GO_switch_uid_list) > 0:
            # create a GO switch to apply the logical function to the GO switches of the list
            self.GO_odf_dic['Organ']['NumberOfSwitches'] += 1
            GO_switch_uid = 'Switch' + str(self.GO_odf_dic['Organ']['NumberOfSwitches']).zfill(3)
            GO_switch_dic = self.GO_odf_dic[GO_switch_uid] = {}

            GO_switch_dic['Name'] = switch_function.upper()[1:] + ' gate'
            GO_switch_dic['Function'] = switch_function[1:]
            if switch_function != '*Not':
                GO_switch_dic['SwitchCount'] = len(GO_switch_uid_list)
            for i in range(len(GO_switch_uid_list)):
                GO_switch_dic['Switch' + str(i+1).zfill(3)] = GO_switch_uid_list[i][-3:]

            return GO_switch_uid

    #-------------------------------------------------------------------------------------------------
    def GO_ODF_build_Switch_object(self, HW_switch_dic, linked_GO_switch_uid = None, switch_name = None, gc_state=-1):
        # build a GO Switch with the properties of the given HW Switch if no linked GO switch provided, only if it is not a keyboard key switch
        # build a GO Panel999Element999 object with type=Switch corresponding to the given HW Switch and in the proper GO Panel
        # link the Panel999Element999 to the build Switch or to the linked GO switch if provided
        # give to the GO Switch the given switch name if provided
        # return the UID of the added GO Switch or the linked GO Switch if provided

        # used HW objects :
        #   Switch C> ImageSetInstance

        if self.HW_ODF_get_linked_objects_by_type(HW_switch_dic, 'KeyboardKey', TO_CHILD, FIRST_ONE) != None:
            # this HW Switch object is controlling a HW KeyboardKey object : it is ignored
            GO_switch_uid = linked_GO_switch_uid
            return GO_switch_uid

        # if the given HW Switch is already associated to a GO Switch, consider this GO Switch as a linked switch
        if HW_switch_dic['_GO_uid'] != '':
            linked_GO_switch_uid = HW_switch_dic['_GO_uid']

        # take the name of the HW switch, and ignore the given switch name (it gives better naming result)
        switch_name = self.HW_ODF_get_attribute_value(HW_switch_dic, 'Name')
        if '(' in switch_name:
            # the HW switch has an opening parenthesis : get the text at the left of this parenthesis
            switch_name = switch_name.split('(')[0].rstrip()

        if linked_GO_switch_uid == None:
            # new GO Switch999 to create
            self.GO_odf_dic['Organ']['NumberOfSwitches'] += 1
            GO_switch_uid = 'Switch' + str(self.GO_odf_dic['Organ']['NumberOfSwitches']).zfill(3)
            GO_switch_dic = self.GO_odf_dic[GO_switch_uid] = {}

            GO_switch_dic['Name'] = switch_name

            if self.HW_ODF_get_attribute_value(HW_switch_dic, 'DefaultToEngaged') == 'Y':
                GO_switch_dic['DefaultToEngaged'] = 'Y'
            else:
                GO_switch_dic['DefaultToEngaged'] = 'N'

            GO_switch_dic['GCState'] = gc_state
            if gc_state != -1:
                GO_switch_dic['StoreInDivisional'] = 'Y'
                GO_switch_dic['StoreInGeneral'] = 'Y'

            if LOG_HW2GO_drawstop: print(f"          {GO_switch_uid} built from {HW_switch_dic['_HW_uid']}")
        else:
            # no new GO Switch999 to create, we reuse the UID of the linked switch
            GO_switch_uid = linked_GO_switch_uid
            if LOG_HW2GO_drawstop: print(f"          {GO_switch_uid} reused for {HW_switch_dic['_HW_uid']}")

        # add in the HW Switch object the ID of the corresponding GO object
        HW_switch_dic['_GO_uid'] = GO_switch_uid

        # manage the graphical part of the switch

        # get the HW ImageSetInstance object associated to the given HW Switch object if any
        HW_img_set_inst_dic = self.HW_ODF_get_object_by_ref_id('ImageSetInstance', HW_switch_dic, 'Disp_ImageSetInstanceID')
        # get the ID of the HW display page in which the switch is displayed if any
        HW_switch_disp_page_id = myint(self.HW_ODF_get_attribute_value(HW_img_set_inst_dic, 'DisplayPageID', MANDATORY))

        if HW_switch_disp_page_id != None and HW_img_set_inst_dic != None:
            if '_GO_panelem_uid' not in HW_switch_dic.keys():
                # build a new GO Panel999Element999 object with Type=Switch to display the switch if it has graphical properties and has not already a GO PanelElement built

                # recover the GO panel UID corresponding to the HW display page ID of the switch
                HW_disp_page_dic = self.HW_ODF_get_object_dic('DisplayPage', HW_switch_disp_page_id)
                GO_panel_uid = HW_disp_page_dic['_GO_uid']

                # create the GO Panel999Element999 switch object to display the switch in it
                self.GO_odf_dic[GO_panel_uid]['NumberOfGUIElements'] += 1
                GO_panel_element_uid = GO_panel_uid + 'Element' + str(self.GO_odf_dic[GO_panel_uid]['NumberOfGUIElements']).zfill(3)
                GO_panel_element_dic = self.GO_odf_dic[GO_panel_element_uid] = {}

                GO_panel_element_dic['Type'] = 'Switch'
                GO_panel_element_dic['Switch'] = str(int(GO_switch_uid[-3:])).zfill(3)

                # get the index of the switch image for OFF and ON positions
                switch_off_img_index = myint(self.HW_ODF_get_attribute_value(HW_switch_dic, 'Disp_ImageSetIndexDisengaged'))
                switch_on_img_index = myint(self.HW_ODF_get_attribute_value(HW_switch_dic, 'Disp_ImageSetIndexEngaged'))
                if switch_off_img_index == None: switch_off_img_index = '1'
                if switch_on_img_index == None: switch_on_img_index = '1'

                # get the attributes of the ImageSetInstance objects and its children
                image_attr_dic = {}
                self.HW_ODF_get_image_attributes(HW_img_set_inst_dic, image_attr_dic, switch_off_img_index)

                # set the position of the switch image
                GO_panel_element_dic['PositionX'] = image_attr_dic['LeftXPosPixels']
                GO_panel_element_dic['PositionY'] = image_attr_dic['TopYPosPixels']

                # get the image dimensions if they are not defined in the HW ODF
                img_w = img_h = None
                if (image_attr_dic['ImageWidthPixels'] == None or image_attr_dic['ImageHeightPixels'] == None) and image_attr_dic['BitmapFilename'] != None:
                    image_path = self.HW_sample_set_odf_path + os.sep + path2ospath(image_attr_dic['BitmapFilename'])
                    if os.path.isfile(image_path):
                        im = Image.open(image_path)
                        img_w = im.size[0]
                        img_h = im.size[1]

                if image_attr_dic['ImageWidthPixels'] != None:
                    GO_panel_element_dic['Width'] = int(image_attr_dic['ImageWidthPixels'])
                elif img_w != None:
                    GO_panel_element_dic['Width'] = img_w
                else:
                    GO_panel_element_dic['Width'] = 10  # default value if bitmap file not present

                if image_attr_dic['ImageHeightPixels'] != None:
                    GO_panel_element_dic['Height'] = int(image_attr_dic['ImageHeightPixels'])
                elif img_h != None:
                    GO_panel_element_dic['Height'] = img_h
                else:
                    GO_panel_element_dic['Height'] = 10  # default value if bitmap file not present

                # update the host panel size if needed to see the switch images
                self.GO_ODF_build_Panel_size_update(self.GO_odf_dic[GO_panel_uid], GO_panel_element_dic['PositionX'] + GO_panel_element_dic['Width'],
                                                                                   GO_panel_element_dic['PositionY'] + GO_panel_element_dic['Height'])

               # set the mouse clickable rectangle width
                if image_attr_dic['ClickableAreaLeftRelativeXPosPixels'] not in (None, 0):
                    GO_panel_element_dic['MouseRectLeft'] = int(image_attr_dic['ClickableAreaLeftRelativeXPosPixels'])

                if image_attr_dic['ClickableAreaRightRelativeXPosPixels'] not in (None, 0):
                    if image_attr_dic['ClickableAreaLeftRelativeXPosPixels'] != None:
                        GO_panel_element_dic['MouseRectWidth'] = image_attr_dic['ClickableAreaRightRelativeXPosPixels'] - image_attr_dic['ClickableAreaLeftRelativeXPosPixels']
                    else:
                        GO_panel_element_dic['MouseRectWidth'] = image_attr_dic['ClickableAreaRightRelativeXPosPixels']
                    # check if the mouse rectangle width is exceeding the image size
                    if 'MouseRectLeft' in GO_panel_element_dic.keys():
                        if GO_panel_element_dic['MouseRectLeft'] + GO_panel_element_dic['MouseRectWidth'] > GO_panel_element_dic['Width']:
                            GO_panel_element_dic['MouseRectWidth'] = GO_panel_element_dic['Width'] - GO_panel_element_dic['MouseRectLeft']
                    else:
                        if GO_panel_element_dic['MouseRectWidth'] > GO_panel_element_dic['Width']:
                            GO_panel_element_dic['MouseRectWidth'] = GO_panel_element_dic['Width']

                # set the mouse clickable rectangle height
                if image_attr_dic['ClickableAreaTopRelativeYPosPixels'] not in (None, 0):
                    GO_panel_element_dic['MouseRectTop'] = int(image_attr_dic['ClickableAreaTopRelativeYPosPixels'])

                if image_attr_dic['ClickableAreaBottomRelativeYPosPixels'] not in (None, 0):
                    if image_attr_dic['ClickableAreaTopRelativeYPosPixels'] != None:
                        GO_panel_element_dic['MouseRectHeight'] = image_attr_dic['ClickableAreaBottomRelativeYPosPixels'] - image_attr_dic['ClickableAreaTopRelativeYPosPixels']
                    else:
                        GO_panel_element_dic['MouseRectHeight'] = image_attr_dic['ClickableAreaBottomRelativeYPosPixels']
                    # check if the mouse rectangle height is exceeding the image size
                    if 'MouseRectTop' in GO_panel_element_dic.keys():
                        if GO_panel_element_dic['MouseRectTop'] + GO_panel_element_dic['MouseRectHeight'] > GO_panel_element_dic['Height']:
                            GO_panel_element_dic['MouseRectHeight'] = GO_panel_element_dic['Height'] - GO_panel_element_dic['MouseRectTop']
                    else:
                       if GO_panel_element_dic['MouseRectHeight'] > GO_panel_element_dic['Height']:
                            GO_panel_element_dic['MouseRectHeight'] = GO_panel_element_dic['Height']

                    GO_panel_element_dic['MouseRadius'] = 0

                # set the attributes of the switch OFF image
                if image_attr_dic['BitmapFilename'] != None:
                    GO_panel_element_dic['ImageOff'] = image_attr_dic['BitmapFilename']
                if image_attr_dic['TransparencyMaskBitmapFilename'] != None:
                    GO_panel_element_dic['MaskOff'] = image_attr_dic['TransparencyMaskBitmapFilename']

                # set the attributes of the switch ON image
                image_attr_dic = {}
                self.HW_ODF_get_image_attributes(HW_img_set_inst_dic, image_attr_dic, switch_on_img_index)
                if image_attr_dic['BitmapFilename'] != None:
                    GO_panel_element_dic['ImageOn'] = image_attr_dic['BitmapFilename']
                if image_attr_dic['TransparencyMaskBitmapFilename'] != None:
                    GO_panel_element_dic['MaskOn'] = image_attr_dic['TransparencyMaskBitmapFilename']

                # attribute set to have no text displayed
                GO_panel_element_dic['TextBreakWidth'] = 0

                # add in the HW Switch object the ID of the corresponding GO object
                HW_img_set_inst_dic['_GO_uid'] = GO_panel_element_uid
                HW_switch_dic['_GO_panelem_uid'] = GO_panel_element_uid

                if LOG_HW2GO_drawstop: print(f"             {GO_panel_element_uid} built, linked to {GO_switch_uid}")
            else:
                if LOG_HW2GO_drawstop: print(f"             {HW_switch_dic['_GO_panelem_uid']} already built for {HW_switch_dic['_HW_uid']}")

        return GO_switch_uid

    #-------------------------------------------------------------------------------------------------
    def GO_ODF_build_Setter_object(self, HW_switch_dic, GO_setter_name, display_text):
        # build the GO PanelElement object corresponding to the given HW Switch + GO setter name and the text to display
        # return the UID of the built PanelElement of None in case of issue

        if HW_switch_dic['_GO_uid'] != '':
            return HW_switch_dic['_GO_uid']

        if GO_setter_name == None:
            return None

        # get the HW ImageSetInstance object associated to the given HW Switch object if any
        HW_img_set_inst_dic = self.HW_ODF_get_object_by_ref_id('ImageSetInstance', HW_switch_dic, 'Disp_ImageSetInstanceID')
        # get the ID of the HW display page in which the switch is displayed if any
        HW_switch_disp_page_id = myint(self.HW_ODF_get_attribute_value(HW_img_set_inst_dic, 'DisplayPageID', MANDATORY))

        if HW_switch_disp_page_id != None and HW_img_set_inst_dic != None:
            # build a new GO Panel999Element999 object with Type=<setter name> to display the setter if it has graphical properties

            # recover the GO panel UID corresponding to the HW display page ID of the switch
            HW_disp_page_dic = self.HW_ODF_get_object_dic('DisplayPage', HW_switch_disp_page_id)
            GO_panel_uid = HW_disp_page_dic['_GO_uid']

            # create the GO Panel999Element999 switch object to display the switch in it
            self.GO_odf_dic[GO_panel_uid]['NumberOfGUIElements'] += 1
            GO_panel_element_uid = GO_panel_uid + 'Element' + str(self.GO_odf_dic[GO_panel_uid]['NumberOfGUIElements']).zfill(3)
            GO_panel_element_dic = self.GO_odf_dic[GO_panel_element_uid] = {}

            GO_panel_element_dic['Type'] = GO_setter_name
            GO_panel_element_dic['DisplayAsPiston'] = 'Y'

            # get the index of the switch image for OFF and ON positions
            switch_off_img_index = myint(self.HW_ODF_get_attribute_value(HW_switch_dic, 'Disp_ImageSetIndexDisengaged'))
            switch_on_img_index = myint(self.HW_ODF_get_attribute_value(HW_switch_dic, 'Disp_ImageSetIndexEngaged'))
            if switch_off_img_index == None: switch_off_img_index = '1'
            if switch_on_img_index == None: switch_on_img_index = '1'

            # get the attributes of the ImageSetInstance objects and its children
            image_attr_dic = {}
            self.HW_ODF_get_image_attributes(HW_img_set_inst_dic, image_attr_dic, switch_off_img_index)

            # set the position of the switch image
            GO_panel_element_dic['PositionX'] = image_attr_dic['LeftXPosPixels']
            GO_panel_element_dic['PositionY'] = image_attr_dic['TopYPosPixels']

            # get the image dimensions if they are not defined in the HW ODF
            img_w = img_h = None
            if (image_attr_dic['ImageWidthPixels'] == None or image_attr_dic['ImageHeightPixels'] == None) and image_attr_dic['BitmapFilename'] != None:
                image_path = self.HW_sample_set_odf_path + os.sep + path2ospath(image_attr_dic['BitmapFilename'])
                if os.path.isfile(image_path):
                    im = Image.open(image_path)
                    img_w = im.size[0]
                    img_h = im.size[1]

            if image_attr_dic['ImageWidthPixels'] != None:
                GO_panel_element_dic['Width'] = int(image_attr_dic['ImageWidthPixels'])
            elif img_w != None:
                GO_panel_element_dic['Width'] = img_w
            else:
                GO_panel_element_dic['Width'] = 32  # size of the default setter image of GO

            if image_attr_dic['ImageHeightPixels'] != None:
                GO_panel_element_dic['Height'] = int(image_attr_dic['ImageHeightPixels'])
            elif img_h != None:
                GO_panel_element_dic['Height'] = img_h
            else:
                GO_panel_element_dic['Height'] = 32  # size of the default setter image of GO

           # set the mouse clickable rectangle width
            if image_attr_dic['ClickableAreaLeftRelativeXPosPixels'] not in (None, 0):
                GO_panel_element_dic['MouseRectLeft'] = int(image_attr_dic['ClickableAreaLeftRelativeXPosPixels'])

            if image_attr_dic['ClickableAreaRightRelativeXPosPixels'] not in (None, 0) and GO_panel_element_dic['Width'] > 1:
                if image_attr_dic['ClickableAreaLeftRelativeXPosPixels'] != None:
                    GO_panel_element_dic['MouseRectWidth'] = image_attr_dic['ClickableAreaRightRelativeXPosPixels'] - image_attr_dic['ClickableAreaLeftRelativeXPosPixels']
                else:
                    GO_panel_element_dic['MouseRectWidth'] = image_attr_dic['ClickableAreaRightRelativeXPosPixels']

            # set the mouse clickable rectangle height
            if image_attr_dic['ClickableAreaTopRelativeYPosPixels'] not in (None, 0):
                GO_panel_element_dic['MouseRectTop'] = int(image_attr_dic['ClickableAreaTopRelativeYPosPixels'])

            if image_attr_dic['ClickableAreaBottomRelativeYPosPixels'] not in (None, 0) and GO_panel_element_dic['Height'] > 1:
                if image_attr_dic['ClickableAreaTopRelativeYPosPixels'] != None:
                    GO_panel_element_dic['MouseRectHeight'] = image_attr_dic['ClickableAreaBottomRelativeYPosPixels'] - image_attr_dic['ClickableAreaTopRelativeYPosPixels']
                else:
                    GO_panel_element_dic['MouseRectHeight'] = image_attr_dic['ClickableAreaBottomRelativeYPosPixels']

                GO_panel_element_dic['MouseRadius'] = 0

            # set the attributes of the switch OFF image
            if image_attr_dic['BitmapFilename'] != None:
                GO_panel_element_dic['ImageOff'] = image_attr_dic['BitmapFilename']
            if image_attr_dic['TransparencyMaskBitmapFilename'] != None:
                GO_panel_element_dic['MaskOff'] = image_attr_dic['TransparencyMaskBitmapFilename']

            # set the attributes of the switch ON image
            image_attr_dic = {}
            self.HW_ODF_get_image_attributes(HW_img_set_inst_dic, image_attr_dic, switch_on_img_index)
            if image_attr_dic['BitmapFilename'] != None:
                GO_panel_element_dic['ImageOn'] = image_attr_dic['BitmapFilename']
            if image_attr_dic['TransparencyMaskBitmapFilename'] != None:
                GO_panel_element_dic['MaskOn'] = image_attr_dic['TransparencyMaskBitmapFilename']

            # attribute set to have no text displayed
            GO_panel_element_dic['TextBreakWidth'] = 0

            # add in the HW Switch object the ID of the corresponding GO object
            HW_img_set_inst_dic['_GO_uid'] = GO_panel_element_uid
            HW_switch_dic['_GO_uid'] = GO_panel_element_uid

            if LOG_HW2GO_drawstop: print(f"             {GO_panel_element_uid} built for setter {GO_setter_name}")

            return GO_panel_element_uid
        else:
            if LOG_HW2GO_drawstop: print(f"             GO PanelElement NOT built for setter {GO_setter_name}")
            return None

    #-------------------------------------------------------------------------------------------------
    def GO_ODF_build_Stop_rank_in_attr(self, HW_pipes_dic, GO_stop_dic, attack_bool):
        # build pipes data (for noise effect) in the given GO Stop from the given HW_pipes_dic dictionary (key = midi note: value = corresponding HW Pipe_SoundEngine01 object)
        # depending on the provided noise attack status
        # return the value of attack_bool which may have been updated in the function

        # the given HW pipe must have always an attack sample
        # if the given HW pipe has a  release sample                       ==> build       attack pipe and    release pipe, attack_bool set to None
        # if the given HW pipe has no release sample and attack_bool=True  ==> build       attack pipe and no release pipe
        #            "             "            "    and attack_bool=False ==> build blank attack pipe and    release pipe from attack sample

        # used HW objects :
        #   Pipe_SoundEngine01 C> Pipe_SoundEngine01_Layer C> Pipe_SoundEngine01_AttackSample C> Sample
        #   Pipe_SoundEngine01 C> Pipe_SoundEngine01_Layer C> Pipe_SoundEngine01_ReleaseSample C> Sample

        # get the first HW pipe of the given pipes dictionary
        HW_pipe_dic = list(HW_pipes_dic.values())[0]
        # get the source HW WindCompartment of the first pipe to use is at GO WindchestGroup of all the pipes
        HW_wind_comp_dic = self.HW_ODF_get_object_by_ref_id('WindCompartment', HW_pipe_dic, 'WindSupply_SourceWindCompartmentID')
        # get the HW ScalingContinuousControlID of the current layer of the first pipe to use it as GO Enclosure of all the pipes
        HW_pipe_layer_dic = self.HW_ODF_get_linked_objects_by_type(HW_pipe_dic, 'Pipe_SoundEngine01_Layer', TO_CHILD, FIRST_ONE)
        HW_cont_ctrl_dic = self.HW_ODF_get_object_by_ref_id('ContinuousControl', HW_pipe_layer_dic, 'AmpLvl_ScalingContinuousControlID')

        GO_windchest_uid = self.GO_ODF_build_WindchestGroup_object(HW_wind_comp_dic, HW_cont_ctrl_dic, None)
        GO_stop_dic['WindchestGroup'] = int(GO_windchest_uid[-3:])

        GO_stop_dic['FirstAccessiblePipeLogicalKeyNumber'] = 1
        GO_stop_dic['FirstAccessiblePipeLogicalPipeNumber'] = 1
        GO_stop_dic['NumberOfAccessiblePipes'] = len(HW_pipes_dic)
        GO_stop_dic['NumberOfLogicalPipes'] = len(HW_pipes_dic)
        GO_stop_dic['Percussive'] = 'N'
        GO_stop_dic['AcceptsRetuning'] = 'N'

        for i, midi_note in enumerate(sorted(HW_pipes_dic.keys())):
            # scan the HW pipes of the given pipes dictionary by MIDI note order

            HW_pipe_dic = HW_pipes_dic[midi_note]

            pipe_id = 'Pipe' + str(i+1).zfill(3)

            # get the first HW Pipe_SoundEngine01_Layer linked to the given HW Pipe_SoundEngine01 (the others if any are ignored)
            HW_pipe_layer_dic = self.HW_ODF_get_linked_objects_by_type(HW_pipe_dic, 'Pipe_SoundEngine01_Layer', TO_CHILD, FIRST_ONE)

            # get the pipe gain if any
            pipe_gain = myfloat(self.HW_ODF_get_attribute_value(HW_pipe_layer_dic, 'AmpLvl_LevelAdjustDecibels'))
            if pipe_gain != None and pipe_gain != 0:
                GO_stop_dic[pipe_id + 'Gain'] = max(pipe_gain, -5)  # noise gain set at minimum at -5

            # get the pipe harmonic number if any
            pipe_harmonic_nb = myint(self.HW_ODF_get_attribute_value(HW_pipe_dic, 'Pitch_Tempered_RankBasePitch64ftHarmonicNum'))
            if pipe_harmonic_nb != None and pipe_harmonic_nb != 0:
                GO_stop_dic[pipe_id + 'HarmonicNumber'] = pipe_harmonic_nb

            HW_pipe_attack_samples_list = self.HW_ODF_get_linked_objects_by_type(HW_pipe_layer_dic, 'Pipe_SoundEngine01_AttackSample', TO_CHILD)
            HW_pipe_release_samples_list = self.HW_ODF_get_linked_objects_by_type(HW_pipe_layer_dic, 'Pipe_SoundEngine01_ReleaseSample', TO_CHILD)

            # decide if attack and/or release pipes have to be built
            if len(HW_pipe_release_samples_list) > 0:
                # there are release samples : it should be a release sound (the attack sample is a silence normally) or a sound with both attack and release
                attack_bool = None  # will be set later at False if there is a silent attack sample
            elif attack_bool:
                # there is no release sample and it is an attack noise : clear the release samples list if not already empty
                HW_pipe_release_samples_list.clear()
                GO_stop_dic['Percussive'] = 'Y'
            else:
                # there is no release sample and it is an release noise : use the attack sample as release sample, use a silent attack
                HW_pipe_release_samples_list = list(HW_pipe_attack_samples_list)
                HW_pipe_attack_samples_list.clear()
                # use a silent loop sample as attack pipe
                GO_stop_dic[pipe_id] = '..' + os.sep + 'SilentLoop.wav'
                self.silent_loop_file_used = True

            # define the attack pipes
            attacks_count = 0
            for HW_pipe_attack_sample_dic in HW_pipe_attack_samples_list:
                # scan the HW Pipe_SoundEngine01_AttackSample child objects of the Pipe_SoundEngine01_Layer object
                HW_sample_dic = self.HW_ODF_get_linked_objects_by_type(HW_pipe_attack_sample_dic, 'Sample', TO_CHILD, FIRST_ONE)
                if HW_sample_dic != None:
                    attacks_count += 1
                    HW_install_package_id = myint(self.HW_ODF_get_attribute_value(HW_sample_dic, 'InstallationPackageID', MANDATORY))
                    sample_file_name = self.convert_HW2GO_file_name(self.HW_ODF_get_attribute_value(HW_sample_dic, 'SampleFilename', MANDATORY), HW_install_package_id)
                    if sample_file_name != None:
                        if attacks_count == 1:
                            GO_stop_dic[pipe_id] = sample_file_name
                        else:
                            GO_stop_dic[pipe_id + 'AttackCount'] = attacks_count - 1
                            GO_stop_dic[pipe_id + 'Attack' + str(attacks_count - 1).zfill(3)] = sample_file_name
                        if 'Blank' in sample_file_name:
                            # if the attack file is a blank loop sample, then the pipe is for a release noise (case of Piotr Graboswki sample sets)
                            attack_bool = False

            # define the release pipes
            if len(HW_pipe_release_samples_list) > 0:
                GO_stop_dic[pipe_id + 'LoadRelease'] = 'N'
                GO_stop_dic[pipe_id + 'ReleaseCount'] = releases_count = 0
                for HW_pipe_release_sample_dic in HW_pipe_release_samples_list:
                    HW_sample_dic = self.HW_ODF_get_linked_objects_by_type(HW_pipe_release_sample_dic, 'Sample', TO_CHILD, FIRST_ONE)
                    if HW_sample_dic != None:
                        HW_install_package_id = myint(self.HW_ODF_get_attribute_value(HW_sample_dic, 'InstallationPackageID', MANDATORY))
                        sample_file_name = self.convert_HW2GO_file_name(self.HW_ODF_get_attribute_value(HW_sample_dic, 'SampleFilename', MANDATORY), HW_install_package_id)
                        if sample_file_name != None:
                            releases_count += 1
                            GO_stop_dic[pipe_id + 'ReleaseCount'] = releases_count
                            GO_stop_dic[pipe_id + 'Release' + str(releases_count).zfill(3)] = sample_file_name
            elif GO_stop_dic['Percussive'] == 'N':
                # it is not a percussive rank, the release of the sample can be loaded
                GO_stop_dic[pipe_id + 'LoadRelease'] = 'Y'

        return attack_bool

    #-------------------------------------------------------------------------------------------------
    def GO_ODF_build_Stop_rank_out_attr(self, HW_stop_dic, GO_stop_dic, GO_manual_dic, rank_to_take='main'):
        # build in the given GO Stop dictionary the data and links to GO Rank(s) for pipes sound generation from the given HW Stop object
        # rank_to_take can be : 'main', 'main_alt', 'alt'

        # used HW objects :
        #   Stop C> StopRank(s) (ActionTypeCode = 1, ActionEffectCode = 1) C> Rank C> Pipe_SoundEngine01 C> Pipe_SoundEngine01_Layer C> Pipe_SoundEngine01_AttackSample C> Sample
        #   Stop C> StopRank(s) (ActionTypeCode = 1, ActionEffectCode = 1) C> Rank C> Pipe_SoundEngine01 C> Pipe_SoundEngine01_Layer C> Pipe_SoundEngine01_ReleaseSample C> Sample

        # get the MIDI notes range of the GO manual to which is attached the given GO Stop
        manual_first_access_midi_note = GO_manual_dic['FirstAccessibleKeyMIDINoteNumber']
        manual_nb_keys = GO_manual_dic['NumberOfAccessibleKeys']

        if LOG_HW2GO_stop_rank: print(f"\n{HW_stop_dic['_HW_uid']} in Manual with {manual_nb_keys} keys from MIDI note {manual_first_access_midi_note} '{HW_stop_dic['Name']}'")

        GO_stop_dic['FirstAccessiblePipeLogicalKeyNumber'] = 0
        GO_stop_dic['NumberOfAccessiblePipes'] = 0
        GO_stop_dic['NumberOfRanks'] = 0
        GO_stop_nb_ranks = 0

        HW_stop_dic['_GO_windchests_uid_list'] = []

        for HW_stop_rank_dic in self.HW_ODF_get_linked_objects_by_type(HW_stop_dic, 'StopRank', TO_CHILD):
            # scan the HW StopRank objects which are children of the given HW Stop object

            # get the HW Rank (and alternate HW Rank if needed) linked to the current HW StopRank
            if rank_to_take == 'main_alt':
                # the main rank and the alternate rank of the current HW StopRank are taken and will be merged in the same GO Rank
                HW_rank_dic = self.HW_ODF_get_object_by_ref_id('Rank', HW_stop_rank_dic, 'RankID')
                HW_alt_rank_dic = self.HW_ODF_get_object_by_ref_id('Rank', HW_stop_rank_dic, 'AlternateRankID')
            elif rank_to_take == 'alt':
                # the alternate rank of the current HW StopRank is taken to be the GO Rank
                HW_rank_dic = self.HW_ODF_get_object_by_ref_id('Rank', HW_stop_rank_dic, 'AlternateRankID')
                HW_alt_rank_dic = None
            else:
                # the rank of the current HW StopRank is taken to be the GO Rank
                HW_rank_dic = self.HW_ODF_get_object_by_ref_id('Rank', HW_stop_rank_dic, 'RankID')
                HW_alt_rank_dic = None

            # get the list of the HW Pipe_SoundEngine01 objects which are children of the HW Rank object
            HW_pipes_dic_list = self.HW_ODF_get_linked_objects_by_type(HW_rank_dic, 'Pipe_SoundEngine01', TO_CHILD)
            if (HW_pipes_dic_list != None and len(HW_pipes_dic_list) > 0 and
                myint(self.HW_ODF_get_attribute_value(HW_stop_rank_dic, 'ActionTypeCode'), 1) == 1 and
                myint(self.HW_ODF_get_attribute_value(HW_stop_rank_dic, 'ActionEffectCode'), 1) == 1):
                # the current StopRank has normal action codes and is linked to a Rank having at least one pipe inside

                # get the MIDI notes range of the HW rank from the HW pipes list
                HW_rank_first_midi_note_nb = 999
                HW_rank_last_midi_note_nb = 0
                for HW_pipe_dic in HW_pipes_dic_list:
                    # scan the Pipe_SoundEngine01 objects which are children of the HW Rank
                    midi_note_nb = myint(self.HW_ODF_get_attribute_value(HW_pipe_dic, 'NormalMIDINoteNumber'), 60)  # MIDI note = 60 when not defined
                    if midi_note_nb >= 36:
                        # MIDI notes under number 36 are ignored (can be fake pipes)
                        HW_rank_first_midi_note_nb = min(midi_note_nb, HW_rank_first_midi_note_nb)
                        HW_rank_last_midi_note_nb  = max(midi_note_nb, HW_rank_last_midi_note_nb)

                if LOG_HW2GO_stop_rank: print(f"   {HW_stop_rank_dic['_HW_uid']} with {HW_rank_last_midi_note_nb-HW_rank_first_midi_note_nb+1} pipes from MIDI notes {HW_rank_first_midi_note_nb} to {HW_rank_last_midi_note_nb}")

                # get the MIDI note increment from division to rank, set by default at 0
                HW_div_midi_note_increment_to_rank = myint(self.HW_ODF_get_attribute_value(HW_stop_rank_dic, 'MIDINoteNumIncrementFromDivisionToRank'), 0)

                # get the MIDI note of the first division input, mapped by default to the first MIDI note of the rank
                HW_div_midi_note_first_mapped_input = myint(self.HW_ODF_get_attribute_value(HW_stop_rank_dic, 'MIDINoteNumOfFirstMappedDivisionInputNode'), HW_rank_first_midi_note_nb)
                # the MIDI note must be higher or equal to the rank first MIDI note - MIDI note increment
                # else the first MIDI note of the division will be mapped to a note lower the first rank MIDI note
                HW_div_midi_note_first_mapped_input = max(HW_div_midi_note_first_mapped_input, HW_rank_first_midi_note_nb - HW_div_midi_note_increment_to_rank)

                # get the number of division inputs mapped to the rank, set by default at the rank notes numbers
                HW_div_nb_mapped_inputs = myint(self.HW_ODF_get_attribute_value(HW_stop_rank_dic, 'NumberOfMappedDivisionInputNodes'), HW_rank_last_midi_note_nb - HW_rank_first_midi_note_nb + 1)
                # the number of mapped division inputs + the first mapped input must not go higher to the rank range
                max_nb_mapped_inputs = HW_rank_last_midi_note_nb - (HW_div_midi_note_first_mapped_input + HW_div_midi_note_increment_to_rank) + 1
                HW_div_nb_mapped_inputs = min(HW_div_nb_mapped_inputs, max_nb_mapped_inputs)

                if LOG_HW2GO_stop_rank: print(f"        MIDI note first mapped input={HW_div_midi_note_first_mapped_input}, nb mapped inputs={HW_div_nb_mapped_inputs}, MIDI note increment={HW_div_midi_note_increment_to_rank}     ")

                # get the number of pipes layers defined inside the first pipe of the current HW rank
                # we consider that all the pipes of the HW rank have the same number of layers as the first pipe has
                HW_pipe1_layers_dic_list = self.HW_ODF_get_linked_objects_by_type(HW_pipes_dic_list[0], 'Pipe_SoundEngine01_Layer', TO_CHILD)
                nb_pipe1_layers = len(HW_pipe1_layers_dic_list)

                for pipes_layer_nb in range(0, 1):  #nb_pipe1_layers):  # consider only the first layer, the other are ignored
                    # scan the pipes layers of the  HW rank, to build one GO rank for each HW rank layer

                    # get the UID of the GO Rank associated to the HW Pipe_SoundEngine01_Layer of the current layer of the first pipe
                    GO_rank_uid = HW_pipe1_layers_dic_list[pipes_layer_nb]['_GO_uid']
                    if GO_rank_uid == '':
                        # there is not yet a GO Rank built for the current HW rank layer : build it
                        GO_rank_uid = self.GO_ODF_build_Rank_object(HW_rank_dic, HW_alt_rank_dic, pipes_layer_nb)
                        self.GO_odf_dic[GO_rank_uid]['_GO_manual_uid'] = GO_manual_dic['_GO_uid']
                        # store in the current HW StopRank the GO WindchestGroup UID in which is the associated rank
                        HW_stop_rank_dic['_GO_windchest_uid'] = HW_rank_dic['_GO_windchest_uid']
                        HW_stop_dic['_GO_windchests_uid_list'].append(HW_rank_dic['_GO_windchest_uid'])

                    GO_rank_dic = self.GO_odf_dic[GO_rank_uid]

                    # add the GO Rank to the GO Stop
                    GO_stop_nb_ranks += 1
                    GO_stop_dic['Rank' + str(GO_stop_nb_ranks).zfill(3)] = GO_rank_uid[-3:]

                    # define the number of the first pipe of the rank used by the current HW StopRank
                    GO_stop_dic[f'Rank{str(GO_stop_nb_ranks).zfill(3)}FirstPipeNumber'] = (
                        HW_div_midi_note_first_mapped_input + HW_div_midi_note_increment_to_rank - HW_rank_first_midi_note_nb + 1)

                    # store the absolute value of the first key of the manual accessing to the rank
                    # the value relative to FirstAccessiblePipeLogicalKeyNumber (as expected) will be set later in this function once all the ranks are built
                    GO_stop_dic[f'Rank{str(GO_stop_nb_ranks).zfill(3)}FirstAccessibleKeyNumber'] = HW_div_midi_note_first_mapped_input - manual_first_access_midi_note + 1

                    # define the number of pipes of the rank used by the current HW StopRank
                    GO_stop_dic[f'Rank{str(GO_stop_nb_ranks).zfill(3)}PipeCount'] = HW_div_nb_mapped_inputs

                    # add in the HW StopRank object the UID of the corresponding GO object
                    HW_stop_rank_dic['_GO_uid'] = GO_rank_uid
            else:
                if LOG_HW2GO_stop_rank: print(f"   {HW_stop_rank_dic['_HW_uid']} has none pipe or unexpected action codes")

        if GO_stop_nb_ranks > 0:
            # based on the Rank999xxx attributes created just before in the GO Stop for each HW StopRank, compute remaining attributes of the GO Stop
            # identify the first and last keys of the manual which can access to the ranks associated to the stop
            stop_first_accessible_key_nb = 999
            stop_last_accessible_key_nb = 0
            for r in range(1, GO_stop_nb_ranks + 1):
                rank_id = 'Rank' + str(r).zfill(3)
                rank_first_access_key = GO_stop_dic[rank_id + 'FirstAccessibleKeyNumber']
                stop_first_accessible_key_nb = min(rank_first_access_key, stop_first_accessible_key_nb)

                rank_last_access_key = rank_first_access_key + GO_stop_dic[rank_id + 'PipeCount'] - 1
                stop_last_accessible_key_nb = max(rank_last_access_key, stop_last_accessible_key_nb)

            GO_stop_dic['FirstAccessiblePipeLogicalKeyNumber'] = stop_first_accessible_key_nb
            GO_stop_dic['NumberOfAccessiblePipes'] = stop_last_accessible_key_nb - stop_first_accessible_key_nb + 1
            GO_stop_dic['NumberOfRanks'] = GO_stop_nb_ranks

            # adjust the Rank999FirstAccessibleKeyNumber attributes so that it is an offset value compated to FirstAccessiblePipeLogicalKeyNumber and no more an absolute value
            for r in range(1, GO_stop_nb_ranks + 1):
                rank_id = 'Rank' + str(r).zfill(3)
                GO_stop_dic[rank_id + 'FirstAccessibleKeyNumber'] -= (GO_stop_dic['FirstAccessiblePipeLogicalKeyNumber'] - 1)

                # remove the attributes which have a default value
                if GO_stop_dic[rank_id + 'FirstPipeNumber'] == 1:
                    GO_stop_dic.pop(rank_id + 'FirstPipeNumber')

                    if GO_stop_dic[rank_id + 'PipeCount'] == GO_stop_dic['NumberOfAccessiblePipes']:
                        GO_stop_dic.pop(rank_id + 'PipeCount')

                if GO_stop_dic[rank_id + 'FirstAccessibleKeyNumber'] == 1:
                    GO_stop_dic.pop(rank_id + 'FirstAccessibleKeyNumber')

        else:
            # none rank build thanks to StopRank objects : try using the attribute Hint_PrimaryAssociatedRankID if defined
            HW_rank_id = myint(self.HW_ODF_get_attribute_value(HW_stop_dic, 'Hint_PrimaryAssociatedRankID'))
            HW_rank_dic = self.HW_ODF_get_object_dic('Rank', HW_rank_id)
            if HW_rank_dic != None:
                # the given HW Stop is linked to one Rank through the Hint attribute

                # get the list of the HW Pipe_SoundEngine01 objects which are children of the HW Rank
                HW_pipes_dic_list = self.HW_ODF_get_linked_objects_by_type(HW_rank_dic, 'Pipe_SoundEngine01', TO_CHILD)
                if len(HW_pipes_dic_list) > 0:
                    # the Rank has at least one pipe inside

                    # get the number of pipes layers defined inside the first pipe of the HW rank
                    # we consider that all the pipes of the HW rank have the same number of layers as the first pipe has
                    HW_pipe1_layers_dic_list = self.HW_ODF_get_linked_objects_by_type(HW_pipes_dic_list[0], 'Pipe_SoundEngine01_Layer', TO_CHILD)
                    nb_pipe1_layers = len(HW_pipe1_layers_dic_list)

                    for pipes_layer_nb in range(0, 1):  #nb_pipe1_layers):  # load only the first layer
                        # scan the pipes layers of the current HW rank, to build one GO rank for each HW rank layer

                        # get the UID of the GO Rank associated to the HW Pipe_SoundEngine01_Layer of the current layer of the first pipe
                        GO_rank_uid = HW_pipe1_layers_dic_list[pipes_layer_nb]['_GO_uid']
                        if GO_rank_uid == '':
                            # there is not yet a GO Rank built for the current HW rank layer
                            GO_rank_uid = self.GO_ODF_build_Rank_object(HW_rank_dic, None, pipes_layer_nb)
                            self.GO_odf_dic[GO_rank_uid]['_GO_manual_uid'] = GO_manual_dic['_GO_uid']
                        GO_rank_dic = self.GO_odf_dic[GO_rank_uid]

                        # add the GO Rank to the GO Stop
                        GO_stop_nb_ranks += 1
                        GO_stop_dic['Rank' + str(GO_stop_nb_ranks).zfill(3)] = GO_rank_uid[-3:]

                        GO_stop_dic['FirstAccessiblePipeLogicalKeyNumber'] = 1
                        GO_stop_dic['NumberOfAccessiblePipes'] = len(HW_pipes_dic_list)
                        GO_stop_dic['NumberOfRanks'] = GO_stop_nb_ranks

    #-------------------------------------------------------------------------------------------------
    def GO_ODF_build_Rank_object(self, HW_rank_dic, HW_alt_rank_dic, pipes_layer_nb):
        # build the GO Rank object from the given HW Rank object (and alternate HW Rank if not None) and its given layer number
        # if an alternate rank is provided (parameter not None), it is considered as a tremmed rank and the normal rank as an un-tremmed rank
        # return the UID of the built GO Rank or None if not created

        # used HW objects :
        #   Rank C> Pipe_SoundEngine01 P> WindCompartment
        #   Rank C> Pipe_SoundEngine01 P> EnclosurePipe P> Enclosure
        #   Rank C> Pipe_SoundEngine01 C> Pipe_SoundEngine01_Layer P> ContinuousControl
        #   Rank C> Pipe_SoundEngine01 C> Pipe_SoundEngine01_Layer C> Pipe_SoundEngine01_AttackSample C> Sample
        #   Rank C> Pipe_SoundEngine01 C> Pipe_SoundEngine01_Layer C> Pipe_SoundEngine01_ReleaseSample C> Sample

        GO_rank_uid = None

        # get the list of the HW Pipe_SoundEngine01 objects which are children of the given HW Rank
        HW_pipes_dic_list = self.HW_ODF_get_linked_objects_by_type(HW_rank_dic, 'Pipe_SoundEngine01', TO_CHILD)
        if len(HW_pipes_dic_list) > 0:
            # the current HW rank has pipes defined inside

            # store in a dictionary the HW Pipe_SoundEngine01 objects of the given HW Rank with as key their MIDI note number
            # get the first and last MIDI note numbers of these pipes
            first_midi_note_nb = 999
            last_midi_note_nb = 0
            pipes_dic = {}
            for HW_pipe_dic in HW_pipes_dic_list:
                # scan the Pipe_SoundEngine01 objects of the given HW Rank

                # get the MIDI note number of the current HW Pipe_SoundEngine01
                # observed with Sound Paradisi sample sets, the MIDI note 60 is not defined, so it is the default value
                midi_note_nb = myint(self.HW_ODF_get_attribute_value(HW_pipe_dic, 'NormalMIDINoteNumber'), 60)
                if midi_note_nb >= 36:
                    # MIDI notes under number 36 are ignored (can be fake pipes)
                    # update the first/last MIDI note numbers
                    first_midi_note_nb = min(midi_note_nb, first_midi_note_nb)
                    last_midi_note_nb = max(midi_note_nb, last_midi_note_nb)

                    # associate the dictionary of the current pipe to its MIDI note number
                    pipes_dic[midi_note_nb] = HW_pipe_dic

            alt_pipes_dic = {}
            if HW_alt_rank_dic != None:
                # an alternate rank is provided
                # store in a dictionary the HW Pipe_SoundEngine01 objects of the given alternate HW Rank with as key their MIDI note number
                # get the first and last MIDI note numbers of these pipe objects
                for HW_pipe_dic in self.HW_ODF_get_linked_objects_by_type(HW_alt_rank_dic, 'Pipe_SoundEngine01', TO_CHILD):
                    # scan the Pipe_SoundEngine01 objects of the given alternate HW Rank

                    # get the MIDI note number of the current HW Pipe_SoundEngine01
                    # observed with Sound Paradisi sample sets, the MIDI note 60 is not defined, so it is the default value
                    midi_note_nb = myint(self.HW_ODF_get_attribute_value(HW_pipe_dic, 'NormalMIDINoteNumber'), 60)
                    if midi_note_nb >= 36:
                        # MIDI notes under number 36 are ignored (can be fake pipes)
                        # associate the dictionary of the current pipe to its MIDI note number
                        alt_pipes_dic[midi_note_nb] = HW_pipe_dic

            # create a GO Rank999 object
            self.GO_odf_dic['Organ']['NumberOfRanks'] += 1
            GO_rank_uid = 'Rank' + str(self.GO_odf_dic['Organ']['NumberOfRanks']).zfill(3)
            GO_rank_dic = self.GO_odf_dic[GO_rank_uid] = {}

            if pipes_layer_nb == 0:
                GO_rank_dic['Name'] = self.HW_ODF_get_attribute_value(HW_rank_dic, 'Name')
            else:
                # identify in the rank name the layer number for the additional layers
                GO_rank_dic['Name'] = self.HW_ODF_get_attribute_value(HW_rank_dic, 'Name') + ' Layer' + str(pipes_layer_nb + 1)

            # set the rank compass
            GO_rank_dic['FirstMidiNoteNumber'] = first_midi_note_nb
            GO_rank_dic['NumberOfLogicalPipes'] = last_midi_note_nb - first_midi_note_nb + 1

            # get the source HW WindCompartment of the first pipe to use it as GO WindchestGroup of the whole GO Rank
            HW_wind_comp_dic = self.HW_ODF_get_object_by_ref_id('WindCompartment', HW_pipes_dic_list[0], 'WindSupply_SourceWindCompartmentID')
            # get the HW scaling ContinuousControl of the first pipe of the current layer to use it as GO Enclosure of the whole GO Rank if any
            HW_pipe_layers_dic_list = self.HW_ODF_get_linked_objects_by_type(HW_pipes_dic_list[0], 'Pipe_SoundEngine01_Layer', TO_CHILD)
            HW_pipe_layer_dic = HW_pipe_layers_dic_list[pipes_layer_nb]
            HW_cont_ctrl_dic = self.HW_ODF_get_object_by_ref_id('ContinuousControl', HW_pipe_layer_dic, 'AmpLvl_ScalingContinuousControlID')
            # get the HW Enclosure of the first pipe to use it as GO Enclosure of the whole GO Rank if any
            HW_enclosure_pipe_dic = self.HW_ODF_get_linked_objects_by_type(HW_pipes_dic_list[0], 'EnclosurePipe', TO_PARENT, FIRST_ONE)
            HW_enclosure_dic = self.HW_ODF_get_object_by_ref_id('Enclosure', HW_enclosure_pipe_dic, 'EnclosureID')
            # create the GO WindchestGroup corresponding to the current HW WindCompartment + ContinuousControl + Enclosure
            # if not already existing, else recover the UID of the existing associated GO WindchestGroup
            GO_windchest_uid = self.GO_ODF_build_WindchestGroup_object(HW_wind_comp_dic, HW_cont_ctrl_dic, HW_enclosure_dic)
            GO_rank_dic['WindchestGroup'] = int(GO_windchest_uid[-3:])
            HW_rank_dic['_GO_windchest_uid'] = GO_windchest_uid

            GO_rank_dic['Percussive'] = 'N'

            for midi_note_nb in range(first_midi_note_nb, last_midi_note_nb + 1):
                # scan the MIDI notes range of the HW rank by increasing MIDI note number

                # set the GO pipe ID corresponding to the current MIDI note (for example Pipe001, Pipe002, ...)
                pipe_id = 'Pipe' + str(midi_note_nb - first_midi_note_nb + 1).zfill(3)

                if midi_note_nb in pipes_dic.keys():
                    # there is a HW Pipe_SoundEngine01 object defined for the current MIDI note
                    HW_pipe_dic = pipes_dic[midi_note_nb]

                    if midi_note_nb in alt_pipes_dic.keys():
                        # there is an alternate HW Pipe_SoundEngine01 object defined for the current MIDI note
                        HW_alt_pipe_dic = alt_pipes_dic[midi_note_nb]
                    else:
                        HW_alt_pipe_dic = None

                    # get the dictionary of the HW Pipe_SoundEngine01_Layer child of the current HW Pipe_SoundEngine01_Layer
                    # and corresponding to the given pipes layer number
                    HW_pipe_layer_dic = self.HW_ODF_get_linked_objects_by_type(HW_pipe_dic, 'Pipe_SoundEngine01_Layer', TO_CHILD)[pipes_layer_nb]

                    # add in the HW Pipe_SoundEngine01_Layer the ID of the corresponding GO rank object
                    HW_pipe_layer_dic['_GO_uid'] = GO_rank_uid

                    # do the same for the alternate pipe if any
                    if HW_alt_pipe_dic != None:
                        HW_alt_pipe_layer_dic = self.HW_ODF_get_linked_objects_by_type(HW_alt_pipe_dic, 'Pipe_SoundEngine01_Layer', TO_CHILD)[pipes_layer_nb]
                        HW_alt_pipe_layer_dic['_GO_uid'] = GO_rank_uid
                    else:
                        HW_alt_pipe_layer_dic = None

                    # get the pipe gain if any
                    pipe_gain = myfloat(self.HW_ODF_get_attribute_value(HW_pipe_layer_dic, 'AmpLvl_LevelAdjustDecibels'), 0)
                    if pipe_gain > 0:
                        GO_rank_dic[pipe_id + 'Gain'] = pipe_gain

                    # get the pipe harmonic number if any
                    pipe_harmonic_nb = myint(self.HW_ODF_get_attribute_value(HW_pipe_dic, 'Pitch_Tempered_RankBasePitch64ftHarmonicNum'), 0)
                    if pipe_harmonic_nb not in (0, 8):  # 8 is the default value in GO ODF
                        GO_rank_dic[pipe_id + 'HarmonicNumber'] = pipe_harmonic_nb

                    # recover the pitch in Hertz of the current pipe if defined
                    HW_pipe_pitch_hz = myfloat(self.HW_ODF_get_attribute_value(HW_pipe_dic, 'Pitch_OriginalOrgan_PitchHz'))
                    if HW_pipe_pitch_hz == 0: HW_pipe_pitch_hz = None

                    # get the list of the Pipe_SoundEngine01_AttackSample child objects of the current Pipe_SoundEngine01_Layer object
                    HW_pipe_attack_samples_list = self.HW_ODF_get_linked_objects_by_type(HW_pipe_layer_dic, 'Pipe_SoundEngine01_AttackSample', TO_CHILD)
                    attacks_count = len(HW_pipe_attack_samples_list)

                    if HW_alt_pipe_layer_dic != None and attacks_count > 0:
                        # ignore the alternate pipe attacks if there is no attack defined for the normal pipe
                        # get the list of the alternate Pipe_SoundEngine01_AttackSample child objects of the current alternate Pipe_SoundEngine01_Layer object
                        HW_alt_pipe_attack_samples_list = self.HW_ODF_get_linked_objects_by_type(HW_alt_pipe_layer_dic, 'Pipe_SoundEngine01_AttackSample', TO_CHILD)
                    else:
                        HW_alt_pipe_attack_samples_list = []
                    alt_pipes_to_build = (len(HW_alt_pipe_attack_samples_list) > 0)
                    # add the alternate pipe attacks number to the total attacks number
                    attacks_count += len(HW_alt_pipe_attack_samples_list)

                    # apply if necessary a pitch tuning correction to the current pipe sample
                    if attacks_count > 0 and HW_pipe_pitch_hz != None:
                        # there is a pitch value defined for the current pipe and and it has linked samples
                        # get the pitch defined for the first attack sample if any
                        HW_pipe_attack_sample_dic = HW_pipe_attack_samples_list[0]
                        HW_sample_dic = self.HW_ODF_get_linked_objects_by_type(HW_pipe_attack_sample_dic, 'Sample', TO_CHILD, FIRST_ONE)
                        HW_sample_pitch_hz = myfloat(self.HW_ODF_get_attribute_value(HW_sample_dic, 'Pitch_ExactSamplePitch'))
                        if HW_sample_pitch_hz != None and HW_sample_pitch_hz != HW_pipe_pitch_hz:
                            # the sample has a pitch defined and it has not the same frequency as the pipe one, need to apply a pitch tuning value to the pipe
                            GO_rank_dic[pipe_id + 'PitchTuning'] = delta_freq_to_cent(HW_pipe_pitch_hz, HW_sample_pitch_hz)

                    # build the attack samples attributes of the normal pipe
                    attack_nb = 0
                    pipe_loop_cross_fade_length = None
                    for HW_pipe_attack_sample_dic in HW_pipe_attack_samples_list:
                        # scan the HW Pipe_SoundEngine01_AttackSample child objects of the Pipe_SoundEngine01_Layer object

                        if pipe_loop_cross_fade_length == None:
                            # write the loop cross fade length a single time for the current pipe
                            pipe_loop_cross_fade_length = myint(self.HW_ODF_get_attribute_value(HW_pipe_attack_sample_dic, 'LoopCrossfadeLengthInSrcSampleMs'))
                            if pipe_loop_cross_fade_length not in (None, 0):
                                pipe_loop_cross_fade_length = min(pipe_loop_cross_fade_length, 3000)
                                GO_rank_dic[pipe_id + 'LoopCrossfadeLength'] = pipe_loop_cross_fade_length

                        # get the dictionary of the first Sample child object of the current Pipe_SoundEngine01_AttackSample object
                        HW_sample_dic = self.HW_ODF_get_linked_objects_by_type(HW_pipe_attack_sample_dic, 'Sample', TO_CHILD, FIRST_ONE)
                        if HW_sample_dic != None:
                            # recover the file name of the current sample
                            HW_install_package_id = myint(self.HW_ODF_get_attribute_value(HW_sample_dic, 'InstallationPackageID', MANDATORY))
                            sample_file_name = self.convert_HW2GO_file_name(self.HW_ODF_get_attribute_value(HW_sample_dic, 'SampleFilename', MANDATORY), HW_install_package_id)
                            if sample_file_name != None:
                                attack_nb += 1
                                if attack_nb == 2:
                                    # if there are more than one attack sample, set the additional attacks count attribute before the second attack sample
                                    GO_rank_dic[pipe_id + 'AttackCount'] = attacks_count - 1
                                if attack_nb == 1:
                                    pipe_atk_id = pipe_id
                                else:
                                    pipe_atk_id = pipe_id + 'Attack' + str(attack_nb - 1).zfill(3)
                                GO_rank_dic[pipe_atk_id] = sample_file_name
                                GO_rank_dic[pipe_atk_id + 'LoadRelease'] = 'N'
                                if alt_pipes_to_build:
                                    GO_rank_dic[pipe_atk_id + 'IsTremulant'] = 0

                    # add the attack samples attributes of the alternate pipe if any (there is necessarily at least one normal attack sample defined before)
                    for HW_pipe_attack_sample_dic in HW_alt_pipe_attack_samples_list:
                        # scan the HW Pipe_SoundEngine01_AttackSample child objects of the alternate Pipe_SoundEngine01_Layer object

                        # get the dictionary of the first alternate Sample child object of the current Pipe_SoundEngine01_AttackSample object
                        HW_sample_dic = self.HW_ODF_get_linked_objects_by_type(HW_pipe_attack_sample_dic, 'Sample', TO_CHILD, FIRST_ONE)
                        if HW_sample_dic != None:
                            attack_nb += 1
                            # recover the file name of the current alternate sample
                            HW_install_package_id = myint(self.HW_ODF_get_attribute_value(HW_sample_dic, 'InstallationPackageID', MANDATORY))
                            sample_file_name = self.convert_HW2GO_file_name(self.HW_ODF_get_attribute_value(HW_sample_dic, 'SampleFilename', MANDATORY), HW_install_package_id)
                            if sample_file_name != None:
                                if attack_nb == 2:
                                    # if there are more than one attack sample, set the additional attacks count attribute before the second attack sample
                                    GO_rank_dic[pipe_id + 'AttackCount'] = attacks_count - 1
                                pipe_atk_id = pipe_id + 'Attack' + str(attack_nb - 1).zfill(3)
                                GO_rank_dic[pipe_atk_id] = sample_file_name
                                GO_rank_dic[pipe_atk_id + 'LoadRelease'] = 'N'
                                GO_rank_dic[pipe_atk_id + 'IsTremulant'] = 1


                    # build the release samples attributes

                    # get the list of the Pipe_SoundEngine01_ReleaseSample child objects of the current Pipe_SoundEngine01_Layer object
                    HW_pipe_release_samples_list = self.HW_ODF_get_linked_objects_by_type(HW_pipe_layer_dic, 'Pipe_SoundEngine01_ReleaseSample', TO_CHILD)
                    releases_count = len(HW_pipe_release_samples_list)

                    if HW_alt_pipe_layer_dic != None and releases_count > 0:
                        # ignore the alternate pipe releases if there is no release defined for the normal pipe
                        # get the list of the alternate Pipe_SoundEngine01_ReleaseSample child objects of the current alternate Pipe_SoundEngine01_Layer object
                        HW_alt_pipe_release_samples_list = self.HW_ODF_get_linked_objects_by_type(HW_alt_pipe_layer_dic, 'Pipe_SoundEngine01_ReleaseSample', TO_CHILD)
                    else:
                        HW_alt_pipe_release_samples_list = []
                    alt_pipes_to_build = (len(HW_alt_pipe_release_samples_list) > 0)
                    # add the alternate pipe releases number to the total releases number
                    releases_count += len(HW_alt_pipe_release_samples_list)

                    if releases_count > 0:
                        # there are release samples
                        release_nb = 0
                        pipe_release_cross_fade_length = None

                        GO_rank_dic[pipe_id + 'ReleaseCount'] = releases_count

                        # build the release samples attributes of the normal pipe
                        for HW_pipe_release_sample_dic in HW_pipe_release_samples_list:
                            # scan the HW Pipe_SoundEngine01_ReleaseSample child objects of the Pipe_SoundEngine01_Layer object

                            if pipe_release_cross_fade_length == None:
                                # write the release cross fade length a single time for the current pipe
                                pipe_release_cross_fade_length = myint(self.HW_ODF_get_attribute_value(HW_pipe_release_sample_dic, 'ReleaseCrossfadeLengthMs'))
                                if pipe_release_cross_fade_length not in (None, 0):
                                    pipe_release_cross_fade_length = min(pipe_release_cross_fade_length, 3000)
                                    GO_rank_dic[pipe_id + 'ReleaseCrossfadeLength'] = pipe_release_cross_fade_length

                            # get the dictionary of the first Sample child object of the current Pipe_SoundEngine01_ReleaseSample object
                            HW_sample_dic = self.HW_ODF_get_linked_objects_by_type(HW_pipe_release_sample_dic, 'Sample', TO_CHILD, FIRST_ONE)
                            if HW_sample_dic != None:
                                # recover the file name of the current sample
                                HW_install_package_id = myint(self.HW_ODF_get_attribute_value(HW_sample_dic, 'InstallationPackageID', MANDATORY))
                                sample_file_name = self.convert_HW2GO_file_name(self.HW_ODF_get_attribute_value(HW_sample_dic, 'SampleFilename', MANDATORY), HW_install_package_id)
                                if sample_file_name != None:
                                    release_nb += 1
                                    pipe_rel_id = pipe_id + 'Release' + str(release_nb).zfill(3)
                                    GO_rank_dic[pipe_rel_id] = sample_file_name
                                    if alt_pipes_to_build:
                                        GO_rank_dic[pipe_rel_id + 'IsTremulant'] = 0

                                    # get the max key release time for the current release sample (-1 by default)
                                    HW_max_key_release_time_int = myint(self.HW_ODF_get_attribute_value(HW_pipe_release_sample_dic, 'ReleaseSelCriteria_LatestKeyReleaseTimeMs'), -1)
                                    if HW_max_key_release_time_int not in (-1, 99999):
                                        # not the default or infinite time which does not need to be indicated in the rank
                                        GO_rank_dic[pipe_rel_id + 'MaxKeyPressTime'] = HW_max_key_release_time_int

                        # add the release samples attributes of the alternate pipe if any (there is necessarily at least one normal release sample defined before)
                        for HW_pipe_release_sample_dic in HW_alt_pipe_release_samples_list:
                            # scan the HW Pipe_SoundEngine01_ReleaseSample child objects of the alternate Pipe_SoundEngine01_Layer object

                            # get the dictionary of the first Sample child object of the current Pipe_SoundEngine01_ReleaseSample object
                            HW_sample_dic = self.HW_ODF_get_linked_objects_by_type(HW_pipe_release_sample_dic, 'Sample', TO_CHILD, FIRST_ONE)
                            if HW_sample_dic != None:
                                # recover the file name of the current sample
                                HW_install_package_id = myint(self.HW_ODF_get_attribute_value(HW_sample_dic, 'InstallationPackageID', MANDATORY))
                                sample_file_name = self.convert_HW2GO_file_name(self.HW_ODF_get_attribute_value(HW_sample_dic, 'SampleFilename', MANDATORY), HW_install_package_id)
                                if sample_file_name != None:
                                    release_nb += 1
                                    pipe_rel_id = pipe_id + 'Release' + str(release_nb).zfill(3)
                                    GO_rank_dic[pipe_rel_id] = sample_file_name
                                    GO_rank_dic[pipe_rel_id + 'IsTremulant'] = 1

                                    # get the max key release time for the current release sample (-1 by default)
                                    HW_max_key_release_time_int = myint(self.HW_ODF_get_attribute_value(HW_pipe_release_sample_dic, 'ReleaseSelCriteria_LatestKeyReleaseTimeMs'), -1)
                                    if HW_max_key_release_time_int not in (-1, 99999):
                                        # not the default or infinite time which does not need to be indicated in the rank
                                        GO_rank_dic[pipe_rel_id + 'MaxKeyPressTime'] = HW_max_key_release_time_int

                else:
                    # there is no HW Pipe_SoundEngine01 object defined for the current MIDI note
                    # add a dummy pipe
                    GO_rank_dic[pipe_id] = 'DUMMY'

            # add in the HW Rank object the ID of the corresponding GO object
            HW_rank_dic['_GO_uid'] = GO_rank_uid
            if HW_alt_rank_dic != None:
                HW_alt_rank_dic['_GO_uid'] = GO_rank_uid

        return GO_rank_uid

    #-------------------------------------------------------------------------------------------------
    def GO_ODF_build_WindchestGroup_object(self, HW_wind_comp_dic, HW_cont_ctrl_dic, HW_enclosure_dic):
        # build the GO WindchestGroup and linked Enclosure objects corresponding to the given HW WindCompartment + ContinuousControl + Enclosure (two last parameters can be at None)
        # a GO WindchestGroup corresponds to a HW WindCompartment + HW ContinuousControl (if not None) + HW Enclosure (if not None)
        # return the UID of the GO WindchestGroup built or already existing

        # used HW objects :
        #   WindCompartment

        if LOG_HW2GO_windchest:
            msg = f"GO WindchestGroup to build from HW {HW_wind_comp_dic['_HW_uid']}"
            if HW_cont_ctrl_dic != None:
                msg += f" + HW {HW_cont_ctrl_dic['_HW_uid']}"
            if HW_enclosure_dic != None:
                msg += f"  + HW {HW_enclosure_dic['_HW_uid']}"
            print(msg)

        if HW_cont_ctrl_dic != None:
            # build a new GO Enclosure or reuse an existing one for the given HW continuous control
            GO_enclosure_cc_uid = self.GO_ODF_build_Enclosure_object(HW_cont_ctrl_dic)
        else:
            GO_enclosure_cc_uid = ''

        if HW_enclosure_dic != None:
            # build a new GO Enclosure or reuse an existing one for the given HW enclosure
            GO_enclosure_enc_uid = self.GO_ODF_build_Enclosure_object(HW_enclosure_dic)
        else:
            GO_enclosure_enc_uid = ''

        # search if there is already a GO WindchestGroup matching with the given HW WindCompartment + Continuouscontrol + Enclosure together
        for GO_object_uid, GO_object_dic in self.GO_odf_dic.items():
            # scan the defined GO objects
            if GO_object_uid[0] == 'W':
                # it is a WindchestGroup object
                if (GO_object_dic['_HW_uid'] == HW_wind_comp_dic['_HW_uid'] and
                    GO_object_dic['_GO_cc_uid'] == GO_enclosure_cc_uid and
                    GO_object_dic['_GO_enc_uid'] == GO_enclosure_enc_uid):
                    # the current GO WindchesGroup matches with the given parameters : no need to create a new GO WindchestGroup
                    if LOG_HW2GO_windchest: print(f"     GO {GO_object_uid} already matches with this need")
                    return GO_object_uid

        # there is no matching GO WindchestGroup, create a new one
        self.GO_odf_dic['Organ']['NumberOfWindchestGroups'] += 1
        GO_windchest_uid = 'WindchestGroup' + str(self.GO_odf_dic['Organ']['NumberOfWindchestGroups']).zfill(3)
        GO_windchest_dic = self.GO_odf_dic[GO_windchest_uid] = {}
        GO_windchest_dic['_GO_uid'] = GO_windchest_uid
        GO_windchest_dic['_GO_cc_uid'] = ''
        GO_windchest_dic['_GO_enc_uid'] = ''
        GO_windchest_dic['Name'] = self.HW_ODF_get_attribute_value(HW_wind_comp_dic, 'Name')
        GO_windchest_dic['NumberOfEnclosures'] = 0

        # add in the HW WindCompartment the UID of the corresponding GO object (several GO WindchestGroup can be linked to the same HW WindCompartment)
        if '_GO_uid_list' not in HW_wind_comp_dic.keys(): HW_wind_comp_dic['_GO_uid_list'] = []
        HW_wind_comp_dic['_GO_uid_list'].append(GO_windchest_uid)
        # add in the GO WindchestGroup the UID of the corresponding HW WindCompartment
        GO_windchest_dic['_HW_uid'] =  HW_wind_comp_dic['_HW_uid']

        # add in the GO WindchestGroup the reference to the GO Enclosure for the HW continuous control if any
        if GO_enclosure_cc_uid != '':
            GO_windchest_dic['_GO_cc_uid'] = GO_enclosure_cc_uid
            GO_windchest_dic['NumberOfEnclosures'] += 1
            GO_windchest_dic['Enclosure' + str(GO_windchest_dic['NumberOfEnclosures']).zfill(3)] = GO_enclosure_cc_uid[-3:]
            GO_windchest_dic['Name'] += '+' + self.GO_odf_dic[GO_enclosure_cc_uid]['Name']

        # add in the GO WindchestGroup the reference to the GO Enclosure for the HW enclosure if any
        if GO_enclosure_enc_uid != '':
            GO_windchest_dic['_GO_enc_uid'] = GO_enclosure_enc_uid
            GO_windchest_dic['NumberOfEnclosures'] += 1
            GO_windchest_dic['Enclosure' + str(GO_windchest_dic['NumberOfEnclosures']).zfill(3)] = GO_enclosure_enc_uid[-3:]
            GO_windchest_dic['Name'] += '+' + self.GO_odf_dic[GO_enclosure_enc_uid]['Name']

        GO_windchest_dic['NumberOfTremulants'] = 0  # will be managed later

        if LOG_HW2GO_windchest: print(f"     GO {GO_windchest_uid} created with {GO_windchest_dic['NumberOfEnclosures']} enclosures")

        return GO_windchest_uid

    #-------------------------------------------------------------------------------------------------
    def GO_ODF_build_Enclosure_object(self, HW_object_dic):
        # build a GO Enclosure object corresponding to the given HW object (ContinuousControl or Enclosure)
        # build GO Panel999Element999 object(s) with type=Enclosure corresponding to the HW ContinuousControls which control the given object
        # return the UID of the built GO enclosure

        # used HW objects :
        #   Enclosure P> ContinuousControl C> ImageSetInstance C> ImageSet C> ImageSetElement
        #                                                                  C> ContinuousControlImageSetStage

        HW_object_type = HW_object_dic['_HW_uid'][:-6]
        if HW_object_type == 'ContinuousControl':
            HW_cont_ctrl_dic = HW_object_dic
        elif HW_object_type == 'Enclosure':
            HW_cont_ctrl_dic = self.HW_ODF_get_linked_objects_by_type(HW_object_dic, 'ContinuousControl', TO_PARENT, FIRST_ONE)
        else:
            return ''

        # recover the HW ContinuousControls which has a graphical interface and are controlling the given HW ContinuousControl (this one included possibly)
        cont_ctrl_dic_list = []
        self.HW_ODF_get_controlling_continuous_controls(HW_cont_ctrl_dic, cont_ctrl_dic_list)
        if len(cont_ctrl_dic_list) == 0:
            # there is none graphical control for the given object, nothing to do
            if LOG_HW2GO_windchest: print(f"     HW {HW_object_dic['_HW_uid']} is controlled by none visible object")
            return ''

        GO_enclosure_uid = ''
        for HW_cc_dic in cont_ctrl_dic_list:
            # scan the controlling ContinuousControls to check if one is already associated to a GO Enclosure
            if HW_cc_dic['_GO_uid'] != '':
                GO_enclosure_uid = HW_cc_dic['_GO_uid']
                break

        if GO_enclosure_uid != '':
            # one GO Enclosure is already created to control the given HW object, set its UID to all the HW ContinuousControls then return it
            for HW_cc_dic in cont_ctrl_dic_list:
                HW_cc_dic['_GO_uid'] = GO_enclosure_uid
            HW_object_dic['_GO_uid'] = GO_enclosure_uid
            HW_cont_ctrl_dic['_GO_uid'] = GO_enclosure_uid
            if LOG_HW2GO_windchest: print(f"     GO {GO_enclosure_uid} already associated with HW {HW_object_dic['_HW_uid']}")
            return GO_enclosure_uid

        # create a GO Enclosure
        self.GO_odf_dic['Organ']['NumberOfEnclosures'] += 1
        GO_enclosure_uid = 'Enclosure' + str(self.GO_odf_dic['Organ']['NumberOfEnclosures']).zfill(3)
        GO_enclosure_dic = self.GO_odf_dic[GO_enclosure_uid] = {}

        if HW_object_type == 'Enclosure':
            GO_enclosure_dic['Name'] = self.HW_ODF_get_attribute_value(HW_object_dic, 'Name')
        else:
            GO_enclosure_dic['Name'] = self.HW_ODF_get_attribute_value(cont_ctrl_dic_list[0], 'Name')

        GO_enclosure_dic['AmpMinimumLevel'] = 1  # if set at 0, when the enclosure is set at its minimum, there is no sound when the enclosure position is increased

        # create the panel elements controlling the GO enclosure
        for HW_cc_dic in cont_ctrl_dic_list:
            # scan the HW continuous controls which are controlling the given object and have a graphical interface

            # get the HW ImageSetInstance object associated to the given HW ContinuousControl
            HW_img_set_inst_dic = self.HW_ODF_get_object_by_ref_id('ImageSetInstance', HW_cc_dic, 'ImageSetInstanceID')
            HW_display_page_id = myint(self.HW_ODF_get_attribute_value(HW_img_set_inst_dic, 'DisplayPageID', MANDATORY))
            HW_display_page_dic = self.HW_ODF_get_object_dic('DisplayPage', HW_display_page_id)

            # create a GO Panel999Element999 enclosure object to control the GO enclosure
            GO_panel_uid = HW_display_page_dic['_GO_uid']
            self.GO_odf_dic[GO_panel_uid]['NumberOfGUIElements'] += 1
            GO_panel_element_uid = GO_panel_uid + 'Element' + str(self.GO_odf_dic[GO_panel_uid]['NumberOfGUIElements']).zfill(3)
            GO_panel_element_dic = self.GO_odf_dic[GO_panel_element_uid] = {}

            GO_panel_element_dic['Type'] = 'Enclosure'
            GO_panel_element_dic['Enclosure'] = str(int(GO_enclosure_uid[-3:])).zfill(3)

            # get the image attributes of the first image index to set the attributes of the GO enclosure
            image_attr_dic = {}
            self.HW_ODF_get_image_attributes(HW_img_set_inst_dic, image_attr_dic, 1)

            GO_panel_element_dic['PositionX'] = image_attr_dic['LeftXPosPixels']
            GO_panel_element_dic['PositionY'] = image_attr_dic['TopYPosPixels']

            if image_attr_dic['ImageWidthPixels'] != None:
                GO_panel_element_dic['Width'] = image_attr_dic['ImageWidthPixels']
            else:
                GO_panel_element_dic['Width'] = 0   # will be set later from the first bitmap dimensions

            if image_attr_dic['ImageHeightPixels'] != None:
                GO_panel_element_dic['Height'] = image_attr_dic['ImageHeightPixels']
            else:
                GO_panel_element_dic['Height'] = 0  # will be set later from the first bitmap dimensions

            # let the mouse clickable area at the default location (i.e. the image dimensions)

            # get the number of bitmaps of the HW ContinuousControl
            HW_img_set_dic = self.HW_ODF_get_object_by_ref_id('ImageSet', HW_img_set_inst_dic, 'ImageSetID')
            HW_img_elems_list = self.HW_ODF_get_linked_objects_by_type(HW_img_set_dic, 'ImageSetElement', TO_CHILD)
            bitmap_count = len(HW_img_elems_list)
            if bitmap_count > 128: bitmap_count = 128  # GO supports up to 128 bitmaps
            GO_panel_element_dic['BitmapCount'] = bitmap_count

            # add the enclosure bitmaps
            for i in range(1, bitmap_count + 1):
                # scan the set of images of the enclosure
                image_attr_dic = {}
                self.HW_ODF_get_image_attributes(HW_img_set_inst_dic, image_attr_dic, i)
                if image_attr_dic['BitmapFilename'] != None:
                    GO_panel_element_dic['Bitmap' + str(i).zfill(3)] = image_attr_dic['BitmapFilename']

                    if GO_panel_element_dic['Width'] == 0 or GO_panel_element_dic['Height'] == 0:
                        # get the dimentions of the current image
                        img_w = img_h = 0
                        if (image_attr_dic['ImageWidthPixels'] == None or image_attr_dic['ImageHeightPixels'] == None) and image_attr_dic['BitmapFilename'] != None:
                            image_path = self.HW_sample_set_odf_path + os.sep + path2ospath(image_attr_dic['BitmapFilename'])
                            if os.path.isfile(image_path):
                                im = Image.open(image_path)
                                img_w = im.size[0]
                                img_h = im.size[1]
                        GO_panel_element_dic['Width'] = img_w
                        GO_panel_element_dic['Height'] = img_h

                if image_attr_dic['TransparencyMaskBitmapFilename'] != None:
                    GO_panel_element_dic['Mask' + str(i).zfill(3)] = image_attr_dic['TransparencyMaskBitmapFilename']

            # attribute set to have no text displayed
            GO_panel_element_dic['TextBreakWidth'] = 0

            HW_cc_dic['_GO_uid'] = GO_enclosure_uid

        if LOG_HW2GO_windchest: print(f"     GO {GO_enclosure_uid} created for HW {HW_object_dic['_HW_uid']}")
        return GO_enclosure_uid

    #-------------------------------------------------------------------------------------------------
    def GO_ODF_child_add(self, parent_uid, child_uid):
        # store in the given GO parent object a reference to the given GO child object

        parent_dic = self.GO_odf_dic[parent_uid]

        if not '_children_list' in parent_dic.keys():
            parent_dic['_children_list'] = []

        if not child_uid in parent_dic['_children_list']:
            parent_dic['_children_list'].append(child_uid)

    #-------------------------------------------------------------------------------------------------
    def GO_ODF_child_type_nb_get(self, parent_uid, child_type):
        # return the number of child objects of the given type stored in the given parent object by GO_ODF_child_add

        parent_dic = self.GO_odf_dic[parent_uid]

        child_type_nb = 0
        if '_children_list' in parent_dic.keys():
            for child_uid in parent_dic['_children_list']:
                if child_uid[:-3] == child_type:
                    child_type_nb += 1

        return child_type_nb

    #-------------------------------------------------------------------------------------------------
    def GO_ODF_apply_children_ref(self, parent_uid):
        # write in the givent GO parent object the reference attributes to GO child objects previously stored in it by GO_ODF_child_add

        parent_dic = self.GO_odf_dic[parent_uid]
        if '_children_list' in parent_dic.keys():
            for child_uid in sorted(parent_dic['_children_list']):
                child_type = child_uid[:-3]
                child_id = child_uid[-3:]

                if child_type == 'Switch':
                    nb_of_attr = 'NumberOfSwitches'
                else:
                    nb_of_attr = 'NumberOf' + child_type + 's'

                if nb_of_attr not in parent_dic.keys():
                    parent_dic[nb_of_attr] = 0
                parent_dic[nb_of_attr] += 1
                parent_dic[child_type + str(parent_dic[nb_of_attr]).zfill(3)] = child_id

    #-------------------------------------------------------------------------------------------------
    def convert_HW2GO_file_name(self, HW_file_name, HW_install_package_id):
        # return the given file path/name (for images or sounds or info files) converted from HW to GO format with path relative to ODF folder
        # in HW format the files path starts from the root package folder (named with 6 digits) and the folders separator is either / or \
        # in GO format the files path starts from the ODF location (in the HW folder OrganDefinitions) and the folders separator is \ (it can be / as well)

        os_file_name_str = path2ospath(HW_file_name)

        if os_file_name_str[0] == os.sep:
            # the HW file name must not start by a path separator (seen on some sample sets)
            os_file_name_str = os_file_name_str[1:]

        os_file_name_str = os.path.join(self.HW_sample_set_path, 'OrganInstallationPackages', str(HW_install_package_id).zfill(6), os_file_name_str)
        actual_file_name_str = get_actual_file_name(os_file_name_str)

        # return the GO file path/name relative to the folder where is located the ODF and with the \ folders separator
        if actual_file_name_str != None:
            return '..' + actual_file_name_str[len(self.HW_sample_set_path):].replace(os.sep,'\\')
        else:
            # file not found in the sample set files
            if DEV_MODE:
                # return the given file name which comes from the HW ODF
                # permits to test HW ODF conversion without having all the files of the sample set on the computer
                return '..' + os_file_name_str[len(self.HW_sample_set_path):].replace(os.sep,'\\')
            else:
                if HW_install_package_id in self.available_HW_packages_id_list:
                    # don't show warning for file missing in the packages which are not of the sample set (i.e. standard packages of Hauptwerk)
                    logs.add(f'WARNING : file not found in the sample set : {os_file_name_str}')
                return None

    #-------------------------------------------------------------------------------------------------
    def HW_DIC2UID(self, HW_DIC):
        # for logging purpose, return the same type as the given data with all the present HW object dictionary converted sto HW object UID string

        if isinstance(HW_DIC, dict):
            if '_HW_uid' in HW_DIC.keys():
                # it is the dictionary of a HW object
                return HW_DIC['_HW_uid']
            else:
                # it is another kind of dictionary content, scan the values of each key
                uid_dic = {}
                for key, value in HW_DIC.items():
                    uid_dic[key] = self.HW_DIC2UID(value)
                return uid_dic

        elif isinstance(HW_DIC, list):
            uid_list = []
            for hw_dic in HW_DIC:
                uid_list.append(self.HW_DIC2UID(hw_dic))
            return uid_list

        elif isinstance(HW_DIC, str):
            return HW_DIC

#-------------------------------------------------------------------------------------------------
class C_GUI_NOTEBOOK():
    # class to manage the graphical user interface of the application for the notebook area


    # variables used for the file viewer tab
    viewer_file_name = None
    viewer_curr_image = None
    viewer_orig_image = None
    viewer_zoom_factor = 1
    viewer_audio_player = None

    #-----------------------------------------------------------------------------------------------
    def wnd_notebook_build(self, wnd_parent):
        # build the notebook and its internal GUI widgets inside the given parent widget

        # notebook to display the events logs or the help
        self.notebook = ttk.Notebook(wnd_parent)
        self.notebook.pack(side='top', fill='both', expand=1)

        # text box to display the application logs in the notebook, with horizontal/vertical scroll bars
        # a frame is used to encapsulate the text box and scroll bars
        self.frm_logs = Frame(self.notebook)
        self.frm_logs.pack(fill='both', expand=1)
        scrollbarv = ttk.Scrollbar(self.frm_logs, orient='vertical')
        scrollbarh = ttk.Scrollbar(self.frm_logs, orient='horizontal')
        scrollbarv.pack(side='right', fill=Y)
        scrollbarh.pack(side='bottom', fill=X)
        self.txt_events_log = Text(self.frm_logs, fg="black", bg='ivory2', bd=3, wrap="none", font='Calibri 11', selectbackground="grey")
        self.txt_events_log.pack(side=LEFT, fill='both', expand=1)
        self.txt_events_log.bind('<Control-Key-a>', self.logs_select_all)
        self.txt_events_log.bind('<Control-Key-A>', self.logs_select_all)
        self.txt_events_log.config(xscrollcommand=scrollbarh.set, yscrollcommand=scrollbarv.set)
        scrollbarv.config(command=self.txt_events_log.yview)
        scrollbarh.config(command=self.txt_events_log.xview)

        # text box to display the help in the notebook, with vertical scroll bar and search widgets
        # a main frame is used to encapsulate two other frames, one for the search widgets, one for the text box and his scroll bar
        self.frm_help = Frame(self.notebook)
        self.frm_help.pack(fill='both', expand=1)
        # widgets to search a text
        self.frm_help_top = Frame(self.frm_help)
        self.frm_help_top.pack(side='top', fill='x')
        self.lab_search = Label(self.frm_help_top, text="Search :", fg="black", borderwidth=0, relief="solid", anchor=E)
        self.lab_search.pack(side='left', padx=5, pady=5, fill='x')
        self.cmb_search_text = ttk.Combobox(self.frm_help_top, height=24, width=20, values=['[Organ]', '[Button]', '[Coupler999]', '[Divisional999]', '[DivisionalCoupler999]', '[DrawStop]', '[Enclosure999]', '[General999]', '[Image999]', '[Label999]', '[Manual999]', '[Panel999]', '[Panel999Element999]', '[Panel999Image999]', '[Panel999xxxxx999]', '[Piston]', '[PushButton]', '[Rank999]', '[ReversiblePiston999]', '[SetterElement999]', '[Stop999]', '[Switch999]', '[Tremulant999]', '[WindchestGroup999]'])
        self.cmb_search_text.pack(side='left', padx=5, pady=5, fill='x')
        self.cmb_search_text.bind('<KeyRelease>', self.help_search_text_key_pressed)
        self.cmb_search_text.bind('<<ComboboxSelected>>', self.help_search_text_key_pressed)
        self.btn_search_prev = Button(self.frm_help_top, text="<", fg="black", width=5, state=NORMAL, command=self.help_search_previous)
        self.btn_search_prev.pack(side='left', padx=5, pady=5, fill='x')
        self.btn_search_next = Button(self.frm_help_top, text=">", fg="black", width=5, state=NORMAL, command=self.help_search_next)
        self.btn_search_next.pack(side='left', padx=5, pady=5, fill='x')
        self.btn_search_clear = Button(self.frm_help_top, text="Clear", fg="black", width=10, state=NORMAL, command=self.help_search_clear)
        self.btn_search_clear.pack(side='left', padx=5, pady=5, fill='x')
        self.lab_search_occur_nb = Label(self.frm_help_top, text="", fg="black", borderwidth=0, relief="solid", anchor=W)
        self.lab_search_occur_nb.pack(side='left', padx=5, pady=5, fill='x')
        # help text box
        self.frm_help_bottom = Frame(self.frm_help)
        self.frm_help_bottom.pack(side = 'bottom', fill='both', expand=1)
        scrollbarv = ttk.Scrollbar(self.frm_help_bottom, orient='vertical')
        scrollbarv.pack(side='right', fill=Y)
        self.txt_help = Text(self.frm_help_bottom, fg="black", bg='azure', bd=3, wrap="word", font='Calibri 11', selectbackground="grey")
        self.txt_help.pack(side='bottom', fill='both', expand=1)
        self.txt_help.config(yscrollcommand=scrollbarv.set)
        scrollbarv.config(command=self.txt_help.yview)
        # define the tags for the syntax highlighting
        self.txt_help.tag_config(TAG_FIELD, foreground='red3')
        self.txt_help.tag_config(TAG_COMMENT, foreground='chartreuse4')
        self.txt_help.tag_config(TAG_OBJ_UID, foreground='blue2', font='Calibri 11 bold')
        self.txt_help.tag_config(TAG_TITLE, foreground='red3', font='Calibri 11 bold')

        # list to search in the GO or HW ODF and display the search results, with vertical scroll bar
        # a main frame is used to encapsulate two other frames, one for the search widgets, one for the list box and his vertical scroll bar
        self.frm_search = Frame(self.notebook)
        self.frm_search.pack(fill='both', expand=1)
        # widgets to search a text
        self.frm_search_top = Frame(self.frm_search)
        self.frm_search_top.pack(side='top', fill='x')

        self.ent_odf_search_text = Entry(self.frm_search_top, width=35, fg="grey")
        self.ent_odf_search_text.pack(side='left', padx=2, pady=0, fill='x')
        self.ent_odf_search_text.insert(0, 'text to search')
        self.ent_odf_search_text.bind('<Return>', self.odf_search_text)
        self.ent_odf_search_text.bind('<Button-1>', self.odf_search_text_selected)
        self.ent_odf_search_text.bind('<KeyPress>', self.odf_search_text_selected)

        self.btn_odf_search = Button(self.frm_search_top, text="Search", fg="black", width=7, state=NORMAL, command=self.odf_search_text)
        self.btn_odf_search.pack(side='left', padx=2, pady=0, fill='x')
        self.btn_odf_search_hw = Button(self.frm_search_top, text="HW search", fg="black", state=NORMAL, command=self.odf_search_text_hw)
        self.btn_odf_search_hw.pack(side='left', padx=2, pady=0, fill='x')

        self.odf_search_regex = BooleanVar(self.wnd_main)
        self.btn_odf_search_regex = Checkbutton(self.frm_search_top, text = "Regular expression", variable=self.odf_search_regex)
        self.btn_odf_search_regex.pack(side='left', padx=0, pady=0, fill='x')

        self.frm_search_top2 = Frame(self.frm_search)
        self.frm_search_top2.pack(side='top', fill='x')
        self.ent_odf_replace_text = Entry(self.frm_search_top2, width=35, fg="grey")
        self.ent_odf_replace_text.pack(side='left', padx=2, pady=0, fill='x')
        self.ent_odf_replace_text.insert(0, 'replacement text')
        self.ent_odf_replace_text.bind('<Button-1>', self.odf_replace_text_selected)
        self.ent_odf_replace_text.bind('<KeyPress>', self.odf_replace_text_selected)

        self.btn_odf_replace = Button(self.frm_search_top2, text="Replace", fg="black", width=7, state=NORMAL, command=self.odf_replace_text)
        self.btn_odf_replace.pack(side='left', padx=2, pady=0, fill='x')

        self.odf_search_range = StringVar(self.wnd_main)
        radiobutton = Radiobutton(self.frm_search_top2, text="in whole\nODF", variable=self.odf_search_range, value="odf")
        radiobutton.pack(side='left', padx=0, pady=0, fill='x')
        radiobutton = Radiobutton(self.frm_search_top2, text="in selected\nsection", variable=self.odf_search_range, value="selected")
        radiobutton.pack(side='left', padx=0, pady=0, fill='x')
        radiobutton = Radiobutton(self.frm_search_top2, text="in children\nof sel. sect.", variable=self.odf_search_range, value="children")
        radiobutton.pack(side='left', padx=0, pady=0, fill='x')
        self.odf_search_range.set('odf')

        # search results list box
        self.frm_search_bottom = Frame(self.frm_search)
        self.frm_search_bottom.pack(side = 'bottom', fill='both', expand=1)
        scrollbarv = ttk.Scrollbar(self.frm_search_bottom, orient='vertical')
        scrollbarv.pack(side=RIGHT, fill=Y)
        self.lst_odf_sresults = Listbox(self.frm_search_bottom, bg='light yellow', font='Calibri 11', fg="black", exportselection=0, selectmode='single', activestyle='none')
        self.lst_odf_sresults.pack(side=LEFT, fill='both', expand=True)
        self.lst_odf_sresults.bind('<ButtonRelease-1>', self.odf_search_text_result_selected)
        self.lst_odf_sresults.config(yscrollcommand=scrollbarv.set)
        scrollbarv.config(command=self.lst_odf_sresults.yview)

        # viewer to show image or play wav file or show panel content
        self.frm_viewer = Frame(self.notebook)
        self.frm_viewer.pack(fill='both', expand=True)
        self.view_canvas = Canvas(self.frm_viewer)
        self.view_canvas.pack(side='top', fill='both', expand=True)
        self.view_canvas.bind('<MouseWheel>', self.viewer_image_update)  # for Windows
        self.view_canvas.bind('<Button-4>', self.viewer_image_update)    # MouseWheel up in Linux
        self.view_canvas.bind('<Button-5>', self.viewer_image_update)    # MouseWheel down in Linux
        self.view_canvas.bind('<ButtonPress-1>', lambda event: self.view_canvas.scan_mark(event.x, event.y))
        self.view_canvas.bind('<B1-Motion>', self.viewer_image_drag)

        # list to navigate inside the Hauptwerk objects in the ODF, with vertical scroll bar
        # a main frame is used to encapsulate two other frames, one for the search widgets, one for the list box and his vertical scroll bar
        self.frm_hw_browser = Frame(self.notebook)
        self.frm_hw_browser.pack(fill='both', expand=True)
        # widgets to search an object UID
        self.frm_hw_browser_top = Frame(self.frm_hw_browser)
        self.frm_hw_browser_top.pack(side='top', fill='x')
        self.ent_hw_uid_search_text = Entry(self.frm_hw_browser_top, width=40)
        self.ent_hw_uid_search_text.pack(side='left', padx=5, pady=5, fill='x')
        self.btn_hw_uid_search = Button(self.frm_hw_browser_top, text="UID search", fg="black", state=NORMAL, command=self.odf_search_uid_hw)
        self.btn_hw_uid_search.pack(side='left', padx=5, pady=5, fill='x')
        # browser list box
        self.frm_hw_browser_bottom = Frame(self.frm_hw_browser)
        self.frm_hw_browser_bottom.pack(side = 'bottom', fill='both', expand=1)
        scrollbarv = ttk.Scrollbar(self.frm_hw_browser_bottom, orient='vertical')
        scrollbarv.pack(side=RIGHT, fill=Y)
        self.lst_hw_browser = Listbox(self.frm_hw_browser_bottom, bg='alice blue', font='Calibri 11', fg="black", selectbackground=COLOR_SELECTED_ITEM, exportselection=0, selectmode='single', activestyle='none')
        self.lst_hw_browser.pack(side=LEFT, fill='both', expand=True)
        self.lst_hw_browser.bind('<ButtonRelease>', self.objects_list_selected_hw)
        self.lst_hw_browser.bind('<Double-1>', self.objects_list_selected_dbl_hw)
        self.lst_hw_browser.config(yscrollcommand=scrollbarv.set)
        scrollbarv.config(command=self.lst_hw_browser.yview)

        # create the notebook tabs, and attach the frames to them
        self.notebook.add(self.frm_logs, text="    Logs    ")
        self.notebook.add(self.frm_help, text="    Help    ")
        self.notebook.add(self.frm_search, text="    Search/replace    ")
        self.notebook.add(self.frm_viewer, text="    Viewer    ")
        self.notebook.add(self.frm_hw_browser, text="    HW objects    ")
        self.notebook.hide(self.frm_hw_browser)  # will be visible only if a Hauptwerk ODF is loaded

        # to initialize the content of the viewer
        self.viewer_file_show(None)

    #-------------------------------------------------------------------------------------------------
    def gui_status_update_notebook(self):
        # update the status of GUI widgets of the search function in the notebook

        # buttons to search previous or next or clear the search in the help
        is_search_text = (self.cmb_search_text.get() != '')
        self.btn_search_prev['state']  = NORMAL if is_search_text else DISABLED
        self.btn_search_next['state']  = NORMAL if is_search_text else DISABLED
        self.btn_search_clear['state'] = NORMAL # if is_search_text else DISABLED

        if self.is_loaded_hw_odf:
            self.btn_odf_search_hw.pack(side='left', padx=5, pady=5, fill='x')
        else:
            self.btn_odf_search_hw.pack_forget()

        # HW objects list
        if self.selected_object_app != 'HW':
            # clear the selected items if it is not a HW object which is selected
            self.lst_hw_browser.selection_clear(0, 'end')

    #-------------------------------------------------------------------------------------------------
    def logs_display(self):
        # add in the logs text box widget the content of the logs buffer then clear it

        logs_list = logs.get()
        if len(logs_list) > 0:
            self.txt_events_log.insert('end', '\n' + '\n'.join(logs_list) + '\n')
            self.txt_events_log.see('end-1c linestart')  # to see the start of the last line of the text
        self.txt_events_log.update()

        # reset the logs buffer
        logs.clear()

    #-------------------------------------------------------------------------------------------------
    def logs_select_all(self, event):
        # (GUI event callback) the user has pressed the Ctrl+a or Ctrl+A keys combinaison in the logs text box to select all the text
        # in Windows it is managed natively by the text box widget, but not in Linux

        self.txt_events_log.tag_add('sel', '1.0', 'end')
        return 'break'  # do not process further the event in the widget

    #-------------------------------------------------------------------------------------------------
    def logs_clear(self):
        # (GUI event callback) the user has selected 'Clear all' in the context menu of the logs text box

        # clear the content of the logs text box
        self.txt_events_log.delete(1.0, "end")

        # reset the logs buffer
        logs.clear()

    #-------------------------------------------------------------------------------------------------
    def help_file_load(self):
        # load in the help text box widget the help file
        # done one time at the application start

        file_name = os.path.dirname(__file__) + os.sep + 'resources' + os.sep + 'Help.txt'

        try:
            with open(file_name, 'r') as f:   # errors='ignore'
                f.seek(0)
                # copy in the widget the help text
                self.txt_help.insert(1.0, f.read())
        except OSError as err:
            # it has not be possible to open the file
            messagebox.showinfo(title="ERROR", message=f'Cannot open the file "{file_name}"\n{err}')
            return False
        except IOError as e:
            messagebox.showinfo(title="ERROR", message=f'I/O error while opening the file "{file_name}"\n{e.errno}: {e.strerror}')
            return False
        except: #handle other exceptions such as attribute errors
            messagebox.showinfo(title="ERROR", message=f'Unexpected error while opening the file "{file_name}"\n{sys.exc_info()[0]}')
            return False

        # apply the ODF syntax highlighting
        self.odf_syntax_highlight(self.txt_help)
        # disable the text box to not permit its editing
        self.txt_help.configure(state='disabled')
        return True

    #-------------------------------------------------------------------------------------------------
    def help_search_next(self):
        # (GUI event callback) the user has clicked on the button '>'
        # show the next occurence of the text to search

        self.help_search_text(self.cmb_search_text.get(), True)

    #-------------------------------------------------------------------------------------------------
    def help_search_previous(self):
        # (GUI event callback) the user has clicked on the button '<'
        # show the previous occurence of the text to search

        self.help_search_text(self.cmb_search_text.get(), False)

    #-------------------------------------------------------------------------------------------------
    def help_search_clear(self):
        # (GUI event callback) the user has clicked on the button 'Clear'
        # clear the text to search (text box and highlighting)

        self.cmb_search_text.delete(0, END)
        self.help_search_text('', False)
        self.lab_search_occur_nb.config(text='')

        # update the status of some GUI widgets
        self.gui_status_update_notebook()

    #-------------------------------------------------------------------------------------------------
    def help_search_object(self):
        # (GUI event callback) the user has clicked on the button "Show in help"
        # search and display in the help the part describing the selected object UID

        if self.edited_object_uid not in (None, 'Header'):
            # substitute the digits by the char 9 in the object UID to create a generic object ID
            gen_object_UID = '['
            for c in self.edited_object_uid: gen_object_UID += '9' if c.isdigit() else c
            gen_object_UID += ']'

            # put the generic object UID in the search text widget
            self.cmb_search_text.delete(0, END)
            self.cmb_search_text.insert(0, gen_object_UID)

            # update the status of GUI widgets
            self.gui_status_update_notebook()

            # search the first occurence of the generic object ID
            self.help_search_next()

            # select the Help tab of the notebook
            self.notebook.select(self.frm_help)

    #-------------------------------------------------------------------------------------------------
    def help_search_text(self, text_to_find, search_next = True):
        # show in the help the next occurence (or previous if search_next=False) of the given text to find
        # highlight in yellow all the occurences of this text

        if text_to_find != '':
            text_len = len(text_to_find)
        else:
            text_to_find = None
            text_len = 0

        if text_to_find != self.text_to_search:
            # a new text has to be searched, highlight all its occurences in the entire help text

            # store the new text to search
            self.text_to_search = text_to_find

            # remove the highlight of the previous searched text occurences
            self.txt_help.tag_remove(TAG_FOUND, '1.0', END)
            self.txt_help.tag_remove(TAG_FOUND2, '1.0', END)
            nb_occurences = 0

            if text_to_find != None:
                # highlight the all occurences of the text to find in the entire help
                # configure the tag for the found text
                self.txt_help.tag_config(TAG_FOUND, foreground='black', background='yellow', font='Calibri 11')
                # get the lines of the text widget
                lines = self.txt_help.get('1.0', END).splitlines()
                # scan all the lines
                for l in range(0, len(lines)):
                    idx = 0
                    while idx != -1:
                        # check the various occurences of the searched text in the current line (if any)
                        idx = lines[l].find(text_to_find, idx)
                        if idx != -1:
                            # highlight the found occurence in the line
                            self.txt_help.tag_add(TAG_FOUND, f'{l+1}.{idx}', f'{l+1}.{idx} + {text_len} chars')
                            # move the search index after the found occurence
                            idx += text_len
                            nb_occurences += 1

                # display the number of occurences of the searched text
                if nb_occurences == 0:
                    self.lab_search_occur_nb.config(text='None occurence')
                elif nb_occurences == 1:
                    self.lab_search_occur_nb.config(text='1 occurence')
                else:
                    self.lab_search_occur_nb.config(text=f'{nb_occurences} occurences')

        if text_to_find != None:
            # search for the next/previous occurence of the text in the help

            # remove the highlight of the previous searched text occurence
            self.txt_help.tag_remove(TAG_FOUND2, '1.0', END)
            # configure the tag for the highlighted found text
            self.txt_help.tag_config(TAG_FOUND2, foreground='black', background='gold2', font='Calibri 11')

            if search_next and self.search_index != None:
                # if search upward, move the current search position after the previous found position
                self.search_index = f'{self.search_index} + {text_len} chars'

            # search for the next/previous occurence
            if self.search_index == None: self.search_index = '1.0'
            self.search_index = self.txt_help.search(text_to_find, self.search_index, backwards = not(search_next))
            if self.search_index == '': self.search_index = None

            if self.search_index != None:
                # show and highlight the found text
                self.txt_help.see(self.search_index)
                self.txt_help.tag_add(TAG_FOUND2, self.search_index, f'{self.search_index} + {text_len} chars')

    #-------------------------------------------------------------------------------------------------
    def help_search_text_key_pressed(self, event):
        # (GUI event callback) the user has pressed a keyboard key in the help text search box

        # update the status of GUI widgets
        self.gui_status_update_notebook()

        self.search_index = None  # restart the search at the beginning of the help text
        self.help_search_text(self.cmb_search_text.get(), True)

    #-------------------------------------------------------------------------------------------------
    def odf_search_text(self, event=None, text_to_replace=None):
        # (GUI event callback) the user has clicked on the button "Search" of the "Search/replace" tab or pressed Enter in the search entry box
        # called by the odf_replace_text function, in this case text_to_replace provides the replacement text for the text to search
        # return True or False wether text has been found

        # recover the text to search
        text_to_search = self.ent_odf_search_text.get()

        # clear the search results list
        self.lst_odf_sresults.delete(0, END)

        if text_to_search != '':
            # fill the list of objects UID in which to do the search, depending on the user's choice
            objects_uid_search_list = []
            if self.odf_search_range.get() == 'odf':
                # the search has to be done in the whole ODF
                objects_uid_search_list = self.odf_data.objects_list_get()
            else:
                # the search range is depending on the selected object UID
                if self.edited_object_uid != None:
                    # an object is selected
                    if self.odf_search_range.get() == 'selected':
                        # the search has to be done inside the selected object
                        objects_uid_search_list.append(self.edited_object_uid)
                    else:
                        # the search has to be done in the children of the selected object
                        objects_uid_search_list = self.odf_data.object_kinship_list_get(self.edited_object_uid, TO_CHILD)
                        if len(objects_uid_search_list) == 0:
                            if self.edited_object_uid == 'Organ':
                                # the Organ object has no children functionnaly, take all the objects but the Header and Organ
                                objects_uid_search_list = list(self.odf_data.objects_list_get())
                                objects_uid_search_list.remove('Header')
                                objects_uid_search_list.remove('Organ')
                            else:
                                messagebox.showinfo(title='OdfEdit', message=f'"{self.edited_object_uid}" has no children')
                                return False
                else:
                    messagebox.showinfo(title='OdfEdit', message='There is none selected object')
                    return False

            results_list = []
            for object_uid in objects_uid_search_list:
                # scan the objects to search in
                object_dic = self.odf_data.object_dic_get(object_uid)
                for i, line in enumerate(object_dic['lines']):
                    # scan the lines of the current object
                    if line[0] != '[' and ((self.odf_search_regex.get() and re.search(text_to_search, line)) or text_to_search in line):
                        # it is not a line with the object UID and it contains the text to search
                        if text_to_replace != None:
                            # the found text has to be replaced
                            if self.odf_search_regex.get():
                                line = re.sub(text_to_search, text_to_replace, line)
                            else:
                                line = line.replace(text_to_search, text_to_replace)
                            # update the current line of the current object
                            object_dic['lines'][i] = line
                        # add the found (and replaced) line to the search results list
                        results_list.append(f'{object_uid} : {line}')
            results_list.sort()

            if len(results_list) > 0:
                # items have been found
                self.lst_odf_sresults.insert(END, *results_list)
                if text_to_replace != None:
                    if self.odf_search_range.get() == 'odf':
                        logs.add(f'"{text_to_search}" has been replaced by "{text_to_replace}" in the whole ODF')
                    elif self.odf_search_range.get() == 'selected':
                        logs.add(f'"{text_to_search}" has been replaced by "{text_to_replace}" in {self.edited_object_uid}')
                    else:
                        logs.add(f'"{text_to_search}" has been replaced by "{text_to_replace}" in children of {self.edited_object_uid}')
                return True
            else:
                self.lst_odf_sresults.insert(END, 'Nothing found (the search is case sensitive)')
                return False

    #-------------------------------------------------------------------------------------------------
    def odf_replace_text(self, event=None):
        # (GUI event callback) the user has clicked on the button "Replace" of the "Search/replace" tab

        # recover the replacement text
        replacement_text = self.ent_odf_replace_text.get()

        if self.odf_search_text(None, replacement_text):
            # the search and replace has been successful
            self.odf_data_changed = True
            # update the links between the objects and their displayed names
            self.odf_data.objects_kinship_update()
            # update the content of GUI widgets
            self.objects_list_update()
            self.objects_tree_update()
            self.object_links_list_update()
            self.object_text_update()
            self.gui_status_update_buttons()
            self.gui_status_update_lists()

            # update the events log text
            self.logs_display()

    #-------------------------------------------------------------------------------------------------
    def odf_search_text_selected(self, event=None):
        # (GUI event callback) the user has clicked on the entry widget to set a text to search

        if self.ent_odf_search_text['fg'] == 'grey':
            self.ent_odf_search_text['fg'] = 'black'
            self.ent_odf_search_text.delete(0, 'end')

    #-------------------------------------------------------------------------------------------------
    def odf_replace_text_selected(self, event=None):
        # (GUI event callback) the user has clicked on the entry widget to set the replacement text

        if self.ent_odf_replace_text['fg'] == 'grey':
            self.ent_odf_replace_text['fg'] = 'black'
            self.ent_odf_replace_text.delete(0, 'end')

    #-------------------------------------------------------------------------------------------------
    def odf_search_text_hw(self, event=None):
        # (GUI event callback) the user has clicked on the button "HW search" of the "Search in ODF" tab

        # recover the text to search
        text_to_search = self.ent_odf_search_text.get()

        self.lst_odf_sresults.delete(0, END)

        if text_to_search != '':
            results_list = []
            for object_type_dic in self.odf_hw2go.HW_odf_dic.values():
                for HW_object_dic in object_type_dic.values():
                    for obj_attr_name, obj_attr_value in HW_object_dic.items():
                        if obj_attr_name[0] != '_':
                            if text_to_search in obj_attr_name or text_to_search in str(obj_attr_value):
                                results_list.append(f"{HW_object_dic['_HW_uid']} : {obj_attr_name}={obj_attr_value}")
            results_list.sort()

            if len(results_list) > 0:
                self.lst_odf_sresults.insert(END, *results_list)
            else:
                messagebox.showinfo(title='Information', message=f'"{text_to_search}" not found in the HW ODF (the search is case sensitive)')

    #-------------------------------------------------------------------------------------------------
    def odf_search_uid_hw(self):
        # (GUI event callback) the user has clicked on the button "UID search" of the HW ODF browser

        # recover the text to search (must be a HW object UID only)
        text_to_search = self.ent_hw_uid_search_text.get()

        if text_to_search != '':
            object_dic = self.odf_hw2go.HW_ODF_get_object_dic(text_to_search)
            if object_dic != None:
                # the UID is existing in the HW ODF
                self.selected_object_app = 'HW'
                self.selected_object_uid = text_to_search
                self.selected_linked_uid = None
                self.edited_object_uid = text_to_search
                self.focused_objects_widget = self.lst_hw_browser
                self.focused_sel_item_id = text_to_search

                # update the status of GUI widgets
                self.object_links_list_update()
                self.objects_list_update_hw()
                self.object_text_update()
                self.gui_status_update_buttons()
                self.gui_status_update_lists()
            else:
                messagebox.showerror(title="Error", message=f'"{text_to_search}" is not a known HW UID')

    #-------------------------------------------------------------------------------------------------
    def odf_search_text_result_selected(self, event):
        # (GUI event callback) the user has clicked on an item of the ODF search results list

        # get the selected indice
        selected_indice = self.lst_odf_sresults.curselection()

        if self.can_i_make_change(object_change_bool=True) and selected_indice != None and not self.lst_odf_sresults.get(selected_indice[0]).startswith('Nothing'):
            # the user has saved his modifications if he wanted and has not canceled the operation
            self.selected_object_uid = self.lst_odf_sresults.get(selected_indice[0]).split(' ')[0]
            self.selected_linked_uid = None
            self.edited_object_uid = self.selected_object_uid

            if self.selected_object_uid == '_General' or self.selected_object_uid[-6:].isdigit():
                # the results are concerning HW UID
                self.selected_object_app = 'HW'
                self.objects_list_update_hw()
            else:
                self.selected_object_app = 'GO'

            self.focused_objects_widget = None

            # update the object text box and links list
            self.object_text_update()
            self.object_links_list_update()

            # select in the object edition text box the line which corresponds to the selected result
            selected_search_result = self.lst_odf_sresults.get(selected_indice[0]).split(':')[1].strip()
            idx = self.txt_object_text.search(selected_search_result, '1.0', stopindex=END)
            if idx != '':
                self.txt_object_text.tag_remove('sel', '1.0', 'end')
                self.txt_object_text.tag_add('sel', idx, f'{idx} + {len(selected_search_result)} chars')
                self.txt_object_text.see(idx)
                self.txt_object_text.focus_set()

            # update the status of GUI widgets
            self.gui_status_update_buttons()
            self.gui_status_update_lists()

    #-------------------------------------------------------------------------------------------------
    def viewer_file_show(self, line):
        # shows in the viewer tab the file defined in the given object line if any and if valid

        label_text = 'Click in the text editor on a line where is defined a bitmap or wave sample file'
        file_type = None
        file_name = None
        pipe_pitch_tuning = None

        if line != None:
            # recover the content of the given line
            (error_msg, attr_name, attr_value, comment) = self.odf_data.object_line_split(line)
            if error_msg == None and attr_value != None and len(attr_value) > 0:
                # the line has been split with success
                if ('Image' in attr_name or 'Mask' in attr_name or 'Bitmap' in attr_name) and (attr_value.upper()[-4:] in ('.BMP', '.GIF', '.JPG', '.ICO', '.PNG')):
                    # it is a supported image file extension
                    file_type = 'image'
                    file_name = attr_value

                elif 'Pipe' in attr_name:
                    if attr_value.upper()[-4:] == '.WAV':
                        # it is a wave file
                        file_type = 'sample'
                        file_name = attr_value
                    elif attr_value[:4] == 'REF:':
                        # it is the referencing REF:xx:xx:xx to borrow the wave file of another manual/stop/pipe
                        # read the three references
                        refs_list = attr_value[5:].split(':')
                        if len(refs_list) < 3 or not (refs_list[0].isdigit and refs_list[1].isdigit and refs_list[2].isdigit):
                            label_text = f'ERROR : three numerical references are expected in the pipe referencing {attr_value}, at the format REF:aa:bb:cc'
                        else:
                            # recover the manual UID, the stop number in the manual, the pipe number in the stop or fist rank of the stop
                            manual_nb = int(refs_list[0])
                            manual_uid = 'Manual' + str(manual_nb).zfill(3)
                            stop_nb = int(refs_list[1])
                            pipe_nb = int(refs_list[2])
                            if self.odf_data.object_dic_get(manual_uid) == None:
                                label_text = f'ERROR : the section {manual_uid} does not exist'
                            elif stop_nb < 1:
                                label_text = f'ERROR : the stop number cannot be lower than 1, it is set at {stop_nb}'
                            elif pipe_nb < 1:
                                label_text = f'ERROR : the pipe number cannot be lower than 1, it is set at {pipe_nb}'
                            else:
                                # search for the appropriate stop UID in the list of the child stops of the manual
                                manual_stops_list = sorted(self.odf_data.object_kinship_list_get(manual_uid, TO_CHILD, 'Stop'))
                                if len(manual_stops_list) < stop_nb:
                                    label_text = f'ERROR : there is no stop number {stop_nb} in the manual {manual_nb}'
                                else:
                                    stop_uid = manual_stops_list[stop_nb - 1]
                                    if self.odf_data.object_dic_get(stop_uid) == None:
                                        label_text = f'ERROR : there is no section {stop_uid} defined'
                                    else:
                                        # proper stop object is found, recover the sample file in the stop object if defined
                                        pipe_id = 'Pipe' + str(pipe_nb).zfill(3)
                                        sample_file = self.odf_data.object_attr_value_get(stop_uid, pipe_id)
                                        pipe_pitch_tuning = myint(self.odf_data.object_attr_value_get(stop_uid, pipe_id + 'PitchTuning'))
                                        if sample_file == None:
                                            # there is no Pipe attribute in the stop, recover the sample file in the first rank
                                            rank_id = myint(self.odf_data.object_attr_value_get(stop_uid, 'Rank001'))
                                            if rank_id == None:
                                                label_text = f'ERROR : there is neither attribute {pipe_id} nor attribute Rank001 defined in the section {stop_uid}'
                                            else:
                                                # recover the sample file in the rank object if defined
                                                rank_uid = 'Rank' + str(rank_id).zfill(3)
                                                sample_file = self.odf_data.object_attr_value_get(rank_uid, pipe_id)
                                                pipe_pitch_tuning = myint(self.odf_data.object_attr_value_get(rank_uid, pipe_id + 'PitchTuning'))
                                        if sample_file != None:
                                            file_type = 'sample'
                                            file_name = sample_file

            if file_name != None:
                # a file name with expected extension has been extracted from the given line
                file_full_path = os.path.dirname(self.odf_data.odf_file_name) + os.sep + path2ospath(file_name)
                if not os.path.isfile(file_full_path):
                    # the file does not actually exist
                    label_text = f'WARNING : the file {file_full_path} does not exist'
                    file_type = None
                    file_name = None

        if file_type == 'image':
            if self.viewer_file_name != file_name:
                # open the new image
                self.viewer_orig_image = Image.open(file_full_path)
                self.viewer_file_name = file_name
                # reset the canvas view position
                self.view_canvas.xview(MOVETO, 0)
                self.view_canvas.yview(MOVETO, 0)
                # display the image (and the label text)
                self.viewer_image_update()
            label_text = None  # the label is displayed in the function viewer_image_update, not in this function
        else:
            self.viewer_orig_image = None

        if file_type == 'sample':
            if self.viewer_file_name == file_name:
                # same sample file as currently in the viewer, stop its playback
                self.viewer_audio_player.stop()
            else:
                self.viewer_file_name = file_name
                # start the playback of the sample
                self.viewer_audio_player = AudioPlayer(file_full_path)
                self.viewer_audio_player.play(block=False)
            # display information about the wave file
            metadata_dic = wav_metadata_get(file_full_path)
            label_text = 'File : ' + self.viewer_file_name + '\n'
            if pipe_pitch_tuning != None:
                label_text += 'with pitch tuning ' + str(pipe_pitch_tuning) + '\n'
            label_text += '\n'
            if metadata_dic['error_msg'] != '':
                label_text += f"ERROR : {metadata_dic['error_msg']}"
            else:
                label_text += "Mono" if metadata_dic['nb_of_channels'] == 1 else "Stereo"
                label_text += f", sampling {metadata_dic['sampling_rate']/1000 :0.1f}kHz"
                label_text += f", resolution {metadata_dic['bits_per_sample']} bits"
                label_text += f", duration {metadata_dic['audio_duration']} sec ({metadata_dic['nb_of_samples']} samples)"
                label_text += '\n'
                if 'midi_note' in metadata_dic.keys():
                    label_text += '\n'
                    label_text += f"MIDI note {metadata_dic['midi_note']}"
                    label_text += f", pitch {metadata_dic['midi_pitch']}"
                    label_text += '\n'
                if 'info' in metadata_dic.keys():
                    label_text += '\n'
                    for key, value in metadata_dic['info'].items():
                        if key == 'IART':
                            label_text += f"Artist : {value}\n"
                        elif key == 'ICOP':
                            label_text += f"Copyright : {value}\n"
                        elif key == 'ISFT':
                            label_text += f"Software used : {value}\n"
                        elif key == 'ICMT':
                            label_text += f"Comments : {value}\n"
                        elif key == 'ICRD':
                            label_text += f"Date : {value}\n"
                        else:
                            label_text += f"{key} - {value}\n"
                if 'loops_nb' in metadata_dic.keys():
                    label_text += '\n'
                    for l in range(1, metadata_dic['loops_nb']+1):
                        label_text += f"Loop {l} : start sample {metadata_dic['loop'+str(l)+'_start_sample']} ({metadata_dic['loop'+str(l)+'_start_seconds']} sec), end sample {metadata_dic['loop'+str(l)+'_end_sample']} ({metadata_dic['loop'+str(l)+'_end_seconds']} sec)\n"
                if 'cue_points_nb' in metadata_dic.keys():
                    label_text += '\n'
                    for l in range(1, metadata_dic['cue_points_nb']+1):
                        label_text += f"Cue point {l} : ID {metadata_dic['cue'+str(l)+'_id']}, located in a {metadata_dic['cue'+str(l)+'_chunk_id']} chunk, data chunk start {metadata_dic['cue'+str(l)+'_chunk_start']}, block start at {metadata_dic['cue'+str(l)+'_block_start']} bytes, sample start at {metadata_dic['cue'+str(l)+'_sample_start']} bytes\n"
                label_text = label_text[:-1] # remove the ending carriage return
        else:
            # if a sample playback is in progress, force it to stop
            if self.viewer_audio_player != None:
                self.viewer_audio_player.stop()

        if file_name == None:
            self.viewer_file_name = None

        if label_text != None:
            # reset the canvas view position
            self.view_canvas.xview(MOVETO, 0)
            self.view_canvas.yview(MOVETO, 0)
            # update the label text
            self.view_canvas.delete('all')
            text_id = self.view_canvas.create_text(10, 10, anchor=NW, text=label_text, font=('Arial','10'), width=self.frm_viewer.winfo_width() - 20)
            text_bbox = self.view_canvas.bbox(text_id)
            if file_type == 'sample':
                # place a background to the text if sample data are displayed
                rect_id = self.view_canvas.create_rectangle(text_bbox[0]-5, text_bbox[1]-5, text_bbox[2]+5, text_bbox[3]+5, fill='white')
                self.view_canvas.tag_lower(rect_id)

    #-------------------------------------------------------------------------------------------------
    def viewer_image_update(self, event=None):
        # (GUI event callback) the user has turned the mouse wheel inside the viewer canvas or the image has to be displayed/updated

        if self.viewer_orig_image == None:
            # there is no image displayed
            return

        # update the viewer zoom factor according to the direction of the wheel movement
        if event != None:
            if event.num == 4 or event.delta > 0:
                # mouse wheel rotation up in Linux or Windows
                self.viewer_zoom_factor = min(6, self.viewer_zoom_factor + 0.1)
            else:
                self.viewer_zoom_factor = max(0.2, self.viewer_zoom_factor - 0.1)

        # scale the image
        self.viewer_curr_image = ImageTk.PhotoImage(ImageOps.scale(self.viewer_orig_image, self.viewer_zoom_factor))

        # update the label text in the canvas
        label_text  = f'File : {self.viewer_file_name}\n\n'
        label_text += f'Image size {self.viewer_orig_image.size[0]} x {self.viewer_orig_image.size[1]},'
        label_text += f' zoom x{self.viewer_zoom_factor:0.1f}'
        label_text += ' (use mouse drag/wheel to move/zoom image)'
        self.view_canvas.delete('all')
        self.view_canvas.create_text(10, 10, anchor=NW, text=label_text, font=('Arial','10'), width=self.frm_viewer.winfo_width() - 20)

        # update the image in the canvas
        self.view_canvas.create_image(10, 70, anchor=NW, image=self.viewer_curr_image)


    #-------------------------------------------------------------------------------------------------
    def viewer_image_drag(self, event):
        # (GUI event callback) the user has dragged the image in the viewer

        if self.viewer_file_name == None:
            # there is no file in the viewer
            return

        self.view_canvas.scan_dragto(event.x, event.y, gain=1)

    #-------------------------------------------------------------------------------------------------
    def viewer_sample_stop(self):
        # stop the sample file playback in progress

        if self.viewer_audio_player != None:
            self.viewer_audio_player.stop()
            self.viewer_audio_player.close()

    #-------------------------------------------------------------------------------------------------
    def objects_list_update_hw(self, event=0):
        # do an update the Hauptwerk objects list widget

        tab = '      '

        # clear the HW objects list widget content
        self.lst_hw_browser.delete(0, END)

        # update the HW objects list widgets
        if len(self.odf_hw2go.HW_odf_dic):
            # there are HW ODF data in the dictionary
            if self.selected_object_uid == None or self.selected_object_app != 'HW':
                center_object_UID = "_General"
            else:
                center_object_UID = self.selected_object_uid

            selected_object_dic = self.odf_hw2go.HW_ODF_get_object_dic(center_object_UID)
            if selected_object_dic != None:
                # set the first element
                if center_object_UID != "_General":
                    self.lst_hw_browser.insert(END, '_General')
                self.lst_hw_browser.insert(END, '*** OBJECTS RELATIONSHIP (parents/current in red/children) ***')

                # display the parents of the selected object
                objects_uid_list = []
                for object_dic in selected_object_dic['_parents']:
                    objects_uid_list.append(object_dic['_HW_uid'])
                for object_uid in sorted(objects_uid_list):
                    object_dic = self.odf_hw2go.HW_ODF_get_object_dic(object_uid)
                    obj_name = self.odf_hw2go.HW_ODF_get_attribute_value(object_dic, 'Text')
                    if obj_name == None: obj_name = self.odf_hw2go.HW_ODF_get_attribute_value(object_dic, 'Name')
                    if obj_name != None:
                        self.lst_hw_browser.insert(END, object_uid + ' (' + obj_name + ')')
                    else:
                        self.lst_hw_browser.insert(END, object_uid)

                # display the selected object
                item_str = tab + center_object_UID
                obj_name = self.odf_hw2go.HW_ODF_get_attribute_value(selected_object_dic, 'Text')
                if obj_name == None:
                    obj_name = self.odf_hw2go.HW_ODF_get_attribute_value(selected_object_dic, 'Name')
                if obj_name != None:
                    item_str += ' (' + obj_name + ')'
                children_nb = len(self.odf_hw2go.HW_ODF_get_attribute_value(selected_object_dic, '_children'))
                if children_nb == 1:
                    item_str += '  >> 1 child'
                elif children_nb >= 1:
                    item_str += '  >> ' + str(children_nb) + ' children'
                self.lst_hw_browser.insert(END, item_str)
                self.lst_hw_browser.itemconfig(END, foreground='red')
                self.lst_hw_browser.selection_set(END)
                self.lst_hw_browser.see(END)


                # display the children of the selected object
                objects_uid_list = []
                for object_dic in selected_object_dic['_children']:
                    objects_uid_list.append(object_dic['_HW_uid'])
                for object_uid in sorted(objects_uid_list):
                    item_str = tab + tab + object_uid
                    object_dic = self.odf_hw2go.HW_ODF_get_object_dic(object_uid)
                    obj_name = self.odf_hw2go.HW_ODF_get_attribute_value(object_dic, 'Text')
                    if obj_name == None:
                        obj_name = self.odf_hw2go.HW_ODF_get_attribute_value(object_dic, 'Name')
                    if obj_name != None:
                        item_str += ' (' + obj_name + ')'
                    children_nb = len(self.odf_hw2go.HW_ODF_get_attribute_value(object_dic, '_children'))
                    if children_nb == 1:
                        item_str += '  >> 1 child'
                    elif children_nb >= 1:
                        item_str += '  >> ' + str(children_nb) + ' children'
                    self.lst_hw_browser.insert(END, item_str)

            self.lst_hw_browser.insert(END, '*** OBJECTS WITHOUT PARENT ***')

            # add at the end all the objects which have no parent except some types
            objects_uid_list = []
            for HW_object_type, HW_object_type_dic in self.odf_hw2go.HW_odf_dic.items():
                # scan the HW object types
                if not HW_object_type.startswith(('Pi', 'Sa', 'TremulantWaveformP', 'SwitchL', '_General')):
                    # excluded objects types are : Pipe_xxx, Sample, TremulantWaveformPipe, SwitchLinkage, _General
                    # the current HW object type can be added in the list
                    for object_dic in HW_object_type_dic.values():
                        # scan the HW objects of the current HW objects type
                        if len(object_dic['_parents']) == 0:
                            # the current object has no parent
                            objects_uid_list.append(object_dic['_HW_uid'])

            for object_uid in sorted(objects_uid_list):
                item_str = object_uid
                object_dic = self.odf_hw2go.HW_ODF_get_object_dic(object_uid)
                obj_name = self.odf_hw2go.HW_ODF_get_attribute_value(object_dic, 'Text')
                if obj_name == None:
                    obj_name = self.odf_hw2go.HW_ODF_get_attribute_value(object_dic, 'Name')
                if obj_name != None:
                    item_str += ' (' + obj_name + ')'
                children_nb = len(self.odf_hw2go.HW_ODF_get_attribute_value(object_dic, '_children'))
                if children_nb == 1:
                    item_str += '  >> 1 child'
                elif children_nb >= 1:
                    item_str += '  >> ' + str(children_nb) + ' children'
                self.lst_hw_browser.insert(END, item_str)

    #-------------------------------------------------------------------------------------------------
    def objects_list_selected_hw(self, event):
        # (GUI event callback) the user has selected an item in the Hauptwerk objects list widget

        if self.gui_events_blocked: return

        # get the line numbers of the selected item in the list
        cursel_tuple = self.lst_hw_browser.curselection()
        if len(cursel_tuple) > 0:
            selected_line_indice = cursel_tuple[0]
        else:
            selected_line_indice = None

        if selected_line_indice != None and self.can_i_make_change(object_change_bool=True):
            # an item of the HW objects list widget is selected
            # recover in the objects list widget the UID of the selected object (before the first space in the selected item text)
            self.selected_object_app = 'HW'
            self.selected_object_uid = self.lst_hw_browser.get(selected_line_indice).strip().split(' ')[0]
            if self.selected_object_uid[0] == '*': # item without object UID
                self.selected_object_uid = None
            self.selected_linked_uid = None
            self.edited_object_uid = self.selected_object_uid

            self.focused_objects_widget = self.lst_hw_browser
            self.focused_sel_item_id = self.selected_object_uid

            # update the object text box and links list
            self.object_links_list_update()
            self.object_text_update()

        # update the status of GUI widgets
        self.gui_status_update_buttons()
        self.gui_status_update_lists()

    #-------------------------------------------------------------------------------------------------
    def objects_list_selected_dbl_hw(self, event):
        # (GUI event callback) the user has double-clicked an item in the Hauptwerk objects list widget

        if self.selected_object_uid != None:
            self.objects_list_update_hw()


#-------------------------------------------------------------------------------------------------
class C_GUI(C_GUI_NOTEBOOK):
    # class to manage the graphical user interface of the application

    odf_data = None             # one instance of the C_ODF_DATA class
    odf_hw2go = None            # one instance of the C_ODF_HW2GO class

    odf_file_save_encoding = '' # StringVar with encoding type (ENCODING_ISO_8859_1 or ENCODING_UTF8_BOM) to use when saving data in an ODF
    odf_file_dir = ''           # directory of the last opened or saved ODF

    selected_object_app = 'GO'  # application associated to the object currently selected : 'GO' or 'HW', GO by default
    selected_object_uid = None  # UID of the object currently selected in the objects lists (GO or HW) or objects tree widgets (GO)
    selected_linked_uid = None  # UID of the linked object currently selected in the linked objects list if any (GO)
    edited_object_uid = None    # UID of the edited object

    focused_objects_widget = None  # objects widget which has the focus : self.lst_objects_list / self.trv_objects_tree / self.lst_links_list / self.lst_hw_browser / None
    focused_sel_item_id = None     # identifier of the selected item of the focused widget

    key_control_pressed_bool = False # flag indicating if a Control key is currently pressed on the keyboard of the computer in OdfEdit

    ignore_b1_release = False      # flag permitting to ignore the processing of the mouse button 1 release event

    opened_objects_iid_list = []   # list of the objects tree nodes iid which are opened

    odf_data_changed = False       # flag indicating that data have been changed in the odf_data and not saved in an ODF
    edited_object_changed = False  # flag indicating that data have been changed in the object currently edited (and not yet applied in odf_data)

    is_loaded_hw_odf = False       # flag set at True if a Hauptwerk ODF is currently loaded

    gui_events_blocked = False     # flag indicating that the GUI events are currently blocked

    text_to_search = None       # text which has to be searched in the help
    search_index = None         # last search result position in the help

    hw2go_warning_displayed_bool = None      # flag indicating that the HW to GO conversion warning has been displayed one time in the current life cycle of the application
    hw2go_convert_unused_ranks_bool = None   # flag BooleanVar set by the menu to ask the HW 2 GO conversion of the HW ranks not used by the conversion
    hw2go_convert_alt_ranks_bool = None      # flag BooleanVar set by the menu to ask the HW 2 GO conversion of the alternate ranks (for wave based tremulants)
    hw2go_alt_ranks_in_main_rank_bool = None # flag BooleanVar set by the menu to ask the HW 2 GO conversion to place the alternate ranks in their main rank

    objects_tree_auto_expand_bool = True # flag BooleanVar set by the menu to define if the objects tree has to be expanded automatically on object selection
                                         # in order to make visible all the occurrences of this object in the tree

    #-------------------------------------------------------------------------------------------------
    def reset_all_data(self):
        # reset all the data of the class

        self.selected_object_app = 'GO'
        self.selected_object_uid = None
        self.selected_linked_uid = None
        self.edited_object_uid = None

        self.focused_objects_widget = None
        self.focused_sel_item_id = None

        self.odf_data_changed = False
        self.edited_object_changed = False

        self.is_loaded_hw_odf = False

        self.odf_data.reset_all_data()
        self.odf_hw2go.reset_all_data()

        self.lst_odf_sresults.delete(0, END)

    #-----------------------------------------------------------------------------------------------
    def wnd_main_build(self):
        # build the main window of the application with all its GUI widgets

        # create the main window
        self.wnd_main = Tk(className='OdfEdit')
        self.wnd_main.title(MAIN_WINDOW_TITLE)
        self.wnd_main.geometry('1600x800+50+50')
        self.wnd_main.protocol("WM_DELETE_WINDOW", self.wnd_main_quit) # to ask the user to save his changed before to close the main window
        # assign an image to the main window icon
        icon = PhotoImage(file = os.path.dirname(__file__) + os.sep + 'resources' + os.sep + 'OdfEdit.png')
        self.wnd_main.iconphoto(False, icon)

        # define the styles of some widgets
        self.wnd_main.style = ttk.Style()
        self.wnd_main.style.theme_use('default')
        self.wnd_main.style.configure("Treeview", highlightthickness=3, font=('Calibri', 11), foreground="black")
        self.wnd_main.style.map('Treeview', background=[('selected', COLOR_SELECTED_ITEM)])
        self.wnd_main.style.configure("TNotebook.Tab", font=('Calibri', 11), foreground="black")
        self.wnd_main.option_add("*TCombobox*Listbox*Background", 'white')
        self.wnd_main.option_add("*TCombobox*Listbox*Foreground", 'black')
        self.wnd_main.option_add('*Dialog.msg.font', 'Calibri 11')
        self.wnd_main.option_add("*Button.Font", 'Calibri 11')

        # bind a fonction to react to ctrl + s or ctrl + S keyboard keys to save changed data
        self.wnd_main.bind('<Control-s>', self.wnd_main_key_ctrl_s)
        self.wnd_main.bind('<Control-S>', self.wnd_main_key_ctrl_s)

        self.wnd_main.bind('<KeyPress>', self.wnd_main_key_press)
        self.wnd_main.bind('<KeyRelease>', self.wnd_main_key_release)

        #--- create the various widgets inside the main window

        #-- top buttons bar

        # top frame to encapsulate widgets bar
        self.frm_top = Frame(self.wnd_main)
        self.frm_top.pack(side='top', fill='x')

        # button "New"
        self.btn_odf_new = Button(self.frm_top, text="New", fg="black", width=7, command=self.file_new)
        self.btn_odf_new.pack(side='left', padx=5, pady=5)

        # button "Open"
        self.btn_odf_file_open = Button(self.frm_top, text="Open", fg="black", width=7, command=self.file_open)
        self.btn_odf_file_open.pack(side='left', padx=5, pady=5)
        CreateToolTip(self.btn_odf_file_open, "Load a GrandOrgue ODF (extension .organ) or a Hauptwerk ODF (extension .Organ_Hauptwerk_xml or .xml).")

        # button "Save"
        self.btn_odf_file_save = Button(self.frm_top, text="Save", fg="black", width=7, state=DISABLED, command=self.file_save)
        self.btn_odf_file_save.pack(side='left', padx=5, pady=5)
        CreateToolTip(self.btn_odf_file_save, "Save the changes done in the last loaded GrandOrgue ODF.")

        # button "Save as..."
        self.btn_odf_file_saveas = Button(self.frm_top, text="Save as...", fg="black", width=10, state=DISABLED, command=self.file_saveas)
        self.btn_odf_file_saveas.pack(side='left', padx=5, pady=5)
        CreateToolTip(self.btn_odf_file_saveas, "Save the changes done in a new GrandOrgue ODF.")

        # button "Check ODF data"
        self.btn_data_check = Button(self.frm_top, text="ODF data check", fg="black", width=15, state=DISABLED, command=self.odf_data_check)
        self.btn_data_check.pack(side='left', padx=5, pady=5)
        CreateToolTip(self.btn_data_check, "Execute checks in the loaded ODF data (syntax, compliance with the specification). Not as exhaustive as GrandOrgue does.")

        # button "Menu" and general menu
        self.btn_gen_menu = Button(self.frm_top, text="â¡", fg="black", width=2, command=self.gen_menu_open)
        self.btn_gen_menu.pack(side='left', padx=5, pady=5)
        self.odf_file_save_encoding = StringVar(self.wnd_main)
        self.odf_file_save_encoding.set(ENCODING_ISO_8859_1)
        self.objects_tree_auto_expand_bool = BooleanVar(self.wnd_main)
        self.hw2go_convert_alt_ranks_bool = BooleanVar(self.wnd_main)
        self.hw2go_alt_ranks_in_main_rank_bool = BooleanVar(self.wnd_main)
        self.hw2go_convert_unused_ranks_bool = BooleanVar(self.wnd_main)
        self.general_menu = Menu(self.btn_gen_menu, tearoff=0)
        self.general_menu['bg'] = 'snow2'
        self.general_menu.add_checkbutton(label="Save ODF with ISO-8859-1 encoding (else UTF-8-BOM)", onvalue=ENCODING_ISO_8859_1, offvalue=ENCODING_UTF8_BOM, variable=self.odf_file_save_encoding)
        self.general_menu.add_checkbutton(label="Auto expand sections tree on section selection", onvalue=True, offvalue=False, variable=self.objects_tree_auto_expand_bool)
##        self.general_menu.add_command(label="Extend manual's compass...", command=self.manual_compass_extend)
        self.general_menu.add_separator()
        self.general_menu.add_checkbutton(label="HW to GO : convert tremmed samples", onvalue=True, offvalue=False, variable=self.hw2go_convert_alt_ranks_bool)
        self.general_menu.add_checkbutton(label="HW to GO : integrate tremmed samples in main ranks", onvalue=True, offvalue=False, variable=self.hw2go_alt_ranks_in_main_rank_bool)
        self.general_menu.add_checkbutton(label="HW to GO : convert unused ranks", onvalue=True, offvalue=False, variable=self.hw2go_convert_unused_ranks_bool)
        self.general_menu.add_separator()
        self.general_menu.add_command(label="Clear logs", command=self.logs_clear)
        self.general_menu.add_command(label="About...", command=self.gen_menu_about)
        self.general_menu.bind('<FocusOut>', self.gen_menu_close)

        # button "Quit"
        self.btn_quit_appli = Button(self.frm_top, text="Quit", fg="black", width=7, relief='groove', command=self.wnd_main_quit)
        self.btn_quit_appli.pack(side='left', padx=10, pady=5)

        # label with loaded ODF file name or to display progression status
        self.lab_odf_file_name = Label(self.frm_top, text="", fg="black", borderwidth=1, relief="solid", anchor='w', height=1)
        self.lab_odf_file_name.pack(side='left', padx=5, pady=5, ipady=3, expand=1, fill='x')

        #-- bottom area with horizontal paned window on the full window width

        # horizontal paned window at the bottom of the main window
        self.paned_wnd = PanedWindow(self.wnd_main, orient ='horizontal', relief = 'sunken', sashrelief = 'raised', sashwidth = 10)
        self.paned_wnd.pack(side='bottom', padx=5, pady=5, expand=1, fill='both')

        #-- paned window element #1 (objects list)

        # frame to occupy the full area of the element #1
        self.frm_hpaned_wnd_1 = Frame(self.wnd_main)
        self.paned_wnd.add(self.frm_hpaned_wnd_1, minsize=200, width=250)

        # label with the number of objects in the objects list, placed at the top of the parent frame
        self.lab_objects_nb = Label(self.frm_hpaned_wnd_1, text="", fg="black", borderwidth=0, relief="solid", anchor=CENTER)
        self.lab_objects_nb.pack(side = 'top', pady=10, fill='x')

        # frame to occupy the bottom area of the parent frame and to encapsulate the list box and its scroll bars
        self.frm_objects_list = Frame(self.frm_hpaned_wnd_1)
        self.frm_objects_list.pack(side = 'bottom', fill='both', expand=1)

        # list box with objects UIDs and names, with horizontal and vertical scroll bars, inside the parent frame
        self.scrollbarv_obj_list = ttk.Scrollbar(self.frm_objects_list, orient='vertical')
        self.scrollbarv_obj_list.pack(side=RIGHT, fill=Y)
        scrollbarh = ttk.Scrollbar(self.frm_objects_list, orient='horizontal')
        scrollbarh.pack(side=BOTTOM, fill=X)
        self.lst_objects_list = Listbox(self.frm_objects_list, bg='white', font='Calibri 11', fg="black", selectbackground=COLOR_SELECTED_ITEM, exportselection=0, selectmode='single', activestyle='none')
        self.lst_objects_list.pack(side=LEFT, fill=BOTH, expand=1)
        self.lst_objects_list.bind('<<ListboxSelect>>', self.objects_list_selected)
        self.lst_objects_list.bind("<B1-Motion>", self.object_b1_motion)
        self.lst_objects_list.bind('<ButtonRelease-1>', self.object_b1_release)
        self.lst_objects_list.bind("<B1-Leave>", lambda event: "break")  # to avoid the auto scrolling in the list on drag
        self.lst_objects_list.config(yscrollcommand=self.scrollbarv_obj_list.set)
        self.lst_objects_list.config(xscrollcommand=scrollbarh.set)
        self.scrollbarv_obj_list.config(command=self.lst_objects_list.yview)
        scrollbarh.config(command=self.lst_objects_list.xview)

        #-- paned window element #2 (objects tree)

        # frame to occupy the full area of the element #2
        self.frm_paned_wnd_2 = Frame(self.wnd_main)
        self.paned_wnd.add(self.frm_paned_wnd_2, minsize=200, width=250)

        # frame to occupy the top area of the parent frame and to encamsulate collapse/expand buttons
        self.frm_top_paned_wnd_2 = Frame(self.frm_paned_wnd_2)
        self.frm_top_paned_wnd_2.pack(side='top', fill='x')

        # button "Collapse" for the objects tree
        self.btn_collapse_all = Button(self.frm_top_paned_wnd_2, text="Collapse", fg="black", state=DISABLED, command=self.objects_tree_collapse_all)
        self.btn_collapse_all.pack(side='left', padx=1, pady=5, fill='x', expand=1)

        # button "Expand" for the objects tree
        self.btn_expand_all = Button(self.frm_top_paned_wnd_2, text="Expand", fg="black", state=DISABLED, command=self.objects_tree_expand_all)
        self.btn_expand_all.pack(side='left', padx=1, pady=5, fill='x', expand=1)

        # button "Unselect"
        self.btn_unselect = Button(self.frm_top_paned_wnd_2, text="Unselect", fg="black", state=DISABLED, command=self.object_unselect)
        self.btn_unselect.pack(side='left', padx=1, pady=5, fill='x', expand=1)

        # frame to occupy the bottom area of the parent frame and to encapsulate the tree view and its scroll bars
        self.frm_object_tree = Frame(self.frm_paned_wnd_2)
        self.frm_object_tree.pack(side = 'bottom', fill='both', expand=1)

        # treeview to display the objects hierarchy, with horizontal and vertical scroll bars
        scrollbarv = ttk.Scrollbar(self.frm_object_tree, orient='vertical')
        scrollbarv.pack(side=RIGHT, fill=Y)
        scrollbarh = ttk.Scrollbar(self.frm_object_tree, orient='horizontal')
        scrollbarh.pack(side=BOTTOM, fill=X)
        self.trv_objects_tree = ttk.Treeview(self.frm_object_tree, show="tree", selectmode='extended')   #'browse')
        self.trv_objects_tree.pack(side=LEFT, fill=BOTH, expand=1)
        self.trv_objects_tree.column('#0', width=500)
        self.trv_objects_tree.bind('<<TreeviewSelect>>', self.objects_tree_selected)
        self.trv_objects_tree.bind("<B1-Motion>", self.object_b1_motion)
        self.trv_objects_tree.bind('<ButtonRelease-1>', self.object_b1_release)

        self.trv_objects_tree.config(yscrollcommand=scrollbarv.set)
        self.trv_objects_tree.config(xscrollcommand=scrollbarh.set)
        scrollbarv.config(command=self.trv_objects_tree.yview)
        scrollbarh.config(command=self.trv_objects_tree.xview)
        self.trv_objects_tree.tag_configure(TAG_SAME_UID, foreground='black', background=COLOR_OBJ_UID_ITEM)

        #-- paned window element #3 (object editor)

        # frame to occupy the full area of the element #3
        self.frm_paned_wnd_3 = Frame(self.wnd_main)
        self.paned_wnd.add(self.frm_paned_wnd_3, minsize=400, width=500)

        # vertical paned window placed inside the frame of the element #3
        self.obj_paned_wnd = PanedWindow(self.frm_paned_wnd_3, orient ='vertical', relief = 'sunken', sashrelief = 'raised', sashwidth = 10)
        self.obj_paned_wnd.pack(side='top', expand=1, fill='both')

        # frame to occupy the full area of the element #1 of the vertical paned window
        self.frm_obj_paned_wnd_1 = Frame(self.wnd_main)
        self.obj_paned_wnd.add(self.frm_obj_paned_wnd_1, minsize=120, height=200)

        # frame to occupy the top area of the parent frame and to encapsulate buttons
        self.frm_top_obj_paned_wnd_1 = Frame(self.frm_obj_paned_wnd_1)
        self.frm_top_obj_paned_wnd_1.pack(side='top', fill='x')

        # button "Apply"
        self.btn_object_apply_chg = Button(self.frm_top_obj_paned_wnd_1, text="Apply", fg="black", state=DISABLED, command=self.object_text_changes_apply)
        self.btn_object_apply_chg.pack(side='left', padx=1, pady=5, fill='x', expand=1)
        CreateToolTip(self.btn_object_apply_chg, "Apply the changes done in the text box below.")

        # button "Add"
        self.btn_object_add = Button(self.frm_top_obj_paned_wnd_1, text="Add", fg="black", state=NORMAL, command=self.object_add)
        self.btn_object_add.pack(side='left', padx=1, pady=5, fill='x', expand=1)
        CreateToolTip(self.btn_object_add, "Add a child object to the selected object or at the root.")

        # button "Parents"
        self.btn_object_parents = Button(self.frm_top_obj_paned_wnd_1, text="Parents", fg="black", state=DISABLED, command=lambda type=TO_PARENT: self.object_link(type))
        self.btn_object_parents.pack(side='left', padx=1, pady=5, fill='x', expand=1)
        CreateToolTip(self.btn_object_parents, "Set links between the selected object and parent objects.")

        # button "Children"
        self.btn_object_children = Button(self.frm_top_obj_paned_wnd_1, text="Children", fg="black", state=DISABLED, command=lambda type=TO_CHILD: self.object_link(type))
        self.btn_object_children.pack(side='left', padx=1, pady=5, fill='x', expand=1)
        CreateToolTip(self.btn_object_children, "Set links between the selected object and child objects.")

        # button "Rename"
        self.btn_object_rename = Button(self.frm_top_obj_paned_wnd_1, text="Rename", fg="black", state=DISABLED, command=self.object_rename)
        self.btn_object_rename.pack(side='left', padx=1, pady=5, fill='x', expand=1)
        CreateToolTip(self.btn_object_rename, "Rename the last three digits of the selected object.")

        # button "Delete"
        self.btn_object_delete = Button(self.frm_top_obj_paned_wnd_1, text="Delete", fg="black", state=DISABLED, command=self.object_delete)
        self.btn_object_delete.pack(side='left', padx=1, pady=5, fill='x', expand=1)
        CreateToolTip(self.btn_object_delete, "Delete the selected object.")

        # button "Help"
        self.btn_show_help = Button(self.frm_top_obj_paned_wnd_1, text="Help", fg="black", state=DISABLED, command=self.help_search_object)
        self.btn_show_help.pack(side='left', padx=1, pady=5, fill='x', expand=1)
        CreateToolTip(self.btn_show_help, "Show in the help the part describing the selected object type.")

        # frame to occupy the bottom area of the parent frame and to encapsulate the parent/children list and its vertical scroll bar
        self.frm_bottom_obj_paned_wnd_1 = Frame(self.frm_obj_paned_wnd_1)
        self.frm_bottom_obj_paned_wnd_1.pack(side='top', fill='both', expand=1)

        # list of the selected object UID and its linked parent/children UID
        scrollbarv = ttk.Scrollbar(self.frm_bottom_obj_paned_wnd_1, orient='vertical')
        scrollbarv.pack(side='right', fill='y')
        self.lst_links_list = Listbox(self.frm_bottom_obj_paned_wnd_1, bg='white', font='Calibri 11', fg="black", selectforeground="white", selectbackground=COLOR_SELECTED_ITEM, exportselection=0, selectmode='single', activestyle='none')
        self.lst_links_list.pack(side='top', fill='both', expand=1)
        self.lst_links_list.bind('<<ListboxSelect>>', self.object_links_list_selected)
        self.lst_links_list.bind('<Double-1>', self.object_links_list_selected_dbl)
        self.lst_links_list.bind("<B1-Motion>", self.object_b1_motion)
        self.lst_links_list.bind('<ButtonRelease-1>', self.object_b1_release)
        self.lst_links_list.bind("<B1-Leave>", lambda event: "break")  # to avoid the auto scrolling in the list on drag
        self.lst_links_list.config(yscrollcommand=scrollbarv.set)
        scrollbarv.config(command=self.lst_links_list.yview)

        # frame to occupy the full area of the element #2 of the vertical paned window
        self.frm_obj_paned_wnd_2 = Frame(self.wnd_main)
        self.obj_paned_wnd.add(self.frm_obj_paned_wnd_2, minsize=200, height=200)

        # text box with the object text and with horizontal and vertical scroll bars
        scrollbarv = ttk.Scrollbar(self.frm_obj_paned_wnd_2, orient='vertical')
        scrollbarv.pack(side='right', fill=Y)
        scrollbarh = ttk.Scrollbar(self.frm_obj_paned_wnd_2, orient='horizontal')
        scrollbarh.pack(side='bottom', fill=X)
        self.txt_object_text = Text(self.frm_obj_paned_wnd_2, fg="black", bg='gray95', bd=3, wrap="none", font="Calibri 11", selectbackground="snow3", undo=True)
        self.txt_object_text.pack(side=LEFT, fill=BOTH, expand=1)
        self.txt_object_text.bind('<<Modified>>', self.object_text_changed)
        self.txt_object_text.bind('<<Paste>>', self.object_text_paste)
        self.txt_object_text.bind('<KeyRelease>', self.object_text_key_pressed)
        self.txt_object_text.bind('<ButtonRelease-1>', self.object_text_click)
        self.txt_object_text.bind('<Double-1>', self.object_text_click_dbl)
        self.txt_object_text.bind('<Control-Key-a>', self.object_text_select_all)
        self.txt_object_text.bind('<Control-Key-A>', self.object_text_select_all)
        self.txt_object_text.config(xscrollcommand=scrollbarh.set, yscrollcommand=scrollbarv.set)
        scrollbarv.config(command=self.txt_object_text.yview)
        scrollbarh.config(command=self.txt_object_text.xview)
        # define the tags for the syntax highlighting in the text box
        self.txt_object_text.tag_config(TAG_FIELD, foreground='red3')
        self.txt_object_text.tag_config(TAG_COMMENT, foreground='chartreuse4')
        self.txt_object_text.tag_config(TAG_OBJ_UID, foreground='blue2', font='Calibri 11 bold')

        #-- paned window element #4 (notebook with several tabs)

        # frame to occupy the full area of the element #4
        self.frm_paned_wnd_4 = Frame(self.wnd_main)
        self.paned_wnd.add(self.frm_paned_wnd_4, minsize=400, width=400)

        # build the notebook GUI
        self.wnd_notebook_build(self.frm_paned_wnd_4)

        # create an instance of the C_ODF_DATA class
        self.odf_data = C_ODF_DATA()

        # create an instance of the C_ODF_HW2GO class
        self.odf_hw2go = C_ODF_HW2GO()

        self.reset_all_data()

        # load the application data
        self.app_data_load()

        # update the status of GUI widgets
        self.gui_status_update_buttons()
        self.gui_status_update_lists()
        self.gui_status_update_notebook()

        # display the logs resulting from the init of the application if any
        self.logs_display()

        # launch a timer to complete some initialization operations 200ms after the application start
        # to permit an application bring up as fast as possible
        self.wnd_main.after(20, self.init_complete)

        return self.wnd_main

    #-------------------------------------------------------------------------------------------------
    def wnd_main_quit(self):
        # (GUI event callback) the user has clicked on the button "Quit" or window top-right "X"

        if self.can_i_make_change(file_change_bool=True):
            # the user has saved his modifications if he wanted and has not canceled the operation
            # save application data
            self.app_data_save()
            # destroy the main window
            self.wnd_main.destroy()

        # stop an eventual audio sample playback in progress in the viewer
        self.viewer_sample_stop()

    #-------------------------------------------------------------------------------------------------
    def wnd_main_key_ctrl_s(self, event):
        # (GUI event callback) the user has pressed on the ctrl + s or ctrl + S keyboard keys

        if self.object_text_changes_apply() and self.odf_data_changed:
            # changes have been made in the ODF data : save them
            self.file_save()

    #-------------------------------------------------------------------------------------------------
    def wnd_main_key_press(self, event):
        # (GUI event callback) the user has pressed a keyboard key

        if event.keysym in ('Control_L', 'Control_R'):
            # control left or right key pressed
            self.key_control_pressed_bool = True
            # update the mouse cursor aspect if it is not the default arrow (i.e. there is a drag&drop in progress)
            if self.wnd_main['cursor'] != '':
                self.wnd_main['cursor'] = 'plus'

    #-------------------------------------------------------------------------------------------------
    def wnd_main_key_release(self, event):
        # (GUI event callback) the user has released a keyboard key

        if event.keysym in ('Control_L', 'Control_R'):
            # control left or right key released
            self.key_control_pressed_bool = False
            # update the mouse cursor aspect if it is not the default arrow (i.e. there is a drag&drop in progress)
            if self.wnd_main['cursor'] != '':
                self.wnd_main['cursor'] = 'sb_up_arrow'

    #-------------------------------------------------------------------------------------------------
    def init_complete(self):
        # function to complete the initialization of the application

        # load the help text
        self.help_file_load()

        # load the GO objects templates
        self.odf_data.objects_templates_load()

        self.logs_display()

    #-------------------------------------------------------------------------------------------------
    def app_data_load(self):
        # load application configuration data from a .cfg file located in the folder of the OdfEdit file (.py or .exe)

        # initialize the saved application data with default values
        self.odf_file_dir = ''
        self.odf_file_save_encoding.set(ENCODING_UTF8_BOM)
        self.objects_tree_auto_expand_bool.set(False)
        self.hw2go_convert_unused_ranks_bool.set(False)
        self.hw2go_convert_alt_ranks_bool.set(False)
        self.hw2go_alt_ranks_in_main_rank_bool.set(True)

        try:
            # load the dictionary stored in the config file
            data_dic = {}
            with open('OdfEdit.cfg', 'r') as f:
                data_dic = eval(f.read())

            # recover each data from the dictionary if they are valid
            if 'last_odf_dir' in data_dic.keys() and os.path.isdir(data_dic['last_odf_dir']):
                self.odf_file_dir = data_dic['last_odf_dir']
            if 'file_save_encoding' in data_dic.keys() and data_dic['file_save_encoding'] in (ENCODING_ISO_8859_1, ENCODING_UTF8_BOM):
                self.odf_file_save_encoding.set(data_dic['file_save_encoding'])
            if 'auto_expand_tree' in data_dic.keys() and data_dic['auto_expand_tree'] in (True, False):
                self.objects_tree_auto_expand_bool.set(data_dic['auto_expand_tree'])
            if 'convert_unused_ranks' in data_dic.keys() and data_dic['convert_unused_ranks'] in (True, False):
                self.hw2go_convert_unused_ranks_bool.set(data_dic['convert_unused_ranks'])
            if 'convert_alt_ranks' in data_dic.keys() and data_dic['convert_alt_ranks'] in (True, False):
                self.hw2go_convert_alt_ranks_bool.set(data_dic['convert_alt_ranks'])
            if 'separate_alt_ranks' in data_dic.keys() and data_dic['separate_alt_ranks'] in (True, False):
                self.hw2go_alt_ranks_in_main_rank_bool.set(data_dic['separate_alt_ranks'])

        except:
            # issue occured to read the config file : we keep the default values set before
            pass

    #-------------------------------------------------------------------------------------------------
    def app_data_save(self):
        # save application configuration data in a .cfg file located in the folder of the OdfEdit file (.py or .exe)

        # build a dictionary with the application data to save
        data_dic = {}
        data_dic['last_odf_dir'] = self.odf_file_dir
        data_dic['file_save_encoding'] = self.odf_file_save_encoding.get()
        data_dic['auto_expand_tree'] = self.objects_tree_auto_expand_bool.get()
        data_dic['convert_unused_ranks'] = self.hw2go_convert_unused_ranks_bool.get()
        data_dic['convert_alt_ranks'] = self.hw2go_convert_alt_ranks_bool.get()
        data_dic['separate_alt_ranks'] = self.hw2go_alt_ranks_in_main_rank_bool.get()

        # save the dictionnary in the config file
        with open('OdfEdit.cfg', 'w') as f:
            f.write(str(data_dic))

    #-------------------------------------------------------------------------------------------------
    def file_new(self):
        # (GUI event callback) the user has clicked on the button "New"
        # do a reset of the objects list/tree, edit box and ODF data

        if self.can_i_make_change(file_change_bool=True):
            # the user has saved his modifications if he wanted and has not canceled the operation

            # reset the various data
            self.reset_all_data()

            # update the various GUI widgets
            self.objects_list_update()
            self.objects_list_update_hw()
            self.objects_tree_update()
            self.object_text_update()
            self.object_links_list_update()
            self.gui_status_update_buttons()
            self.gui_status_update_notebook()
            self.notebook.hide(self.frm_hw_browser)

    #-------------------------------------------------------------------------------------------------
    def file_open(self):
        # (GUI event callback) the user has clicked on the button "Open"

        if self.can_i_make_change(file_change_bool=True):
            # the user has saved his modifications if he wanted and has not canceled the operation

            # let the user select the ODF file to open
            file_name = fd.askopenfilename(title='Open an Organ Definition File (ODF)', initialdir = self.odf_file_dir , filetypes=[('All supported ODF', '*.organ *.xml *.Organ_Hauptwerk_xml'), ('GrandOrgue ODF', '*.organ'), ('Hauptwerk ODF', '*.xml *.Organ_Hauptwerk_xml')])
            if len(file_name) > 0:
                # a file has been selected by the user

                # reset the various data
                self.reset_all_data()
                self.gui_status_update_buttons()
                self.gui_status_update_notebook()

                # store the file extension of the selected file
                file_extension = os.path.splitext(file_name)[1]

                # store the directory of the selected file
                self.odf_file_dir = os.path.dirname(file_name)

                # reset the data and HMI
                self.file_new()

                # select the logs tab of the notebook to show the file opening logs
                self.notebook.select(self.frm_logs)
                self.notebook.hide(self.frm_hw_browser)

                if file_extension in ('.xml', '.Organ_Hauptwerk_xml'):
                    # Hauptwerk ODF selected : build a GrandOrgue ODF which uses the Hauptwerk sample set

                    HW_odf_file_name = path2ospath(file_name)
                    # define the name of the built GO ODF according to the name of the HW ODF : same path and file name, only the extension is changed
                    if file_extension == '.xml':
                        if '.Organ.Hauptwerk.xml' in HW_odf_file_name:
                            GO_odf_file_name = HW_odf_file_name.replace('.Organ.Hauptwerk.xml', '.organ')
                        else:
                            GO_odf_file_name = HW_odf_file_name.replace('.xml', '.organ')
                    else:
                        GO_odf_file_name = HW_odf_file_name.replace('.Organ_Hauptwerk_xml', '.organ')

                    # legal message displayed to the user before to start the ODF building
                    if not self.hw2go_warning_displayed_bool and not DEV_MODE:
                        confirm = messagebox.askokcancel(title="Hauptwerk ODF conversion to GrandOrgue format", message=HW_CONV_MSG)
                    else:
                        confirm = True
                    if confirm:
                        self.hw2go_warning_displayed_bool = True
                        if self.odf_hw2go.GO_ODF_build_from_HW_ODF(HW_odf_file_name, GO_odf_file_name, self.progress_status_update,
                                                                   self.hw2go_convert_unused_ranks_bool.get(), self.hw2go_convert_alt_ranks_bool.get(),
                                                                   self.hw2go_alt_ranks_in_main_rank_bool.get(), self.odf_file_save_encoding.get()):
                            # the GO ODF building has succeeded
                            self.is_loaded_hw_odf = True
                            # display the HW objects notebook tab and list inside this tab
                            self.notebook.add(self.frm_hw_browser)
                            # the built GO ODF will be then loaded
                            file_name = GO_odf_file_name
                        else:
                            logs.add('ERROR : something went wrong while converting the Hauptwerk ODF in a GrandOrgue ODF')
                            file_name = ''
                        self.logs_display()
                    else:
                        file_name = ''

                if file_name != '':
                    # GrandOrgue ODF selected or built from a Hauptwerk ODF
                    self.progress_status_update('Loading ODF...')
                    if self.odf_data.load_from_file(file_name):
                        # the file has been loaded properly
                        # update the objects list / tree / text
                        self.initial_dir = file_name

                self.objects_list_update()
                self.objects_list_update_hw()
                self.objects_tree_update()
                self.object_text_update()
                self.object_links_list_update()
                self.gui_status_update_buttons()
                self.gui_status_update_notebook()

                self.logs_display()

    #-------------------------------------------------------------------------------------------------
    def file_save(self):
        # (GUI event callback) the user has clicked on the button "Save"
        # return True or False whether the saving has been done or not in the current loaded ODF

        return self.file_saveas(self.odf_data.odf_file_name)

    #-------------------------------------------------------------------------------------------------
    def file_saveas(self, file_name = ''):
        # (GUI event callback) the user has clicked on the button "Save as"
        # return True or False whether the saving has been done or not

        if file_name == '':
            # let the user select the ODF file in which to make the saving
            file_name = fd.asksaveasfilename(title='Save in ODF...', filetypes=[('ODF', '*.organ')])

        if file_name != '' and self.odf_data.save_to_file(file_name, self.odf_file_save_encoding.get()):
            # a file has been selected by the user
            # and the ODF data have been correctly saved

            # store the directory of the saved file
            self.odf_file_dir = os.path.dirname(file_name)

            self.odf_data_changed = False
            self.gui_status_update_buttons()
            data_saved = True
        else:
            data_saved = False

        self.logs_display()
        return data_saved

    #-------------------------------------------------------------------------------------------------
    def can_i_make_change(self, file_change_bool=False, object_change_bool=False):
        # before a file change or window closing (file_change_bool=True) or a selected object change (object_change_bool=True)
        # ask to the user if he wants to save his modifications if any, if the answer is yes then do it
        # return True if the change to do can be done

        change_ok_bool = True

        if file_change_bool:
            # the coming change will be at file level
            if self.edited_object_changed:
                # the selected object have been edited
                # ask to the user if he wants to apply changes made in the selected object and to save the changed ODF data
                if self.edited_object_uid != None:
                    confirm = messagebox.askyesnocancel(title="Apply and save changes ?", message=f"Do you want to apply and save changes made in {self.edited_object_uid} ?")
                else:
                    confirm = messagebox.askyesnocancel(title="Apply and save changes ?", message=f"Do you want to apply and save changes ?")
                if confirm:  # answer is yes
                    if not self.object_text_changes_apply():
                        change_ok_bool = False
                    elif not self.file_save():
                        change_ok_bool = False
                elif confirm is None:  # answer is cancel
                    change_ok_bool = False
                else:  # answer is no
                    pass

            elif self.odf_data_changed:
                # data have changed in the ODF data
                # ask to the user if he wants to save the changes done
                confirm = messagebox.askyesnocancel(title="Save changes ?", message=f"Do you want to save changes ?")
                if confirm:  # answer is yes
                    if not self.file_save():
                        change_ok_bool = False
                elif confirm is None:  # answer is cancel
                    change_ok_bool = False
                else:  # answer is no
                    pass

        elif self.edited_object_changed:
            # the coming change will be at selected object level, and the selected object have been edited
            # ask to the user if he wants to apply changes made in the selected object
            if self.edited_object_uid != None:
                confirm = messagebox.askyesnocancel(title="Apply changes ?", message=f"Do you want to apply changes made in {self.edited_object_uid} ?")
            else:
                confirm = messagebox.askyesnocancel(title="Apply changes ?", message=f"Do you want to apply changes ?")
            if confirm:  # answer is yes
                if not self.object_text_changes_apply():
                    change_ok_bool = False
            elif confirm is None:  # answer is cancel
                change_ok_bool = False
            else:  # answer is no
                pass

        return change_ok_bool

    #-------------------------------------------------------------------------------------------------
    def gui_events_block(self):
        # set the flag which blocks the GUI events processing and launch a blocking timer of 100ms

        if self.gui_events_blocked == False:
            # the events are not yet blocked
            self.gui_events_blocked = True
            # launch a timer which will unblock the events 100ms later, the time for the modified widgets to have completed their update
            self.wnd_main.after(100, self.gui_events_unblock)

    #-------------------------------------------------------------------------------------------------
    def gui_events_unblock(self):
        # (GUI event callback) end of a timer started by the function gui_events_block
        # reset the flag which blocks the GUI events processing

        self.gui_events_blocked = False

    #-------------------------------------------------------------------------------------------------
    def gui_status_update_buttons(self):
        # update the status of some GUI widgets in a single time, according to some status of the application

        # recover the number of defined objects in the ODF data
        objects_nb = self.odf_data.objects_number_get()

        # recover the list of possible parents and children objects of the selected object
        (possible_parents_list, possible_children_list) = self.odf_data.object_poss_kinship_list_get(self.edited_object_uid)
        possible_children_type_list = self.odf_data.object_poss_children_type_list_get(self.edited_object_uid)

        if 'Header' not in self.odf_data.objects_list_get() or 'Organ' not in self.odf_data.objects_list_get():
            # the root object Header or Organ is not present in the ODF
            root_object_not_def = True
        else:
            root_object_not_def = False

        # button "New"
        self.btn_odf_new['state'] = NORMAL if objects_nb > 0 else DISABLED

        # button "Save"
        self.btn_odf_file_save['state'] = NORMAL if (self.odf_data.odf_file_name != '' and self.odf_data_changed) else DISABLED
        self.btn_odf_file_save['foreground'] = 'red' if (self.odf_data.odf_file_name != '' and self.odf_data_changed) else 'grey'

        # button "Save as"
        self.btn_odf_file_saveas['state'] = NORMAL if objects_nb > 0 else DISABLED
        self.btn_odf_file_saveas['foreground'] = 'red' if (self.odf_data.odf_file_name == '' and self.odf_data_changed) else 'black'

        # button "Do check"
        self.btn_data_check['state'] = NORMAL if objects_nb > 0 else DISABLED

        # button "Apply changes"
        self.btn_object_apply_chg['state'] = NORMAL if self.edited_object_changed else DISABLED
        self.btn_object_apply_chg['foreground'] = 'red' if self.edited_object_changed else 'grey'

        # button "Add"
        self.btn_object_add['state'] = NORMAL if (len(possible_children_type_list) > 0 or root_object_not_def) else DISABLED

        # button "Parents"
        self.btn_object_parents['state'] = NORMAL if len(possible_parents_list) > 0 else DISABLED

        # button "Children"
        self.btn_object_children['state'] = NORMAL if len(possible_children_list) > 0 else DISABLED

        # button "Rename"
        self.btn_object_rename['state'] = NORMAL if (self.edited_object_uid != None and self.selected_object_app == 'GO' and self.edited_object_uid[-3:].isdigit()) else DISABLED

        # button "Delete"
        self.btn_object_delete['state'] = NORMAL if (self.edited_object_uid != None and self.selected_object_app == 'GO') else DISABLED

        # button "Unselect"
        self.btn_unselect['state'] = NORMAL if (self.edited_object_uid != None and self.selected_object_app == 'GO') else DISABLED

        # button "Show help"
        self.btn_show_help['state'] = NORMAL if (self.edited_object_uid not in (None, 'Header') and self.selected_object_app == 'GO') else DISABLED

        # buttons "Collapse all" and "Expand all"
        self.btn_collapse_all['state'] = NORMAL if objects_nb > 0 else DISABLED
        self.btn_expand_all['state'] = NORMAL if objects_nb > 0 else DISABLED

        # label with the loaded ODF name
        if self.odf_data.odf_file_name == '':
            if objects_nb == 0:
                self.lab_odf_file_name.config(text='Click on the button "Open" to load a GrandOrgue or Hauptwerk ODF, or "Add" to create new sections')
            else:
                self.lab_odf_file_name.config(text='Click on the button "Save as" to define a file name')
        else:
            self.lab_odf_file_name.config(text=self.odf_data.odf_file_name)
        self.lab_odf_file_name['foreground'] = 'black'

        # label with the number of objects
        if objects_nb == 0:
            self.lab_objects_nb.config(text="")
        elif objects_nb == 1:
            self.lab_objects_nb.config(text="1 section")
        else:
            self.lab_objects_nb.config(text=f"{objects_nb} sections")

    #-------------------------------------------------------------------------------------------------
    def gui_status_update_lists(self):
        # update the selections in the GUI lists/tree

        # to block the GUI events triggered by the GUI updates done in this function
        self.gui_events_block()

        # GO objects list
        # highlight and make visible the item corresponding to the selected object UID
        self.lst_objects_list.selection_clear(0, 'end')
        for i in range(0, self.lst_objects_list.size()):
            object_uid = self.lst_objects_list.get(i).split(' ')[0]
            if object_uid == self.selected_object_uid and self.selected_object_app == 'GO':
                # the current item corresponds to the selected GO object UID : highlight it
                self.lst_objects_list.itemconfig(i, foreground='black', background=COLOR_OBJ_UID_ITEM)
            else:
                self.lst_objects_list.itemconfig(i, foreground='black', background='white')

            if self.focused_objects_widget == self.lst_objects_list and self.focused_sel_item_id == object_uid:
                # the current item has the focus : select it and make it visible
                self.lst_objects_list.selection_set(i)
                self.lst_objects_list.see(i)

        # GO linked objects list
        self.lst_links_list.selection_clear(0, 'end')
        for i in range(0, self.lst_links_list.size()):
            object_uid = self.lst_links_list.get(i).strip().split(' ')[0]
            if object_uid == self.selected_object_uid and self.selected_object_app == 'GO':
                # the current item corresponds to the selected GO object UID : highlight it
                self.lst_links_list.itemconfig(i, foreground='black', background=COLOR_OBJ_UID_ITEM)
            else:
                self.lst_links_list.itemconfig(i, foreground='black', background='white')

            if self.focused_objects_widget == self.lst_links_list and self.focused_sel_item_id == object_uid:
                # the current item has the focus : select it
                self.lst_links_list.selection_set(i)
                self.lst_links_list.see(i)

        # GO objects tree
        if self.selected_object_app == 'GO':
            object_uid = self.selected_object_uid
        else:
            object_uid = None
        # select the items corresponding to the selected object UID
        for iid in self.trv_objects_tree.get_children():
            self.objects_tree_nodes_select(iid, object_uid)

    #-------------------------------------------------------------------------------------------------
    def gen_menu_open(self):
        # (GUI event callback) the user has clicked on the button Menu to open the general menu

        self.general_menu.tk_popup(self.btn_gen_menu.winfo_rootx() + self.btn_gen_menu.winfo_width(), self.btn_gen_menu.winfo_rooty())

    #-------------------------------------------------------------------------------------------------
    def gen_menu_close(self, event=None):
        # (GUI event callback) the menu has lost its focus

        self.general_menu.grab_release()

    #-------------------------------------------------------------------------------------------------
    def gen_menu_about(self):
        # (GUI event callback) the user has clicked on the item About... of the general Menu

        messagebox.showinfo('OdfEdit', f'OdfEdit {APP_VERSION} - {RELEASE_DATE}\n\ngithub.com/GrandOrgue/OdfEdit')

    #-------------------------------------------------------------------------------------------------
    def objects_list_update(self):
        # do an update of the objects list widget content

        # clear the objects list widget content
        self.lst_objects_list.delete(0, 'end')

        # update the widget with the current list of sorted objects UID and name
        # puting the 'Header' and 'Organ' objects in first position of the list and excluding the Header object
        organ_text = None
        header_text = None
        for object_uid in sorted(self.odf_data.objects_list_get()):
            item_text = self.odf_data.object_names_get(object_uid)
            if object_uid == 'Organ':
                organ_text = item_text
            elif object_uid =='Header':
                header_text = item_text
            else:
                self.lst_objects_list.insert(END, item_text)

        if organ_text != None:
            self.lst_objects_list.insert(0, organ_text)
        if header_text != None:
            self.lst_objects_list.insert(0, header_text)

    #-------------------------------------------------------------------------------------------------
    def objects_list_selected(self, event):
        # (GUI event callback) the user has selected an item in the objects list widget

        if self.gui_events_blocked: return

        # get the line number of the selected item in the list
        cursel_tuple = self.lst_objects_list.curselection()
        if len(cursel_tuple) > 0:
            selected_line_indice = cursel_tuple[0]
        else:
            selected_line_indice = None

        if selected_line_indice != None:
            # an item has been selected in the list

            # ignore the mouse button 1 release if the edited object has been changed : to let the user say if he wants to save the change or not or cancel
            self.ignore_b1_release = self.edited_object_changed

            if self.can_i_make_change(object_change_bool=True):
                # the user has saved his modifications if he wanted and has not canceled the selection

                # recover in the objects list widget the UID of the selected object (before the first space in the selected item text)
                object_uid = self.lst_objects_list.get(selected_line_indice).split(' ')[0]
                self.selected_object_app = 'GO'
                self.selected_object_uid = object_uid
                self.selected_linked_uid = None
                self.edited_object_uid = self.selected_object_uid

                self.focused_objects_widget = self.lst_objects_list
                self.focused_sel_item_id = object_uid

                if self.ignore_b1_release:
                    # do now the processing of the mouse button 1 release
                    self.ignore_b1_release = False
                    self.object_b1_release(event)
                # else the widgets will be updated on mouse button release

            else:
                # the user had canceled the selection
                self.ignore_b1_release = False
                self.gui_status_update_lists()

    #-------------------------------------------------------------------------------------------------
    def objects_tree_update(self):
        # do an update of the objects tree widget

        # memorize the nodes of the tree which are currently opened to restore them in the updated list
        self.opened_objects_iid_list.clear()
        for iid in self.trv_objects_tree.get_children(''):
            self.objects_tree_node_and_children_opened_nodes_get(iid)

        # delete all the nodes of the tree
        for node_iid in self.trv_objects_tree.get_children():
            self.trv_objects_tree.delete(node_iid)

        odf_objects_list = self.odf_data.objects_list_get()
        if len(odf_objects_list) > 0:
            # there are existing objects

            # treeview insert syntax : insert(parent_iid or '', position (0 or 'end'), node_iid, keyword arguments...)

            if 'Header' in odf_objects_list:
                # place the Header object in first position of the tree
                iid = self.trv_objects_tree.insert('', 'end', 'Header', text='Header')

            if 'Organ' in odf_objects_list:
                # place the Organ object after the Header or in first position if no header
                organ_node_iid = self.trv_objects_tree.insert('', 'end', 'Organ', text=self.odf_data.object_names_get('Organ'), open=True)
            else:
                organ_node_iid = ''

            depth = 0
            for object_uid in sorted(odf_objects_list):
                if object_uid not in ('Header', 'Organ'):
                    # scan the objects UID of the objects list which are not Header or Organ
                    object_type = self.odf_data.object_type_get(object_uid)
                    if object_type in ('General', 'Manual', 'Panel', 'WindchestGroup', 'Image', 'Label', 'ReversiblePiston', 'SetterElement'):
                        # put the current object under the 'Organ' node
                        self.objects_tree_child_add(organ_node_iid, object_uid, depth)
                    elif len(self.odf_data.object_kinship_list_get(object_uid, TO_PARENT)) == 0:
                        # the object has no parent, put it at the root of the tree
                        self.objects_tree_child_add('', object_uid, depth)

    #-------------------------------------------------------------------------------------------------
    def objects_tree_child_add(self, parent_node_iid, child_object_uid, depth):
        # recursive function to insert in the objects tree widget the given child object UID under the given parent node ID

        # insert the given child object in the tree under the given parent node iid
        child_node_iid = self.trv_objects_tree.insert(parent_node_iid, 'end', parent_node_iid + child_object_uid, text=self.odf_data.object_names_get(child_object_uid))

        if child_node_iid in self.opened_objects_iid_list:
            # the given child node iid has to be opened
            self.trv_objects_tree.item(child_node_iid, open=True)
            self.opened_objects_iid_list.remove(child_node_iid)

        # the given child becomes the parent for the next recursive call
        new_parent_node_iid = child_node_iid
        new_parent_uid = child_object_uid
        new_parent_type = self.odf_data.object_type_get(new_parent_uid)

        # scan the children of new parent to add the corresponding children nodes
        if self.odf_data.object_dic_get(new_parent_uid) != None:
            # the new parent object UID exists in the ODF dictionary
            if not(new_parent_type == 'Manual' and depth > 0):
                # it is not a Manual object at depth higher than 1 (to avoid Manual childs in the tree when Manual is not child of Organ)
                for child_uid in sorted(self.odf_data.object_kinship_list_get(new_parent_uid, TO_CHILD)):
                    self.objects_tree_child_add(new_parent_node_iid, child_uid, depth + 1)

    #-------------------------------------------------------------------------------------------------
    def objects_tree_expand_all(self):
        # (GUI event callback) the user has pressed the button "Expand all"
        # expend all the nodes of the objects tree widget

        for iid in self.trv_objects_tree.get_children(''):
            self.objects_tree_node_and_children_open(iid, True)

    #-------------------------------------------------------------------------------------------------
    def objects_tree_collapse_all(self):
        # (GUI event callback) the user has pressed the button "Collapse all"
        # collapse all the nodes of the objects tree widget except the root and the 'Organ' nodes

        for iid in self.trv_objects_tree.get_children(''):
            self.objects_tree_node_and_children_open(iid, False)

    #-------------------------------------------------------------------------------------------------
    def objects_tree_node_and_parents_open(self, node_iid):
        # recursive function to open the given node and his parents in the objects tree

        if node_iid != '':
            # the node exists
            self.trv_objects_tree.item(node_iid, open=True)

            # apply the open status to the parent node of node_iid
            self.objects_tree_node_and_parents_open(self.trv_objects_tree.parent(node_iid))

    #-------------------------------------------------------------------------------------------------
    def objects_tree_node_and_children_open(self, node_iid, open_status):
        # recursive function to open (if True, else close) the given node and his children in the objects tree

        if self.trv_objects_tree.item(node_iid, option='text').startswith('Organ'):
            # the Organ node must stay always opened
            self.trv_objects_tree.item(node_iid, open=True)
        else:
            self.trv_objects_tree.item(node_iid, open=open_status)

        # apply the open status to the child nodes
        for iid in self.trv_objects_tree.get_children(node_iid):
            self.objects_tree_node_and_children_open(iid, open_status)

    #-------------------------------------------------------------------------------------------------
    def objects_tree_nodes_select(self, node_iid, object_uid):
        # recursive function to select and make visible the nodes of the objects tree which contain the given object UID text

        if object_uid != None and self.trv_objects_tree.item(node_iid)['text'].split(' ')[0] == object_uid:
            # the node node_iid corresponds to the object UID : tag it and open it parents nodes
            self.trv_objects_tree.item(node_iid, tags=TAG_SAME_UID)
            # open the parents of the node so that the object is visible if it is requested by the user in the menu
            if self.objects_tree_auto_expand_bool.get():
                self.objects_tree_node_and_parents_open(self.trv_objects_tree.parent(node_iid))
        else:
            # remove the tag on the node_iid if any
            self.trv_objects_tree.item(node_iid, tags=())

        if self.focused_objects_widget == self.trv_objects_tree and self.focused_sel_item_id != None and node_iid.endswith(self.focused_sel_item_id):
            # the current node has the focus (use of endswith in case the focused_sel_item_id doesn't fit the full path of the node iid)
            self.trv_objects_tree.selection_add(node_iid)
            self.trv_objects_tree.see(node_iid)
        else:
            self.trv_objects_tree.selection_remove(node_iid)

        # search to select the object_uid in the children of node_iid
        for iid in self.trv_objects_tree.get_children(node_iid):
            self.objects_tree_nodes_select(iid, object_uid)

    #-------------------------------------------------------------------------------------------------
    def objects_tree_node_show(self, object_uid, parent_uid, node_iid=''):
        # recursive function to show in the objects tree the node which has the given object UID under the given parent object UID

        if node_iid != '' and node_iid.endswith(parent_uid + object_uid):
            # the given node is matching the given UIDs (use of endswith in case the given parent + object UID doesn't fit the full path of the node iid)
            self.trv_objects_tree.see(node_iid)
            return True
        else:
            for iid in self.trv_objects_tree.get_children(node_iid):
                if self.objects_tree_node_show(object_uid, parent_uid, iid):
                    return True
            return False

    #-------------------------------------------------------------------------------------------------
    def objects_tree_node_and_children_opened_nodes_get(self, node_iid):
        # recursive function to build the list of the opened nodes from the given node iid and its children

        if self.trv_objects_tree.item(node_iid, 'open'):
            self.opened_objects_iid_list.append(node_iid)

        # check the children of the given node_iid
        for iid in self.trv_objects_tree.get_children(node_iid):
            self.objects_tree_node_and_children_opened_nodes_get(iid)

    #-------------------------------------------------------------------------------------------------
    def objects_tree_selected(self, event):
        # (GUI event callback) the user has selected an item in the objects tree widget

        if self.gui_events_blocked: return

        # get the iid of the selected node in the tree
        cursel_tuple = self.trv_objects_tree.selection()
        if len(cursel_tuple) > 0:
            selected_node_iid = cursel_tuple[0]
        else:
            selected_node_iid = None

        if selected_node_iid != None:
            # an item has been selected in the objects tree

            # ignore the mouse button 1 release if the edited object has been changed : to let the user say if he wants to save the change or not or cancel
            self.ignore_b1_release = self.edited_object_changed

            if self.can_i_make_change(object_change_bool=True):
                # the user has saved his modifications if he wanted and has not canceled the operation

                # recover the object UID
                object_uid = self.trv_objects_tree.item(selected_node_iid, option='text').split(' ')[0]
                self.selected_object_app = 'GO'
                self.selected_object_uid = object_uid
                self.selected_linked_uid = None
                self.edited_object_uid = self.selected_object_uid

                self.focused_objects_widget = self.trv_objects_tree
                self.focused_sel_item_id = selected_node_iid

                if self.ignore_b1_release:
                    # do now the processing of the mouse button 1 release
                    self.ignore_b1_release = False
                    self.object_b1_release(event)
                # else the widgets will be updated on mouse button release

            else:
                # the user had canceled the selection
                self.ignore_b1_release = False
                self.gui_status_update_lists()

    #-------------------------------------------------------------------------------------------------
    def object_links_list_update(self):
        # update the selected object links list

        tab = '    '

        # clear the objects list widget content
        self.lst_links_list.delete(0, END)

        if self.selected_object_app == 'GO' and self.selected_object_uid not in (None, 'Header', 'Organ'):

            # display the selected object
            self.lst_links_list.insert('end', self.odf_data.object_names_get(self.selected_object_uid))

            # display the parents
            parents_list = sorted(self.odf_data.object_kinship_list_get(self.selected_object_uid, TO_PARENT))
            if len(parents_list) > 0:
                self.lst_links_list.insert('end', f'Parents : #{len(parents_list)}')
                for parent_uid in parents_list:
                    self.lst_links_list.insert('end', tab + self.odf_data.object_names_get(parent_uid))

            # display the children
            children_list = sorted(self.odf_data.object_kinship_list_get(self.selected_object_uid, TO_CHILD))
            if len(children_list) > 0:
                self.lst_links_list.insert('end', f'Children : #{len(children_list)}')
                for child_uid in children_list:
                    self.lst_links_list.insert('end', tab + self.odf_data.object_names_get(child_uid))

    #-------------------------------------------------------------------------------------------------
    def object_links_list_selected(self, event):
        # (GUI event callback) the user has selected an item in the object links list widget

        if self.gui_events_blocked: return

        # get the line number of the selected item in the list
        cursel_tuple = self.lst_links_list.curselection()
        if len(cursel_tuple) > 0:
            selected_line_indice = cursel_tuple[0]
        else:
            selected_line_indice = None

        if selected_line_indice != None:
            # an item has been selected in the object links list

            # ignore the mouse button 1 release if the edited object has been changed : to let the user say if he wants to save the change or not or cancel
            self.ignore_b1_release = self.edited_object_changed

            if self.can_i_make_change(object_change_bool=True):
                # the user has saved his modifications if he wanted and has not canceled the operation

                # recover in the list widget the UID of the selected object (before the first space in the selected item text)
                object_uid = self.lst_links_list.get(selected_line_indice).strip().split(' ')[0]
                if object_uid not in ('Parents', 'Children', self.selected_object_uid):
                    self.selected_linked_uid = object_uid
                    self.edited_object_uid = self.selected_linked_uid
                    self.focused_sel_item_id = self.selected_linked_uid
                else:
                    self.selected_linked_uid = None
                    self.edited_object_uid = self.selected_object_uid
                    self.focused_sel_item_id = self.selected_object_uid

                self.focused_objects_widget = self.lst_links_list

                if self.ignore_b1_release:
                    # do now the processing of the mouse button 1 release
                    self.ignore_b1_release = False
                    self.object_b1_release(event)
                # else the widgets will be updated on mouse button release

            else:
                # the user had canceled the selection
                self.ignore_b1_release = False
                self.gui_status_update_lists()

    #-------------------------------------------------------------------------------------------------
    def object_links_list_selected_dbl(self, event):
        # (GUI event callback) the user has double-clicked an item in the object links list widget

        if self.selected_linked_uid != None:
            # make the selected linked UID the selected object UID
            self.selected_object_uid = self.selected_linked_uid
            self.selected_linked_uid = None
            self.ignore_b1_release = True

            # update the status of GUI widgets
            self.object_links_list_update()
            self.gui_status_update_buttons()
            self.gui_status_update_lists()

    #-------------------------------------------------------------------------------------------------
    def object_b1_motion(self, event):
        # (GUI event callback) the user has moved inside the objects lists or tree his mouse with the button 1 pressed

        # change the mouse cursor aspect
        if self.wnd_main['cursor'] == '':
            if self.key_control_pressed_bool:
                self.wnd_main['cursor'] = 'plus'
            else:
                self.wnd_main['cursor'] = 'sb_up_arrow'

    #-------------------------------------------------------------------------------------------------
    def object_b1_release(self, event):
        # (GUI event callback) the user has released inside the GO objects lists or tree the mouse button 1

        # restore the default mouse cursor
        self.wnd_main['cursor'] = ''

        if self.ignore_b1_release:
            # the mouse button 1 release event has to be ignored (asked by a list/tree select function if the edited object has been changed)
            return

        if self.edited_object_uid != None and self.odf_data.object_dic_get(self.edited_object_uid) != None:
            # manage the drag & drop of the edited object if the user has moved it with the mouse

            dragged_object_uid = self.edited_object_uid

            # recover the widget and the object UID on which the mouse button has been released (the target object UID)
            target_widget = event.widget.winfo_containing(event.x_root, event.y_root)
            if target_widget == self.lst_objects_list:
                index = self.lst_objects_list.nearest(event.y)
                target_object_uid = self.lst_objects_list.get(index).split(' ')[0]
            elif target_widget == self.trv_objects_tree:
                index = self.trv_objects_tree.identify_row(event.y)
                target_object_uid = self.trv_objects_tree.item(index, option='text').split(' ')[0]
            elif target_widget == self.lst_links_list:
                index = self.lst_links_list.nearest(event.y)
                target_object_uid = self.lst_links_list.get(index).strip().split(' ')[0]
                if target_object_uid in ('Parents', 'Children'):
                    target_object_uid = None
            else:
                target_object_uid = None

            dragged_object_type = self.odf_data.object_type_get(dragged_object_uid)
            target_object_type = self.odf_data.object_type_get(target_object_uid)

            if target_object_uid not in (None, '') and target_object_uid != dragged_object_uid:
                # the object UID is not the same between mouse button press and release : a drag action has been done

                # recover the list of the object types which can be children of the target object
                possible_children_type_list = self.odf_data.object_poss_children_type_list_get(target_object_uid)
                if dragged_object_type not in possible_children_type_list:
                    # the type of the dragged object cannot be child of the target object
                    if target_object_type == 'Stop' and dragged_object_type == 'Rank':
                        messagebox.showerror('OdfEdit', f'{dragged_object_type} cannot be child of {target_object_type} which refers to a WindchestGroup.')
                    else:
                        messagebox.showerror('OdfEdit', f'{dragged_object_type} cannot be child of {target_object_type}.')
                else:
                    if not self.key_control_pressed_bool:
                        # it is an object move operation (key Control is not pressed on mouse button release)
                        allowed_dragged_object_types_list = ('Coupler', 'Enclosure', 'PanelElement', 'PanelImage', 'Rank', 'Stop', 'Tremulant')
                        if dragged_object_type in allowed_dragged_object_types_list:
                            # the dragged object can be moved to become child of another object
                            parents_uid_list = list(self.odf_data.object_kinship_list_get(dragged_object_uid, TO_PARENT))
                            if target_object_uid in parents_uid_list:
                                # the target object is already parent of the dragged object
                                messagebox.showerror('OdfEdit', f'{target_object_uid} is already parent of {dragged_object_uid}.')
                            else:
                                # the dragged object can be moved as child of the target object
                                # if the dragged object has already a parent of the type of the target object, remove it in the parents list of the dragged object
                                for parent_uid in list(parents_uid_list):
                                    if self.odf_data.object_type_get(parent_uid) == target_object_type:
                                        parents_uid_list.remove(parent_uid)
                                # add the target object UID in the parents list of the dragged object
                                parents_uid_list.append(target_object_uid)
                                # update the parent links of the dragged object
                                object_uid = self.odf_data.object_link(dragged_object_uid, parents_uid_list, TO_PARENT)
                                if object_uid != None:
                                    # the links update has been done properly
                                    self.odf_data_changed = True
                                    self.selected_object_uid = object_uid
                                    self.selected_linked_uid = None
                                    self.edited_object_uid = self.selected_object_uid
                                    self.focused_objects_widget = self.trv_objects_tree
                                    self.focused_sel_item_id = target_object_uid + object_uid
                                    # update the content of GUI widgets
                                    self.objects_list_update()
                                    self.objects_tree_update()
                        else:
                            message = 'Only the following section types\ncan be moved toward a new parent section : '
                            for object_type in allowed_dragged_object_types_list:
                                message += '\n      ' + object_type
                            messagebox.showinfo('OdfEdit', message)
                    else:
                        # it is an object copy operation (key Control is pressed on mouse button release)
                        new_object_uid = self.odf_data.object_copy(dragged_object_uid, target_object_uid)
                        if new_object_uid != None:
                            # the object copy has been done properly
                            self.odf_data_changed = True
                            self.selected_object_uid = new_object_uid
                            self.selected_linked_uid = None
                            self.edited_object_uid = self.selected_object_uid
                            self.focused_objects_widget = self.trv_objects_tree
                            self.focused_sel_item_id = target_object_uid + new_object_uid
                            # update the content of GUI widgets
                            self.objects_list_update()
                            self.objects_tree_update()

                # update the events log text
                self.logs_display()

        # update the status of GUI widgets
        self.object_text_update()
        self.object_links_list_update()
        self.gui_status_update_buttons()
        self.gui_status_update_lists()

        # reset by security the control pressed flag
        self.key_control_pressed_bool = False

    #-------------------------------------------------------------------------------------------------
    def object_unselect(self):
        # (GUI event callback) the user has selected 'Clear all' in the context menu of the object text box

        if self.can_i_make_change(object_change_bool=True):
            # clear the current object selection
            self.selected_object_app = 'GO'
            self.selected_object_uid = None
            self.selected_linked_uid = None
            self.edited_object_uid = None

            self.focused_objects_widget = None
            self.focused_sel_item_id = None

            # update the object text and links list
            self.object_text_update()
            self.object_links_list_update()

            # reset the edit modified flag
            self.txt_object_text.edit_modified(False)
            self.edited_object_changed = False

            self.gui_status_update_buttons()
            self.gui_status_update_lists()

    #-------------------------------------------------------------------------------------------------
    def object_text_update(self):
        # update the content of the object editor text box widget

        # to block the GUI events triggered by the text box content change
        self.gui_events_block()

        # erase the content of the text box and the viewer
        self.txt_object_text.delete(1.0, "end")
        self.viewer_file_show(None)

        # choose which object lines to display in the text box
        object_lines_list = []
        if self.selected_object_app == 'GO':
            # get the data lines list of the selected GrandOrgue object UID
            object_lines_list = self.odf_data.object_lines_read(self.edited_object_uid)
        elif self.selected_object_app == 'HW':
            # get the data lines list of the selected Hauptwerk object UID
            object_lines_list = self.odf_hw2go.HW_ODF_get_object_attr_list(self.selected_object_uid)

        # write the object data lines in the object text box
        if object_lines_list != None and len(object_lines_list) > 0:
            self.txt_object_text.insert(1.0, '\n'.join(object_lines_list))

        # place the insertion cursor at the beginning of the text
        self.txt_object_text.mark_set("insert", "1.0")

        # apply the syntax highlighting
        self.odf_syntax_highlight(self.txt_object_text)

        # reset the text modified flag
        self.txt_object_text.edit_modified(False)
        self.edited_object_changed = False

    #-------------------------------------------------------------------------------------------------
    def object_text_changed(self, event):
        # (GUI event callback) the user has made a change in the object text box

        if self.gui_events_blocked: return

        if self.txt_object_text.edit_modified() and self.edited_object_changed == False and self.selected_object_app == 'GO':
            # update the status of GUI widgets
            self.edited_object_changed = True
            self.gui_status_update_buttons()

    #-------------------------------------------------------------------------------------------------
    def object_text_click(self, event):
        # (GUI event callback) the user has clicked with left button in the object text box

        cursor_pos = self.txt_object_text.index('insert')

        line = self.txt_object_text.get(cursor_pos + ' linestart', cursor_pos + ' lineend')
        self.viewer_file_show(line)

    #-------------------------------------------------------------------------------------------------
    def object_text_click_dbl(self, event):
        # (GUI event callback) the user has double clicked with left button in the object text box

        # get the position of the cursor in the text box
        cursor_pos = self.txt_object_text.index('insert')
        line_nb = int(cursor_pos.split('.')[0])
        char_nb = int(cursor_pos.split('.')[1])
        # get the entire line in which is the cursor
        line = self.txt_object_text.get(cursor_pos + ' linestart', cursor_pos + ' lineend')

        pos = line.find('=')
        if pos >= 0:
            # there is an equal character in the line
            if char_nb <= pos:
                # the cursor is at the left of the cursor : select the text from the start of the line until the equal character
                self.txt_object_text.tag_add('sel', f'{line_nb}.0', f'{line_nb}.{pos}')
            else:
                # the cursor is at the right of the cursor
                posc = line.find(';', pos + 1)
                if posc >= 0:
                    # there is a comment at the end of the line : select the text from the equal char until the semi-colon
                    self.txt_object_text.tag_add('sel', f'{line_nb}.{pos+1}', f'{line_nb}.{posc}')
                else:
                    # there is no comment at the end of the line : select the text from the equal char until the end of the line
                    self.txt_object_text.tag_add('sel', f'{line_nb}.{pos+1}', f'{line_nb}.{pos+1} lineend')
        elif line[0] == '[':
            # the line starts with an opening bracket
            pos = line.find(']')
            if pos > 0:
                # there is a closing bracket : select the text between the bracket
                self.txt_object_text.tag_add('sel', f'{line_nb}.1', f'{line_nb}.{pos}')
            else:
                # there is no closing bracket : select the entire line
                self.txt_object_text.tag_add('sel', f'{line_nb}.0', f'{line_nb}.0 lineend')
        else:
            # in all other cases, select the entire line
            self.txt_object_text.tag_add('sel', f'{line_nb}.0', f'{line_nb}.0 lineend')

        return 'break'  # don't let tkinter manage the event

    #-------------------------------------------------------------------------------------------------
    def object_text_key_pressed(self, event):
        # (GUI event callback) the user has pressed a keyboard key in the object text box

        # update the syntax highlighting
        self.odf_syntax_highlight(self.txt_object_text)

    #-------------------------------------------------------------------------------------------------
    def object_text_select_all(self, event):
        # (GUI event callback) the user has pressed the Ctrl+a or Ctrl+A keys combinaison in the object text box to select all the text
        # in Windows it is managed natively by the text box widget, but not in Linux

        self.txt_object_text.tag_add('sel', '1.0', 'end')
        return 'break'  # do not process further the event in the widget

    #-------------------------------------------------------------------------------------------------
    def object_text_paste(self, event):
        # (GUI event callback) the user has requested a past in the object text box
        # in Windows it is managed correctly to past instead of a selected text of the text box widget, but not in Linux

        # delete the current selected if any
        try:
            event.widget.delete('sel.first', 'sel.last')
        except:
            pass

        # paste the text of the clipboard if any
        try:
            event.widget.insert('insert', event.widget.clipboard_get())
        except:
            pass

        return 'break'  # do not process further the event in the widget

    #-------------------------------------------------------------------------------------------------
    def object_text_changes_apply(self):
        # (GUI event callback) the user has clicked on the button "Apply" to apply the changes done in the object text box
        # return False if there is an error in the text to apply, else True

        if not self.edited_object_changed:
            # there is no change to apply
            return True

        # convert the object text lines in a list
        object_lines_list = self.txt_object_text.get(1.0, 'end').splitlines()

        if len(object_lines_list) <= 1 and object_lines_list[0] == '':
            # the text box is empty
            return True

        # apply the object data in the ODF data
        object_uid = self.odf_data.object_lines_write(object_lines_list, self.edited_object_uid)
        if object_uid != None:
            # the modification has been applied with success
            self.odf_data_changed = True
            self.edited_object_changed = False
            # reset the edit modified flag
            self.txt_object_text.edit_modified(False)

            if object_uid != self.edited_object_uid and self.edited_object_uid != None:
                # the object UID has been renamed inside the edited lines list
                if self.selected_linked_uid != None:
                    self.selected_linked_uid = object_uid
                else:
                    self.selected_object_uid = object_uid
                self.focused_sel_item_id = self.focused_sel_item_id.replace(self.edited_object_uid, object_uid)
                self.edited_object_uid = object_uid

            # update the various GUI widgets
            self.objects_list_update()
            self.objects_tree_update()
            self.object_links_list_update()
            self.gui_status_update_buttons()
            self.gui_status_update_lists()
            changes_applied = True
        else:
            changes_applied = False
            # select the Logs tab of the notebook to show error logs
            self.notebook.select(self.frm_logs)

        # update the events log text
        self.logs_display()

        return changes_applied

    #-------------------------------------------------------------------------------------------------
    def object_add(self):
        # (GUI event callback) the user has clicked on the button "Add" to create a new object

        if not self.can_i_make_change(object_change_bool=True):
            # the user has answered Cancel if the edited object has been modified
            return

        # recover the list of the object types which can be child of the edited object
        object_types_list = self.odf_data.object_poss_children_type_list_get(self.edited_object_uid)

        # add to the objects types list Organ and Header if not already defined in the ODF
        if 'Organ' not in self.odf_data.objects_list_get():
            object_types_list.insert(0, 'Organ')
        if 'Header' not in self.odf_data.objects_list_get():
            object_types_list.insert(0, 'Header')

        # let the user choose the object type to add with the proper invitation message
        if 'Header' in object_types_list or 'Organ' in object_types_list:
            if self.edited_object_uid in (None, 'Header'):
                msg = 'Choose a type of section to add at the root'
            else:
                msg = f'Choose a type of section to add as child of\n{self.edited_object_uid} or at the root'
        else:
            if self.edited_object_uid == None:
                return
            else:
                msg = f'Choose a type of section to add as child of\n{self.odf_data.object_names_get(self.edited_object_uid)}'
        chosen_type_list = ask_choose_list_items(self.wnd_main, 'Section add', msg, object_types_list, multiselect_bool=False)

        if chosen_type_list == None or len(chosen_type_list) == 0:
            # no chosen object type
            return

        # recover the chosen object type and its parent UID
        chosen_object_type = chosen_type_list[0]
        if self.edited_object_uid in ('Header', 'Organ'):
            parent_object_uid = None
        else:
            parent_object_uid = self.edited_object_uid

        # create the object in the ODF
        new_object_uid = self.odf_data.object_add(chosen_object_type, parent_object_uid)
        if new_object_uid != None:
            # the object has been created successfully
            self.odf_data_changed = True
            # set the new object as the current selected and focused object
            self.selected_object_uid = new_object_uid
            self.selected_linked_uid = None
            self.edited_object_uid = new_object_uid
            if self.focused_objects_widget == self.trv_objects_tree:
                # in the objects tree the new object is child of the curent selected node
                self.focused_sel_item_id += new_object_uid
            else:
                self.focused_sel_item_id = new_object_uid

            # update the content of GUI widgets
            self.objects_list_update()
            self.objects_tree_update()
            self.object_links_list_update()
            self.object_text_update()
            self.gui_status_update_buttons()
            self.gui_status_update_lists()

        # update the events log text
        self.logs_display()

    #-------------------------------------------------------------------------------------------------
    def object_link(self, relationship):
        # (GUI event callback ) the user has clicked on the button "Parents" or "Children" to link the current selected object UID to another object
        # relationship must be TO_PARENT or TO_CHILD

        if not self.can_i_make_change(object_change_bool=True):
            # the user has answered Cancel if the edited object has been modified
            return

        # recover the list of the parents/children objects of the edited object
        current_kinship_list = list(self.odf_data.object_kinship_list_get(self.edited_object_uid, relationship))

        # add in the current kinship list the name of each object to have same object names as in the possible kinship list
        for i, object_uid in enumerate(current_kinship_list):
            current_kinship_list[i] = self.odf_data.object_names_get(object_uid)

        # recover the list of the objects UID which can be possibly parents or children of the edited object
        (possible_parents_list, possible_children_list)  = self.odf_data.object_poss_kinship_list_get(self.edited_object_uid)

        # take the list corresponding to the kinship type, this will be the possible kinship objects list
        if relationship == TO_PARENT:
            if len(possible_parents_list) == 0:
                # no possible parent object
                return
            else:
                possible_kinship_list = possible_parents_list
        elif relationship == TO_CHILD:
            if len(possible_children_list) == 0:
                # no possible child object
                return
            else:
                possible_kinship_list = possible_children_list
        else:
            # wrong relationship value given
            return

        # add in the possible kinship objects list the name of each object to facilitate the objects selection
        for i, object_uid in enumerate(possible_kinship_list):
            possible_kinship_list[i] = self.odf_data.object_names_get(object_uid)

        # let the user choose the parent/children object(s) to which link the selected object
        if relationship == TO_PARENT:
            selected_kinship_list = ask_choose_list_items(self.wnd_main, 'Link to parents',
                                                          f'Select/unselect parent(s) of\n{self.odf_data.object_names_get(self.edited_object_uid)}',
                                                          sorted(possible_kinship_list), current_kinship_list, True)
        else:
            selected_kinship_list = ask_choose_list_items(self.wnd_main, 'Link to children',
                                                          f'Select/unselect child(ren) of\n{self.odf_data.object_names_get(self.edited_object_uid)}',
                                                          sorted(possible_kinship_list), current_kinship_list, True)

        if selected_kinship_list == None:
            # operation cancelled
            return

        # remove the object name in the selected kinship objects list before to give it to the function odf_data.object_link
        for i in range(len(selected_kinship_list)):
            selected_kinship_list[i] = selected_kinship_list[i].split(' ')[0]

        # link the selected object to the one of the selected kinship objects list
        object_uid = self.odf_data.object_link(self.edited_object_uid, selected_kinship_list, relationship)
        if object_uid != None:
            # the link change has been done successfully
            self.odf_data_changed = True

            if self.focused_objects_widget != self.trv_objects_tree:
                self.focused_sel_item_id = object_uid
            # else if the focus is in the objects tree let unchanged the selected node iid
            # in case the object has not been renamed or has still the current parent node

            # update the object selection
            self.selected_object_uid = object_uid
            self.selected_linked_uid = None
            self.edited_object_uid = object_uid

            # update the content of GUI widgets
            self.objects_list_update()
            self.objects_tree_update()
            self.object_links_list_update()
            self.object_text_update()
            self.gui_status_update_buttons()
            self.gui_status_update_lists()

        # update the events log text
        self.logs_display()

    #-------------------------------------------------------------------------------------------------
    def object_rename(self):
        # (GUI event callback) the user has clicked on the button "Rename" to rename the current selected object UID

        if (not self.can_i_make_change(object_change_bool=True) and not self.edited_object_uid[-3:].isdigit()):
            # the user has answered Cancel if the edited object has been modified
            # of the edited object UID has not 3 digits at the end
            return

        # ask to the user the new object ID to set
        answer = sd.askstring("Section index rename", f"Define a new index value for\nthe 3 ending digits of {self.edited_object_uid} :",
                              initialvalue=int(self.edited_object_uid[-3:]), parent=self.wnd_main)
        if answer == None:
            return

        # check the given number
        if not answer.isdigit():
            messagebox.showerror(title='Naming error', message='Only digits are expected')
        elif int(answer) not in range(0,1000):
            messagebox.showerror(title='Naming error', message='A value between 0 and 999 is expected')
        else:
            # the given number is correct
            # define the new UID of the object
            new_uid = self.edited_object_uid[:-3] + str(int(answer)).zfill(3)
            # check if the new UID can be applied
            object_type = self.odf_data.object_type_get(self.edited_object_uid)
            if new_uid == self.edited_object_uid:
                messagebox.showerror(title='Naming error', message=f'{new_uid} is not a new name !')
            elif new_uid in self.odf_data.objects_list_get():
                messagebox.showerror(title='Naming error', message=f'A section named {new_uid} already exists')
            elif int(answer) == 0 and object_type not in ('Panel', 'Manual'):
                messagebox.showerror(title='Naming error', message='Only Manual and Panel can end with 000')
            elif self.odf_data.object_rename(self.edited_object_uid, new_uid) != None:
                # the object has been renamed successfully
                self.odf_data_changed = True
                # update the UID of the selected object
                if self.selected_linked_uid != None:
                    self.selected_linked_uid = new_uid
                else:
                    self.selected_object_uid = new_uid
                self.focused_sel_item_id = self.focused_sel_item_id.replace(self.edited_object_uid, new_uid)
                self.edited_object_uid = new_uid

                # update the content of GUI widgets
                self.objects_list_update()
                self.objects_tree_update()
                self.object_links_list_update()
                self.object_text_update()
                self.gui_status_update_buttons()
                self.gui_status_update_lists()

            # update the events log text
            self.logs_display()

    #-------------------------------------------------------------------------------------------------
    def object_delete(self):
        # (GUI event callback) the user has clicked on the button "Delete" to delete the current selected object UID

        if self.edited_object_uid == None or self.selected_object_app != 'GO':
            return

        # if the selected object has children, it cannot be deleted, inform the user about this
        if len(self.odf_data.object_kinship_list_get(self.edited_object_uid, TO_CHILD)) > 0:
            messagebox.showwarning('OdfEdit', f'Section {self.edited_object_uid} cannot be deleted while it has child(ren).')
            return

        if messagebox.askokcancel("OdfEdit", f"Do you confirm you want to delete the section {self.edited_object_uid} ?"):
            # the user confirmed the deletion

            # choose the object UID which will be selected after the removal of the current selected object
            if self.focused_objects_widget == self.lst_links_list and self.selected_linked_uid != None:
                # a parent/child object is selected in the linked objects list : the parent will be the selected object
                next_selected_object_uid = self.selected_object_uid
            else:
                next_selected_object_uid = None

            # identify the line in the objects list widget where is present the object to delete (to make visible this line after the deletion)
            for line_nb in range(self.lst_objects_list.size()):
                if self.lst_objects_list.get(line_nb).split(' ')[0] == self.edited_object_uid:
                    break

            # remove the object in the ODF data
            if self.odf_data.object_delete(self.edited_object_uid):
                # the object has been removed without issue
                self.odf_data_changed = True
                self.edited_object_changed = False
                # update the current object UID
                self.selected_object_uid = next_selected_object_uid
                self.selected_linked_uid = None
                self.edited_object_uid = None
                self.focused_objects_widget = None

                # update the content of GUI widgets
                self.objects_list_update()
                self.lst_objects_list.see(line_nb)
                self.objects_tree_update()
                self.object_links_list_update()
                self.object_text_update()
                self.gui_status_update_buttons()
                self.gui_status_update_lists()

            # update the events log text
            self.logs_display()

    #-------------------------------------------------------------------------------------------------
    def manual_compass_extend(self):
        # (GUI event callback) the user has clicked on the button Menu to extend the compass of the selected manual

        if self.odf_data.object_type_get(self.edited_object_uid) == 'Manual':
            # the current edited object is a Manual

            manual_uid = self.edited_object_uid

            # recover the compass of the manual
            min_midi_note = myint(self.odf_data.object_attr_value_get(manual_uid, 'FirstAccessibleKeyMIDINoteNumber'))
            if min_midi_note == None:
                messagebox.showerror(title='OdfEdit', message=f'The manual {manual_uid} has no attribute FirstAccessibleKeyMIDINoteNumber defined')
                return

            midi_note_nb = myint(self.odf_data.object_attr_value_get(manual_uid, 'NumberOfAccessibleKeys'))
            if midi_note_nb == None:
                messagebox.showerror(title='OdfEdit', message=f'The manual {manual_uid} has no attribute NumberOfAccessibleKeys defined')
                return

            # ask the user to give the MIDI note to which extend the manual
            answer = sd.askstring("Manual compass extension", f"The manual {manual_uid} has a MIDI notes compass from {min_midi_note} to {min_midi_note + midi_note_nb - 1}\nEnter the MIDI note number to which extend this manual, it can be above or below the current compass, in the range 36-96.\n(notes requiring more than one octave of wav sample pitch tuning will have a dummy pipe)",
                                  initialvalue='', parent=self.wnd_main)
            if answer != None:
                # the user has validated his choice
                if answer.isdigit() and int(answer) in range(36, 97):
                    # the user has given a proper MIDI note number
                    # do the compass extension
                    self.odf_data.compass_extend_manual(manual_uid, int(answer))

##                    # report in the logs tab the extension done
##                    new_min_midi_note = myint(self.odf_data.object_attr_value_get(manual_uid, 'FirstAccessibleKeyMIDINoteNumber'))
##                    new_midi_note_nb = myint(self.odf_data.object_attr_value_get(manual_uid, 'NumberOfAccessibleKeys'))
##                    if new_midi_note_nb > midi_note_nb:
##                        # the extension has been done
##                        logs.add(f'{manual_uid} compass extended from {min_midi_note} -> {min_midi_note + midi_note_nb - 1} to {new_min_midi_note} -> {new_min_midi_note + new_midi_note_nb - 1}')
                    # select the logs tab of the notebook to show the logs generated by the extension
                    self.notebook.select(self.frm_logs)
                else:
                    messagebox.showerror(title='OdfEdit', message='Only a MIDI note number is accepted !')
        else:
            messagebox.showinfo(title='OdfEdit', message='Firstly select the manual to which apply the compass extension')

        # update the events log text
        self.logs_display()

    #-------------------------------------------------------------------------------------------------
    images_ref=[]  # list needed to keep in memory the reference to the images opened by PhotoImage and added in the text box (to prevent them being garbage collected)

    def odf_syntax_highlight(self, txt_widget):
        # apply syntax highlighting to the content of the given object text box widget

        # remove the tags previously set in the text box
        txt_widget.tag_remove(TAG_FIELD, '1.0', END)
        txt_widget.tag_remove(TAG_COMMENT, '1.0', END)
        txt_widget.tag_remove(TAG_OBJ_UID, '1.0', END)
        txt_widget.tag_remove(TAG_TITLE, '1.0', END)

        # put in a list the lines of the text box
        lines = txt_widget.get('1.0', END).splitlines()

        # scan all the characters of the text box lines
        for l in range(0, len(lines)):
            c0 = None
            for c in range(0, len(lines[l])):
                if lines[l][c] == ';':
                    # comment : apply the comment color until the end of the line
                    txt_widget.tag_add(TAG_COMMENT, f'{l+1}.{c}', f'{l+1}.0 lineend')
                    break  # skip the rest of the line
                elif lines[l][c] == '[':
                    # start of an object UID
                    c0 = c
                elif lines[l][c] == ']':
                    # end of an object UID : apply the UID color between the opening and closing brackets
                    if c0 != None:
                        txt_widget.tag_add(TAG_OBJ_UID, f'{l+1}.{c0}', f'{l+1}.{c+1}')
                        c0 = None
                elif txt_widget.get(f'{l + 1}.{c}') == '=':
                    # equal character : apply the field color before the '='
                    txt_widget.tag_add(TAG_FIELD, f'{l+1}.0', f'{l + 1}.{c}')
                elif lines[l][:2] == '__' :
                    # start of line tag identifying an image file to insert (in the help)
                    # recover the file name after the '__' tag
                    file_name = lines[l][2:]
                    # remove the file name in the widget
                    txt_widget.delete(f'{l+1}.0', f'{l+1}.0 lineend')
                    try:
                        # open the image file
                        photo = PhotoImage(file = os.path.dirname(__file__) + os.sep + 'resources' + os.sep + file_name)
                        # add the reference of the image in the list to store these references
                        self.images_ref.append(photo)
                        # insert the image in the text box
                        txt_widget.image_create(f'{l+1}.0', image=photo, padx=10, pady=10)
                    except:
                        # insert a message indicating that the image has not been opened
                        txt_widget.insert(f'{l+1}.0', f'!!! cannot open the image resources{os.sep + file_name}')
                    break
                elif lines[l][:2] == '>>' :
                    # title line (in the help) : apply the title color to the whole line
                    txt_widget.delete(f'{l+1}.0', f'{l+1}.3')
                    txt_widget.tag_add(TAG_TITLE, f'{l+1}.0', f'{l+1}.0 lineend')
                    break  # skip the rest of the line

    #-------------------------------------------------------------------------------------------------
    def odf_data_check(self):
        # check the consistency of the ODF data

        # ask to the user to apply his object data change before to launch the check
        if self.can_i_make_change(object_change_bool=True):
            # the user has not cancelled the operation

            # do the check
            self.odf_data.check_odf_data(self.progress_status_update)

            # update the events log text
            self.logs_display()

            # select the Logs tab of the notebook to show the check result
            self.notebook.select(self.frm_logs)

            self.gui_status_update_buttons()

    #-------------------------------------------------------------------------------------------------
    def progress_status_update(self, message):
        # callback function called by the C_ODF_DATA.check_odf_data or C_ODF_HW2GO.GO_ODF_build_from_HW_ODF function
        # to display in the object links label widget a progress status message

        self.lab_odf_file_name.config(text=message)
        self.lab_odf_file_name['foreground'] = 'red3'
        self.lab_odf_file_name.update()

#-------------------------------------------------------------------------------------------------
class CreateToolTip(object):
    # class to create a tooltip for a given widget
    # tk_ToolTip_class101.py
    # gives a Tkinter widget a tooltip as the mouse is above the widget
    # tested with Python27 and Python34  by  vegaseat  09sep2014
    # www.daniweb.com/programming/software-development/code/484591/a-tooltip-class-for-tkinter
    # Modified to include a delay time by Victor Zaccardo, 25mar16
    # example of usage : tooltip = CreateToolTip(parend_widget, "string to display")
    def __init__(self, widget, text='widget info'):
        self.waittime = 500     #miliseconds
        self.wraplength = 180   #pixels
        self.widget = widget
        self.text = text
        self.widget.bind("<Enter>", self.enter)
        self.widget.bind("<Leave>", self.leave)
        self.widget.bind("<ButtonPress>", self.leave)
        self.id = None
        self.tw = None
    def enter(self, event=None):
        self.schedule()
    def leave(self, event=None):
        self.unschedule()
        self.hidetip()
    def schedule(self):
        self.unschedule()
        self.id = self.widget.after(self.waittime, self.showtip)
    def unschedule(self):
        id = self.id
        self.id = None
        if id: self.widget.after_cancel(id)
    def showtip(self, event=None):
        x = y = 0
        x, y, cx, cy = self.widget.bbox("insert")
        x += self.widget.winfo_rootx() + 25
        y += self.widget.winfo_rooty() + 20
        # creates a toplevel window
        self.tw = Toplevel(self.widget)
        # Leaves only the label and removes the app window
        self.tw.wm_overrideredirect(True)
        self.tw.wm_geometry("+%d+%d" % (x, y))
        label = Label(self.tw, text=self.text, justify='left',
        background="#ffffff", relief='solid', borderwidth=1,
        wraplength = self.wraplength)
        label.pack(ipadx=1)
    def hidetip(self):
        tw = self.tw
        self.tw= None
        if tw: tw.destroy()

#-------------------------------------------------------------------------------------------------
NOTES = ['C', 'Cis', 'D', 'Dis', 'E', 'F', 'Fis', 'G', 'Gis', 'A', 'Ais', 'B']
OCTAVES = list(range(11))
NOTES_IN_OCTAVE = len(NOTES)

def midi_number_to_note(number: int) -> tuple:
    # convert the given MIDI note number to note and octave numbers
    octave = number // NOTES_IN_OCTAVE
    assert octave in OCTAVES, f'Wrong octave {octave} number in midi_number_to_note function'
    assert 0 <= number <= 127, f'Wrong MIDI note number {number} in midi_number_to_note function'
    note = NOTES[number % NOTES_IN_OCTAVE]
    return note, octave

def midi_note_to_number(note: str, octave: int) -> int:
    # convert the given note and octave numbers to a MIDI note number
    assert note in NOTES, f'Wrong note name {note} in midi_note_to_number function input'
    assert octave in OCTAVES, f'Wrong octave number {octave} in midi_note_to_number function input'
    note = NOTES.index(note)
    note += (NOTES_IN_OCTAVE * octave)
    assert 0 <= note <= 127, f'Wrong note number {note} in midi_note_to_number function'
    return note

def frequency_to_midi_number(frequency: float, a4_frequency: float) -> int:
    # convert the given frequency in Hz into a MIDI note number
    # using the given reference frequency of the A4 note (which has MIDI note 69), set at 440Hz by default if None is provided
    if a4_frequency == None: a4_frequency = 440.0
    return round(12 * math.log2(frequency / a4_frequency) + 69)

def delta_freq_to_cent(frequency1: float, frequency2: float) -> int:
    # return the number of cents (integer) between the two given frequencies (f1 compared to f2)
    return int(1200.0 * math.log2(frequency1 / frequency2))

#-------------------------------------------------------------------------------------------------
wavpack_sample_rates = (6000, 8000, 9600, 11025, 12000, 16000, 22050, 24000, 32000, 44100, 48000, 64000, 88200, 96000, 192000)

def wav_metadata_get(file_name):
    # return in a dictionary the metadata of the given .wav file (wav or wavpack format)
    # the provided keys are :
    #   file_format : "wave" or "wavepack" or None if error
    #   error_msg   : message describing an error occured during the file processing, empty string if no error
    #   compression_code : 1='Microsoft PCM', 3='Microsoft IEEE float', several other...
    #   nb_of_channels   : 1=mono, 2=stereo
    #   sampling_rate    : for example 44100 (Hz)
    #   bits_per_sample  : for example 16 (bits)
    #   nb_of_samples    : number of audio samples
    #   audio_data_size  : size in bytes of the audio sampled data
    #   audio_duration   : the duration in seconds (with two decimals) of the sampled data
    # keys present only if a sample chunk is defined in the file
    #   midi_note        : MIDI note of the sample, between 0 and 127
    #   midi_pitch       : fixed point value between 0. and 100.
    #   loops_nb                : number of defined loops
    #   loop<n>_id              : ID of the loop n
    #   loop<n>_type            : type of the loop n (0=normal forward looping, 1=alternating forward and backward, 2=backward looping)
    #   loop<n>_start_sample    : number of the starting sample of the loop n
    #   loop<n>_start_seconds   : seconds of the starting sample of the loop n (with two decimals)
    #   loop<n>_end_sample      : number of the ending sample of the loop n
    #   loop<n>_end_seconds     : seconds of the ending sample of the loop n (with two decimals)
    #   loop<n>_replay_times_nb : number of times the loop has to be played (0=infinite)
    # keys present only if a cue chunk is defined in the file
    #   cue_points_nb           : number of defined cue points
    #   cue<n>_id               : ID of the cue point n
    #   cue<n>__chunk_id        : 'data' or 'slnt' whether the cue point is in a data or silent chunk
    #   cue<n>_chunk_start      : position of the start of the data chunk that contains the cue point
    #   cue<n>_block_start      : byte position of the cue in the "data" or "slnt" chunk
    #   cue<n>_sample_start     : position of the cue in number of bytes from the start of the block
    # keys present only if a LIST chunk is defined in the file
    #   info                    : a dictionary containing as keys the info ID and as value the corresponding info text


    file_format = None
    metadata_dic = {}
    metadata_dic['error_msg'] = ''

    if not os.path.isfile(file_name):
        # the provided file doesn't exist
        metadata_dic['error_msg'] = f'The file "{file_name}" does not exist.'
        return metadata_dic

    # open the given file
    file_obj = open(file_name, 'rb')

    is_chunck_in_sub_block = False  # flag indicating if we are currently decoding wave chunks inside a wavepack sub-block

    while file_obj.read(1) and metadata_dic['error_msg'] == '':
        # scan the file while the end of file is not reached and no error has occured
        file_obj.seek(-1, 1)   # move the file pointer one byte back to compensate the read(1) of the while instruction

        # identification of the file format
        if file_format == None:
            # if the file format is unknown, get it from the ID in first 4 bytes of the file
            file_type_str = file_obj.read(4)
            file_obj.seek(-4, 1)
            if file_type_str == b'wvpk':
                file_format = 'wavepack'
                if LOG_wav_decode: print(f'WavePack file')
            elif file_type_str == b'RIFF':
                file_format = 'wave'
                if LOG_wav_decode: print(f'Wave file')
            else:
                metadata_dic['error_msg'] = f'Unsupported file format'


        # firstly : identification of the block or chunk start on which is the file pointer, and get its size

        if file_format == 'wavepack' and not is_chunck_in_sub_block:
            # a WavePack block header or sub-block is supposed to start here

            if file_obj.read(4) == b'wvpk':
                # start of a WavePack block header
                # get the block size (in bytes)
                wvpk_block_size = int.from_bytes(file_obj.read(4), byteorder='little')
                wvpk_sub_block_id = None  # it is a block header, not a sub-block
                if LOG_wav_decode: print(f'"wvpk" block, size {wvpk_block_size} bytes')
            else:
                # it is not a block header, it should be a sub-block
                file_obj.seek(-4, 1)
                # reads the sub-block ID
                wvpk_sub_block_id = int.from_bytes(file_obj.read(1), byteorder='little')
                # read the size of the sub-block (in bytes)
                if wvpk_sub_block_id & 0x80:
                    # it is a large block, its size is encoded on 3 bytes
                    wvpk_sub_block_size = int.from_bytes(file_obj.read(3), byteorder='little') * 2  # x2 to convert the size from words to bytes
                else:
                    wvpk_sub_block_size = int.from_bytes(file_obj.read(1), byteorder='little') * 2
                if LOG_wav_decode: print(f'  "wvpk" sub-block ID {hex(wvpk_sub_block_id)}, size {wvpk_sub_block_size} bytes')

                if (wvpk_sub_block_id & 0x3f) == 0x21 or (wvpk_sub_block_id & 0x3f) == 0x22:
                    # a RIFF_HEADER or RIFF_TRAILER chunk is present in the data of this sub-block
                    if LOG_wav_decode: print('     WavePack sub-block with RIFF chunk inside')
                    is_chunck_in_sub_block = True
                else:
                    is_chunck_in_sub_block = False

        if file_format == 'wave' or is_chunck_in_sub_block:
            # a Wave chunk or sub-chunk is supposed to start here
            # get the chunk or sub-chunk ID (a string of 4 characters)
            chunk_id = file_obj.read(4).decode()
            # read the size of the chunk or sub-chunk (in bytes)
            wave_chunk_size = int.from_bytes(file_obj.read(4), byteorder='little')

            if wave_chunk_size % 2:
                # the chunk size has an odd number of bytes, a word padding byte is written after
                # increment the chunk size by 1 to cover this padding byte
                wave_chunk_size += 1

            if LOG_wav_decode: print(f'  "{chunk_id}" chunk, size {wave_chunk_size} bytes')

            if is_chunck_in_sub_block:
                # the chunck is inside a WavePack sub-block
                # reduce the remaining sub-block size by the size of the chunk
                if chunk_id == 'RIFF':
                    wvpk_sub_block_size -= 12 # the RIFF chunk has 12 bytes
                elif chunk_id == 'data':
                    wvpk_sub_block_size -= 8  # the data chunk has 8 bytes (ID and size fields, without data) when inside a wavpack sub-block
                else:
                    wvpk_sub_block_size -= (wave_chunk_size + 8)  # size of the sub-chunk + ID and size fields


        # secondly : read the data in the current block / sub-block or chunk / sub-chunk

        if file_format == 'wavepack' and wvpk_sub_block_id == None:
            # WavePack block header
            # get some data from the block header
            file_obj.read(2)     # skip the version
            block_index_u8 = int.from_bytes(file_obj.read(1), byteorder='little')    # upper 8 bits  of 40-bit block index
            total_samples_u8 = int.from_bytes(file_obj.read(1), byteorder='little')  # upper 8 bits  of 40-bit total samples
            total_samples_l32 = int.from_bytes(file_obj.read(4), byteorder='little') # lower 32 bits of 40-bit total samples
            block_index_l32 = int.from_bytes(file_obj.read(4), byteorder='little')   # lower 32 bits of 40-bit block index
            file_obj.read(4)     # skip the number of samples in this block
            flags  = int.from_bytes(file_obj.read(4), byteorder='little')            # flags for id and decoding
            file_obj.read(4)     # skip the CRC for actual decoded data

            # compose the block index
            block_index = (block_index_u8 << 32) + block_index_l32
            if LOG_wav_decode: print(f'              first sample index is {block_index}')

            # get data from some flags of the first block if not already defined
            if block_index == 0 and 'nb_of_samples' not in metadata_dic:
                # compose the total number of samples
                metadata_dic['nb_of_samples'] = (total_samples_u8 << 32) + total_samples_l32

                metadata_dic['bits_per_sample'] = ((flags & 0b11) + 1) * 8

                if ((flags >> 2) & 0b1) == 0:
                    metadata_dic['nb_of_channels'] = 2
                else:
                    metadata_dic['nb_of_channels'] = 1

                metadata_dic['sampling_rate'] = wavpack_sample_rates[(flags >> 23) & 0b1111]
                metadata_dic['compression_code'] = (flags >> 3) & 0b1  # 0 = losslessaudio, 1 = hybrid mode
                metadata_dic['audio_data_size'] = metadata_dic['nb_of_samples'] * metadata_dic['nb_of_channels'] * (metadata_dic['bits_per_sample'] / 8)

        if file_format == 'wavepack' and wvpk_sub_block_id != None and not is_chunck_in_sub_block:
            # WavePack sub-block which does not contain Wave chunks
            # skip this sub-block in the file
            file_obj.seek(wvpk_sub_block_size, 1)
            if LOG_wav_decode: print(f'     Skipped WavePack sub-block')

        if file_format == 'wave' or is_chunck_in_sub_block:
            # wave chunck or sub-chunck
            if chunk_id == 'RIFF':
                # RIFF chunk
                if file_obj.read(4) == b'WAVE':
                    # the RIFF type ID is WAVE, it is a valid .wav file
                    if LOG_wav_decode: print(f'      RIFF type ID is Wave as expected')
                else:
                    metadata_dic['error_msg'] = f'RIFF chunk has not the "WAVE" format, unsuported file format'
                wave_chunk_size = 0  # no remaining data to read in this chunk

            elif chunk_id == 'fmt ':
                # format chunk
                metadata_dic['compression_code'] = int.from_bytes(file_obj.read(2), byteorder='little')
                metadata_dic['nb_of_channels'] = int.from_bytes(file_obj.read(2), byteorder='little')
                metadata_dic['sampling_rate'] = int.from_bytes(file_obj.read(4), byteorder='little')
                file_obj.read(4) # skip the bytes per second
                file_obj.read(2) # skip the block align
                metadata_dic['bits_per_sample'] = int.from_bytes(file_obj.read(2), byteorder='little')
                wave_chunk_size -= 16   # 16 bytes already read in this chunk
                if LOG_wav_decode: print(f'      fmt data recovered')

            elif chunk_id == 'smpl':
                # sample chunk
                file_obj.read(4) # skip the manufacturer ID
                file_obj.read(4) # skip the product ID
                file_obj.read(4) # skip the sample period
                metadata_dic['midi_note'] = int.from_bytes(file_obj.read(4), byteorder='little')
                metadata_dic['midi_pitch'] = '%.4f' % (int.from_bytes(file_obj.read(4), byteorder='little') * 100 / 0xFFFFFFFF)

                file_obj.read(4) # skip the SMPTE format
                file_obj.read(4) # skip the SMPTE offset
                metadata_dic['loops_nb'] = loops_nb = int.from_bytes(file_obj.read(4), byteorder='little')
                file_obj.read(4) # skip the sampler data bytes number
                wave_chunk_size -= 36   # 36 bytes already read in this chunk

                for l in range(1, loops_nb+1):
                    metadata_dic[f'loop{l}_id'] = int.from_bytes(file_obj.read(4), byteorder='little')
                    metadata_dic[f'loop{l}_type'] = int.from_bytes(file_obj.read(4), byteorder='little')
                    metadata_dic[f'loop{l}_start_sample'] = int.from_bytes(file_obj.read(4), byteorder='little')
                    metadata_dic[f'loop{l}_start_seconds'] = int(metadata_dic[f'loop{l}_start_sample'] *100 / metadata_dic['sampling_rate']) / 100
                    metadata_dic[f'loop{l}_end_sample'] = int.from_bytes(file_obj.read(4), byteorder='little')
                    metadata_dic[f'loop{l}_end_seconds'] = int(metadata_dic[f'loop{l}_end_sample'] *100 / metadata_dic['sampling_rate']) / 100
                    file_obj.read(4) # skip the loop fraction
                    metadata_dic[f'loop{l}_replay_times_nb'] = int.from_bytes(file_obj.read(4), byteorder='little')
                    wave_chunk_size -= 24   # 24 bytes already read in this chunk
                if LOG_wav_decode: print(f'      smpl data recovered')

            elif chunk_id == 'cue ':
                # cue chunk
                metadata_dic['cue_points_nb'] = cue_points_nb = int.from_bytes(file_obj.read(4), byteorder='little')
                wave_chunk_size -= 4   # 4 bytes already read in this chunk

                for c in range(1, cue_points_nb+1):
                    metadata_dic[f'cue{c}_id'] = int.from_bytes(file_obj.read(4), byteorder='little')
                    file_obj.read(4) # skip the cue position
                    if file_obj.read(4) == b'data':
                        metadata_dic[f'cue{c}_chunk_id'] = 'data'
                    else:
                        metadata_dic[f'cue{c}_chunk_id'] = 'silent'
                    metadata_dic[f'cue{c}_chunk_start'] = int.from_bytes(file_obj.read(4), byteorder='little')
                    metadata_dic[f'cue{c}_block_start'] = int.from_bytes(file_obj.read(4), byteorder='little')
                    metadata_dic[f'cue{c}_sample_start'] = int.from_bytes(file_obj.read(4), byteorder='little')
                    wave_chunk_size -= 24   # 24 bytes already read in this chunk
                if LOG_wav_decode: print(f'      cue data recovered')

            elif chunk_id == 'LIST':
                # list chunk
                # get the list type
                list_type_id = file_obj.read(4).decode()
                wave_chunk_size -= 4   # 4 bytes already read in this chunk

                if list_type_id == 'INFO':
                    # get the data of the INFO type list
                    metadata_dic['info'] = {}
                    while wave_chunk_size > 0:  # loop until the end of the chunk
                        info_id = file_obj.read(4).decode()
                        text_size = int.from_bytes(file_obj.read(4), byteorder='little')
                        text_content = file_obj.read(text_size).decode()
                        while text_content[-1:] == '\x00':  # remove the trailing 0x00 characters
                            text_content = text_content[:-1]
                        metadata_dic['info'][info_id] = text_content
                        wave_chunk_size -= 8 + text_size   # 8 + text size bytes already read in this chunk
                    if LOG_wav_decode: print(f'      LIST INFO data recovered')

            elif chunk_id == 'data':
                # data chunk
                metadata_dic['audio_data_size'] = wave_chunk_size # size in bytes of the audio sampled data
                metadata_dic['nb_of_samples'] = int(wave_chunk_size / (metadata_dic['nb_of_channels'] * metadata_dic['bits_per_sample'] / 8))
                if is_chunck_in_sub_block:
                    wave_chunk_size = 0  # inside a WavePack sub-block, the data sub-chunk has no data, erase the chunk size value

            # move the file pointer at the end of the chunk
            file_obj.seek(wave_chunk_size, 1)

            if is_chunck_in_sub_block and wvpk_sub_block_size <= 0:
                # the end of the WavePack RIFF sub-bloc is reached
                is_chunck_in_sub_block = False
                if LOG_wav_decode: print('   End of Wave chunk in WavePack sub-block is reached')

    # close the given file
    file_obj.close()

    if file_format != None:
        if 'audio_data_size' not in metadata_dic.keys():
            # wav file without data chunk inside
            metadata_dic['error_msg'] = f'The file "{file_name}" has not audio samples inside.'
        else:
            # compute the duration of the audio samples in seconds (float with 2 decimals)
            metadata_dic['audio_duration'] = int(metadata_dic['audio_data_size'] * 100 / (metadata_dic['sampling_rate'] * metadata_dic['nb_of_channels'] * metadata_dic['bits_per_sample'] / 8)) / 100

    metadata_dic['file_format'] = file_format

    return metadata_dic

#-------------------------------------------------------------------------------------------------
def myint(data, default_val=None):
    # return the given data in integer format, or the provided default value (or None if not defined) if it cannot be converted to integer or is not defined

    if data == None:
        return default_val

    try:
        return int(data)
    except:
        return default_val

#-------------------------------------------------------------------------------------------------
def myfloat(data, default_val=None):
    # return the given data in float format, or the provided default value (or None if not defined) if it cannot be converted to float or is not defined

    if data == None:
        return default_val

    try:
        return float(data)
    except:
        return default_val

#-------------------------------------------------------------------------------------------------
def mystr(data, default_val=''):
    # return the given data in string format, or the provided default value (or '' if not defined) if it cannot be converted to string or is not defined

    if data == None:
        return default_val

    try:
        return str(data)
    except:
        return default_val

#-------------------------------------------------------------------------------------------------
prev_actual_file_name = ''  # variable to keep in memory the previous found actual file name, to speed up the processing of the next one if there are common parts
def get_actual_file_name(file_name):
    # return the given file path/name with the actual characters case as they are defined on the storage
    # return None if the given file name doesn't exist
    # the given file path/name must have the path separator of the OS on which is running the script

    global prev_actual_file_name

    # split the given file name by elements separated by the OS path separator
    file_name_split = file_name.split(os.sep)
    file_name_split_len = len(file_name_split)

    i = 0
    if prev_actual_file_name != '':
        # recover from the previous actual file name the path elements which are equal to the one of the given file name (to spend less time in the next while loop)
        # split the previous actual file name by elements separated by the OS path separator
        prev_actual_file_name_split = prev_actual_file_name.split(os.sep)
        actual_file_name = ''
        while i < file_name_split_len and file_name_split[i].lower() == prev_actual_file_name_split[i].lower():
            actual_file_name += prev_actual_file_name_split[i] + os.sep
            i += 1
        if i == file_name_split_len:
            # the entire previous actual file name has been recovered, remove the last separator
            actual_file_name = actual_file_name[:-1]

    if i == 0:
        # nothing to recover from the previous actual file name or it is empty
        # we consider that the root folder of the given file name has the actual case
        actual_file_name = file_name_split[0] + os.sep
        i = 1

    # recover from the storage the actual name of the remaining elements of the given file path/name
    while i < file_name_split_len:
        found = False
        for actual_element in os.listdir(actual_file_name):
            if actual_element.lower() == file_name_split[i].lower():
                found = True
                break
        if not found:
            return None
        actual_file_name = os.path.join(actual_file_name, actual_element)
        i += 1

    prev_actual_file_name = actual_file_name
    return actual_file_name

#-------------------------------------------------------------------------------------------------
def path2ospath(file_name):
    # replace the / or \ in the given file name by the OS separator

    if os.sep == '/':
        return file_name.replace('\\', os.sep)
    else:
        return file_name.replace('/', os.sep)

#-------------------------------------------------------------------------------------------------
dialog_wnd_w = 300
dialog_wnd_h = 450

def ask_choose_list_items(parent_wnd, title, message, choice_items_list, preselect_items_list = [], multiselect_bool=False, resizable_wnd_bool=True):
    # opens a dialog box to ask the user to select items in the given choice items list
    # if items are provided in preselect_items_list and they are present in choice_items_list, they are pre-selected in the list
    # returns a list containing the items selected in the given choice items list, or None if the user clicked on Cancel or close button

    global dialog_wnd_w
    global dialog_wnd_h

    # disable the parent window so that the dialog box is modal (only possible in Windows OS)
    if os.name == 'nt':
        parent_wnd.wm_attributes("-disabled", True)

    # create the toplevel modal dialog window
    dialog_wnd = Toplevel(parent_wnd, takefocus=True)
    dialog_wnd.title(title)
    if not resizable_wnd_bool:
        dialog_wnd.resizable(False, False)

    # place the dialog window at the center of the parent window
    parent_wnd_x = parent_wnd.winfo_x()
    parent_wnd_y = parent_wnd.winfo_y()
    parent_wnd_w = parent_wnd.winfo_width()
    parent_wnd_h = parent_wnd.winfo_height()
    dialog_wnd_x = parent_wnd_x + int(parent_wnd_w/2) - int(dialog_wnd_w/2)
    dialog_wnd_y = parent_wnd_y + int(parent_wnd_h/2) - int(dialog_wnd_h/2)
    if dialog_wnd_x < 0: dialog_wnd_x = 0
    if dialog_wnd_y < 0: dialog_wnd_y = 0
    dialog_wnd.geometry(f"{dialog_wnd_w}x{dialog_wnd_h}+{dialog_wnd_x}+{dialog_wnd_y}")

    # tell the window manager this is the child window of the parent window, permits to let the child window flash if one clicks onto parent
    dialog_wnd.transient(parent_wnd)
    dialog_wnd.focus_force()

    # string var permitting to know the reason of the dialog box closure
    closure_reason = StringVar()
    closure_reason.set('none')

    # link to the callback WM_DELETE_WINDOW or Escape key to manage the window closure
    dialog_wnd.protocol("WM_DELETE_WINDOW",  lambda reason='cancel': closure_reason.set(reason))
    dialog_wnd.bind('<Escape>', lambda reason='cancel': closure_reason.set(reason))

    # create the top label widget
    listdialog_label = Label(dialog_wnd, text=message, fg="black", anchor='center', wraplength=dialog_wnd_w - 10, height=2)
    listdialog_label.pack(side='top', padx=5, pady=5, fill='x')

    # frame to occupy the bottom area of the dialog window and to encapsulate OK and Cancel buttons
    listdialog_frm1 = Frame(dialog_wnd)
    listdialog_frm1.pack(side='bottom', fill='x')

    # OK button
    toplevel_dialog_yes_button = Button(listdialog_frm1, text='OK', command=lambda reason='ok': closure_reason.set(reason))
    toplevel_dialog_yes_button.pack(side='left', padx=5, pady=5, fill='x', expand=1)

    # Cancel button
    toplevel_dialog_no_button = Button(listdialog_frm1, text='Cancel', command=lambda reason='cancel': closure_reason.set(reason))
    toplevel_dialog_no_button.pack(side='left', padx=5, pady=5, fill='x', expand=1)

    # frame to occupy the middle area of the window and to encapsulate the list and its vertical scroll bar
    listdialog_frm2 = Frame(dialog_wnd)
    listdialog_frm2.pack(side='top', fill='both', padx=5, expand=1)

    # list box widget with its vertical scroll bar
    scrollbarv = ttk.Scrollbar(listdialog_frm2, orient='vertical')
    scrollbarv.pack(side='right', fill='y')
    listdialog_list = Listbox(listdialog_frm2, selectmode=('multiple' if multiselect_bool else 'single'))
    listdialog_list.pack(side='left', fill='both', expand=1)
    listdialog_list.config(yscrollcommand=scrollbarv.set)
    scrollbarv.config(command=listdialog_list.yview)

    # fill the list box
    see_used_bool = False
    for item in choice_items_list:
        # scan the items of the choice list
        # add the current item to the list widget
        listdialog_list.insert('end', item)
        if item in preselect_items_list:
            # the current has to be selected
            listdialog_list.selection_set('end')
            if not see_used_bool:
                # make visible the first selected item
                listdialog_list.see('end')
                see_used_bool = True

    # wait for the change of the StringVar closure_reason
    dialog_wnd.wait_variable(closure_reason)

    if closure_reason.get() == 'ok':
        # the user has clicked on the OK button, recover the list of the selected items
        selected_items_list = []
        for i in listdialog_list.curselection():
            selected_items_list.append(listdialog_list.get(i))
    else:
        selected_items_list = None

    # store the dialog window current dimensions
    dialog_wnd_w = dialog_wnd.winfo_width()
    dialog_wnd_h = dialog_wnd.winfo_height()

    # re-enable the parent window
    if os.name == 'nt':
        parent_wnd.wm_attributes("-disabled", False)
    # destroy this dialog box
    dialog_wnd.destroy()
    # restore the parent window if it was in icon state
    parent_wnd.deiconify()

    return selected_items_list

#-------------------------------------------------------------------------------------------------
def main():
    # main function of the application

    # initiate a C_GUI class instance, display the main window based on this instance, start the main loop of this window
    C_GUI().wnd_main_build().mainloop()

#-------------------------------------------------------------------------------------------------
# first line of code executed at the launch of the script
# if we are in the main execution environment, call the main function of the application
if __name__ == '__main__': main()
